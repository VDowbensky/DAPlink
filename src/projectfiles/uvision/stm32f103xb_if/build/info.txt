; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\info.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\info.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\info.crf ..\..\..\source\daplink\info.c]
                          THUMB

                          AREA ||i.hex_to_ascii||, CODE, READONLY, ALIGN=1

                  hex_to_ascii PROC
;;;32     
;;;33     static char hex_to_ascii(uint8_t x)
000000  2809              CMP      r0,#9
;;;34     {
000002  d900              BLS      |L1.6|
000004  3027              ADDS     r0,r0,#0x27
                  |L1.6|
000006  3030              ADDS     r0,r0,#0x30
;;;35         return ('0' + (x>9 ? x+0x27 : x));
000008  b2c0              UXTB     r0,r0
;;;36     }
00000a  4770              BX       lr
;;;37     
                          ENDP


                          AREA ||i.info_crc_compute||, CODE, READONLY, ALIGN=2

                  info_crc_compute PROC
;;;294    
;;;295    void info_crc_compute()
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297        crc_bootloader = 0;
000002  4913              LDR      r1,|L2.80|
000004  2000              MOVS     r0,#0
000006  6008              STR      r0,[r1,#0]  ; crc_bootloader
;;;298        crc_interface = 0;
000008  4912              LDR      r1,|L2.84|
00000a  6008              STR      r0,[r1,#0]  ; crc_interface
;;;299        crc_config_admin = 0;
00000c  4912              LDR      r1,|L2.88|
00000e  6008              STR      r0,[r1,#0]  ; crc_config_admin
;;;300        crc_config_user = 0;
000010  4912              LDR      r1,|L2.92|
000012  6008              STR      r0,[r1,#0]  ; crc_config_user
;;;301    
;;;302        // Compute the CRCs of regions that exist
;;;303        if (DAPLINK_ROM_BL_SIZE > 0) {
;;;304            crc_bootloader = crc32((void *)DAPLINK_ROM_BL_START, DAPLINK_ROM_BL_SIZE - 4);
000014  f64b31fc          MOV      r1,#0xbbfc
000018  f04f6000          MOV      r0,#0x8000000
00001c  f7fffffe          BL       crc32
000020  490b              LDR      r1,|L2.80|
000022  6008              STR      r0,[r1,#0]  ; crc_bootloader
;;;305        }
;;;306    
;;;307        if (DAPLINK_ROM_IF_SIZE > 0) {
;;;308            crc_interface = crc32((void *)DAPLINK_ROM_IF_START, DAPLINK_ROM_IF_SIZE - 4);
000024  490e              LDR      r1,|L2.96|
000026  480f              LDR      r0,|L2.100|
000028  f7fffffe          BL       crc32
00002c  4909              LDR      r1,|L2.84|
00002e  6008              STR      r0,[r1,#0]  ; crc_interface
;;;309        }
;;;310    
;;;311        if (DAPLINK_ROM_CONFIG_ADMIN_SIZE > 0) {
;;;312            crc_config_admin = crc32((void *)DAPLINK_ROM_CONFIG_ADMIN_START, DAPLINK_ROM_CONFIG_ADMIN_SIZE);
000030  f44f6180          MOV      r1,#0x400
000034  480c              LDR      r0,|L2.104|
000036  f7fffffe          BL       crc32
00003a  4907              LDR      r1,|L2.88|
00003c  6008              STR      r0,[r1,#0]  ; crc_config_admin
;;;313        }
;;;314    
;;;315        if (DAPLINK_ROM_CONFIG_USER_SIZE > 0) {
;;;316            crc_config_user = crc32((void *)DAPLINK_ROM_CONFIG_USER_START, DAPLINK_ROM_CONFIG_USER_SIZE);
00003e  f44f6180          MOV      r1,#0x400
000042  480a              LDR      r0,|L2.108|
000044  f7fffffe          BL       crc32
000048  4904              LDR      r1,|L2.92|
00004a  6008              STR      r0,[r1,#0]  ; crc_config_user
;;;317        }
;;;318    }
00004c  bd10              POP      {r4,pc}
;;;319    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      crc_bootloader
                  |L2.84|
                          DCD      crc_interface
                  |L2.88|
                          DCD      crc_config_admin
                  |L2.92|
                          DCD      crc_config_user
                  |L2.96|
                          DCD      0x00013bfc
                  |L2.100|
                          DCD      0x0800c000
                  |L2.104|
                          DCD      0x0800bc00
                  |L2.108|
                          DCD      0x0801fc00

                          AREA ||i.info_get_board_id||, CODE, READONLY, ALIGN=2

                  info_get_board_id PROC
;;;69     
;;;70     const char *info_get_board_id(void)
000000  4800              LDR      r0,|L3.4|
;;;71     {
;;;72         return string_board_id;
;;;73     }
000002  4770              BX       lr
;;;74     
                          ENDP

                  |L3.4|
                          DCD      ||.data||+0x14

                          AREA ||i.info_get_bootloader_present||, CODE, READONLY, ALIGN=2

                  info_get_bootloader_present PROC
;;;224    
;;;225    bool info_get_bootloader_present(void)
000000  2001              MOVS     r0,#1
;;;226    {
;;;227        bool present = true;
;;;228    
;;;229        if (0 == DAPLINK_ROM_BL_SIZE) {
;;;230            present = false;
;;;231        }
;;;232    
;;;233        if (DAPLINK_BUILD_KEY_BL != info_bl->build_key) {
000002  06c1              LSLS     r1,r0,#27
000004  4a06              LDR      r2,|L4.32|
000006  6a09              LDR      r1,[r1,#0x20]
000008  4291              CMP      r1,r2
00000a  d000              BEQ      |L4.14|
;;;234            present = false;
00000c  2000              MOVS     r0,#0
                  |L4.14|
;;;235        }
;;;236    
;;;237        if (DAPLINK_HIC_ID != info_bl->hic_id) {
00000e  f04f6100          MOV      r1,#0x8000000
000012  4a04              LDR      r2,|L4.36|
000014  6a49              LDR      r1,[r1,#0x24]
000016  4291              CMP      r1,r2
000018  d000              BEQ      |L4.28|
;;;238            present = false;
00001a  2000              MOVS     r0,#0
                  |L4.28|
;;;239        }
;;;240    
;;;241        return present;
;;;242    }
00001c  4770              BX       lr
;;;243    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x9b939d93
                  |L4.36|
                          DCD      0x97969908

                          AREA ||i.info_get_bootloader_version||, CODE, READONLY, ALIGN=1

                  info_get_bootloader_version PROC
;;;320    // Get version info as an integer
;;;321    uint32_t info_get_bootloader_version(void)
000000  b500              PUSH     {lr}
;;;322    {
;;;323        // Don't read version if image is not present
;;;324        if (!info_get_bootloader_present()) {
000002  f7fffffe          BL       info_get_bootloader_present
000006  b908              CBNZ     r0,|L5.12|
;;;325            return 0;
000008  2000              MOVS     r0,#0
                  |L5.10|
;;;326        }
;;;327    
;;;328        return info_bl->version;
;;;329    }
00000a  bd00              POP      {pc}
                  |L5.12|
00000c  f04f6000          MOV      r0,#0x8000000         ;328
000010  6a80              LDR      r0,[r0,#0x28]         ;328
000012  e7fa              B        |L5.10|
;;;330    
                          ENDP


                          AREA ||i.info_get_config_admin_present||, CODE, READONLY, ALIGN=1

                  info_get_config_admin_present PROC
;;;262    
;;;263    bool info_get_config_admin_present(void)
000000  2000              MOVS     r0,#0
;;;264    {
;;;265        //TODO, c1728p9 - check if admin config has been loaded
;;;266        return false;
;;;267    }
000002  4770              BX       lr
;;;268    
                          ENDP


                          AREA ||i.info_get_config_user_present||, CODE, READONLY, ALIGN=1

                  info_get_config_user_present PROC
;;;268    
;;;269    bool info_get_config_user_present(void)
000000  2000              MOVS     r0,#0
;;;270    {
;;;271        //TODO, c1728p9 - check if user config has a valid key
;;;272        return false;
;;;273    }
000002  4770              BX       lr
;;;274    
                          ENDP


                          AREA ||i.info_get_crc_bootloader||, CODE, READONLY, ALIGN=2

                  info_get_crc_bootloader PROC
;;;274    
;;;275    uint32_t info_get_crc_bootloader()
000000  4801              LDR      r0,|L8.8|
;;;276    {
;;;277        return crc_bootloader;
000002  6800              LDR      r0,[r0,#0]  ; crc_bootloader
;;;278    }
000004  4770              BX       lr
;;;279    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      crc_bootloader

                          AREA ||i.info_get_crc_config_admin||, CODE, READONLY, ALIGN=2

                  info_get_crc_config_admin PROC
;;;284    
;;;285    uint32_t info_get_crc_config_admin()
000000  4801              LDR      r0,|L9.8|
;;;286    {
;;;287        return crc_config_admin;
000002  6800              LDR      r0,[r0,#0]  ; crc_config_admin
;;;288    }
000004  4770              BX       lr
;;;289    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      crc_config_admin

                          AREA ||i.info_get_crc_config_user||, CODE, READONLY, ALIGN=2

                  info_get_crc_config_user PROC
;;;289    
;;;290    uint32_t info_get_crc_config_user()
000000  4801              LDR      r0,|L10.8|
;;;291    {
;;;292        return crc_config_user;
000002  6800              LDR      r0,[r0,#0]  ; crc_config_user
;;;293    }
000004  4770              BX       lr
;;;294    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      crc_config_user

                          AREA ||i.info_get_crc_interface||, CODE, READONLY, ALIGN=2

                  info_get_crc_interface PROC
;;;279    
;;;280    uint32_t info_get_crc_interface()
000000  4801              LDR      r0,|L11.8|
;;;281    {
;;;282        return crc_interface;
000002  6800              LDR      r0,[r0,#0]  ; crc_interface
;;;283    }
000004  4770              BX       lr
;;;284    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      crc_interface

                          AREA ||i.info_get_hic_id||, CODE, READONLY, ALIGN=2

                  info_get_hic_id PROC
;;;84     
;;;85     const char *info_get_hic_id(void)
000000  4800              LDR      r0,|L12.4|
;;;86     {
;;;87         return string_hic_id;
;;;88     }
000002  4770              BX       lr
;;;89     const char *info_get_version(void)
                          ENDP

                  |L12.4|
                          DCD      ||.bss||+0xa0

                          AREA ||i.info_get_host_id||, CODE, READONLY, ALIGN=2

                  info_get_host_id PROC
;;;74     
;;;75     const char *info_get_host_id(void)
000000  4800              LDR      r0,|L13.4|
;;;76     {
;;;77         return string_host_id;
;;;78     }
000002  4770              BX       lr
;;;79     
                          ENDP

                  |L13.4|
                          DCD      ||.bss||+0x5e

                          AREA ||i.info_get_interface_present||, CODE, READONLY, ALIGN=2

                  info_get_interface_present PROC
;;;243    
;;;244    bool info_get_interface_present(void)
000000  2001              MOVS     r0,#1
;;;245    {
;;;246        bool present = true;
;;;247    
;;;248        if (0 == DAPLINK_ROM_IF_SIZE) {
;;;249            present = false;
;;;250        }
;;;251    
;;;252        if (DAPLINK_BUILD_KEY_IF != info_if->build_key) {
000002  4906              LDR      r1,|L14.28|
000004  4a06              LDR      r2,|L14.32|
000006  6a09              LDR      r1,[r1,#0x20]
000008  4291              CMP      r1,r2
00000a  d000              BEQ      |L14.14|
;;;253            present = false;
00000c  2000              MOVS     r0,#0
                  |L14.14|
;;;254        }
;;;255    
;;;256        if (DAPLINK_HIC_ID != info_if->hic_id) {
00000e  4903              LDR      r1,|L14.28|
000010  4a04              LDR      r2,|L14.36|
000012  6a49              LDR      r1,[r1,#0x24]
000014  4291              CMP      r1,r2
000016  d000              BEQ      |L14.26|
;;;257            present = false;
000018  2000              MOVS     r0,#0
                  |L14.26|
;;;258        }
;;;259    
;;;260        return present;
;;;261    }
00001a  4770              BX       lr
;;;262    
                          ENDP

                  |L14.28|
                          DCD      0x0800c000
                  |L14.32|
                          DCD      0x9b939e8f
                  |L14.36|
                          DCD      0x97969908

                          AREA ||i.info_get_interface_version||, CODE, READONLY, ALIGN=2

                  info_get_interface_version PROC
;;;330    
;;;331    uint32_t info_get_interface_version(void)
000000  b500              PUSH     {lr}
;;;332    {
;;;333        // Don't read version if image is not present
;;;334        if (!info_get_interface_present()) {
000002  f7fffffe          BL       info_get_interface_present
000006  b908              CBNZ     r0,|L15.12|
;;;335            return 0;
000008  2000              MOVS     r0,#0
                  |L15.10|
;;;336        }
;;;337    
;;;338        return info_if->version;
;;;339    }
00000a  bd00              POP      {pc}
                  |L15.12|
00000c  4801              LDR      r0,|L15.20|
00000e  6a80              LDR      r0,[r0,#0x28]         ;338
000010  e7fb              B        |L15.10|
;;;340    
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x0800c000

                          AREA ||i.info_get_mac||, CODE, READONLY, ALIGN=2

                  info_get_mac PROC
;;;92     }
;;;93     const char *info_get_mac(void)
000000  4800              LDR      r0,|L16.4|
;;;94     {
;;;95         return string_mac;
;;;96     }
000002  4770              BX       lr
;;;97     
                          ENDP

                  |L16.4|
                          DCD      ||.bss||+0x51

                          AREA ||i.info_get_target_id||, CODE, READONLY, ALIGN=2

                  info_get_target_id PROC
;;;79     
;;;80     const char *info_get_target_id(void)
000000  4800              LDR      r0,|L17.4|
;;;81     {
;;;82         return string_target_id;
;;;83     }
000002  4770              BX       lr
;;;84     
                          ENDP

                  |L17.4|
                          DCD      ||.bss||+0x7f

                          AREA ||i.info_get_unique_id||, CODE, READONLY, ALIGN=2

                  info_get_unique_id PROC
;;;64     
;;;65     const char *info_get_unique_id(void)
000000  4800              LDR      r0,|L18.4|
;;;66     {
;;;67         return string_unique_id;
;;;68     }
000002  4770              BX       lr
;;;69     
                          ENDP

                  |L18.4|
                          DCD      ||.bss||+0x20

                          AREA ||i.info_get_unique_id_string_descriptor||, CODE, READONLY, ALIGN=2

                  info_get_unique_id_string_descriptor PROC
;;;97     
;;;98     const char *info_get_unique_id_string_descriptor(void)
000000  4800              LDR      r0,|L19.4|
;;;99     {
;;;100        return usb_desc_unique_id;
;;;101    }
000002  4770              BX       lr
;;;102    
                          ENDP

                  |L19.4|
                          DCD      ||.bss||+0xa9

                          AREA ||i.info_get_version||, CODE, READONLY, ALIGN=2

                  info_get_version PROC
;;;88     }
;;;89     const char *info_get_version(void)
000000  4800              LDR      r0,|L20.4|
;;;90     {
;;;91         return string_version;
;;;92     }
000002  4770              BX       lr
;;;93     const char *info_get_mac(void)
                          ENDP

                  |L20.4|
                          DCD      ||.data||+0x1e

                          AREA ||i.info_init||, CODE, READONLY, ALIGN=2

                  info_init PROC
;;;202    
;;;203    void info_init(void)
000000  b510              PUSH     {r4,lr}
;;;204    {
;;;205        info_crc_compute();
000002  f7fffffe          BL       info_crc_compute
;;;206        read_unique_id(host_id);
000006  4805              LDR      r0,|L21.28|
000008  f7fffffe          BL       read_unique_id
;;;207        setup_basics();
00000c  f7fffffe          BL       setup_basics
;;;208        setup_unique_id();
000010  f7fffffe          BL       setup_unique_id
;;;209        setup_string_descriptor();
000014  f7fffffe          BL       setup_string_descriptor
;;;210    }
000018  bd10              POP      {r4,pc}
;;;211    
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      host_id

                          AREA ||i.info_set_uuid_target||, CODE, READONLY, ALIGN=2

                  info_set_uuid_target PROC
;;;211    
;;;212    void info_set_uuid_target(uint32_t *uuid_data)
000000  b570              PUSH     {r4-r6,lr}
;;;213    {
000002  4604              MOV      r4,r0
;;;214        uint32_t idx = 0;
000004  2500              MOVS     r5,#0
;;;215        // Save the target ID
;;;216        memcpy(target_id, uuid_data, 16);
000006  e894004e          LDM      r4,{r1-r3,r6}
00000a  480e              LDR      r0,|L22.68|
00000c  c04e              STM      r0!,{r1-r3,r6}
;;;217        // patch for MAC use. Make sure MSB bits are set correctly
;;;218        uuid_data[2] |= (0x2 << 8);
00000e  68a0              LDR      r0,[r4,#8]
000010  f4407000          ORR      r0,r0,#0x200
000014  60a0              STR      r0,[r4,#8]
;;;219        uuid_data[2] &= ~(0x1 << 8);
000016  68a0              LDR      r0,[r4,#8]
000018  f4207080          BIC      r0,r0,#0x100
00001c  60a0              STR      r0,[r4,#8]
;;;220        idx += util_write_hex16(string_mac + idx, uuid_data[2] & 0xFFFF);
00001e  8922              LDRH     r2,[r4,#8]
000020  b291              UXTH     r1,r2
000022  4a09              LDR      r2,|L22.72|
000024  1950              ADDS     r0,r2,r5
000026  f7fffffe          BL       util_write_hex16
00002a  4405              ADD      r5,r5,r0
;;;221        idx += util_write_hex32(string_mac + idx, uuid_data[3]);
00002c  4a06              LDR      r2,|L22.72|
00002e  68e1              LDR      r1,[r4,#0xc]
000030  1950              ADDS     r0,r2,r5
000032  f7fffffe          BL       util_write_hex32
000036  4405              ADD      r5,r5,r0
;;;222        string_mac[idx++] = 0;
000038  4903              LDR      r1,|L22.72|
00003a  2200              MOVS     r2,#0
00003c  4628              MOV      r0,r5
00003e  1c6d              ADDS     r5,r5,#1
000040  540a              STRB     r2,[r1,r0]
;;;223    }
000042  bd70              POP      {r4-r6,pc}
;;;224    
                          ENDP

                  |L22.68|
                          DCD      target_id
                  |L22.72|
                          DCD      string_mac

                          AREA ||i.setup_basics||, CODE, READONLY, ALIGN=2

                  setup_basics PROC
;;;109    #pragma O0
;;;110    static void setup_basics(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;111    #elif (!defined(__GNUC__))
;;;112    /* #pragma GCC push_options */
;;;113    /* #pragma GCC optimize("O0") */
;;;114    static void __attribute__((optimize("O0"))) setup_basics(void)
;;;115    #else
;;;116    #error "Unknown compiler"
;;;117    #endif
;;;118    
;;;119    {
;;;120        uint8_t i = 0, idx = 0;
000004  2500              MOVS     r5,#0
000006  2400              MOVS     r4,#0
;;;121        uint16_t family_id = get_family_id();
000008  f7fffffe          BL       get_family_id
00000c  4606              MOV      r6,r0
;;;122        memset(string_board_id, 0, sizeof(string_board_id));
00000e  2105              MOVS     r1,#5
000010  4857              LDR      r0,|L23.368|
000012  f7fffffe          BL       __aeabi_memclr4
;;;123        memset(string_host_id, 0, sizeof(string_host_id));
000016  2121              MOVS     r1,#0x21
000018  4856              LDR      r0,|L23.372|
00001a  f7fffffe          BL       __aeabi_memclr
;;;124        memset(string_target_id, 0, sizeof(string_target_id));
00001e  2121              MOVS     r1,#0x21
000020  4855              LDR      r0,|L23.376|
000022  f7fffffe          BL       __aeabi_memclr
;;;125        memset(string_hic_id, 0, sizeof(string_hic_id));
000026  2109              MOVS     r1,#9
000028  4854              LDR      r0,|L23.380|
00002a  f7fffffe          BL       __aeabi_memclr4
;;;126        memset(string_board_id, 0, sizeof(string_board_id));
00002e  2105              MOVS     r1,#5
000030  484f              LDR      r0,|L23.368|
000032  f7fffffe          BL       __aeabi_memclr4
;;;127        // Host ID
;;;128        idx = 0;
000036  bf00              NOP      
;;;129    
;;;130        for (i = 0; i < 4; i++) {
000038  bf00              NOP      
00003a  e00a              B        |L23.82|
                  |L23.60|
;;;131            idx += util_write_hex32(string_host_id + idx, host_id[i]);
00003c  4a50              LDR      r2,|L23.384|
00003e  f8521025          LDR      r1,[r2,r5,LSL #2]
000042  4a4c              LDR      r2,|L23.372|
000044  1910              ADDS     r0,r2,r4
000046  f7fffffe          BL       util_write_hex32
00004a  4420              ADD      r0,r0,r4
00004c  b2c4              UXTB     r4,r0
00004e  1c68              ADDS     r0,r5,#1              ;130
000050  b2c5              UXTB     r5,r0                 ;130
                  |L23.82|
000052  2d04              CMP      r5,#4                 ;130
000054  dbf2              BLT      |L23.60|
;;;132        }
;;;133    
;;;134        string_host_id[idx++] = 0;
000056  2200              MOVS     r2,#0
000058  4620              MOV      r0,r4
00005a  1c61              ADDS     r1,r4,#1
00005c  b2cc              UXTB     r4,r1
00005e  4945              LDR      r1,|L23.372|
000060  540a              STRB     r2,[r1,r0]
;;;135        // Target ID
;;;136        idx = 0;
000062  2400              MOVS     r4,#0
;;;137    
;;;138        for (i = 0; i < 4; i++) {
000064  2500              MOVS     r5,#0
000066  e00a              B        |L23.126|
                  |L23.104|
;;;139            idx += util_write_hex32(string_target_id + idx, target_id[i]);
000068  4a46              LDR      r2,|L23.388|
00006a  f8521025          LDR      r1,[r2,r5,LSL #2]
00006e  4a42              LDR      r2,|L23.376|
000070  1910              ADDS     r0,r2,r4
000072  f7fffffe          BL       util_write_hex32
000076  4420              ADD      r0,r0,r4
000078  b2c4              UXTB     r4,r0
00007a  1c68              ADDS     r0,r5,#1              ;138
00007c  b2c5              UXTB     r5,r0                 ;138
                  |L23.126|
00007e  2d04              CMP      r5,#4                 ;138
000080  dbf2              BLT      |L23.104|
;;;140        }
;;;141    
;;;142        string_target_id[idx++] = 0;
000082  2200              MOVS     r2,#0
000084  4621              MOV      r1,r4
000086  1c60              ADDS     r0,r4,#1
000088  b2c4              UXTB     r4,r0
00008a  483b              LDR      r0,|L23.376|
00008c  5442              STRB     r2,[r0,r1]
;;;143        // HIC ID
;;;144        idx = 0;
00008e  2400              MOVS     r4,#0
;;;145        idx += util_write_hex32(string_hic_id + idx, hic_id);
000090  493a              LDR      r1,|L23.380|
000092  1908              ADDS     r0,r1,r4
000094  493c              LDR      r1,|L23.392|
000096  6809              LDR      r1,[r1,#0]  ; hic_id
000098  f7fffffe          BL       util_write_hex32
00009c  4420              ADD      r0,r0,r4
00009e  b2c4              UXTB     r4,r0
;;;146        string_hic_id[idx++] = 0;
0000a0  4620              MOV      r0,r4
0000a2  1c61              ADDS     r1,r4,#1
0000a4  b2cc              UXTB     r4,r1
0000a6  4935              LDR      r1,|L23.380|
0000a8  2200              MOVS     r2,#0
0000aa  540a              STRB     r2,[r1,r0]
;;;147        // Board ID
;;;148        memcpy(string_board_id, get_board_id(), 4);
0000ac  f7fffffe          BL       get_board_id
0000b0  4607              MOV      r7,r0
0000b2  2204              MOVS     r2,#4
0000b4  4639              MOV      r1,r7
0000b6  482e              LDR      r0,|L23.368|
0000b8  f7fffffe          BL       __aeabi_memcpy
;;;149        string_board_id[4] = 0;
0000bc  492c              LDR      r1,|L23.368|
0000be  2000              MOVS     r0,#0
0000c0  7108              STRB     r0,[r1,#4]
;;;150        idx = 0;
0000c2  2400              MOVS     r4,#0
;;;151        //Family ID
;;;152        string_family_id[idx++] = hex_to_ascii(((family_id >> 12) & 0xF));    
0000c4  0b30              LSRS     r0,r6,#12
0000c6  f7fffffe          BL       hex_to_ascii
0000ca  4601              MOV      r1,r0
0000cc  482f              LDR      r0,|L23.396|
0000ce  4622              MOV      r2,r4
0000d0  1c64              ADDS     r4,r4,#1
0000d2  5481              STRB     r1,[r0,r2]
;;;153        string_family_id[idx++] = hex_to_ascii(((family_id >> 8) & 0xF));
0000d4  f3c62003          UBFX     r0,r6,#8,#4
0000d8  f7fffffe          BL       hex_to_ascii
0000dc  4601              MOV      r1,r0
0000de  482b              LDR      r0,|L23.396|
0000e0  4622              MOV      r2,r4
0000e2  1c64              ADDS     r4,r4,#1
0000e4  5481              STRB     r1,[r0,r2]
;;;154    #if !(defined(DAPLINK_BL)) &&  defined(DRAG_N_DROP_SUPPORT)   //need to change the unique id when the msd is disabled 
;;;155        #if defined(MSC_ENDPOINT)
;;;156        if (config_ram_get_disable_msd() == 1 || flash_algo_valid()==0){
0000e6  f7fffffe          BL       config_ram_get_disable_msd
0000ea  2801              CMP      r0,#1
0000ec  d002              BEQ      |L23.244|
0000ee  f7fffffe          BL       flash_algo_valid
0000f2  b960              CBNZ     r0,|L23.270|
                  |L23.244|
;;;157            string_family_id[idx++] = hex_to_ascii((((family_id >> 4) | 0x08) & 0xF)); 
0000f4  2108              MOVS     r1,#8
0000f6  ea411126          ORR      r1,r1,r6,ASR #4
0000fa  f001000f          AND      r0,r1,#0xf
0000fe  f7fffffe          BL       hex_to_ascii
000102  4621              MOV      r1,r4
000104  1c62              ADDS     r2,r4,#1
000106  b2d4              UXTB     r4,r2
000108  4a20              LDR      r2,|L23.396|
00010a  5450              STRB     r0,[r2,r1]
00010c  e008              B        |L23.288|
                  |L23.270|
;;;158        } else {
;;;159            string_family_id[idx++] = hex_to_ascii(((family_id >> 4) & 0xF));
00010e  f3c61003          UBFX     r0,r6,#4,#4
000112  f7fffffe          BL       hex_to_ascii
000116  4621              MOV      r1,r4
000118  1c62              ADDS     r2,r4,#1
00011a  b2d4              UXTB     r4,r2
00011c  4a1b              LDR      r2,|L23.396|
00011e  5450              STRB     r0,[r2,r1]
                  |L23.288|
;;;160        }
;;;161        #else //no msd support always have the most significant bit set for family id 2nd byte
;;;162            string_family_id[idx++] = hex_to_ascii((((family_id >> 4) | 0x08) & 0xF)); 
;;;163        #endif
;;;164    #else
;;;165        string_family_id[idx++] = hex_to_ascii(((family_id >> 4) & 0xF));
;;;166    #endif
;;;167        string_family_id[idx++] = hex_to_ascii(((family_id) & 0xF));    
000120  f006000f          AND      r0,r6,#0xf
000124  f7fffffe          BL       hex_to_ascii
000128  4621              MOV      r1,r4
00012a  1c62              ADDS     r2,r4,#1
00012c  b2d4              UXTB     r4,r2
00012e  4a17              LDR      r2,|L23.396|
000130  5450              STRB     r0,[r2,r1]
;;;168        string_family_id[idx++] = 0;
000132  2200              MOVS     r2,#0
000134  4620              MOV      r0,r4
000136  1c61              ADDS     r1,r4,#1
000138  b2cc              UXTB     r4,r1
00013a  4914              LDR      r1,|L23.396|
00013c  540a              STRB     r2,[r1,r0]
;;;169        // Version
;;;170        idx = 0;
00013e  2400              MOVS     r4,#0
;;;171        string_version[idx++] = '0' + (DAPLINK_VERSION / 1000) % 10;
000140  4813              LDR      r0,|L23.400|
000142  2230              MOVS     r2,#0x30
000144  4621              MOV      r1,r4
000146  1c64              ADDS     r4,r4,#1
000148  5442              STRB     r2,[r0,r1]
;;;172        string_version[idx++] = '0' + (DAPLINK_VERSION / 100) % 10;
00014a  2232              MOVS     r2,#0x32
00014c  4621              MOV      r1,r4
00014e  1c64              ADDS     r4,r4,#1
000150  5442              STRB     r2,[r0,r1]
;;;173        string_version[idx++] = '0' + (DAPLINK_VERSION / 10) % 10;
000152  2235              MOVS     r2,#0x35
000154  4621              MOV      r1,r4
000156  1c64              ADDS     r4,r4,#1
000158  5442              STRB     r2,[r0,r1]
;;;174        string_version[idx++] = '0' + (DAPLINK_VERSION / 1) % 10;
00015a  2236              MOVS     r2,#0x36
00015c  4621              MOV      r1,r4
00015e  1c64              ADDS     r4,r4,#1
000160  5442              STRB     r2,[r0,r1]
;;;175        string_version[idx++] = 0;
000162  2200              MOVS     r2,#0
000164  4621              MOV      r1,r4
000166  1c64              ADDS     r4,r4,#1
000168  5442              STRB     r2,[r0,r1]
;;;176    }
00016a  e8bd81f0          POP      {r4-r8,pc}
;;;177    
                          ENDP

00016e  0000              DCW      0x0000
                  |L23.368|
                          DCD      string_board_id
                  |L23.372|
                          DCD      string_host_id
                  |L23.376|
                          DCD      string_target_id
                  |L23.380|
                          DCD      string_hic_id
                  |L23.384|
                          DCD      host_id
                  |L23.388|
                          DCD      target_id
                  |L23.392|
                          DCD      hic_id
                  |L23.396|
                          DCD      string_family_id
                  |L23.400|
                          DCD      string_version

                          AREA ||i.setup_string_descriptor||, CODE, READONLY, ALIGN=2

                  setup_string_descriptor PROC
;;;186    
;;;187    static void setup_string_descriptor()
000000  b570              PUSH     {r4-r6,lr}
;;;188    {
;;;189        uint8_t i = 0, idx = 0, len = 0;
000002  2500              MOVS     r5,#0
000004  2400              MOVS     r4,#0
000006  2600              MOVS     r6,#0
;;;190        len = strlen((const char *)string_unique_id);
000008  4811              LDR      r0,|L24.80|
00000a  f7fffffe          BL       strlen
00000e  b2c6              UXTB     r6,r0
;;;191        // bLength
;;;192        usb_desc_unique_id[idx++] = len * 2 + 2;
000010  2002              MOVS     r0,#2
000012  eb000046          ADD      r0,r0,r6,LSL #1
000016  b2c2              UXTB     r2,r0
000018  480e              LDR      r0,|L24.84|
00001a  4621              MOV      r1,r4
00001c  1c64              ADDS     r4,r4,#1
00001e  5442              STRB     r2,[r0,r1]
;;;193        // bDescriptorType
;;;194        usb_desc_unique_id[idx++] = 3;
000020  2203              MOVS     r2,#3
000022  4621              MOV      r1,r4
000024  1c64              ADDS     r4,r4,#1
000026  5442              STRB     r2,[r0,r1]
;;;195    
;;;196        // bString
;;;197        for (i = 0; i < len; i++) {
000028  bf00              NOP      
00002a  e00e              B        |L24.74|
                  |L24.44|
;;;198            usb_desc_unique_id[idx++] = string_unique_id[i];
00002c  4808              LDR      r0,|L24.80|
00002e  1c61              ADDS     r1,r4,#1
000030  5d42              LDRB     r2,[r0,r5]
000032  4620              MOV      r0,r4
000034  b2cc              UXTB     r4,r1
000036  4907              LDR      r1,|L24.84|
000038  540a              STRB     r2,[r1,r0]
;;;199            usb_desc_unique_id[idx++] = 0;
00003a  2200              MOVS     r2,#0
00003c  4620              MOV      r0,r4
00003e  1c61              ADDS     r1,r4,#1
000040  b2cc              UXTB     r4,r1
000042  4904              LDR      r1,|L24.84|
000044  540a              STRB     r2,[r1,r0]
000046  1c68              ADDS     r0,r5,#1              ;197
000048  b2c5              UXTB     r5,r0                 ;197
                  |L24.74|
00004a  42b5              CMP      r5,r6                 ;197
00004c  dbee              BLT      |L24.44|
;;;200        }
;;;201    }
00004e  bd70              POP      {r4-r6,pc}
;;;202    
                          ENDP

                  |L24.80|
                          DCD      string_unique_id
                  |L24.84|
                          DCD      usb_desc_unique_id

                          AREA ||i.setup_unique_id||, CODE, READONLY, ALIGN=2

                  setup_unique_id PROC
;;;177    
;;;178    static void setup_unique_id()
000000  b510              PUSH     {r4,lr}
;;;179    {
;;;180        memset(string_unique_id, 0, sizeof(string_unique_id));
000002  2131              MOVS     r1,#0x31
000004  4809              LDR      r0,|L25.44|
000006  f7fffffe          BL       __aeabi_memclr4
;;;181        strcat(string_unique_id, string_board_id);
00000a  4909              LDR      r1,|L25.48|
00000c  4807              LDR      r0,|L25.44|
00000e  f7fffffe          BL       strcat
;;;182        strcat(string_unique_id, string_family_id);
000012  4908              LDR      r1,|L25.52|
000014  4805              LDR      r0,|L25.44|
000016  f7fffffe          BL       strcat
;;;183        strcat(string_unique_id, string_host_id);
00001a  4907              LDR      r1,|L25.56|
00001c  4803              LDR      r0,|L25.44|
00001e  f7fffffe          BL       strcat
;;;184        strcat(string_unique_id, string_hic_id);
000022  4906              LDR      r1,|L25.60|
000024  4801              LDR      r0,|L25.44|
000026  f7fffffe          BL       strcat
;;;185    }
00002a  bd10              POP      {r4,pc}
;;;186    
                          ENDP

                  |L25.44|
                          DCD      string_unique_id
                  |L25.48|
                          DCD      string_board_id
                  |L25.52|
                          DCD      string_family_id
                  |L25.56|
                          DCD      string_host_id
                  |L25.60|
                          DCD      string_hic_id

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  host_id
                          %        16
                  target_id
                          %        16
                  string_unique_id
                          %        49
                  string_mac
                          %        13
                  string_host_id
                          %        33
                  string_target_id
                          %        33
                  string_hic_id
                          %        9
                  usb_desc_unique_id
                          %        100

                          AREA ||.data||, DATA, ALIGN=2

                  hic_id
                          DCD      0x97969908
                  crc_bootloader
                          DCD      0x00000000
                  crc_interface
                          DCD      0x00000000
                  crc_config_admin
                          DCD      0x00000000
                  crc_config_user
                          DCD      0x00000000
                  string_board_id
                          DCD      0x00000000
000018  00                DCB      0x00
                  string_family_id
000019  000000            DCB      0x00,0x00,0x00
00001c  0000              DCB      0x00,0x00
                  string_version
00001e  0000              DCB      0x00,0x00
000020  000000            DCB      0x00,0x00,0x00
