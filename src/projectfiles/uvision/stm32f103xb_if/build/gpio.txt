; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\gpio.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\gpio.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\gpio.crf ..\..\..\source\hic_hal\stm32\stm32f103xb\gpio.c]
                          THUMB

                          AREA ||i.GPIOGetButtonState||, CODE, READONLY, ALIGN=1

                  GPIOGetButtonState PROC
;;;219    
;;;220    uint8_t GPIOGetButtonState(void)
000000  2000              MOVS     r0,#0
;;;221    {
;;;222        return 0;
;;;223    }
000002  4770              BX       lr
;;;224    
                          ENDP


                          AREA ||i.gpio_get_reset_btn_fwrd||, CODE, READONLY, ALIGN=1

                  gpio_get_reset_btn_fwrd PROC
;;;213    
;;;214    uint8_t gpio_get_reset_btn_fwrd(void)
000000  2000              MOVS     r0,#0
;;;215    {
;;;216        return 0;
;;;217    }
000002  4770              BX       lr
;;;218    
                          ENDP


                          AREA ||i.gpio_get_reset_btn_no_fwrd||, CODE, READONLY, ALIGN=2

                  gpio_get_reset_btn_no_fwrd PROC
;;;208    
;;;209    uint8_t gpio_get_reset_btn_no_fwrd(void)
000000  4802              LDR      r0,|L3.12|
;;;210    {
;;;211        return (nRESET_PIN_PORT->IDR & nRESET_PIN) ? 0 : 1;
000002  6800              LDR      r0,[r0,#0]
000004  f3400000          SBFX     r0,r0,#0,#1
000008  1c40              ADDS     r0,r0,#1
;;;212    }
00000a  4770              BX       lr
;;;213    
                          ENDP

                  |L3.12|
                          DCD      0x40010c08

                          AREA ||i.gpio_init||, CODE, READONLY, ALIGN=2

                  gpio_init PROC
;;;114    
;;;115    void gpio_init(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;116    {
;;;117        GPIO_InitTypeDef GPIO_InitStructure;
;;;118        // enable clock to ports
;;;119        __HAL_RCC_GPIOA_CLK_ENABLE();
000004  4856              LDR      r0,|L4.352|
000006  b085              SUB      sp,sp,#0x14           ;116
000008  6981              LDR      r1,[r0,#0x18]
00000a  f0410104          ORR      r1,r1,#4
00000e  6181              STR      r1,[r0,#0x18]
000010  6981              LDR      r1,[r0,#0x18]
000012  f0010104          AND      r1,r1,#4
;;;120        __HAL_RCC_GPIOB_CLK_ENABLE();
000016  9104              STR      r1,[sp,#0x10]
000018  6981              LDR      r1,[r0,#0x18]
00001a  f0410108          ORR      r1,r1,#8
00001e  6181              STR      r1,[r0,#0x18]
000020  6981              LDR      r1,[r0,#0x18]
000022  f0010108          AND      r1,r1,#8
;;;121        __HAL_RCC_GPIOC_CLK_ENABLE();
000026  9104              STR      r1,[sp,#0x10]
000028  6981              LDR      r1,[r0,#0x18]
00002a  f0410110          ORR      r1,r1,#0x10
00002e  6181              STR      r1,[r0,#0x18]
000030  6981              LDR      r1,[r0,#0x18]
000032  f0010110          AND      r1,r1,#0x10
;;;122        __HAL_RCC_GPIOD_CLK_ENABLE();
000036  9104              STR      r1,[sp,#0x10]
000038  6981              LDR      r1,[r0,#0x18]
00003a  f0410120          ORR      r1,r1,#0x20
00003e  6181              STR      r1,[r0,#0x18]
000040  6981              LDR      r1,[r0,#0x18]
000042  f0010120          AND      r1,r1,#0x20
;;;123        // Enable USB connect pin
;;;124        __HAL_RCC_AFIO_CLK_ENABLE();
000046  9104              STR      r1,[sp,#0x10]
000048  6981              LDR      r1,[r0,#0x18]
00004a  f0410101          ORR      r1,r1,#1
00004e  6181              STR      r1,[r0,#0x18]
000050  6981              LDR      r1,[r0,#0x18]
000052  f0010101          AND      r1,r1,#1
;;;125        // Disable JTAG to free pins for other uses
;;;126        // Note - SWD is still enabled
;;;127        __HAL_AFIO_REMAP_SWJ_NOJTAG();
000056  9104              STR      r1,[sp,#0x10]
000058  4942              LDR      r1,|L4.356|
00005a  684a              LDR      r2,[r1,#4]
00005c  f02262e0          BIC      r2,r2,#0x7000000
000060  f0427200          ORR      r2,r2,#0x2000000
000064  604a              STR      r2,[r1,#4]
;;;128    
;;;129        USB_CONNECT_PORT_ENABLE();
000066  6981              LDR      r1,[r0,#0x18]
000068  f0410104          ORR      r1,r1,#4
00006c  6181              STR      r1,[r0,#0x18]
00006e  6980              LDR      r0,[r0,#0x18]
;;;130        USB_CONNECT_OFF();
000070  493d              LDR      r1,|L4.360|
000072  f0000004          AND      r0,r0,#4              ;129
000076  9004              STR      r0,[sp,#0x10]
000078  f44f4000          MOV      r0,#0x8000
00007c  6008              STR      r0,[r1,#0]
;;;131        GPIO_InitStructure.Pin = USB_CONNECT_PIN;
;;;132        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;133        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
00007e  2401              MOVS     r4,#1
;;;134        HAL_GPIO_Init(USB_CONNECT_PORT, &GPIO_InitStructure);
000080  f8df90e4          LDR      r9,|L4.360|
000084  e9cd0400          STRD     r0,r4,[sp,#0]
000088  2503              MOVS     r5,#3                 ;132
00008a  f1a90914          SUB      r9,r9,#0x14
00008e  4669              MOV      r1,sp
000090  9503              STR      r5,[sp,#0xc]
000092  4648              MOV      r0,r9
000094  f7fffffe          BL       HAL_GPIO_Init
;;;135        // configure LEDs
;;;136        HAL_GPIO_WritePin(RUNNING_LED_PORT, RUNNING_LED_PIN, GPIO_PIN_SET);
000098  f8df80d0          LDR      r8,|L4.364|
00009c  2201              MOVS     r2,#1
00009e  2110              MOVS     r1,#0x10
0000a0  4640              MOV      r0,r8
0000a2  f7fffffe          BL       HAL_GPIO_WritePin
;;;137        GPIO_InitStructure.Pin = RUNNING_LED_PIN;
0000a6  2010              MOVS     r0,#0x10
;;;138        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;139        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;140        HAL_GPIO_Init(RUNNING_LED_PORT, &GPIO_InitStructure);
0000a8  e9cd0400          STRD     r0,r4,[sp,#0]
0000ac  4669              MOV      r1,sp
0000ae  9503              STR      r5,[sp,#0xc]
0000b0  4640              MOV      r0,r8
0000b2  f7fffffe          BL       HAL_GPIO_Init
;;;141    
;;;142        HAL_GPIO_WritePin(CONNECTED_LED_PORT, CONNECTED_LED_PIN, GPIO_PIN_SET);
0000b6  2201              MOVS     r2,#1
0000b8  4f2d              LDR      r7,|L4.368|
0000ba  0356              LSLS     r6,r2,#13
0000bc  4631              MOV      r1,r6
0000be  4638              MOV      r0,r7
0000c0  f7fffffe          BL       HAL_GPIO_WritePin
;;;143        GPIO_InitStructure.Pin = CONNECTED_LED_PIN;
;;;144        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;145        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;146        HAL_GPIO_Init(CONNECTED_LED_PORT, &GPIO_InitStructure);
0000c4  e9cd6400          STRD     r6,r4,[sp,#0]
0000c8  4669              MOV      r1,sp
0000ca  4638              MOV      r0,r7
0000cc  9503              STR      r5,[sp,#0xc]
0000ce  f7fffffe          BL       HAL_GPIO_Init
;;;147    
;;;148        HAL_GPIO_WritePin(PIN_CDC_LED_PORT, PIN_CDC_LED, GPIO_PIN_SET);
0000d2  2201              MOVS     r2,#1
0000d4  2104              MOVS     r1,#4
0000d6  4640              MOV      r0,r8
0000d8  f7fffffe          BL       HAL_GPIO_WritePin
;;;149        GPIO_InitStructure.Pin = PIN_CDC_LED;
0000dc  2004              MOVS     r0,#4
;;;150        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;151        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;152        HAL_GPIO_Init(PIN_CDC_LED_PORT, &GPIO_InitStructure);
0000de  e9cd0400          STRD     r0,r4,[sp,#0]
0000e2  4669              MOV      r1,sp
0000e4  9503              STR      r5,[sp,#0xc]
0000e6  4640              MOV      r0,r8
0000e8  f7fffffe          BL       HAL_GPIO_Init
;;;153    
;;;154        HAL_GPIO_WritePin(PIN_MSC_LED_PORT, PIN_MSC_LED, GPIO_PIN_SET);
0000ec  2201              MOVS     r2,#1
0000ee  2102              MOVS     r1,#2
0000f0  4640              MOV      r0,r8
0000f2  f7fffffe          BL       HAL_GPIO_WritePin
;;;155        GPIO_InitStructure.Pin = PIN_MSC_LED;
0000f6  2602              MOVS     r6,#2
;;;156        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;157        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;158        HAL_GPIO_Init(PIN_MSC_LED_PORT, &GPIO_InitStructure);
0000f8  e9cd6400          STRD     r6,r4,[sp,#0]
0000fc  4669              MOV      r1,sp
0000fe  4640              MOV      r0,r8
000100  9503              STR      r5,[sp,#0xc]
000102  f7fffffe          BL       HAL_GPIO_Init
;;;159    
;;;160        // reset button configured as gpio open drain output with a pullup
;;;161        HAL_GPIO_WritePin(nRESET_PIN_PORT, nRESET_PIN, GPIO_PIN_SET);
000106  2201              MOVS     r2,#1
000108  4611              MOV      r1,r2
00010a  4640              MOV      r0,r8
00010c  f7fffffe          BL       HAL_GPIO_WritePin
;;;162        GPIO_InitStructure.Pin = nRESET_PIN;
;;;163        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_OD;
000110  2011              MOVS     r0,#0x11
000112  e9cd4000          STRD     r4,r0,[sp,#0]
;;;164        GPIO_InitStructure.Pull = GPIO_PULLUP;
;;;165        HAL_GPIO_Init(nRESET_PIN_PORT, &GPIO_InitStructure);
000116  4669              MOV      r1,sp
000118  4640              MOV      r0,r8
00011a  9402              STR      r4,[sp,#8]
00011c  f7fffffe          BL       HAL_GPIO_Init
;;;166    
;;;167        // Turn on power to the board. When the target is unpowered
;;;168        // it holds the reset line low.
;;;169        HAL_GPIO_WritePin(POWER_EN_PIN_PORT, POWER_EN_PIN, GPIO_PIN_RESET);
000120  2200              MOVS     r2,#0
000122  2120              MOVS     r1,#0x20
000124  4640              MOV      r0,r8
000126  f7fffffe          BL       HAL_GPIO_WritePin
;;;170        GPIO_InitStructure.Pin = POWER_EN_PIN;
00012a  2020              MOVS     r0,#0x20
;;;171        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;172        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;173        HAL_GPIO_Init(POWER_EN_PIN_PORT, &GPIO_InitStructure);
00012c  e9cd0400          STRD     r0,r4,[sp,#0]
000130  4669              MOV      r1,sp
000132  9503              STR      r5,[sp,#0xc]
000134  4640              MOV      r0,r8
000136  f7fffffe          BL       HAL_GPIO_Init
;;;174    
;;;175        // Setup the 8MHz MCO
;;;176        GPIO_InitStructure.Pin = GPIO_PIN_8;
00013a  0220              LSLS     r0,r4,#8
;;;177        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;178        GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
;;;179        HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
00013c  e9cd0600          STRD     r0,r6,[sp,#0]
000140  4669              MOV      r1,sp
000142  9503              STR      r5,[sp,#0xc]
000144  4648              MOV      r0,r9
000146  f7fffffe          BL       HAL_GPIO_Init
;;;180        output_clock_enable();
00014a  f7fffffe          BL       output_clock_enable
;;;181    
;;;182        // Let the voltage rails stabilize.  This is especailly important
;;;183        // during software resets, since the target's 3.3v rail can take
;;;184        // 20-50ms to drain.  During this time the target could be driving
;;;185        // the reset pin low, causing the bootloader to think the reset
;;;186        // button is pressed.
;;;187        // Note: With optimization set to -O2 the value 1000000 delays for ~85ms
;;;188        busy_wait(1000000);
00014e  4809              LDR      r0,|L4.372|
000150  9004              STR      r0,[sp,#0x10]
                  |L4.338|
000152  1e40              SUBS     r0,r0,#1
000154  9004              STR      r0,[sp,#0x10]
000156  d1fc              BNE      |L4.338|
;;;189    }
000158  b005              ADD      sp,sp,#0x14
00015a  e8bd83f0          POP      {r4-r9,pc}
;;;190    
                          ENDP

00015e  0000              DCW      0x0000
                  |L4.352|
                          DCD      0x40021000
                  |L4.356|
                          DCD      0x40010000
                  |L4.360|
                          DCD      0x40010814
                  |L4.364|
                          DCD      0x40010c00
                  |L4.368|
                          DCD      0x40011000
                  |L4.372|
                          DCD      0x000f4240

                          AREA ||i.gpio_set_board_power||, CODE, READONLY, ALIGN=1

                  gpio_set_board_power PROC
;;;229    
;;;230    void gpio_set_board_power(bool powerEnabled)
000000  4770              BX       lr
;;;231    {
;;;232    }
                          ENDP


                          AREA ||i.gpio_set_cdc_led||, CODE, READONLY, ALIGN=2

                  gpio_set_cdc_led PROC
;;;196    
;;;197    void gpio_set_cdc_led(gpio_led_state_t state)
000000  b120              CBZ      r0,|L6.12|
;;;198    {
;;;199        // LED is active low
;;;200        HAL_GPIO_WritePin(PIN_CDC_LED_PORT, PIN_CDC_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
000002  2200              MOVS     r2,#0
                  |L6.4|
000004  2104              MOVS     r1,#4
000006  4802              LDR      r0,|L6.16|
000008  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L6.12|
00000c  2201              MOVS     r2,#1
00000e  e7f9              B        |L6.4|
;;;201    }
;;;202    
                          ENDP

                  |L6.16|
                          DCD      0x40010c00

                          AREA ||i.gpio_set_hid_led||, CODE, READONLY, ALIGN=2

                  gpio_set_hid_led PROC
;;;190    
;;;191    void gpio_set_hid_led(gpio_led_state_t state)
000000  b120              CBZ      r0,|L7.12|
;;;192    {
;;;193        // LED is active low
;;;194        HAL_GPIO_WritePin(PIN_HID_LED_PORT, PIN_HID_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
000002  2200              MOVS     r2,#0
                  |L7.4|
000004  2108              MOVS     r1,#8
000006  4802              LDR      r0,|L7.16|
000008  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L7.12|
00000c  2201              MOVS     r2,#1
00000e  e7f9              B        |L7.4|
;;;195    }
;;;196    
                          ENDP

                  |L7.16|
                          DCD      0x40010c00

                          AREA ||i.gpio_set_msc_led||, CODE, READONLY, ALIGN=2

                  gpio_set_msc_led PROC
;;;202    
;;;203    void gpio_set_msc_led(gpio_led_state_t state)
000000  b120              CBZ      r0,|L8.12|
;;;204    {
;;;205        // LED is active low
;;;206        HAL_GPIO_WritePin(PIN_MSC_LED_PORT, PIN_MSC_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
000002  2200              MOVS     r2,#0
                  |L8.4|
000004  2102              MOVS     r1,#2
000006  4802              LDR      r0,|L8.16|
000008  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L8.12|
00000c  2201              MOVS     r2,#1
00000e  e7f9              B        |L8.4|
;;;207    }
;;;208    
                          ENDP

                  |L8.16|
                          DCD      0x40010c00

                          AREA ||i.output_clock_enable||, CODE, READONLY, ALIGN=2

                  output_clock_enable PROC
;;;53     
;;;54     static void output_clock_enable(void)
000000  b570              PUSH     {r4-r6,lr}
;;;55     {
000002  b08e              SUB      sp,sp,#0x38
;;;56         HAL_StatusTypeDef ret;
;;;57         RCC_ClkInitTypeDef clk_init;
;;;58         TIM_OC_InitTypeDef pwm_config;
;;;59         uint32_t unused;
;;;60         uint32_t period;
;;;61         uint32_t source_clock;
;;;62     
;;;63         HAL_RCC_GetClockConfig(&clk_init, &unused);
000004  a90c              ADD      r1,sp,#0x30
000006  a807              ADD      r0,sp,#0x1c
000008  f7fffffe          BL       HAL_RCC_GetClockConfig
00000c  980b              LDR      r0,[sp,#0x2c]
00000e  f5b05f00          CMP      r0,#0x2000
000012  d005              BEQ      |L9.32|
000014  f5b05f20          CMP      r0,#0x2800
000018  d023              BEQ      |L9.98|
00001a  f5b05f40          CMP      r0,#0x3000
00001e  d022              BEQ      |L9.102|
                  |L9.32|
000020  2001              MOVS     r0,#1
                  |L9.34|
;;;64     
;;;65         /* Compute the period value to have TIMx counter clock equal to 8000000 Hz */
;;;66         source_clock = SystemCoreClock / tim1_clk_div(clk_init.APB2CLKDivider);
000022  4925              LDR      r1,|L9.184|
;;;67         period = (uint32_t)(source_clock / 8000000) - 1;
;;;68     
;;;69         /* Set TIMx instance */
;;;70         timer.Instance = TIM1;
000024  4d27              LDR      r5,|L9.196|
;;;71     
;;;72         timer.Init.Period            = period;
;;;73         timer.Init.Prescaler         = 0;
000026  2400              MOVS     r4,#0
000028  6809              LDR      r1,[r1,#0]            ;66  ; SystemCoreClock
00002a  fbb1f0f0          UDIV     r0,r1,r0              ;66
00002e  4923              LDR      r1,|L9.188|
000030  fbb0f6f1          UDIV     r6,r0,r1              ;67
000034  4822              LDR      r0,|L9.192|
000036  e9c50400          STRD     r0,r4,[r5,#0]
00003a  1e76              SUBS     r6,r6,#1
00003c  e9c56403          STRD     r6,r4,[r5,#0xc]
;;;74         timer.Init.ClockDivision     = 0;
;;;75         timer.Init.CounterMode       = TIM_COUNTERMODE_UP;
;;;76         timer.Init.RepetitionCounter = 0;//period / 2;
;;;77     
;;;78         __HAL_RCC_TIM1_CLK_ENABLE();
000040  4821              LDR      r0,|L9.200|
000042  60ac              STR      r4,[r5,#8]            ;76  ; timer
000044  616c              STR      r4,[r5,#0x14]  ; timer
000046  6981              LDR      r1,[r0,#0x18]
000048  f4416100          ORR      r1,r1,#0x800
00004c  6181              STR      r1,[r0,#0x18]
00004e  6980              LDR      r0,[r0,#0x18]
000050  f4006000          AND      r0,r0,#0x800
;;;79     
;;;80         ret = HAL_TIM_PWM_DeInit(&timer);
000054  900d              STR      r0,[sp,#0x34]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       HAL_TIM_PWM_DeInit
;;;81         if (ret != HAL_OK) {
00005c  b128              CBZ      r0,|L9.106|
;;;82             util_assert(0);
00005e  2252              MOVS     r2,#0x52
;;;83             return;
000060  e023              B        |L9.170|
                  |L9.98|
000062  2002              MOVS     r0,#2
000064  e7dd              B        |L9.34|
                  |L9.102|
000066  2004              MOVS     r0,#4
000068  e7db              B        |L9.34|
                  |L9.106|
;;;84         }
;;;85     
;;;86         ret = HAL_TIM_PWM_Init(&timer);
00006a  4816              LDR      r0,|L9.196|
00006c  f7fffffe          BL       HAL_TIM_PWM_Init
;;;87         if (ret != HAL_OK) {
000070  b108              CBZ      r0,|L9.118|
;;;88             util_assert(0);
000072  2258              MOVS     r2,#0x58
;;;89             return;
000074  e019              B        |L9.170|
                  |L9.118|
;;;90         }
;;;91     
;;;92         pwm_config.OCMode = TIM_OCMODE_PWM2;
000076  2070              MOVS     r0,#0x70
000078  e9cd0400          STRD     r0,r4,[sp,#0]
;;;93         pwm_config.Pulse = 0; // TODO - make sure this isn't used
;;;94         pwm_config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;95         pwm_config.OCNPolarity = TIM_OCPOLARITY_HIGH;
00007c  9402              STR      r4,[sp,#8]
;;;96         pwm_config.OCFastMode = TIM_OCFAST_DISABLE;
00007e  9403              STR      r4,[sp,#0xc]
;;;97         pwm_config.OCIdleState = TIM_OCIDLESTATE_RESET;
000080  9404              STR      r4,[sp,#0x10]
;;;98         pwm_config.OCNIdleState = TIM_OCIDLESTATE_RESET;
000082  9405              STR      r4,[sp,#0x14]
;;;99         ret = HAL_TIM_PWM_ConfigChannel(&timer, &pwm_config, TIM_CHANNEL_1);
000084  2200              MOVS     r2,#0
000086  4669              MOV      r1,sp
000088  480e              LDR      r0,|L9.196|
00008a  9406              STR      r4,[sp,#0x18]
00008c  f7fffffe          BL       HAL_TIM_PWM_ConfigChannel
;;;100        if (ret != HAL_OK) {
000090  b108              CBZ      r0,|L9.150|
;;;101            util_assert(0);
000092  2265              MOVS     r2,#0x65
;;;102            return;
000094  e009              B        |L9.170|
                  |L9.150|
;;;103        }
;;;104    
;;;105        __HAL_TIM_SET_COMPARE(&timer, TIM_CHANNEL_1, period / 2);
000096  6829              LDR      r1,[r5,#0]  ; timer
000098  0870              LSRS     r0,r6,#1
00009a  6348              STR      r0,[r1,#0x34]
;;;106        ret = HAL_TIM_PWM_Start(&timer, TIM_CHANNEL_1);
00009c  2100              MOVS     r1,#0
00009e  4809              LDR      r0,|L9.196|
0000a0  f7fffffe          BL       HAL_TIM_PWM_Start
;;;107        if (ret != HAL_OK) {
0000a4  2800              CMP      r0,#0
0000a6  d004              BEQ      |L9.178|
;;;108            util_assert(0);
0000a8  226c              MOVS     r2,#0x6c
                  |L9.170|
0000aa  a108              ADR      r1,|L9.204|
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       _util_assert
                  |L9.178|
;;;109            return;
;;;110        }
;;;111    
;;;112        return;
;;;113    }
0000b2  b00e              ADD      sp,sp,#0x38
0000b4  bd70              POP      {r4-r6,pc}
;;;114    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L9.184|
                          DCD      SystemCoreClock
                  |L9.188|
                          DCD      0x007a1200
                  |L9.192|
                          DCD      0x40012c00
                  |L9.196|
                          DCD      ||.bss||
                  |L9.200|
                          DCD      0x40021000
                  |L9.204|
0000cc  2e2e5c2e          DCB      "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\gpio.c"
0000d0  2e5c2e2e
0000d4  5c736f75
0000d8  7263655c
0000dc  6869635f
0000e0  68616c5c
0000e4  73746d33
0000e8  325c7374
0000ec  6d333266
0000f0  31303378
0000f4  625c6770
0000f8  696f2e63
0000fc  00                DCB      0
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0

                          AREA ||i.target_forward_reset||, CODE, READONLY, ALIGN=1

                  target_forward_reset PROC
;;;224    
;;;225    void target_forward_reset(bool assert_reset)
000000  4770              BX       lr
;;;226    {
;;;227        // Do nothing - reset is forwarded in gpio_get_sw_reset
;;;228    }
;;;229    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  timer
                          %        60

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_c8a4be98____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___6_gpio_c_c8a4be98____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_c8a4be98____REVSH|
#line 495
|__asm___6_gpio_c_c8a4be98____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_c8a4be98____RRX|
#line 682
|__asm___6_gpio_c_c8a4be98____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
