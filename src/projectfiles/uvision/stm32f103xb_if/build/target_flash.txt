; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\target_flash.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\target_flash.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\target_flash.crf ..\..\..\source\daplink\interface\target_flash.c]
                          THUMB

                          AREA ||i.flash_func_start||, CODE, READONLY, ALIGN=2

                  flash_func_start PROC
;;;105    
;;;106    static error_t flash_func_start(flash_func_t func)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;107    {
;;;108        program_target_t * flash = current_flash_algo;
000004  4f20              LDR      r7,|L1.136|
000006  4605              MOV      r5,r0                 ;107
;;;109    
;;;110        if (last_flash_func != func)
000008  787e              LDRB     r6,[r7,#1]  ; last_flash_func
00000a  687c              LDR      r4,[r7,#4]  ; current_flash_algo
00000c  42ae              CMP      r6,r5
00000e  d037              BEQ      |L1.128|
000010  f04f0800          MOV      r8,#0                 ;107
;;;111        {
;;;112            // Finish the currently active function.
;;;113            if (FLASH_FUNC_NOP != last_flash_func &&
000014  b1be              CBZ      r6,|L1.70|
000016  f1040038          ADD      r0,r4,#0x38
;;;114                ((flash->algo_flags & kAlgoSingleInitType) == 0 || FLASH_FUNC_NOP == func ) &&
00001a  f7fffffe          BL       __aeabi_uread4
00001e  0780              LSLS     r0,r0,#30
000020  d500              BPL      |L1.36|
000022  b98d              CBNZ     r5,|L1.72|
                  |L1.36|
;;;115                0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->uninit, last_flash_func, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
000024  1d20              ADDS     r0,r4,#4
000026  f7fffffe          BL       __aeabi_uread4
00002a  4601              MOV      r1,r0
00002c  f8cd8000          STR      r8,[sp,#0]
000030  f8cd8004          STR      r8,[sp,#4]
000034  2300              MOVS     r3,#0
000036  4632              MOV      r2,r6
000038  f1040018          ADD      r0,r4,#0x18
00003c  f8cd8008          STR      r8,[sp,#8]
000040  f7fffffe          BL       swd_flash_syscall_exec
000044  b148              CBZ      r0,|L1.90|
                  |L1.70|
;;;116                return ERROR_UNINIT;
;;;117            }
;;;118    
;;;119            // Start a new function.
;;;120            if (FLASH_FUNC_NOP != func &&
000046  b1d5              CBZ      r5,|L1.126|
                  |L1.72|
;;;121                ((flash->algo_flags & kAlgoSingleInitType) == 0 || FLASH_FUNC_NOP == last_flash_func ) &&
000048  f1040038          ADD      r0,r4,#0x38
00004c  f7fffffe          BL       __aeabi_uread4
000050  0780              LSLS     r0,r0,#30
000052  d505              BPL      |L1.96|
000054  7878              LDRB     r0,[r7,#1]  ; last_flash_func
000056  b118              CBZ      r0,|L1.96|
000058  e011              B        |L1.126|
                  |L1.90|
00005a  200c              MOVS     r0,#0xc               ;116
                  |L1.92|
;;;122                0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->init, flash_start, 0, func, 0, FLASHALGO_RETURN_BOOL)) {
;;;123                return ERROR_INIT;
;;;124            }
;;;125    
;;;126            last_flash_func = func;
;;;127        }
;;;128    
;;;129        return ERROR_SUCCESS;
;;;130    }
00005c  e8bd83fe          POP      {r1-r9,pc}
                  |L1.96|
000060  4620              MOV      r0,r4                 ;122
000062  f7fffffe          BL       __aeabi_uread4
000066  e9cd5800          STRD     r5,r8,[sp,#0]         ;122
00006a  f8cd8008          STR      r8,[sp,#8]            ;122
00006e  4601              MOV      r1,r0                 ;122
000070  2300              MOVS     r3,#0                 ;122
000072  f1040018          ADD      r0,r4,#0x18           ;122
000076  68fa              LDR      r2,[r7,#0xc]          ;122  ; flash_start
000078  f7fffffe          BL       swd_flash_syscall_exec
00007c  b110              CBZ      r0,|L1.132|
                  |L1.126|
00007e  707d              STRB     r5,[r7,#1]            ;126
                  |L1.128|
000080  2000              MOVS     r0,#0                 ;129
000082  e7eb              B        |L1.92|
                  |L1.132|
000084  200b              MOVS     r0,#0xb               ;123
000086  e7e9              B        |L1.92|
;;;131    
                          ENDP

                  |L1.136|
                          DCD      ||.data||

                          AREA ||i.get_flash_algo||, CODE, READONLY, ALIGN=2

                  get_flash_algo PROC
;;;81     
;;;82     static program_target_t * get_flash_algo(uint32_t addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;83     {
000004  4605              MOV      r5,r0
;;;84         region_info_t * flash_region = g_board_info.target_cfg->flash_regions;
000006  4814              LDR      r0,|L2.88|
000008  f7fffffe          BL       __aeabi_uread4
00000c  f100040c          ADD      r4,r0,#0xc
;;;85     
;;;86         for (; flash_region->start != 0 || flash_region->end != 0; ++flash_region) {
;;;87             if (addr >= flash_region->start && addr <= flash_region->end) {
;;;88                 flash_start = flash_region->start; //save the flash start
000010  4f12              LDR      r7,|L2.92|
000012  e007              B        |L2.36|
                  |L2.20|
000014  42ae              CMP      r6,r5                 ;87
000016  d804              BHI      |L2.34|
000018  1d20              ADDS     r0,r4,#4              ;87
00001a  f7fffffe          BL       __aeabi_uread4
00001e  42a8              CMP      r0,r5                 ;87
000020  d20c              BCS      |L2.60|
                  |L2.34|
000022  3414              ADDS     r4,r4,#0x14           ;87
                  |L2.36|
000024  4620              MOV      r0,r4                 ;86
000026  f7fffffe          BL       __aeabi_uread4
00002a  0006              MOVS     r6,r0                 ;86
00002c  d1f2              BNE      |L2.20|
00002e  1d20              ADDS     r0,r4,#4              ;86
000030  f7fffffe          BL       __aeabi_uread4
000034  2800              CMP      r0,#0                 ;86
000036  d1ed              BNE      |L2.20|
;;;89                 if (flash_region->flash_algo) {
;;;90                     return flash_region->flash_algo;
;;;91                 }else{
;;;92                     return NULL;
;;;93                 }
;;;94             }
;;;95         }
;;;96     
;;;97         //could not find a flash algo for the region; use default
;;;98         if (default_region) {
000038  68bc              LDR      r4,[r7,#8]  ; default_region
00003a  b14c              CBZ      r4,|L2.80|
                  |L2.60|
00003c  4620              MOV      r0,r4
;;;99             flash_start = default_region->start;
00003e  f7fffffe          BL       __aeabi_uread4
;;;100            return default_region->flash_algo;
000042  60f8              STR      r0,[r7,#0xc]  ; flash_start
000044  f1040010          ADD      r0,r4,#0x10
000048  e8bd41f0          POP      {r4-r8,lr}
00004c  f7ffbffe          B.W      __aeabi_uread4
                  |L2.80|
;;;101        } else {
;;;102            return NULL;
000050  2000              MOVS     r0,#0
;;;103        }
;;;104    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;105    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      g_board_info+0x10
                  |L2.92|
                          DCD      ||.data||

                          AREA ||i.target_flash_busy||, CODE, READONLY, ALIGN=2

                  target_flash_busy PROC
;;;402    
;;;403    static uint8_t target_flash_busy(void){
000000  4802              LDR      r0,|L3.12|
;;;404        return (state == STATE_OPEN);
000002  7800              LDRB     r0,[r0,#0]  ; state
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L3.10|
000008  2000              MOVS     r0,#0
                  |L3.10|
;;;405    }
00000a  4770              BX       lr
;;;406    #endif
                          ENDP

                  |L3.12|
                          DCD      ||.data||

                          AREA ||i.target_flash_erase_chip||, CODE, READONLY, ALIGN=2

                  target_flash_erase_chip PROC
;;;334    
;;;335    static error_t target_flash_erase_chip(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;336    {
;;;337        if (g_board_info.target_cfg){
000002  4826              LDR      r0,|L4.156|
000004  4606              MOV      r6,r0
000006  f7fffffe          BL       __aeabi_uread4
00000a  b3e0              CBZ      r0,|L4.134|
;;;338            error_t status = ERROR_SUCCESS;
00000c  2500              MOVS     r5,#0
00000e  f100040c          ADD      r4,r0,#0xc
;;;339            region_info_t * flash_region = g_board_info.target_cfg->flash_regions;
;;;340    
;;;341            for (; flash_region->start != 0 || flash_region->end != 0; ++flash_region) {
000012  e027              B        |L4.100|
                  |L4.20|
000014  4638              MOV      r0,r7
;;;342                program_target_t *new_flash_algo = get_flash_algo(flash_region->start);
000016  f7fffffe          BL       get_flash_algo
;;;343                if ((new_flash_algo != NULL) && ((new_flash_algo->algo_flags & kAlgoSkipChipErase) != 0)) {
00001a  b120              CBZ      r0,|L4.38|
00001c  3038              ADDS     r0,r0,#0x38
00001e  f7fffffe          BL       __aeabi_uread4
000022  0740              LSLS     r0,r0,#29
000024  d41d              BMI      |L4.98|
                  |L4.38|
;;;344                    // skip flash region
;;;345                    continue;
;;;346                }
;;;347                status = target_flash_set(flash_region->start);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       __aeabi_uread4
00002c  f7fffffe          BL       target_flash_set
;;;348                if (status != ERROR_SUCCESS) {
000030  2800              CMP      r0,#0
000032  d12d              BNE      |L4.144|
;;;349                    return status;
;;;350                }
;;;351                status = flash_func_start(FLASH_FUNC_ERASE);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       flash_func_start
00003a  0005              MOVS     r5,r0
;;;352                if (status != ERROR_SUCCESS) {
00003c  d128              BNE      |L4.144|
;;;353                    return status;
;;;354                }
;;;355                if (0 == swd_flash_syscall_exec(&current_flash_algo->sys_call_s, current_flash_algo->erase_chip, 0, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
00003e  4818              LDR      r0,|L4.160|
000040  6847              LDR      r7,[r0,#4]  ; current_flash_algo
000042  f1070008          ADD      r0,r7,#8
000046  f7fffffe          BL       __aeabi_uread4
00004a  4601              MOV      r1,r0
00004c  2000              MOVS     r0,#0
00004e  9000              STR      r0,[sp,#0]
000050  9001              STR      r0,[sp,#4]
000052  4603              MOV      r3,r0
000054  4602              MOV      r2,r0
000056  9002              STR      r0,[sp,#8]
000058  f1070018          ADD      r0,r7,#0x18
00005c  f7fffffe          BL       swd_flash_syscall_exec
000060  b1b8              CBZ      r0,|L4.146|
                  |L4.98|
000062  3414              ADDS     r4,r4,#0x14
                  |L4.100|
000064  4620              MOV      r0,r4                 ;341
000066  f7fffffe          BL       __aeabi_uread4
00006a  0007              MOVS     r7,r0                 ;341
00006c  d1d2              BNE      |L4.20|
00006e  1d20              ADDS     r0,r4,#4              ;341
000070  f7fffffe          BL       __aeabi_uread4
000074  2800              CMP      r0,#0                 ;341
000076  d1cd              BNE      |L4.20|
000078  4630              MOV      r0,r6                 ;341
;;;356                    return ERROR_ERASE_ALL;
;;;357                }
;;;358            }
;;;359    
;;;360            // Reset and re-initialize the target after the erase if required
;;;361            if (g_board_info.target_cfg->erase_reset) {
00007a  f7fffffe          BL       __aeabi_uread4
00007e  f89001a2          LDRB     r0,[r0,#0x1a2]
000082  b120              CBZ      r0,|L4.142|
;;;362                status = target_flash_init();
000084  e000              B        |L4.136|
                  |L4.134|
000086  e006              B        |L4.150|
                  |L4.136|
000088  f7fffffe          BL       target_flash_init
00008c  4605              MOV      r5,r0
                  |L4.142|
;;;363            }
;;;364    
;;;365            return status;
00008e  4628              MOV      r0,r5
                  |L4.144|
;;;366        } else {
;;;367            return ERROR_FAILURE;
;;;368        }
;;;369    }
000090  bdfe              POP      {r1-r7,pc}
                  |L4.146|
000092  2010              MOVS     r0,#0x10              ;356
000094  bdfe              POP      {r1-r7,pc}
                  |L4.150|
000096  2001              MOVS     r0,#1                 ;367
000098  bdfe              POP      {r1-r7,pc}
;;;370    
                          ENDP

00009a  0000              DCW      0x0000
                  |L4.156|
                          DCD      g_board_info+0x10
                  |L4.160|
                          DCD      ||.data||

                          AREA ||i.target_flash_erase_sector||, CODE, READONLY, ALIGN=2

                  target_flash_erase_sector PROC
;;;303    
;;;304    static error_t target_flash_erase_sector(uint32_t addr)
000000  b53e              PUSH     {r1-r5,lr}
;;;305    {
000002  4605              MOV      r5,r0
;;;306        if (g_board_info.target_cfg) {
000004  4816              LDR      r0,|L5.96|
000006  f7fffffe          BL       __aeabi_uread4
00000a  b330              CBZ      r0,|L5.90|
;;;307            error_t status = ERROR_SUCCESS;
;;;308            program_target_t * flash = current_flash_algo;
00000c  4815              LDR      r0,|L5.100|
;;;309    
;;;310            if (!flash) {
00000e  6844              LDR      r4,[r0,#4]  ; current_flash_algo
000010  b144              CBZ      r4,|L5.36|
;;;311                return ERROR_INTERNAL;
;;;312            }
;;;313    
;;;314            // Check to make sure the address is on a sector boundary
;;;315            if ((addr % target_flash_erase_sector_size(addr)) != 0) {
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       target_flash_erase_sector_size
000018  fbb5f1f0          UDIV     r1,r5,r0
00001c  fb005011          MLS      r0,r0,r1,r5
000020  b9c8              CBNZ     r0,|L5.86|
000022  e001              B        |L5.40|
                  |L5.36|
000024  2002              MOVS     r0,#2                 ;311
                  |L5.38|
;;;316                return ERROR_ERASE_SECTOR;
;;;317            }
;;;318    
;;;319            status = flash_func_start(FLASH_FUNC_ERASE);
;;;320    
;;;321            if (status != ERROR_SUCCESS) {
;;;322                return status;
;;;323            }
;;;324    
;;;325            if (0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->erase_sector, addr, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
;;;326                return ERROR_ERASE_SECTOR;
;;;327            }
;;;328    
;;;329            return ERROR_SUCCESS;
;;;330        } else {
;;;331            return ERROR_FAILURE;
;;;332        }
;;;333    }
000026  bd3e              POP      {r1-r5,pc}
                  |L5.40|
000028  2001              MOVS     r0,#1                 ;319
00002a  f7fffffe          BL       flash_func_start
00002e  2800              CMP      r0,#0                 ;321
000030  d1f9              BNE      |L5.38|
000032  f104000c          ADD      r0,r4,#0xc            ;325
000036  f7fffffe          BL       __aeabi_uread4
00003a  4601              MOV      r1,r0                 ;325
00003c  2000              MOVS     r0,#0                 ;325
00003e  9000              STR      r0,[sp,#0]            ;325
000040  9001              STR      r0,[sp,#4]            ;325
000042  4603              MOV      r3,r0                 ;325
000044  9002              STR      r0,[sp,#8]            ;325
000046  462a              MOV      r2,r5                 ;325
000048  f1040018          ADD      r0,r4,#0x18           ;325
00004c  f7fffffe          BL       swd_flash_syscall_exec
000050  b108              CBZ      r0,|L5.86|
000052  2000              MOVS     r0,#0                 ;329
000054  bd3e              POP      {r1-r5,pc}
                  |L5.86|
000056  200f              MOVS     r0,#0xf               ;326
000058  bd3e              POP      {r1-r5,pc}
                  |L5.90|
00005a  2001              MOVS     r0,#1                 ;331
00005c  bd3e              POP      {r1-r5,pc}
;;;334    
                          ENDP

00005e  0000              DCW      0x0000
                  |L5.96|
                          DCD      g_board_info+0x10
                  |L5.100|
                          DCD      ||.data||

                          AREA ||i.target_flash_erase_sector_size||, CODE, READONLY, ALIGN=2

                  target_flash_erase_sector_size PROC
;;;383    
;;;384    static uint32_t target_flash_erase_sector_size(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;385    {
000002  4605              MOV      r5,r0
;;;386        if (g_board_info.target_cfg){
000004  4814              LDR      r0,|L6.88|
000006  f7fffffe          BL       __aeabi_uread4
00000a  1e06              SUBS     r6,r0,#0
00000c  d023              BEQ      |L6.86|
;;;387            if(g_board_info.target_cfg->sector_info_length > 0) {
00000e  f1060008          ADD      r0,r6,#8
000012  f7fffffe          BL       __aeabi_uread4
000016  b1b8              CBZ      r0,|L6.72|
;;;388                int sector_index = g_board_info.target_cfg->sector_info_length - 1;
000018  1e44              SUBS     r4,r0,#1
;;;389                for (; sector_index >= 0; sector_index--) {
00001a  d415              BMI      |L6.72|
                  |L6.28|
;;;390                    if (addr >= g_board_info.target_cfg->sectors_info[sector_index].start) {
00001c  1d30              ADDS     r0,r6,#4
00001e  f7fffffe          BL       __aeabi_uread4
000022  eb0000c4          ADD      r0,r0,r4,LSL #3
000026  f7fffffe          BL       __aeabi_uread4
00002a  42a8              CMP      r0,r5
00002c  d80a              BHI      |L6.68|
;;;391                        return g_board_info.target_cfg->sectors_info[sector_index].size;
00002e  1d30              ADDS     r0,r6,#4
000030  f7fffffe          BL       __aeabi_uread4
000034  2104              MOVS     r1,#4
000036  eb0101c4          ADD      r1,r1,r4,LSL #3
00003a  e8bd4070          POP      {r4-r6,lr}
00003e  4408              ADD      r0,r0,r1
000040  f7ffbffe          B.W      __aeabi_uread4
                  |L6.68|
000044  1e64              SUBS     r4,r4,#1
000046  d5e9              BPL      |L6.28|
                  |L6.72|
;;;392                    }
;;;393                }
;;;394            }
;;;395            //sector information should be in sector_info
;;;396            util_assert(0);
000048  f44f72c6          MOV      r2,#0x18c
00004c  a103              ADR      r1,|L6.92|
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       _util_assert
;;;397            return 0;
000054  2000              MOVS     r0,#0
                  |L6.86|
;;;398        } else {
;;;399            return 0;
;;;400        }
;;;401    }
000056  bd70              POP      {r4-r6,pc}
;;;402    
                          ENDP

                  |L6.88|
                          DCD      g_board_info+0x10
                  |L6.92|
00005c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\interface\\target_flash.c",0
000060  2e5c2e2e
000064  5c736f75
000068  7263655c
00006c  6461706c
000070  696e6b5c
000074  696e7465
000078  72666163
00007c  655c7461
000080  72676574
000084  5f666c61
000088  73682e63
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.target_flash_init||, CODE, READONLY, ALIGN=2

                  target_flash_init PROC
;;;154    
;;;155    static error_t target_flash_init()
000000  b570              PUSH     {r4-r6,lr}
;;;156    {
;;;157        if (g_board_info.target_cfg) {
000002  4817              LDR      r0,|L7.96|
000004  4604              MOV      r4,r0
000006  f7fffffe          BL       __aeabi_uread4
00000a  b330              CBZ      r0,|L7.90|
;;;158            last_flash_func = FLASH_FUNC_NOP;
00000c  4d15              LDR      r5,|L7.100|
00000e  2000              MOVS     r0,#0
000010  7068              STRB     r0,[r5,#1]
;;;159    
;;;160            current_flash_algo = NULL;
;;;161    
;;;162            if (0 == target_set_state(RESET_PROGRAM)) {
000012  6068              STR      r0,[r5,#4]  ; current_flash_algo
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       target_set_state
00001a  b128              CBZ      r0,|L7.40|
00001c  4620              MOV      r0,r4
;;;163                return ERROR_RESET;
;;;164            }
;;;165    
;;;166            //get default region
;;;167            region_info_t * flash_region = g_board_info.target_cfg->flash_regions;
00001e  f7fffffe          BL       __aeabi_uread4
000022  f100040c          ADD      r4,r0,#0xc
;;;168            for (; flash_region->start != 0 || flash_region->end != 0; ++flash_region) {
000026  e00a              B        |L7.62|
                  |L7.40|
000028  2007              MOVS     r0,#7                 ;163
;;;169                if (flash_region->flags & kRegionIsDefault) {
;;;170                    default_region = flash_region;
;;;171                    break;
;;;172                }
;;;173            }
;;;174    
;;;175            state = STATE_OPEN;
;;;176            return ERROR_SUCCESS;
;;;177        } else {
;;;178            return ERROR_FAILURE;
;;;179        }
;;;180    
;;;181    }
00002a  bd70              POP      {r4-r6,pc}
                  |L7.44|
00002c  f1040008          ADD      r0,r4,#8              ;169
000030  f7fffffe          BL       __aeabi_uread4
000034  07c0              LSLS     r0,r0,#31             ;169
000036  d001              BEQ      |L7.60|
000038  60ac              STR      r4,[r5,#8]            ;171  ; default_region
00003a  e00a              B        |L7.82|
                  |L7.60|
00003c  3414              ADDS     r4,r4,#0x14           ;171
                  |L7.62|
00003e  4620              MOV      r0,r4                 ;168
000040  f7fffffe          BL       __aeabi_uread4
000044  2800              CMP      r0,#0                 ;168
000046  d1f1              BNE      |L7.44|
000048  1d20              ADDS     r0,r4,#4              ;168
00004a  f7fffffe          BL       __aeabi_uread4
00004e  2800              CMP      r0,#0                 ;168
000050  d1ec              BNE      |L7.44|
                  |L7.82|
000052  2001              MOVS     r0,#1                 ;175
000054  7028              STRB     r0,[r5,#0]            ;175
000056  2000              MOVS     r0,#0                 ;176
000058  bd70              POP      {r4-r6,pc}
                  |L7.90|
00005a  2001              MOVS     r0,#1                 ;178
00005c  bd70              POP      {r4-r6,pc}
;;;182    
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      g_board_info+0x10
                  |L7.100|
                          DCD      ||.data||

                          AREA ||i.target_flash_program_page||, CODE, READONLY, ALIGN=2

                  target_flash_program_page PROC
;;;208    
;;;209    static error_t target_flash_program_page(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;210    {
000004  4681              MOV      r9,r0
000006  4615              MOV      r5,r2
000008  4688              MOV      r8,r1
;;;211        if (g_board_info.target_cfg) {
00000a  484d              LDR      r0,|L8.320|
00000c  f7fffffe          BL       __aeabi_uread4
000010  2800              CMP      r0,#0
000012  d075              BEQ      |L8.256|
;;;212            error_t status = ERROR_SUCCESS;
;;;213            program_target_t * flash = current_flash_algo;
000014  484b              LDR      r0,|L8.324|
;;;214    
;;;215            if (!flash) {
000016  6847              LDR      r7,[r0,#4]  ; current_flash_algo
000018  b197              CBZ      r7,|L8.64|
;;;216                return ERROR_INTERNAL;
;;;217            }
;;;218    
;;;219            // check if security bits were set
;;;220            if (g_target_family && g_target_family->security_bits_set){
00001a  484b              LDR      r0,|L8.328|
00001c  6800              LDR      r0,[r0,#0]  ; g_target_family
00001e  b138              CBZ      r0,|L8.48|
000020  6943              LDR      r3,[r0,#0x14]
000022  b12b              CBZ      r3,|L8.48|
;;;221                if (1 == g_target_family->security_bits_set(addr, (uint8_t *)buf, size)) {
000024  462a              MOV      r2,r5
000026  4641              MOV      r1,r8
000028  4648              MOV      r0,r9
00002a  4798              BLX      r3
00002c  2801              CMP      r0,#1
00002e  d00b              BEQ      |L8.72|
                  |L8.48|
;;;222                    return ERROR_SECURITY_BITS;
;;;223                }
;;;224            }
;;;225    
;;;226            status = flash_func_start(FLASH_FUNC_PROGRAM);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       flash_func_start
000036  f04f0a00          MOV      r10,#0
;;;227    
;;;228            if (status != ERROR_SUCCESS) {
00003a  2800              CMP      r0,#0
00003c  d101              BNE      |L8.66|
00003e  e05b              B        |L8.248|
                  |L8.64|
000040  2002              MOVS     r0,#2                 ;216
                  |L8.66|
;;;229                return status;
;;;230            }
;;;231    
;;;232            while (size > 0) {
;;;233                uint32_t write_size = MIN(size, flash->program_buffer_size);
;;;234    
;;;235                // Write page to buffer
;;;236                if (!swd_write_memory(flash->program_buffer, (uint8_t *)buf, write_size)) {
;;;237                    return ERROR_ALGO_DATA_SEQ;
;;;238                }
;;;239    
;;;240                // Run flash programming
;;;241                if (!swd_flash_syscall_exec(&flash->sys_call_s,
;;;242                                            flash->program_page,
;;;243                                            addr,
;;;244                                            write_size,
;;;245                                            flash->program_buffer,
;;;246                                            0,
;;;247                                            FLASHALGO_RETURN_BOOL)) {
;;;248                    return ERROR_WRITE;
;;;249                }
;;;250    
;;;251                if (config_get_automation_allowed()) {
;;;252                    // Verify data flashed if in automation mode
;;;253                    if (flash->verify != 0) {
;;;254                        status = flash_func_start(FLASH_FUNC_VERIFY);
;;;255                        if (status != ERROR_SUCCESS) {
;;;256                            return status;
;;;257                        }
;;;258                        flash_algo_return_t return_type;
;;;259                        if ((flash->algo_flags & kAlgoVerifyReturnsAddress) != 0) {
;;;260                            return_type = FLASHALGO_RETURN_POINTER;
;;;261                        } else {
;;;262                            return_type = FLASHALGO_RETURN_BOOL;
;;;263                        }
;;;264                        if (!swd_flash_syscall_exec(&flash->sys_call_s,
;;;265                                            flash->verify,
;;;266                                            addr,
;;;267                                            write_size,
;;;268                                            flash->program_buffer,
;;;269                                            0,
;;;270                                            return_type)) {
;;;271                            return ERROR_WRITE_VERIFY;
;;;272                        }
;;;273                    } else {
;;;274                        while (write_size > 0) {
;;;275                            uint8_t rb_buf[16];
;;;276                            uint32_t verify_size = MIN(write_size, sizeof(rb_buf));
;;;277                            if (!swd_read_memory(addr, rb_buf, verify_size)) {
;;;278                                return ERROR_ALGO_DATA_SEQ;
;;;279                            }
;;;280                            if (memcmp(buf, rb_buf, verify_size) != 0) {
;;;281                                return ERROR_WRITE_VERIFY;
;;;282                            }
;;;283                            addr += verify_size;
;;;284                            buf += verify_size;
;;;285                            size -= verify_size;
;;;286                            write_size -= verify_size;
;;;287                        }
;;;288                        continue;
;;;289                    }
;;;290                }
;;;291                addr += write_size;
;;;292                buf += write_size;
;;;293                size -= write_size;
;;;294    
;;;295            }
;;;296    
;;;297            return ERROR_SUCCESS;
;;;298    
;;;299        } else {
;;;300            return ERROR_FAILURE;
;;;301        }
;;;302    }
000042  b004              ADD      sp,sp,#0x10
000044  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.72|
000048  200d              MOVS     r0,#0xd               ;222
00004a  e7fa              B        |L8.66|
                  |L8.76|
00004c  f1070034          ADD      r0,r7,#0x34           ;233
000050  f7fffffe          BL       __aeabi_uread4
000054  42a8              CMP      r0,r5                 ;233
000056  d901              BLS      |L8.92|
000058  462c              MOV      r4,r5                 ;233
00005a  e000              B        |L8.94|
                  |L8.92|
00005c  4604              MOV      r4,r0                 ;233
                  |L8.94|
00005e  f1070024          ADD      r0,r7,#0x24           ;236
000062  4683              MOV      r11,r0                ;236
000064  f7fffffe          BL       __aeabi_uread4
000068  4622              MOV      r2,r4                 ;236
00006a  4641              MOV      r1,r8                 ;236
00006c  f7fffffe          BL       swd_write_memory
000070  2800              CMP      r0,#0                 ;236
000072  d05a              BEQ      |L8.298|
000074  4658              MOV      r0,r11                ;236
000076  f7fffffe          BL       __aeabi_uread4
00007a  4606              MOV      r6,r0                 ;241
00007c  f1070010          ADD      r0,r7,#0x10           ;241
000080  f7fffffe          BL       __aeabi_uread4
000084  4601              MOV      r1,r0                 ;241
000086  f1070018          ADD      r0,r7,#0x18           ;241
00008a  e9cd6a00          STRD     r6,r10,[sp,#0]        ;241
00008e  e9cda002          STRD     r10,r0,[sp,#8]        ;241
000092  4623              MOV      r3,r4                 ;241
000094  464a              MOV      r2,r9                 ;241
000096  f7fffffe          BL       swd_flash_syscall_exec
00009a  b1a8              CBZ      r0,|L8.200|
00009c  f7fffffe          BL       config_get_automation_allowed
0000a0  b338              CBZ      r0,|L8.242|
0000a2  f1070014          ADD      r0,r7,#0x14           ;253
0000a6  9000              STR      r0,[sp,#0]            ;253
0000a8  f7fffffe          BL       __aeabi_uread4
0000ac  b348              CBZ      r0,|L8.258|
0000ae  2003              MOVS     r0,#3                 ;254
0000b0  f7fffffe          BL       flash_func_start
0000b4  2800              CMP      r0,#0                 ;255
0000b6  d1c4              BNE      |L8.66|
0000b8  f1070038          ADD      r0,r7,#0x38           ;259
0000bc  f7fffffe          BL       __aeabi_uread4
0000c0  07c0              LSLS     r0,r0,#31             ;259
0000c2  d003              BEQ      |L8.204|
0000c4  2601              MOVS     r6,#1                 ;260
0000c6  e002              B        |L8.206|
                  |L8.200|
0000c8  2011              MOVS     r0,#0x11              ;248
0000ca  e7ba              B        |L8.66|
                  |L8.204|
0000cc  2600              MOVS     r6,#0                 ;262
                  |L8.206|
0000ce  4658              MOV      r0,r11                ;262
0000d0  f7fffffe          BL       __aeabi_uread4
0000d4  4683              MOV      r11,r0                ;264
0000d6  9800              LDR      r0,[sp,#0]            ;264
0000d8  f7fffffe          BL       __aeabi_uread4
0000dc  f8cdb000          STR      r11,[sp,#0]           ;264
0000e0  e9cda601          STRD     r10,r6,[sp,#4]        ;264
0000e4  4601              MOV      r1,r0                 ;264
0000e6  4623              MOV      r3,r4                 ;264
0000e8  464a              MOV      r2,r9                 ;264
0000ea  9803              LDR      r0,[sp,#0xc]          ;264
0000ec  f7fffffe          BL       swd_flash_syscall_exec
0000f0  b1c8              CBZ      r0,|L8.294|
                  |L8.242|
0000f2  44a1              ADD      r9,r9,r4              ;291
0000f4  44a0              ADD      r8,r8,r4              ;292
0000f6  1b2d              SUBS     r5,r5,r4              ;293
                  |L8.248|
0000f8  2d00              CMP      r5,#0                 ;232
0000fa  d1a7              BNE      |L8.76|
0000fc  2000              MOVS     r0,#0                 ;297
0000fe  e7a0              B        |L8.66|
                  |L8.256|
000100  e01c              B        |L8.316|
                  |L8.258|
000102  e018              B        |L8.310|
                  |L8.260|
000104  2c10              CMP      r4,#0x10              ;276
000106  d201              BCS      |L8.268|
000108  4626              MOV      r6,r4                 ;276
00010a  e000              B        |L8.270|
                  |L8.268|
00010c  2610              MOVS     r6,#0x10              ;276
                  |L8.270|
00010e  4632              MOV      r2,r6                 ;277
000110  4669              MOV      r1,sp                 ;277
000112  4648              MOV      r0,r9                 ;277
000114  f7fffffe          BL       swd_read_memory
000118  b138              CBZ      r0,|L8.298|
00011a  4632              MOV      r2,r6                 ;280
00011c  4669              MOV      r1,sp                 ;280
00011e  4640              MOV      r0,r8                 ;280
000120  f7fffffe          BL       memcmp
000124  b118              CBZ      r0,|L8.302|
                  |L8.294|
000126  2012              MOVS     r0,#0x12              ;281
000128  e78b              B        |L8.66|
                  |L8.298|
00012a  200a              MOVS     r0,#0xa               ;278
00012c  e789              B        |L8.66|
                  |L8.302|
00012e  1bad              SUBS     r5,r5,r6              ;285
000130  44b1              ADD      r9,r9,r6              ;283
000132  44b0              ADD      r8,r8,r6              ;284
000134  1ba4              SUBS     r4,r4,r6              ;286
                  |L8.310|
000136  2c00              CMP      r4,#0                 ;274
000138  d0de              BEQ      |L8.248|
00013a  e7e3              B        |L8.260|
                  |L8.316|
00013c  2001              MOVS     r0,#1                 ;300
00013e  e780              B        |L8.66|
;;;303    
                          ENDP

                  |L8.320|
                          DCD      g_board_info+0x10
                  |L8.324|
                          DCD      ||.data||
                  |L8.328|
                          DCD      g_target_family

                          AREA ||i.target_flash_program_page_min_size||, CODE, READONLY, ALIGN=2

                  target_flash_program_page_min_size PROC
;;;370    
;;;371    static uint32_t target_flash_program_page_min_size(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
000002  4605              MOV      r5,r0
;;;373        if (g_board_info.target_cfg){
000004  4808              LDR      r0,|L9.40|
000006  f7fffffe          BL       __aeabi_uread4
00000a  2800              CMP      r0,#0
00000c  d00b              BEQ      |L9.38|
;;;374            uint32_t size = DEFAULT_PROGRAM_PAGE_MIN_SIZE;
00000e  f44f7480          MOV      r4,#0x100
;;;375            if (size > target_flash_erase_sector_size(addr)) {
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       target_flash_erase_sector_size
000018  42a0              CMP      r0,r4
00001a  d203              BCS      |L9.36|
;;;376                size = target_flash_erase_sector_size(addr);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       target_flash_erase_sector_size
000022  4604              MOV      r4,r0
                  |L9.36|
;;;377            }
;;;378            return size;
000024  4620              MOV      r0,r4
                  |L9.38|
;;;379        } else {
;;;380            return 0;
;;;381        }
;;;382    }
000026  bd70              POP      {r4-r6,pc}
;;;383    
                          ENDP

                  |L9.40|
                          DCD      g_board_info+0x10

                          AREA ||i.target_flash_set||, CODE, READONLY, ALIGN=2

                  target_flash_set PROC
;;;131    
;;;132    static error_t target_flash_set(uint32_t addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;133    {
;;;134        program_target_t * new_flash_algo = get_flash_algo(addr);
000004  f7fffffe          BL       get_flash_algo
000008  0004              MOVS     r4,r0
;;;135        if (new_flash_algo == NULL) {
00000a  d01f              BEQ      |L10.76|
;;;136            return ERROR_ALGO_MISSING;
;;;137        }
;;;138        if(current_flash_algo != new_flash_algo){
00000c  4d11              LDR      r5,|L10.84|
00000e  6868              LDR      r0,[r5,#4]  ; current_flash_algo
000010  42a0              CMP      r0,r4
000012  d018              BEQ      |L10.70|
;;;139            //run uninit to last func
;;;140            error_t status = flash_func_start(FLASH_FUNC_NOP);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       flash_func_start
;;;141            if (status != ERROR_SUCCESS) {
00001a  2800              CMP      r0,#0
00001c  d114              BNE      |L10.72|
;;;142                return status;
;;;143            }
;;;144            // Download flash programming algorithm to target
;;;145            if (0 == swd_write_memory(new_flash_algo->algo_start, (uint8_t *)new_flash_algo->algo_blob, new_flash_algo->algo_size)) {
00001e  f104002c          ADD      r0,r4,#0x2c
000022  f7fffffe          BL       __aeabi_uread4
000026  4607              MOV      r7,r0
000028  f1040030          ADD      r0,r4,#0x30
00002c  f7fffffe          BL       __aeabi_uread4
000030  4606              MOV      r6,r0
000032  f1040028          ADD      r0,r4,#0x28
000036  f7fffffe          BL       __aeabi_uread4
00003a  463a              MOV      r2,r7
00003c  4631              MOV      r1,r6
00003e  f7fffffe          BL       swd_write_memory
000042  b128              CBZ      r0,|L10.80|
;;;146                return ERROR_ALGO_DL;
;;;147            }
;;;148    
;;;149            current_flash_algo = new_flash_algo;
000044  606c              STR      r4,[r5,#4]  ; current_flash_algo
                  |L10.70|
;;;150    
;;;151        }
;;;152        return ERROR_SUCCESS;
000046  2000              MOVS     r0,#0
                  |L10.72|
;;;153    }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L10.76|
00004c  2009              MOVS     r0,#9                 ;136
00004e  e7fb              B        |L10.72|
                  |L10.80|
000050  2008              MOVS     r0,#8                 ;146
000052  e7f9              B        |L10.72|
;;;154    
                          ENDP

                  |L10.84|
                          DCD      ||.data||

                          AREA ||i.target_flash_uninit||, CODE, READONLY, ALIGN=2

                  target_flash_uninit PROC
;;;182    
;;;183    static error_t target_flash_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        if (g_board_info.target_cfg) {
000002  480e              LDR      r0,|L11.60|
000004  f7fffffe          BL       __aeabi_uread4
000008  b1b0              CBZ      r0,|L11.56|
;;;186            error_t status = flash_func_start(FLASH_FUNC_NOP);
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       flash_func_start
;;;187            if (status != ERROR_SUCCESS) {
000010  2800              CMP      r0,#0
000012  d110              BNE      |L11.54|
;;;188                return status;
;;;189            }
;;;190            if (config_get_auto_rst()) {
000014  f7fffffe          BL       config_get_auto_rst
000018  b108              CBZ      r0,|L11.30|
;;;191                // Resume the target if configured to do so
;;;192                target_set_state(RESET_RUN);
00001a  2002              MOVS     r0,#2
00001c  e000              B        |L11.32|
                  |L11.30|
;;;193            } else {
;;;194                // Leave the target halted until a reset occurs
;;;195                target_set_state(RESET_PROGRAM);
00001e  2001              MOVS     r0,#1
                  |L11.32|
000020  f7fffffe          BL       target_set_state
;;;196            }
;;;197            // Check to see if anything needs to be done after programming.
;;;198            // This is usually a no-op for most targets.
;;;199            target_set_state(POST_FLASH_RESET);
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       target_set_state
;;;200    
;;;201            state = STATE_CLOSED;
00002a  4905              LDR      r1,|L11.64|
00002c  2000              MOVS     r0,#0
00002e  7008              STRB     r0,[r1,#0]
;;;202            swd_off();
000030  f7fffffe          BL       swd_off
;;;203            return ERROR_SUCCESS;
000034  2000              MOVS     r0,#0
                  |L11.54|
;;;204        } else {
;;;205            return ERROR_FAILURE;
;;;206        }
;;;207    }
000036  bd10              POP      {r4,pc}
                  |L11.56|
000038  2001              MOVS     r0,#1                 ;205
00003a  bd10              POP      {r4,pc}
;;;208    
                          ENDP

                  |L11.60|
                          DCD      g_board_info+0x10
                  |L11.64|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  flash_intf
                          DCD      target_flash_init
                          DCD      target_flash_uninit
                          DCD      target_flash_program_page
                          DCD      target_flash_erase_sector
                          DCD      target_flash_erase_chip
                          DCD      target_flash_program_page_min_size
                          DCD      target_flash_erase_sector_size
                          DCD      target_flash_busy
                          DCD      target_flash_set

                          AREA ||area_number.15||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.constdata||
                  flash_intf_target
                          DCD      flash_intf

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00                DCB      0x00
                  last_flash_func
000001  000000            DCB      0x00,0x00,0x00
                  current_flash_algo
                          DCD      0x00000000
                  default_region
                          DCD      0x00000000
                  flash_start
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\interface\\target_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_target_flash_c_89c53bb5____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___14_target_flash_c_89c53bb5____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_target_flash_c_89c53bb5____REVSH|
#line 495
|__asm___14_target_flash_c_89c53bb5____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_target_flash_c_89c53bb5____RRX|
#line 682
|__asm___14_target_flash_c_89c53bb5____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
