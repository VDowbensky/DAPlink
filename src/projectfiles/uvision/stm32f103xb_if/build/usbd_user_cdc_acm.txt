; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\usbd_user_cdc_acm.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usbd_user_cdc_acm.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\usbd_user_cdc_acm.crf ..\..\..\source\daplink\usb2uart\usbd_user_cdc_acm.c]
                          THUMB

                          AREA ||i.USBD_CDC_ACM_PortGetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortGetLineCoding PROC
;;;103     */
;;;104    int32_t USBD_CDC_ACM_PortGetLineCoding(CDC_LINE_CODING *line_coding)
000000  b570              PUSH     {r4-r6,lr}
;;;105    {
;;;106        line_coding->dwDTERate   = UART_Config.Baudrate;
000002  4d07              LDR      r5,|L1.32|
000004  4604              MOV      r4,r0                 ;105
000006  4621              MOV      r1,r4
000008  6828              LDR      r0,[r5,#0]  ; UART_Config
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;107        line_coding->bDataBits   = UART_Config.DataBits;
00000e  7928              LDRB     r0,[r5,#4]  ; UART_Config
000010  71a0              STRB     r0,[r4,#6]
;;;108        line_coding->bParityType = UART_Config.Parity;
000012  7968              LDRB     r0,[r5,#5]  ; UART_Config
000014  7160              STRB     r0,[r4,#5]
;;;109        line_coding->bCharFormat = UART_Config.StopBits;
000016  79a8              LDRB     r0,[r5,#6]  ; UART_Config
000018  7120              STRB     r0,[r4,#4]
;;;110        return (1);
00001a  2001              MOVS     r0,#1
;;;111    }
00001c  bd70              POP      {r4-r6,pc}
;;;112    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||+0x4

                          AREA ||i.USBD_CDC_ACM_PortInitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortInitialize PROC
;;;40      */
;;;41     int32_t USBD_CDC_ACM_PortInitialize(void)
000000  b510              PUSH     {r4,lr}
;;;42     {
;;;43         uart_initialize();
000002  f7fffffe          BL       uart_initialize
;;;44         main_cdc_send_event();
000006  f7fffffe          BL       main_cdc_send_event
;;;45         return 1;
00000a  2001              MOVS     r0,#1
;;;46     }
00000c  bd10              POP      {r4,pc}
;;;47     
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortReset||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortReset PROC
;;;69      */
;;;70     int32_t USBD_CDC_ACM_PortReset(void)
000000  b510              PUSH     {r4,lr}
;;;71     {
;;;72         uart_reset();
000002  f7fffffe          BL       uart_reset
;;;73         return 1;
000006  2001              MOVS     r0,#1
;;;74     }
000008  bd10              POP      {r4,pc}
;;;75     
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortSetControlLineState||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortSetControlLineState PROC
;;;148     */
;;;149    int32_t USBD_CDC_ACM_PortSetControlLineState(uint16_t ctrl_bmp)
000000  2001              MOVS     r0,#1
;;;150    {
;;;151        return (1);
;;;152    }
000002  4770              BX       lr
;;;153    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortSetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortSetLineCoding PROC
;;;84      */
;;;85     int32_t USBD_CDC_ACM_PortSetLineCoding(CDC_LINE_CODING *line_coding)
000000  b510              PUSH     {r4,lr}
;;;86     {
000002  4604              MOV      r4,r0
;;;87         UART_Config.Baudrate    = line_coding->dwDTERate;
000004  f7fffffe          BL       __aeabi_uread4
000008  4907              LDR      r1,|L5.40|
;;;88         UART_Config.DataBits    = (UART_DataBits) line_coding->bDataBits;
00000a  6008              STR      r0,[r1,#0]  ; UART_Config
00000c  79a0              LDRB     r0,[r4,#6]
00000e  7108              STRB     r0,[r1,#4]
;;;89         UART_Config.Parity      = (UART_Parity)   line_coding->bParityType;
000010  7960              LDRB     r0,[r4,#5]
000012  7148              STRB     r0,[r1,#5]
;;;90         UART_Config.StopBits    = (UART_StopBits) line_coding->bCharFormat;
000014  7920              LDRB     r0,[r4,#4]
000016  7188              STRB     r0,[r1,#6]
;;;91         UART_Config.FlowControl = UART_FLOW_CONTROL_NONE;
000018  2000              MOVS     r0,#0
00001a  71c8              STRB     r0,[r1,#7]
;;;92         return uart_set_configuration(&UART_Config);
00001c  e8bd4010          POP      {r4,lr}
000020  4608              MOV      r0,r1
000022  f7ffbffe          B.W      uart_set_configuration
;;;93     }
;;;94     
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      ||.data||+0x4

                          AREA ||i.USBD_CDC_ACM_PortUninitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortUninitialize PROC
;;;55      */
;;;56     int32_t USBD_CDC_ACM_PortUninitialize(void)
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58         uart_uninitialize();
000002  f7fffffe          BL       uart_uninitialize
;;;59         return 1;
000006  2001              MOVS     r0,#1
;;;60     }
000008  bd10              POP      {r4,pc}
;;;61     
                          ENDP


                          AREA ||i.USBD_CDC_ACM_SendBreak||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_SendBreak PROC
;;;113    static U32 start_break_time = 0;
;;;114    int32_t USBD_CDC_ACM_SendBreak(uint16_t dur)
000000  b570              PUSH     {r4-r6,lr}
;;;115    {
000002  4605              MOV      r5,r0
;;;116        uint32_t end_break_time;
;;;117    #ifdef DRAG_N_DROP_SUPPORT
;;;118        if (!flash_intf_target->flash_busy())
000004  480d              LDR      r0,|L7.60|
000006  6800              LDR      r0,[r0,#0]  ; flash_intf_target
000008  69c1              LDR      r1,[r0,#0x1c]
00000a  4788              BLX      r1
00000c  b9a0              CBNZ     r0,|L7.56|
;;;119    #endif
;;;120        { //added checking if flashing on target is in progress
;;;121            // reset and send the unique id over CDC
;;;122            if (dur != 0) {
;;;123                start_break_time = osKernelGetSysTimerCount();
00000e  4c0c              LDR      r4,|L7.64|
000010  b135              CBZ      r5,|L7.32|
000012  f7fffffe          BL       osKernelGetSysTimerCount
;;;124                target_set_state(RESET_HOLD);
000016  6020              STR      r0,[r4,#0]  ; start_break_time
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       target_set_state
00001e  e00b              B        |L7.56|
                  |L7.32|
;;;125            } else {
;;;126                end_break_time = osKernelGetSysTimerCount();
000020  f7fffffe          BL       osKernelGetSysTimerCount
;;;127    
;;;128                // long reset -> send uID over serial (300 -> break > 3s)
;;;129                if ((end_break_time - start_break_time) >= (300)) {
000024  6821              LDR      r1,[r4,#0]  ; start_break_time
000026  1a40              SUBS     r0,r0,r1
000028  f5b07f96          CMP      r0,#0x12c
00002c  d301              BCC      |L7.50|
;;;130                    main_reset_target(1);
00002e  2001              MOVS     r0,#1
000030  e000              B        |L7.52|
                  |L7.50|
;;;131                } else {
;;;132                    main_reset_target(0);
000032  2000              MOVS     r0,#0
                  |L7.52|
000034  f7fffffe          BL       main_reset_target
                  |L7.56|
;;;133                }
;;;134            }
;;;135        }
;;;136        return (1);
000038  2001              MOVS     r0,#1
;;;137    }
00003a  bd70              POP      {r4-r6,pc}
;;;138    
                          ENDP

                  |L7.60|
                          DCD      flash_intf_target
                  |L7.64|
                          DCD      ||.data||

                          AREA ||i.cdc_process_event||, CODE, READONLY, ALIGN=1

                  cdc_process_event PROC
;;;153    
;;;154    void cdc_process_event()
000000  b500              PUSH     {lr}
;;;155    {
000002  b091              SUB      sp,sp,#0x44
;;;156        int32_t len_data = 0;
;;;157        uint8_t data[64];
;;;158    
;;;159        len_data = USBD_CDC_ACM_DataFree();
000004  f7fffffe          BL       USBD_CDC_ACM_DataFree
;;;160    
;;;161        if (len_data > sizeof(data)) {
000008  2840              CMP      r0,#0x40
00000a  d901              BLS      |L8.16|
;;;162            len_data = sizeof(data);
00000c  2040              MOVS     r0,#0x40
00000e  e000              B        |L8.18|
                  |L8.16|
;;;163        }
;;;164    
;;;165        if (len_data) {
000010  b160              CBZ      r0,|L8.44|
                  |L8.18|
;;;166            len_data = uart_read_data(data, len_data);
000012  b281              UXTH     r1,r0
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       uart_read_data
00001a  0001              MOVS     r1,r0
00001c  d006              BEQ      |L8.44|
;;;167        }
;;;168    
;;;169        if (len_data) {
;;;170            if (USBD_CDC_ACM_DataSend(data , len_data)) {
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       USBD_CDC_ACM_DataSend
000024  b110              CBZ      r0,|L8.44|
;;;171                main_blink_cdc_led(MAIN_LED_FLASH);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       main_blink_cdc_led
                  |L8.44|
;;;172            }
;;;173        }
;;;174    
;;;175        len_data = uart_write_free();
00002c  f7fffffe          BL       uart_write_free
000030  4601              MOV      r1,r0
;;;176    
;;;177        if (len_data > sizeof(data)) {
000032  2840              CMP      r0,#0x40
000034  d901              BLS      |L8.58|
;;;178            len_data = sizeof(data);
000036  2140              MOVS     r1,#0x40
000038  e000              B        |L8.60|
                  |L8.58|
;;;179        }
;;;180    
;;;181        if (len_data) {
00003a  b159              CBZ      r1,|L8.84|
                  |L8.60|
;;;182            len_data = USBD_CDC_ACM_DataRead(data, len_data);
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       USBD_CDC_ACM_DataRead
000042  b138              CBZ      r0,|L8.84|
;;;183        }
;;;184    
;;;185        if (len_data) {
;;;186            if (uart_write_data(data, len_data)) {
000044  b281              UXTH     r1,r0
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       uart_write_data
00004c  b110              CBZ      r0,|L8.84|
;;;187                main_blink_cdc_led(MAIN_LED_FLASH);
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       main_blink_cdc_led
                  |L8.84|
;;;188            }
;;;189        }
;;;190    
;;;191        // Always process events
;;;192        main_cdc_send_event();
000054  f7fffffe          BL       main_cdc_send_event
;;;193    }
000058  b011              ADD      sp,sp,#0x44
00005a  bd00              POP      {pc}
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  start_break_time
                          DCD      0x00000000
                  UART_Config
                          %        8
