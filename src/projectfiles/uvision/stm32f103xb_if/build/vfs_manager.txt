; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\vfs_manager.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\vfs_manager.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\vfs_manager.crf ..\..\..\source\daplink\drag-n-drop\vfs_manager.c]
                          THUMB

                          AREA ||i.build_filesystem||, CODE, READONLY, ALIGN=2

                  build_filesystem PROC
;;;377    
;;;378    static void build_filesystem()
000000  b510              PUSH     {r4,lr}
;;;379    {
;;;380        // Update anything that could have changed file system state
;;;381        file_transfer_state = default_transfer_state;
000002  2228              MOVS     r2,#0x28
000004  490d              LDR      r1,|L1.60|
000006  480e              LDR      r0,|L1.64|
000008  f7fffffe          BL       __aeabi_memcpy4
;;;382        vfs_user_build_filesystem();
00000c  f7fffffe          BL       vfs_user_build_filesystem
;;;383        vfs_set_file_change_callback(file_change_handler);
000010  480c              LDR      r0,|L1.68|
000012  f7fffffe          BL       vfs_set_file_change_callback
;;;384        // Set mass storage parameters
;;;385        USBD_MSC_MemorySize = vfs_get_total_size();
000016  f7fffffe          BL       vfs_get_total_size
00001a  490b              LDR      r1,|L1.72|
;;;386        USBD_MSC_BlockSize  = VFS_SECTOR_SIZE;
00001c  4a0b              LDR      r2,|L1.76|
;;;387        USBD_MSC_BlockGroup = 1;
00001e  4b0c              LDR      r3,|L1.80|
000020  6008              STR      r0,[r1,#0]            ;386  ; USBD_MSC_MemorySize
000022  f44f7100          MOV      r1,#0x200             ;386
;;;388        USBD_MSC_BlockCount = USBD_MSC_MemorySize / USBD_MSC_BlockSize;
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  6011              STR      r1,[r2,#0]            ;387  ; USBD_MSC_BlockSize
00002c  4909              LDR      r1,|L1.84|
00002e  2201              MOVS     r2,#1                 ;387
000030  601a              STR      r2,[r3,#0]  ; USBD_MSC_BlockGroup
;;;389        USBD_MSC_BlockBuf   = (uint8_t *)usb_buffer;
000032  6008              STR      r0,[r1,#0]  ; USBD_MSC_BlockCount
000034  4909              LDR      r1,|L1.92|
000036  4808              LDR      r0,|L1.88|
000038  6008              STR      r0,[r1,#0]  ; USBD_MSC_BlockBuf
;;;390    }
00003a  bd10              POP      {r4,pc}
;;;391    
                          ENDP

                  |L1.60|
                          DCD      ||.constdata||
                  |L1.64|
                          DCD      ||.bss||+0x200
                  |L1.68|
                          DCD      file_change_handler
                  |L1.72|
                          DCD      USBD_MSC_MemorySize
                  |L1.76|
                          DCD      USBD_MSC_BlockSize
                  |L1.80|
                          DCD      USBD_MSC_BlockGroup
                  |L1.84|
                          DCD      USBD_MSC_BlockCount
                  |L1.88|
                          DCD      ||.bss||
                  |L1.92|
                          DCD      USBD_MSC_BlockBuf

                          AREA ||i.changing_state||, CODE, READONLY, ALIGN=2

                  changing_state PROC
;;;372    
;;;373    static bool changing_state()
000000  4804              LDR      r0,|L2.20|
;;;374    {
;;;375        return vfs_state != vfs_state_next;
000002  7841              LDRB     r1,[r0,#1]  ; vfs_state
000004  7880              LDRB     r0,[r0,#2]  ; vfs_state_next
000006  4281              CMP      r1,r0
000008  d001              BEQ      |L2.14|
00000a  2001              MOVS     r0,#1
;;;376    }
00000c  4770              BX       lr
                  |L2.14|
00000e  2000              MOVS     r0,#0                 ;375
000010  4770              BX       lr
;;;377    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      ||.data||

                          AREA ||i.file_change_handler||, CODE, READONLY, ALIGN=2

                  file_change_handler PROC
;;;392    // Callback to handle changes to the root directory.  Should be used with vfs_set_file_change_callback
;;;393    static void file_change_handler(const vfs_filename_t filename, vfs_file_change_t change, vfs_file_t file, vfs_file_t new_file_data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;394    {
000004  461e              MOV      r6,r3
000006  4615              MOV      r5,r2
000008  460c              MOV      r4,r1
00000a  4607              MOV      r7,r0
;;;395        vfs_mngr_printf("vfs_manager file_change_handler(name=%*s, file=%p, change=%i)\r\n", 11, filename, file, change);
;;;396        vfs_user_file_change_handler(filename, change, file, new_file_data);
00000c  f7fffffe          BL       vfs_user_file_change_handler
;;;397        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000010  482c              LDR      r0,|L3.196|
000012  f8901020          LDRB     r1,[r0,#0x20]  ; file_transfer_state
000016  2903              CMP      r1,#3
000018  d00f              BEQ      |L3.58|
;;;398            // If the transfer is finished stop further processing
;;;399            return;
;;;400        }
;;;401    
;;;402        if (VFS_FILE_CHANGED == change) {
00001a  2c02              CMP      r4,#2
00001c  d00f              BEQ      |L3.62|
;;;403            if (file == file_transfer_state.file_to_program) {
;;;404                stream_type_t stream;
;;;405                uint32_t size = vfs_file_get_size(new_file_data);
;;;406                vfs_sector_t sector = vfs_file_get_start_sector(new_file_data);
;;;407                stream = stream_type_from_name(filename);
;;;408                transfer_update_file_info(file, sector, size, stream);
;;;409            }
;;;410        }
;;;411    
;;;412        if (VFS_FILE_CREATED == change) {
00001e  b304              CBZ      r4,|L3.98|
;;;413            stream_type_t stream;
;;;414    
;;;415            if (STREAM_TYPE_NONE != stream_type_from_name(filename)) {
;;;416                // Check for a know file extension to detect the current file being
;;;417                // transferred.  Ignore hidden files since MAC uses hidden files with
;;;418                // the same extension to keep track of transfer info in some cases.
;;;419                if (!(VFS_FILE_ATTR_HIDDEN & vfs_file_get_attr(new_file_data))) {
;;;420                    stream = stream_type_from_name(filename);
;;;421                    uint32_t size = vfs_file_get_size(new_file_data);
;;;422                    vfs_sector_t sector = vfs_file_get_start_sector(new_file_data);
;;;423                    transfer_update_file_info(file, sector, size, stream);
;;;424                }
;;;425            }
;;;426        }
;;;427    
;;;428        if (VFS_FILE_DELETED == change) {
000020  2c01              CMP      r4,#1
000022  d10a              BNE      |L3.58|
;;;429            if (file == file_transfer_state.file_to_program) {
000024  6801              LDR      r1,[r0,#0]  ; file_transfer_state
000026  42a9              CMP      r1,r5
000028  d107              BNE      |L3.58|
00002a  f8901022          LDRB     r1,[r0,#0x22]  ; file_transfer_state
00002e  b3a9              CBZ      r1,|L3.156|
000030  2100              MOVS     r1,#0
000032  1e4a              SUBS     r2,r1,#1
000034  6001              STR      r1,[r0,#0]  ; file_transfer_state
000036  6082              STR      r2,[r0,#8]  ; file_transfer_state
000038  6181              STR      r1,[r0,#0x18]  ; file_transfer_state
                  |L3.58|
;;;430                // The file that was being transferred has been deleted
;;;431                transfer_reset_file_info();
;;;432            }
;;;433        }
;;;434    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L3.62|
00003e  6800              LDR      r0,[r0,#0]            ;403  ; file_transfer_state
000040  42a8              CMP      r0,r5                 ;403
000042  d1fa              BNE      |L3.58|
000044  4630              MOV      r0,r6                 ;405
000046  f7fffffe          BL       vfs_file_get_size
00004a  4604              MOV      r4,r0                 ;405
00004c  4630              MOV      r0,r6                 ;406
00004e  f7fffffe          BL       vfs_file_get_start_sector
000052  4606              MOV      r6,r0                 ;406
000054  4638              MOV      r0,r7                 ;407
000056  f7fffffe          BL       stream_type_from_name
00005a  4603              MOV      r3,r0                 ;407
00005c  4622              MOV      r2,r4                 ;408
00005e  4631              MOV      r1,r6                 ;408
000060  e017              B        |L3.146|
                  |L3.98|
000062  4638              MOV      r0,r7                 ;415
000064  f7fffffe          BL       stream_type_from_name
000068  2803              CMP      r0,#3                 ;415
00006a  d0e6              BEQ      |L3.58|
00006c  4630              MOV      r0,r6                 ;419
00006e  f7fffffe          BL       vfs_file_get_attr
000072  0780              LSLS     r0,r0,#30             ;419
000074  d4e1              BMI      |L3.58|
000076  4638              MOV      r0,r7                 ;420
000078  f7fffffe          BL       stream_type_from_name
00007c  4607              MOV      r7,r0                 ;420
00007e  4630              MOV      r0,r6                 ;421
000080  f7fffffe          BL       vfs_file_get_size
000084  4604              MOV      r4,r0                 ;421
000086  4630              MOV      r0,r6                 ;422
000088  f7fffffe          BL       vfs_file_get_start_sector
00008c  4601              MOV      r1,r0                 ;422
00008e  463b              MOV      r3,r7                 ;423
000090  4622              MOV      r2,r4                 ;423
                  |L3.146|
000092  4628              MOV      r0,r5                 ;423
000094  e8bd41f0          POP      {r4-r8,lr}            ;423
000098  f7ffbffe          B.W      transfer_update_file_info
                  |L3.156|
00009c  2228              MOVS     r2,#0x28              ;423
00009e  490a              LDR      r1,|L3.200|
0000a0  4808              LDR      r0,|L3.196|
0000a2  f7fffffe          BL       __aeabi_memcpy4
0000a6  f7fffffe          BL       sync_lock
0000aa  4808              LDR      r0,|L3.204|
0000ac  7881              LDRB     r1,[r0,#2]            ;423  ; vfs_state_next
0000ae  2901              CMP      r1,#1                 ;423
0000b0  d103              BNE      |L3.186|
0000b2  7841              LDRB     r1,[r0,#1]            ;423  ; vfs_state
0000b4  2902              CMP      r1,#2                 ;423
0000b6  d100              BNE      |L3.186|
0000b8  7081              STRB     r1,[r0,#2]            ;423
                  |L3.186|
0000ba  e8bd41f0          POP      {r4-r8,lr}            ;423
0000be  f7ffbffe          B.W      sync_unlock
;;;435    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      ||.bss||+0x200
                  |L3.200|
                          DCD      ||.constdata||
                  |L3.204|
                          DCD      ||.data||

                          AREA ||i.file_data_handler||, CODE, READONLY, ALIGN=2

                  file_data_handler PROC
;;;437    // for detecting the start of a BIN/HEX file and performing programming
;;;438    static void file_data_handler(uint32_t sector, const uint8_t *buf, uint32_t num_of_sectors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;439    {
;;;440        stream_type_t stream;
;;;441        uint32_t size;
;;;442    
;;;443        // this is the key for starting a file write - we dont care what file types are sent
;;;444        //  just look for something unique (NVIC table, hex, srec, etc) until root dir is updated
;;;445        if (!file_transfer_state.stream_started) {
000004  4e1d              LDR      r6,|L4.124|
000006  4604              MOV      r4,r0                 ;439
000008  4617              MOV      r7,r2                 ;439
00000a  f8960022          LDRB     r0,[r6,#0x22]  ; file_transfer_state
00000e  4688              MOV      r8,r1                 ;439
;;;446            // look for file types we can program
;;;447            stream = stream_start_identify((uint8_t *)buf, VFS_SECTOR_SIZE * num_of_sectors);
000010  0255              LSLS     r5,r2,#9
000012  b960              CBNZ     r0,|L4.46|
000014  4629              MOV      r1,r5                 ;439
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       stream_start_identify
;;;448    
;;;449            if (STREAM_TYPE_NONE != stream) {
00001c  2803              CMP      r0,#3
00001e  d002              BEQ      |L4.38|
;;;450                transfer_stream_open(stream, sector);
000020  4621              MOV      r1,r4
000022  f7fffffe          BL       transfer_stream_open
                  |L4.38|
;;;451            }
;;;452        }
;;;453    
;;;454        if (file_transfer_state.stream_started) {
000026  f8960022          LDRB     r0,[r6,#0x22]  ; file_transfer_state
00002a  2800              CMP      r0,#0
00002c  d00f              BEQ      |L4.78|
                  |L4.46|
;;;455            // Ignore sectors coming before this file
;;;456            if (sector < file_transfer_state.start_sector) {
00002e  6870              LDR      r0,[r6,#4]  ; file_transfer_state
000030  42a0              CMP      r0,r4
000032  d80c              BHI      |L4.78|
;;;457                return;
;;;458            }
;;;459    
;;;460            // sectors must be in order
;;;461            if (sector != file_transfer_state.file_next_sector) {
000034  68f0              LDR      r0,[r6,#0xc]  ; file_transfer_state
000036  42a0              CMP      r0,r4
000038  d00b              BEQ      |L4.82|
;;;462                vfs_mngr_printf("vfs_manager file_data_handler sector=%i\r\n", sector);
;;;463    
;;;464                if (sector < file_transfer_state.file_next_sector) {
00003a  d908              BLS      |L4.78|
;;;465                    vfs_mngr_printf("    sector out of order! lowest ooo = %i\r\n",
;;;466                                    file_transfer_state.last_ooo_sector);
;;;467    
;;;468                    if (VFS_INVALID_SECTOR == file_transfer_state.last_ooo_sector) {
00003c  6930              LDR      r0,[r6,#0x10]  ; file_transfer_state
00003e  1c40              ADDS     r0,r0,#1
000040  d100              BNE      |L4.68|
;;;469                        file_transfer_state.last_ooo_sector = sector;
000042  6134              STR      r4,[r6,#0x10]  ; file_transfer_state
                  |L4.68|
;;;470                    }
;;;471    
;;;472                    file_transfer_state.last_ooo_sector =
000044  6930              LDR      r0,[r6,#0x10]  ; file_transfer_state
000046  42a0              CMP      r0,r4
000048  d200              BCS      |L4.76|
;;;473                        MIN(file_transfer_state.last_ooo_sector, sector);
00004a  4604              MOV      r4,r0
                  |L4.76|
00004c  6134              STR      r4,[r6,#0x10]  ; file_transfer_state
                  |L4.78|
;;;474                } else {
;;;475                    vfs_mngr_printf("    sector not part of file transfer\r\n");
;;;476                }
;;;477    
;;;478                vfs_mngr_printf("    discarding data - size transferred=0x%x, data=%x,%x,%x,%x,...\r\n",
;;;479                                file_transfer_state.size_transferred, buf[0], buf[1], buf[2], buf[3]);
;;;480                return;
;;;481            }
;;;482    
;;;483            // This sector could be part of the file so record it
;;;484            size = VFS_SECTOR_SIZE * num_of_sectors;
;;;485            file_transfer_state.size_transferred += size;
;;;486            file_transfer_state.file_next_sector = sector + num_of_sectors;
;;;487    
;;;488            // If stream processing is done then discard the data
;;;489            if (file_transfer_state.stream_finished) {
;;;490                vfs_mngr_printf("vfs_manager file_data_handler\r\n    sector=%i, size=%i\r\n", sector, size);
;;;491                vfs_mngr_printf("    discarding data - size transferred=0x%x, data=%x,%x,%x,%x,...\r\n",
;;;492                                file_transfer_state.size_transferred, buf[0], buf[1], buf[2], buf[3]);
;;;493                transfer_update_state(ERROR_SUCCESS);
;;;494                return;
;;;495            }
;;;496    
;;;497            transfer_stream_data(sector, buf, size);
;;;498        }
;;;499    }
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.82|
000052  69f0              LDR      r0,[r6,#0x1c]         ;485  ; file_transfer_state
000054  462a              MOV      r2,r5
000056  4410              ADD      r0,r0,r2              ;485
000058  61f0              STR      r0,[r6,#0x1c]         ;486  ; file_transfer_state
00005a  19e0              ADDS     r0,r4,r7              ;486
00005c  60f0              STR      r0,[r6,#0xc]          ;489  ; file_transfer_state
00005e  f8960023          LDRB     r0,[r6,#0x23]         ;489  ; file_transfer_state
000062  b120              CBZ      r0,|L4.110|
000064  e8bd41f0          POP      {r4-r8,lr}            ;493
000068  2000              MOVS     r0,#0                 ;493
00006a  f7ffbffe          B.W      transfer_update_state
                  |L4.110|
00006e  4641              MOV      r1,r8                 ;497
000070  4620              MOV      r0,r4                 ;497
000072  e8bd41f0          POP      {r4-r8,lr}            ;497
000076  f7ffbffe          B.W      transfer_stream_data
;;;500    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      ||.bss||+0x200

                          AREA ||i.ready_for_state_change||, CODE, READONLY, ALIGN=2

                  ready_for_state_change PROC
;;;500    
;;;501    static bool ready_for_state_change(void)
000000  b570              PUSH     {r4-r6,lr}
;;;502    {
;;;503        uint32_t timeout_ms = INVALID_TIMEOUT_MS;
;;;504        util_assert(vfs_state != vfs_state_next);
000002  4d24              LDR      r5,|L5.148|
000004  f04f34ff          MOV      r4,#0xffffffff        ;503
000008  7868              LDRB     r0,[r5,#1]  ; vfs_state
00000a  78a9              LDRB     r1,[r5,#2]  ; vfs_state_next
00000c  4288              CMP      r0,r1
00000e  d001              BEQ      |L5.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L5.22|
                  |L5.20|
000014  2000              MOVS     r0,#0
                  |L5.22|
000016  f44f72fc          MOV      r2,#0x1f8
00001a  a11f              ADR      r1,|L5.152|
00001c  f7fffffe          BL       _util_assert
;;;505    
;;;506        if (VFS_MNGR_STATE_CONNECTED == vfs_state) {
000020  7868              LDRB     r0,[r5,#1]  ; vfs_state
000022  2802              CMP      r0,#2
000024  d003              BEQ      |L5.46|
;;;507            switch (file_transfer_state.transfer_state) {
;;;508                case TRANSFER_NOT_STARTED:
;;;509                case TRASNFER_FINISHED:
;;;510                    timeout_ms = DISCONNECT_DELAY_MS;
;;;511                    break;
;;;512    
;;;513                case TRANSFER_IN_PROGRESS:
;;;514                    timeout_ms = DISCONNECT_DELAY_TRANSFER_TIMEOUT_MS;
;;;515                    break;
;;;516    
;;;517                case TRANSFER_CAN_BE_FINISHED:
;;;518                    timeout_ms = DISCONNECT_DELAY_TRANSFER_IDLE_MS;
;;;519                    break;
;;;520    
;;;521                default:
;;;522                    util_assert(0);
;;;523                    timeout_ms = DISCONNECT_DELAY_MS;
;;;524                    break;
;;;525            }
;;;526        } else if ((VFS_MNGR_STATE_DISCONNECTED == vfs_state) &&
000026  b1c0              CBZ      r0,|L5.90|
;;;527                   (VFS_MNGR_STATE_CONNECTED == vfs_state_next)) {
;;;528            timeout_ms = CONNECT_DELAY_MS;
;;;529        } else if ((VFS_MNGR_STATE_RECONNECTING == vfs_state) &&
000028  2801              CMP      r0,#1
00002a  d01a              BEQ      |L5.98|
00002c  e022              B        |L5.116|
                  |L5.46|
00002e  4827              LDR      r0,|L5.204|
000030  f44f74fa          MOV      r4,#0x1f4             ;510
000034  f8900020          LDRB     r0,[r0,#0x20]         ;507  ; file_transfer_state
000038  b1e0              CBZ      r0,|L5.116|
00003a  2801              CMP      r0,#1                 ;507
00003c  d00a              BEQ      |L5.84|
00003e  2802              CMP      r0,#2                 ;507
000040  d018              BEQ      |L5.116|
000042  2803              CMP      r0,#3                 ;507
000044  d016              BEQ      |L5.116|
000046  f240220a          MOV      r2,#0x20a             ;522
00004a  a113              ADR      r1,|L5.152|
00004c  2000              MOVS     r0,#0                 ;522
00004e  f7fffffe          BL       _util_assert
000052  e00f              B        |L5.116|
                  |L5.84|
000054  f6446420          MOV      r4,#0x4e20            ;514
000058  e00c              B        |L5.116|
                  |L5.90|
00005a  78a8              LDRB     r0,[r5,#2]            ;527  ; vfs_state_next
00005c  2802              CMP      r0,#2                 ;527
00005e  d008              BEQ      |L5.114|
000060  e008              B        |L5.116|
                  |L5.98|
;;;530                   (VFS_MNGR_STATE_CONNECTED == vfs_state_next)) {
000062  78a8              LDRB     r0,[r5,#2]  ; vfs_state_next
000064  2802              CMP      r0,#2
000066  d001              BEQ      |L5.108|
;;;531            timeout_ms = RECONNECT_DELAY_MS;
;;;532        } else if ((VFS_MNGR_STATE_RECONNECTING == vfs_state) &&
;;;533                   (VFS_MNGR_STATE_DISCONNECTED == vfs_state_next)) {
000068  b118              CBZ      r0,|L5.114|
00006a  e003              B        |L5.116|
                  |L5.108|
00006c  f64014c4          MOV      r4,#0x9c4             ;531
000070  e000              B        |L5.116|
                  |L5.114|
;;;534            timeout_ms = 0;
000072  2400              MOVS     r4,#0
                  |L5.116|
;;;535        }
;;;536    
;;;537        if (INVALID_TIMEOUT_MS == timeout_ms) {
000074  1c60              ADDS     r0,r4,#1
000076  d105              BNE      |L5.132|
;;;538            util_assert(0);
000078  f240221a          MOV      r2,#0x21a
00007c  a106              ADR      r1,|L5.152|
00007e  f7fffffe          BL       _util_assert
;;;539            timeout_ms = 0;
000082  2400              MOVS     r4,#0
                  |L5.132|
;;;540        }
;;;541    
;;;542        return time_usb_idle > timeout_ms ? true : false;
000084  68a8              LDR      r0,[r5,#8]  ; time_usb_idle
000086  42a0              CMP      r0,r4
000088  d901              BLS      |L5.142|
00008a  2001              MOVS     r0,#1
;;;543    }
00008c  bd70              POP      {r4-r6,pc}
                  |L5.142|
00008e  2000              MOVS     r0,#0                 ;542
000090  bd70              POP      {r4-r6,pc}
;;;544    
                          ENDP

000092  0000              DCW      0x0000
                  |L5.148|
                          DCD      ||.data||
                  |L5.152|
000098  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00009c  2e5c2e2e
0000a0  5c736f75
0000a4  7263655c
0000a8  6461706c
0000ac  696e6b5c
0000b0  64726167
0000b4  2d6e2d64
0000b8  726f705c
0000bc  7666735f
0000c0  6d616e61
0000c4  6765722e
0000c8  63      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L5.204|
                          DCD      ||.bss||+0x200

                          AREA ||i.sync_assert_usb_thread||, CODE, READONLY, ALIGN=2

                  sync_assert_usb_thread PROC
;;;357    
;;;358    static void sync_assert_usb_thread(void)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360        util_assert(osThreadGetId() == sync_thread);
000002  f7fffffe          BL       osThreadGetId
000006  4907              LDR      r1,|L6.36|
000008  6849              LDR      r1,[r1,#4]  ; sync_thread
00000a  4288              CMP      r0,r1
00000c  d101              BNE      |L6.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L6.20|
                  |L6.18|
000012  2000              MOVS     r0,#0
                  |L6.20|
000014  e8bd4010          POP      {r4,lr}
000018  f44f72b4          MOV      r2,#0x168
00001c  a102              ADR      r1,|L6.40|
00001e  f7ffbffe          B.W      _util_assert
;;;361    }
;;;362    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      ||.data||
                  |L6.40|
000028  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00002c  2e5c2e2e
000030  5c736f75
000034  7263655c
000038  6461706c
00003c  696e6b5c
000040  64726167
000044  2d6e2d64
000048  726f705c
00004c  7666735f
000050  6d616e61
000054  6765722e
000058  63      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.sync_lock||, CODE, READONLY, ALIGN=2

                  sync_lock PROC
;;;362    
;;;363    static void sync_lock(void)
000000  4802              LDR      r0,|L7.12|
;;;364    {
;;;365        osMutexAcquire(sync_mutex, 0);
000002  2100              MOVS     r1,#0
000004  68c0              LDR      r0,[r0,#0xc]  ; sync_mutex
000006  f7ffbffe          B.W      osMutexAcquire
;;;366    }
;;;367    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.sync_unlock||, CODE, READONLY, ALIGN=2

                  sync_unlock PROC
;;;367    
;;;368    static void sync_unlock(void)
000000  4801              LDR      r0,|L8.8|
;;;369    {
;;;370        osMutexRelease(sync_mutex);
000002  68c0              LDR      r0,[r0,#0xc]  ; sync_mutex
000004  f7ffbffe          B.W      osMutexRelease
;;;371    }
;;;372    
                          ENDP

                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.transfer_stream_data||, CODE, READONLY, ALIGN=2

                  transfer_stream_data PROC
;;;694    // Update the tranfer state with new information
;;;695    static void transfer_stream_data(uint32_t sector, const uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;696    {
;;;697        error_t status;
;;;698        vfs_mngr_printf("vfs_manager transfer_stream_data(sector=%i, size=%i)\r\n", sector, size);
;;;699        vfs_mngr_printf("    size processed=0x%x, data=%x,%x,%x,%x,...\r\n",
;;;700                        file_transfer_state.size_processed, data[0], data[1], data[2], data[3]);
;;;701    
;;;702        if (file_transfer_state.stream_finished) {
000004  4c1e              LDR      r4,|L9.128|
000006  4615              MOV      r5,r2                 ;696
000008  460e              MOV      r6,r1                 ;696
00000a  f8940023          LDRB     r0,[r4,#0x23]  ; file_transfer_state
00000e  b138              CBZ      r0,|L9.32|
;;;703            util_assert(0);
000010  e8bd41f0          POP      {r4-r8,lr}
000014  f24022bf          MOV      r2,#0x2bf
000018  a11a              ADR      r1,|L9.132|
00001a  2000              MOVS     r0,#0
00001c  f7ffbffe          B.W      _util_assert
                  |L9.32|
;;;704            return;
;;;705        }
;;;706    
;;;707        util_assert(size % VFS_SECTOR_SIZE == 0);
000020  05e8              LSLS     r0,r5,#23
000022  d01f              BEQ      |L9.100|
000024  2000              MOVS     r0,#0
                  |L9.38|
000026  f24022c3          MOV      r2,#0x2c3
00002a  a116              ADR      r1,|L9.132|
00002c  f7fffffe          BL       _util_assert
;;;708        util_assert(file_transfer_state.stream_open);
000030  f8940021          LDRB     r0,[r4,#0x21]  ; file_transfer_state
000034  f44f7231          MOV      r2,#0x2c4
000038  a112              ADR      r1,|L9.132|
00003a  f7fffffe          BL       _util_assert
;;;709        status = stream_write((uint8_t *)data, size);
00003e  4629              MOV      r1,r5
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       stream_write
000046  2700              MOVS     r7,#0
000048  2601              MOVS     r6,#1                 ;707
;;;710        vfs_mngr_printf("    stream_write ret=%i\r\n", status);
;;;711    
;;;712        if (ERROR_SUCCESS_DONE == status) {
00004a  2813              CMP      r0,#0x13
00004c  d00c              BEQ      |L9.104|
;;;713            // Override status so ERROR_SUCCESS_DONE
;;;714            // does not get passed into transfer_update_state
;;;715            status = stream_close();
;;;716            vfs_mngr_printf("    stream_close ret=%i\r\n", status);
;;;717            file_transfer_state.stream_open = false;
;;;718            file_transfer_state.stream_finished = true;
;;;719            file_transfer_state.stream_optional_finish = true;
;;;720        } else if (ERROR_SUCCESS_DONE_OR_CONTINUE == status) {
00004e  2814              CMP      r0,#0x14
000050  d011              BEQ      |L9.118|
;;;721            status = ERROR_SUCCESS;
;;;722            file_transfer_state.stream_optional_finish = true;
;;;723        } else {
;;;724            file_transfer_state.stream_optional_finish = false;
000052  f8847024          STRB     r7,[r4,#0x24]
                  |L9.86|
;;;725        }
;;;726    
;;;727        file_transfer_state.size_processed += size;
000056  6961              LDR      r1,[r4,#0x14]  ; file_transfer_state
000058  4429              ADD      r1,r1,r5
;;;728        transfer_update_state(status);
00005a  6161              STR      r1,[r4,#0x14]  ; file_transfer_state
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  f7ffbffe          B.W      transfer_update_state
                  |L9.100|
000064  2001              MOVS     r0,#1                 ;707
000066  e7de              B        |L9.38|
                  |L9.104|
000068  f7fffffe          BL       stream_close
00006c  f8847021          STRB     r7,[r4,#0x21]         ;717
000070  f8846023          STRB     r6,[r4,#0x23]         ;718
000074  e000              B        |L9.120|
                  |L9.118|
000076  2000              MOVS     r0,#0                 ;721
                  |L9.120|
000078  f8846024          STRB     r6,[r4,#0x24]         ;722
00007c  e7eb              B        |L9.86|
;;;729    }
;;;730    
                          ENDP

00007e  0000              DCW      0x0000
                  |L9.128|
                          DCD      ||.bss||+0x200
                  |L9.132|
000084  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
000088  2e5c2e2e
00008c  5c736f75
000090  7263655c
000094  6461706c
000098  696e6b5c
00009c  64726167
0000a0  2d6e2d64
0000a4  726f705c
0000a8  7666735f
0000ac  6d616e61
0000b0  6765722e
0000b4  63      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.transfer_stream_open||, CODE, READONLY, ALIGN=2

                  transfer_stream_open PROC
;;;640    // Update the tranfer state with new information
;;;641    static void transfer_stream_open(stream_type_t stream, uint32_t start_sector)
000000  b570              PUSH     {r4-r6,lr}
;;;642    {
;;;643        error_t status;
;;;644        util_assert(!file_transfer_state.stream_open);
000002  4d1c              LDR      r5,|L10.116|
000004  4606              MOV      r6,r0                 ;642
000006  460c              MOV      r4,r1                 ;642
000008  f8950021          LDRB     r0,[r5,#0x21]  ; file_transfer_state
00000c  2800              CMP      r0,#0
00000e  d011              BEQ      |L10.52|
000010  2000              MOVS     r0,#0
                  |L10.18|
000012  f44f7221          MOV      r2,#0x284
000016  a118              ADR      r1,|L10.120|
000018  f7fffffe          BL       _util_assert
;;;645        util_assert(start_sector != VFS_INVALID_SECTOR);
00001c  1c60              ADDS     r0,r4,#1
00001e  d000              BEQ      |L10.34|
000020  2001              MOVS     r0,#1
                  |L10.34|
000022  f2402285          MOV      r2,#0x285
000026  a114              ADR      r1,|L10.120|
000028  f7fffffe          BL       _util_assert
;;;646        vfs_mngr_printf("vfs_manager transfer_update_stream_open(stream=%i, start_sector=%i)\r\n",
;;;647                        stream, start_sector);
;;;648    
;;;649        // Initialize the starting sector if it has not been set
;;;650        if (VFS_INVALID_SECTOR == file_transfer_state.start_sector) {
00002c  6868              LDR      r0,[r5,#4]  ; file_transfer_state
00002e  1c40              ADDS     r0,r0,#1
000030  d002              BEQ      |L10.56|
000032  e002              B        |L10.58|
                  |L10.52|
000034  2001              MOVS     r0,#1                 ;644
000036  e7ec              B        |L10.18|
                  |L10.56|
;;;651            file_transfer_state.start_sector = start_sector;
000038  606c              STR      r4,[r5,#4]  ; file_transfer_state
                  |L10.58|
;;;652    
;;;653            if (start_sector != VFS_INVALID_SECTOR) {
;;;654                vfs_mngr_printf("    start_sector=%i\r\n", start_sector);
;;;655            }
;;;656        }
;;;657    
;;;658        // Initialize the stream if it has not been set
;;;659        if (STREAM_TYPE_NONE == file_transfer_state.stream) {
00003a  f8950027          LDRB     r0,[r5,#0x27]  ; file_transfer_state
00003e  2803              CMP      r0,#3
000040  d101              BNE      |L10.70|
;;;660            file_transfer_state.stream = stream;
000042  f8856027          STRB     r6,[r5,#0x27]
                  |L10.70|
;;;661    
;;;662            if (stream != STREAM_TYPE_NONE) {
;;;663                vfs_mngr_printf("    stream=%i\r\n", stream);
;;;664            }
;;;665        }
;;;666    
;;;667        // Check - Starting sector must be the same
;;;668        if (start_sector != file_transfer_state.start_sector) {
000046  6868              LDR      r0,[r5,#4]  ; file_transfer_state
000048  42a0              CMP      r0,r4
00004a  d103              BNE      |L10.84|
;;;669            vfs_mngr_printf("    error: starting sector changed from %i to %i\r\n", file_transfer_state.start_sector, start_sector);
;;;670            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;671            return;
;;;672        }
;;;673    
;;;674        // Check - stream must be the same
;;;675        if (stream != file_transfer_state.stream) {
00004c  f8950027          LDRB     r0,[r5,#0x27]  ; file_transfer_state
000050  42b0              CMP      r0,r6
000052  d001              BEQ      |L10.88|
                  |L10.84|
000054  2003              MOVS     r0,#3                 ;670
000056  e008              B        |L10.106|
                  |L10.88|
;;;676            vfs_mngr_printf("    error: changed types during transfer from %i to %i\r\n", file_transfer_state.stream, stream);
;;;677            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;678            return;
;;;679        }
;;;680    
;;;681        // Open stream
;;;682        status = stream_open(stream);
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       stream_open
;;;683        vfs_mngr_printf("    stream_open stream=%i ret %i\r\n", stream, status);
;;;684    
;;;685        if (ERROR_SUCCESS == status) {
00005e  b920              CBNZ     r0,|L10.106|
;;;686            file_transfer_state.file_next_sector = start_sector;
000060  f8454f0c          STR      r4,[r5,#0xc]!  ; file_transfer_state
;;;687            file_transfer_state.stream_open = true;
000064  2101              MOVS     r1,#1
000066  7569              STRB     r1,[r5,#0x15]
;;;688            file_transfer_state.stream_started = true;
000068  75a9              STRB     r1,[r5,#0x16]
                  |L10.106|
;;;689        }
;;;690    
;;;691        transfer_update_state(status);
00006a  e8bd4070          POP      {r4-r6,lr}
00006e  f7ffbffe          B.W      transfer_update_state
;;;692    }
;;;693    
                          ENDP

000072  0000              DCW      0x0000
                  |L10.116|
                          DCD      ||.bss||+0x200
                  |L10.120|
000078  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00007c  2e5c2e2e
000080  5c736f75
000084  7263655c
000088  6461706c
00008c  696e6b5c
000090  64726167
000094  2d6e2d64
000098  726f705c
00009c  7666735f
0000a0  6d616e61
0000a4  6765722e
0000a8  63      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.transfer_update_file_info||, CODE, READONLY, ALIGN=2

                  transfer_update_file_info PROC
;;;558    // Update the tranfer state with file information
;;;559    static void transfer_update_file_info(vfs_file_t file, uint32_t start_sector, uint32_t size, stream_type_t stream)
000000  b430              PUSH     {r4,r5}
;;;560    {
;;;561        vfs_mngr_printf("vfs_manager transfer_update_file_info(file=%p, start_sector=%i, size=%i)\r\n", file, start_sector, size);
;;;562    
;;;563        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000002  4c19              LDR      r4,|L11.104|
000004  f8945020          LDRB     r5,[r4,#0x20]  ; file_transfer_state
000008  2d03              CMP      r5,#3
00000a  d002              BEQ      |L11.18|
;;;564            util_assert(0);
;;;565            return;
;;;566        }
;;;567    
;;;568        // Initialize the directory entry if it has not been set
;;;569        if (VFS_FILE_INVALID == file_transfer_state.file_to_program) {
00000c  6825              LDR      r5,[r4,#0]  ; file_transfer_state
00000e  b13d              CBZ      r5,|L11.32|
000010  e007              B        |L11.34|
                  |L11.18|
000012  bc30              POP      {r4,r5}               ;564
000014  f44f720d          MOV      r2,#0x234             ;564
000018  a114              ADR      r1,|L11.108|
00001a  2000              MOVS     r0,#0                 ;564
00001c  f7ffbffe          B.W      _util_assert
                  |L11.32|
;;;570            file_transfer_state.file_to_program = file;
000020  6020              STR      r0,[r4,#0]  ; file_transfer_state
                  |L11.34|
;;;571    
;;;572            if (file != VFS_FILE_INVALID) {
;;;573                vfs_mngr_printf("    file_to_program=%p\r\n", file);
;;;574            }
;;;575        }
;;;576    
;;;577        // Initialize the starting sector if it has not been set
;;;578        if (VFS_INVALID_SECTOR == file_transfer_state.file_start_sector) {
000022  68a0              LDR      r0,[r4,#8]  ; file_transfer_state
000024  1c40              ADDS     r0,r0,#1
000026  d100              BNE      |L11.42|
;;;579            file_transfer_state.file_start_sector = start_sector;
000028  60a1              STR      r1,[r4,#8]  ; file_transfer_state
                  |L11.42|
;;;580    
;;;581            if (start_sector != VFS_INVALID_SECTOR) {
;;;582                vfs_mngr_printf("    start_sector=%i\r\n", start_sector);
;;;583            }
;;;584        }
;;;585    
;;;586        // Initialize the stream if it has not been set
;;;587        if (STREAM_TYPE_NONE == file_transfer_state.stream) {
00002a  f8940027          LDRB     r0,[r4,#0x27]  ; file_transfer_state
00002e  2803              CMP      r0,#3
000030  d101              BNE      |L11.54|
;;;588            file_transfer_state.stream = stream;
000032  f8843027          STRB     r3,[r4,#0x27]
                  |L11.54|
;;;589    
;;;590            if (stream != STREAM_TYPE_NONE) {
;;;591                vfs_mngr_printf("    stream=%i\r\n", stream);
;;;592            }
;;;593        }
;;;594    
;;;595        // Check - File size must either grow or be smaller than the size already transferred
;;;596        if ((size < file_transfer_state.file_size) && (size < file_transfer_state.size_transferred) && (size > 0)) {
000036  69a0              LDR      r0,[r4,#0x18]  ; file_transfer_state
000038  4290              CMP      r0,r2
00003a  d905              BLS      |L11.72|
00003c  69e0              LDR      r0,[r4,#0x1c]  ; file_transfer_state
00003e  4290              CMP      r0,r2
000040  d902              BLS      |L11.72|
000042  b10a              CBZ      r2,|L11.72|
                  |L11.68|
;;;597            vfs_mngr_printf("    error: file size changed from %i to %i\r\n", file_transfer_state.file_size, size);
;;;598            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
000044  2003              MOVS     r0,#3
;;;599            return;
000046  e00c              B        |L11.98|
                  |L11.72|
;;;600        }
;;;601    
;;;602        // Check - Starting sector must be the same  - this is optional for file info since it may not be present initially
;;;603        if ((VFS_INVALID_SECTOR != start_sector) && (start_sector != file_transfer_state.file_start_sector)) {
000048  1c48              ADDS     r0,r1,#1
00004a  d002              BEQ      |L11.82|
00004c  68a0              LDR      r0,[r4,#8]  ; file_transfer_state
00004e  4288              CMP      r0,r1
000050  d1f8              BNE      |L11.68|
                  |L11.82|
;;;604            vfs_mngr_printf("    error: starting sector changed from %i to %i\r\n", file_transfer_state.file_start_sector, start_sector);
;;;605            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;606            return;
;;;607        }
;;;608    
;;;609        // Check - stream must be the same
;;;610        if ((stream != STREAM_TYPE_NONE) && (stream != file_transfer_state.stream)) {
000052  2b03              CMP      r3,#3
000054  d003              BEQ      |L11.94|
000056  f8940027          LDRB     r0,[r4,#0x27]  ; file_transfer_state
00005a  4298              CMP      r0,r3
00005c  d1f2              BNE      |L11.68|
                  |L11.94|
;;;611            vfs_mngr_printf("    error: changed types during transfer from %i to %i\r\n", file_transfer_state.stream, stream);
;;;612            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;613            return;
;;;614        }
;;;615    
;;;616        // Update values - Size is the only value that can change
;;;617        file_transfer_state.file_size = size;
;;;618        vfs_mngr_printf("    updated size=%i\r\n", size);
;;;619    
;;;620        transfer_update_state(ERROR_SUCCESS);
00005e  2000              MOVS     r0,#0
000060  61a2              STR      r2,[r4,#0x18]  ; file_transfer_state
                  |L11.98|
000062  bc30              POP      {r4,r5}
000064  f7ffbffe          B.W      transfer_update_state
;;;621    }
;;;622    
                          ENDP

                  |L11.104|
                          DCD      ||.bss||+0x200
                  |L11.108|
00006c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
000070  2e5c2e2e
000074  5c736f75
000078  7263655c
00007c  6461706c
000080  696e6b5c
000084  64726167
000088  2d6e2d64
00008c  726f705c
000090  7666735f
000094  6d616e61
000098  6765722e
00009c  63      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.transfer_update_state||, CODE, READONLY, ALIGN=2

                  transfer_update_state PROC
;;;731    // Check if the current transfer is still in progress, done, or if an error has occurred
;;;732    static void transfer_update_state(error_t status)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;733    {
;;;734        bool transfer_timeout;
;;;735        bool transfer_started;
;;;736        bool transfer_can_be_finished;
;;;737        bool transfer_must_be_finished;
;;;738        bool out_of_order_sector;
;;;739        error_t local_status = status;
000004  4604              MOV      r4,r0
;;;740        util_assert((status != ERROR_SUCCESS_DONE) &&
000006  2813              CMP      r0,#0x13
000008  d003              BEQ      |L12.18|
00000a  2c14              CMP      r4,#0x14
00000c  d001              BEQ      |L12.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L12.20|
                  |L12.18|
000012  2000              MOVS     r0,#0
                  |L12.20|
000014  f44f7239          MOV      r2,#0x2e4
000018  a143              ADR      r1,|L12.296|
00001a  f7fffffe          BL       _util_assert
;;;741                    (status != ERROR_SUCCESS_DONE_OR_CONTINUE));
;;;742    
;;;743        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
00001e  4d4f              LDR      r5,|L12.348|
000020  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
000024  2803              CMP      r0,#3
000026  d00c              BEQ      |L12.66|
;;;744            util_assert(0);
;;;745            return;
;;;746        }
;;;747    
;;;748        // Update file info status.  The end of a file is never known for sure since
;;;749        // what looks like a complete file could be part of a file getting flushed to disk.
;;;750        // The criteria for an successful optional finish is
;;;751        // 1. A file has been detected
;;;752        // 2. The size of the file indicated in the root dir has been transferred
;;;753        // 3. The file size is greater than zero
;;;754        // 4. Matching start sector set by stream and vfs changes
;;;755        file_transfer_state.file_info_optional_finish =
000028  6829              LDR      r1,[r5,#0]  ; file_transfer_state
00002a  b191              CBZ      r1,|L12.82|
00002c  e9d50206          LDRD     r0,r2,[r5,#0x18]
;;;756            (file_transfer_state.file_to_program != VFS_FILE_INVALID) &&
;;;757            (file_transfer_state.size_transferred >= file_transfer_state.file_size) &&
000030  4282              CMP      r2,r0
000032  d30e              BCC      |L12.82|
;;;758            (file_transfer_state.file_size > 0) &&
000034  b168              CBZ      r0,|L12.82|
000036  e9d50201          LDRD     r0,r2,[r5,#4]
;;;759            (file_transfer_state.start_sector == file_transfer_state.file_start_sector);
00003a  4290              CMP      r0,r2
00003c  d109              BNE      |L12.82|
00003e  2001              MOVS     r0,#1
000040  e008              B        |L12.84|
                  |L12.66|
000042  e8bd47f0          POP      {r4-r10,lr}           ;744
000046  f44f723a          MOV      r2,#0x2e8             ;744
00004a  a137              ADR      r1,|L12.296|
00004c  2000              MOVS     r0,#0                 ;744
00004e  f7ffbffe          B.W      _util_assert
                  |L12.82|
000052  2000              MOVS     r0,#0
                  |L12.84|
000054  f8850025          STRB     r0,[r5,#0x25]
;;;760        transfer_timeout = file_transfer_state.transfer_timeout;
000058  f8959026          LDRB     r9,[r5,#0x26]  ; file_transfer_state
;;;761        transfer_started = (VFS_FILE_INVALID != file_transfer_state.file_to_program) ||
00005c  b919              CBNZ     r1,|L12.102|
;;;762                           (STREAM_TYPE_NONE != file_transfer_state.stream);
00005e  f8951027          LDRB     r1,[r5,#0x27]  ; file_transfer_state
000062  2903              CMP      r1,#3
000064  d001              BEQ      |L12.106|
                  |L12.102|
000066  2101              MOVS     r1,#1
000068  e000              B        |L12.108|
                  |L12.106|
00006a  2100              MOVS     r1,#0
                  |L12.108|
00006c  4688              MOV      r8,r1
;;;763        // The transfer can be finished if both file and stream processing
;;;764        // can be considered complete
;;;765        transfer_can_be_finished = file_transfer_state.file_info_optional_finish &&
00006e  b120              CBZ      r0,|L12.122|
;;;766                                   file_transfer_state.stream_optional_finish;
000070  f8951024          LDRB     r1,[r5,#0x24]  ; file_transfer_state
000074  b109              CBZ      r1,|L12.122|
000076  2601              MOVS     r6,#1
000078  e000              B        |L12.124|
                  |L12.122|
00007a  2600              MOVS     r6,#0
                  |L12.124|
;;;767        // The transfer must be fnished if stream processing is for sure complete
;;;768        // and file processing can be considered complete
;;;769        transfer_must_be_finished = file_transfer_state.stream_finished &&
00007c  f8951023          LDRB     r1,[r5,#0x23]  ; file_transfer_state
000080  b111              CBZ      r1,|L12.136|
;;;770                                    file_transfer_state.file_info_optional_finish;
000082  b108              CBZ      r0,|L12.136|
000084  2001              MOVS     r0,#1
000086  e000              B        |L12.138|
                  |L12.136|
000088  2000              MOVS     r0,#0
                  |L12.138|
00008a  4682              MOV      r10,r0
;;;771        out_of_order_sector = false;
;;;772    
;;;773        if (file_transfer_state.last_ooo_sector != VFS_INVALID_SECTOR) {
00008c  6928              LDR      r0,[r5,#0x10]  ; file_transfer_state
00008e  2700              MOVS     r7,#0                 ;771
000090  1c40              ADDS     r0,r0,#1
000092  d010              BEQ      |L12.182|
;;;774            util_assert(file_transfer_state.start_sector != VFS_INVALID_SECTOR);
000094  6868              LDR      r0,[r5,#4]  ; file_transfer_state
000096  1c40              ADDS     r0,r0,#1
000098  d000              BEQ      |L12.156|
00009a  2001              MOVS     r0,#1
                  |L12.156|
00009c  f2403206          MOV      r2,#0x306
0000a0  a121              ADR      r1,|L12.296|
0000a2  f7fffffe          BL       _util_assert
;;;775            uint32_t sector_offset = (file_transfer_state.last_ooo_sector -
0000a6  6869              LDR      r1,[r5,#4]  ; file_transfer_state
0000a8  6928              LDR      r0,[r5,#0x10]  ; file_transfer_state
0000aa  1a40              SUBS     r0,r0,r1
;;;776                                      file_transfer_state.start_sector) * VFS_SECTOR_SIZE;
;;;777    
;;;778            if (sector_offset < file_transfer_state.size_processed) {
0000ac  6969              LDR      r1,[r5,#0x14]  ; file_transfer_state
0000ae  0240              LSLS     r0,r0,#9              ;775
0000b0  4281              CMP      r1,r0
0000b2  d900              BLS      |L12.182|
;;;779                // The out of order sector was within the range of data already
;;;780                // processed.
;;;781                out_of_order_sector = true;
0000b4  2701              MOVS     r7,#1
                  |L12.182|
0000b6  2003              MOVS     r0,#3                 ;743
;;;782            }
;;;783        }
;;;784    
;;;785        // Set the transfer state and set the status if necessary
;;;786        if (local_status != ERROR_SUCCESS) {
0000b8  b114              CBZ      r4,|L12.192|
                  |L12.186|
;;;787            file_transfer_state.transfer_state = TRASNFER_FINISHED;
0000ba  f8850020          STRB     r0,[r5,#0x20]
0000be  e01d              B        |L12.252|
                  |L12.192|
;;;788        } else if (transfer_timeout) {
0000c0  f1b90f00          CMP      r9,#0
0000c4  d009              BEQ      |L12.218|
;;;789            if (out_of_order_sector) {
0000c6  b10f              CBZ      r7,|L12.204|
;;;790                local_status = ERROR_OOO_SECTOR;
0000c8  2406              MOVS     r4,#6
0000ca  e7f6              B        |L12.186|
                  |L12.204|
;;;791            } else if (!transfer_started) {
0000cc  f1b80f00          CMP      r8,#0
0000d0  d0f3              BEQ      |L12.186|
;;;792                local_status = ERROR_SUCCESS;
;;;793            } else if (transfer_can_be_finished) {
0000d2  2e00              CMP      r6,#0
0000d4  d1f1              BNE      |L12.186|
;;;794                local_status = ERROR_SUCCESS;
;;;795            } else {
;;;796                local_status = ERROR_TRANSFER_TIMEOUT;
0000d6  2404              MOVS     r4,#4
0000d8  e7ef              B        |L12.186|
                  |L12.218|
;;;797            }
;;;798    
;;;799            file_transfer_state.transfer_state = TRASNFER_FINISHED;
;;;800        } else if (transfer_must_be_finished) {
0000da  f1ba0f00          CMP      r10,#0
0000de  d1ec              BNE      |L12.186|
;;;801            file_transfer_state.transfer_state = TRASNFER_FINISHED;
;;;802        } else if (transfer_can_be_finished) {
0000e0  b10e              CBZ      r6,|L12.230|
;;;803            file_transfer_state.transfer_state = TRANSFER_CAN_BE_FINISHED;
0000e2  2002              MOVS     r0,#2
0000e4  e003              B        |L12.238|
                  |L12.230|
;;;804        } else if (transfer_started) {
0000e6  f1b80f00          CMP      r8,#0
0000ea  d003              BEQ      |L12.244|
;;;805            file_transfer_state.transfer_state = TRANSFER_IN_PROGRESS;
0000ec  2001              MOVS     r0,#1
                  |L12.238|
0000ee  f8850020          STRB     r0,[r5,#0x20]
0000f2  e012              B        |L12.282|
                  |L12.244|
;;;806        }
;;;807    
;;;808        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
0000f4  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
0000f8  2803              CMP      r0,#3
0000fa  d10b              BNE      |L12.276|
                  |L12.252|
;;;809            vfs_mngr_printf("vfs_manager transfer_update_state(status=%i)\r\n", status);
;;;810            vfs_mngr_printf("    file=%p, start_sect= %i %i, size=%i\r\n",
;;;811                            file_transfer_state.file_to_program, file_transfer_state.start_sector,
;;;812                            file_transfer_state.file_start_sector, file_transfer_state.file_size);
;;;813            vfs_mngr_printf("    stream=%i, size_processed=%i, opt_finish=%i, timeout=%i\r\n",
;;;814                            file_transfer_state.stream, file_transfer_state.size_processed,
;;;815                            file_transfer_state.file_info_optional_finish, transfer_timeout);
;;;816    
;;;817            // Close the file stream if it is open
;;;818            if (file_transfer_state.stream_open) {
0000fc  f8950021          LDRB     r0,[r5,#0x21]  ; file_transfer_state
000100  b130              CBZ      r0,|L12.272|
;;;819                error_t close_status;
;;;820                close_status = stream_close();
000102  f7fffffe          BL       stream_close
;;;821                vfs_mngr_printf("    stream closed ret=%i\r\n", close_status);
;;;822                file_transfer_state.stream_open = false;
000106  2100              MOVS     r1,#0
000108  f8851021          STRB     r1,[r5,#0x21]
;;;823    
;;;824                if (ERROR_SUCCESS == local_status) {
00010c  b904              CBNZ     r4,|L12.272|
;;;825                    local_status = close_status;
00010e  4604              MOV      r4,r0
                  |L12.272|
;;;826                }
;;;827            }
;;;828    
;;;829            // Set the fail reason
;;;830            fail_reason = local_status;
000110  4813              LDR      r0,|L12.352|
000112  7004              STRB     r4,[r0,#0]
                  |L12.276|
;;;831            vfs_mngr_printf("    Transfer finished, status: %i=%s\r\n", fail_reason, error_get_string(fail_reason));
;;;832        }
;;;833    
;;;834        // If this state change is not from aborting a transfer
;;;835        // due to a remount then trigger a remount
;;;836        if (!transfer_timeout) {
000114  f1b90f00          CMP      r9,#0
000118  d103              BNE      |L12.290|
                  |L12.282|
;;;837            vfs_mngr_fs_remount();
00011a  e8bd47f0          POP      {r4-r10,lr}
00011e  f7ffbffe          B.W      vfs_mngr_fs_remount
                  |L12.290|
;;;838        }
;;;839    }
000122  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

000126  0000              DCW      0x0000
                  |L12.296|
000128  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00012c  2e5c2e2e
000130  5c736f75
000134  7263655c
000138  6461706c
00013c  696e6b5c
000140  64726167
000144  2d6e2d64
000148  726f705c
00014c  7666735f
000150  6d616e61
000154  6765722e
000158  63      
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L12.348|
                          DCD      ||.bss||+0x200
                  |L12.352|
                          DCD      ||.data||

                          AREA ||i.usbd_msc_init||, CODE, READONLY, ALIGN=2

                  usbd_msc_init PROC
;;;301    
;;;302    void usbd_msc_init(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       osThreadGetId
000006  4c07              LDR      r4,|L13.36|
000008  6060              STR      r0,[r4,#4]  ; sync_thread
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       osMutexNew
;;;303    {
;;;304        sync_init();
;;;305        build_filesystem();
000010  60e0              STR      r0,[r4,#0xc]  ; sync_mutex
000012  f7fffffe          BL       build_filesystem
;;;306        vfs_state = VFS_MNGR_STATE_DISCONNECTED;
000016  2000              MOVS     r0,#0
000018  7060              STRB     r0,[r4,#1]
;;;307        vfs_state_next = VFS_MNGR_STATE_DISCONNECTED;
;;;308        time_usb_idle = 0;
;;;309        USBD_MSC_MediaReady = 0;
00001a  4903              LDR      r1,|L13.40|
00001c  70a0              STRB     r0,[r4,#2]            ;307
00001e  60a0              STR      r0,[r4,#8]  ; time_usb_idle
000020  6008              STR      r0,[r1,#0]  ; USBD_MSC_MediaReady
;;;310    }
000022  bd10              POP      {r4,pc}
;;;311    
                          ENDP

                  |L13.36|
                          DCD      ||.data||
                  |L13.40|
                          DCD      USBD_MSC_MediaReady

                          AREA ||i.usbd_msc_read_sect||, CODE, READONLY, ALIGN=2

                  usbd_msc_read_sect PROC
;;;311    
;;;312    void usbd_msc_read_sect(uint32_t sector, uint8_t *buf, uint32_t num_of_sectors)
000000  b570              PUSH     {r4-r6,lr}
;;;313    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;314        sync_assert_usb_thread();
000008  f7fffffe          BL       sync_assert_usb_thread
;;;315    
;;;316        // dont proceed if we're not ready
;;;317        if (!USBD_MSC_MediaReady) {
00000c  4b07              LDR      r3,|L14.44|
00000e  6818              LDR      r0,[r3,#0]  ; USBD_MSC_MediaReady
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L14.40|
;;;318            return;
;;;319        }
;;;320    
;;;321        // indicate msc activity
;;;322        main_blink_msc_led(MAIN_LED_FLASH);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       main_blink_msc_led
;;;323        vfs_read(sector, buf, num_of_sectors);
00001a  4622              MOV      r2,r4
00001c  4629              MOV      r1,r5
00001e  4630              MOV      r0,r6
000020  e8bd4070          POP      {r4-r6,lr}
000024  f7ffbffe          B.W      vfs_read
                  |L14.40|
;;;324    }
000028  bd70              POP      {r4-r6,pc}
;;;325    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      USBD_MSC_MediaReady

                          AREA ||i.usbd_msc_write_sect||, CODE, READONLY, ALIGN=2

                  usbd_msc_write_sect PROC
;;;325    
;;;326    void usbd_msc_write_sect(uint32_t sector, uint8_t *buf, uint32_t num_of_sectors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;327    {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;328        sync_assert_usb_thread();
00000a  f7fffffe          BL       sync_assert_usb_thread
;;;329    
;;;330        if (!USBD_MSC_MediaReady) {
00000e  4810              LDR      r0,|L15.80|
000010  6800              LDR      r0,[r0,#0]  ; USBD_MSC_MediaReady
000012  2800              CMP      r0,#0
000014  d01a              BEQ      |L15.76|
;;;331            return;
;;;332        }
;;;333    
;;;334        // Restart the disconnect counter on every packet
;;;335        // so the device does not detach in the middle of a
;;;336        // transfer.
;;;337        time_usb_idle = 0;
000016  490f              LDR      r1,|L15.84|
;;;338    
;;;339        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000018  4c0f              LDR      r4,|L15.88|
00001a  2000              MOVS     r0,#0                 ;337
00001c  6088              STR      r0,[r1,#8]  ; time_usb_idle
00001e  f8940020          LDRB     r0,[r4,#0x20]  ; file_transfer_state
000022  2803              CMP      r0,#3
000024  d012              BEQ      |L15.76|
;;;340            return;
;;;341        }
;;;342    
;;;343        // indicate msc activity
;;;344        main_blink_msc_led(MAIN_LED_FLASH);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       main_blink_msc_led
;;;345        vfs_write(sector, buf, num_of_sectors);
00002c  462a              MOV      r2,r5
00002e  4631              MOV      r1,r6
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       vfs_write
;;;346        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000036  f8940020          LDRB     r0,[r4,#0x20]  ; file_transfer_state
00003a  2803              CMP      r0,#3
00003c  d006              BEQ      |L15.76|
;;;347            return;
;;;348        }
;;;349        file_data_handler(sector, buf, num_of_sectors);
00003e  462a              MOV      r2,r5
000040  4631              MOV      r1,r6
000042  4638              MOV      r0,r7
000044  e8bd41f0          POP      {r4-r8,lr}
000048  f7ffbffe          B.W      file_data_handler
                  |L15.76|
;;;350    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;351    
                          ENDP

                  |L15.80|
                          DCD      USBD_MSC_MediaReady
                  |L15.84|
                          DCD      ||.data||
                  |L15.88|
                          DCD      ||.bss||+0x200

                          AREA ||i.vfs_mngr_fs_enable||, CODE, READONLY, ALIGN=2

                  vfs_mngr_fs_enable PROC
;;;161    
;;;162    void vfs_mngr_fs_enable(bool enable)
000000  b510              PUSH     {r4,lr}
;;;163    {
000002  4604              MOV      r4,r0
;;;164        sync_lock();
000004  f7fffffe          BL       sync_lock
;;;165    
;;;166        if (enable) {
;;;167            if (VFS_MNGR_STATE_DISCONNECTED == vfs_state_next) {
000008  4905              LDR      r1,|L16.32|
00000a  b13c              CBZ      r4,|L16.28|
00000c  7888              LDRB     r0,[r1,#2]  ; vfs_state_next
00000e  b908              CBNZ     r0,|L16.20|
;;;168                vfs_state_next = VFS_MNGR_STATE_CONNECTED;
000010  2002              MOVS     r0,#2
                  |L16.18|
000012  7088              STRB     r0,[r1,#2]
                  |L16.20|
;;;169            }
;;;170        } else {
;;;171            vfs_state_next = VFS_MNGR_STATE_DISCONNECTED;
;;;172        }
;;;173    
;;;174        sync_unlock();
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      sync_unlock
                  |L16.28|
00001c  2000              MOVS     r0,#0                 ;171
00001e  e7f8              B        |L16.18|
;;;175    }
;;;176    
                          ENDP

                  |L16.32|
                          DCD      ||.data||

                          AREA ||i.vfs_mngr_fs_remount||, CODE, READONLY, ALIGN=2

                  vfs_mngr_fs_remount PROC
;;;176    
;;;177    void vfs_mngr_fs_remount(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179        sync_lock();
000002  f7fffffe          BL       sync_lock
;;;180    
;;;181        // Only start a remount if in the connected state and not in a transition
;;;182        if (!changing_state() && (VFS_MNGR_STATE_CONNECTED == vfs_state)) {
000006  f7fffffe          BL       changing_state
00000a  b928              CBNZ     r0,|L17.24|
00000c  4804              LDR      r0,|L17.32|
00000e  7841              LDRB     r1,[r0,#1]  ; vfs_state
000010  2902              CMP      r1,#2
000012  d101              BNE      |L17.24|
;;;183            vfs_state_next = VFS_MNGR_STATE_RECONNECTING;
000014  2101              MOVS     r1,#1
000016  7081              STRB     r1,[r0,#2]
                  |L17.24|
;;;184        }
;;;185    
;;;186        sync_unlock();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      sync_unlock
;;;187    }
;;;188    
                          ENDP

                  |L17.32|
                          DCD      ||.data||

                          AREA ||i.vfs_mngr_get_transfer_status||, CODE, READONLY, ALIGN=2

                  vfs_mngr_get_transfer_status PROC
;;;295    
;;;296    error_t vfs_mngr_get_transfer_status()
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298        sync_assert_usb_thread();
000002  f7fffffe          BL       sync_assert_usb_thread
;;;299        return fail_reason;
000006  4801              LDR      r0,|L18.12|
000008  7800              LDRB     r0,[r0,#0]  ; fail_reason
;;;300    }
00000a  bd10              POP      {r4,pc}
;;;301    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.vfs_mngr_init||, CODE, READONLY, ALIGN=2

                  vfs_mngr_init PROC
;;;188    
;;;189    void vfs_mngr_init(bool enable)
000000  b510              PUSH     {r4,lr}
;;;190    {
000002  4604              MOV      r4,r0
;;;191        sync_assert_usb_thread();
000004  f7fffffe          BL       sync_assert_usb_thread
;;;192        build_filesystem();
000008  f7fffffe          BL       build_filesystem
;;;193    
;;;194        if (enable) {
;;;195            vfs_state = VFS_MNGR_STATE_CONNECTED;
00000c  4906              LDR      r1,|L19.40|
;;;196            vfs_state_next = VFS_MNGR_STATE_CONNECTED;
;;;197            USBD_MSC_MediaReady = 1;
00000e  4a07              LDR      r2,|L19.44|
000010  b124              CBZ      r4,|L19.28|
000012  2002              MOVS     r0,#2                 ;195
000014  7048              STRB     r0,[r1,#1]            ;195
000016  7088              STRB     r0,[r1,#2]            ;196
000018  2001              MOVS     r0,#1
00001a  e002              B        |L19.34|
                  |L19.28|
;;;198        } else {
;;;199            vfs_state = VFS_MNGR_STATE_DISCONNECTED;
00001c  2000              MOVS     r0,#0
00001e  7048              STRB     r0,[r1,#1]
;;;200            vfs_state_next = VFS_MNGR_STATE_DISCONNECTED;
000020  7088              STRB     r0,[r1,#2]
                  |L19.34|
000022  6010              STR      r0,[r2,#0]            ;197  ; USBD_MSC_MediaReady
;;;201            USBD_MSC_MediaReady = 0;
;;;202        }
;;;203    }
000024  bd10              POP      {r4,pc}
;;;204    
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
                          DCD      ||.data||
                  |L19.44|
                          DCD      USBD_MSC_MediaReady

                          AREA ||i.vfs_mngr_periodic||, CODE, READONLY, ALIGN=2

                  vfs_mngr_periodic PROC
;;;204    
;;;205    void vfs_mngr_periodic(uint32_t elapsed_ms)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;206    {
000004  4604              MOV      r4,r0
;;;207        bool change_state;
;;;208        vfs_mngr_state_t vfs_state_local;
;;;209        vfs_mngr_state_t vfs_state_local_prev;
;;;210        sync_assert_usb_thread();
000006  f7fffffe          BL       sync_assert_usb_thread
;;;211        sync_lock();
00000a  f7fffffe          BL       sync_lock
;;;212    
;;;213        // Return immediately if the desired state has been reached
;;;214        if (!changing_state()) {
00000e  f7fffffe          BL       changing_state
000012  b180              CBZ      r0,|L20.54|
;;;215            sync_unlock();
;;;216            return;
;;;217        }
;;;218    
;;;219        change_state = ready_for_state_change();
000014  f7fffffe          BL       ready_for_state_change
;;;220    
;;;221        if (time_usb_idle < MAX_EVENT_TIME_MS) {
000018  4a21              LDR      r2,|L20.160|
00001a  f64e2360          MOV      r3,#0xea60
00001e  6891              LDR      r1,[r2,#8]  ; time_usb_idle
000020  4299              CMP      r1,r3
000022  d201              BCS      |L20.40|
;;;222            time_usb_idle += elapsed_ms;
000024  4421              ADD      r1,r1,r4
000026  6091              STR      r1,[r2,#8]  ; time_usb_idle
                  |L20.40|
;;;223        }
;;;224    
;;;225        if (!change_state) {
000028  b128              CBZ      r0,|L20.54|
;;;226            sync_unlock();
;;;227            return;
;;;228        }
;;;229    
;;;230        vfs_mngr_printf("vfs_mngr_periodic()\r\n");
;;;231        vfs_mngr_printf("   time_usb_idle=%i\r\n", time_usb_idle);
;;;232        vfs_mngr_printf("   transfer_state=%i\r\n", file_transfer_state.transfer_state);
;;;233        // Transistion to new state
;;;234        vfs_state_local_prev = vfs_state;
;;;235        vfs_state = vfs_state_next;
00002a  7894              LDRB     r4,[r2,#2]  ; vfs_state_next
00002c  7855              LDRB     r5,[r2,#1]            ;234  ; vfs_state
00002e  7054              STRB     r4,[r2,#1]
;;;236    
;;;237        switch (vfs_state) {
000030  2c01              CMP      r4,#1
000032  d106              BNE      |L20.66|
000034  e003              B        |L20.62|
                  |L20.54|
000036  e8bd41f0          POP      {r4-r8,lr}            ;226
00003a  f7ffbffe          B.W      sync_unlock
                  |L20.62|
;;;238            case VFS_MNGR_STATE_RECONNECTING:
;;;239                // Transition back to the connected state
;;;240                vfs_state_next = VFS_MNGR_STATE_CONNECTED;
00003e  2002              MOVS     r0,#2
000040  7090              STRB     r0,[r2,#2]
                  |L20.66|
;;;241                break;
;;;242    
;;;243            default:
;;;244                // No state change logic required in other states
;;;245                break;
;;;246        }
;;;247    
;;;248        vfs_state_local = vfs_state;
;;;249        time_usb_idle = 0;
000042  2600              MOVS     r6,#0
;;;250        sync_unlock();
000044  6096              STR      r6,[r2,#8]  ; time_usb_idle
000046  f7fffffe          BL       sync_unlock
00004a  2701              MOVS     r7,#1                 ;235
;;;251        // Processing when leaving a state
;;;252        vfs_mngr_printf("    state %i->%i\r\n", vfs_state_local_prev, vfs_state_local);
;;;253    
;;;254        switch (vfs_state_local_prev) {
00004c  b1cd              CBZ      r5,|L20.130|
00004e  2d01              CMP      r5,#1
000050  d017              BEQ      |L20.130|
000052  2d02              CMP      r5,#2
000054  d115              BNE      |L20.130|
;;;255            case VFS_MNGR_STATE_DISCONNECTED:
;;;256                // No action needed
;;;257                break;
;;;258    
;;;259            case VFS_MNGR_STATE_RECONNECTING:
;;;260                // No action needed
;;;261                break;
;;;262    
;;;263            case VFS_MNGR_STATE_CONNECTED:
;;;264    
;;;265                // Close ongoing transfer if there is one
;;;266                if (file_transfer_state.transfer_state != TRASNFER_FINISHED) {
000056  4d13              LDR      r5,|L20.164|
000058  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
00005c  2803              CMP      r0,#3
00005e  d004              BEQ      |L20.106|
;;;267                    vfs_mngr_printf("    transfer timeout\r\n");
;;;268                    file_transfer_state.transfer_timeout = true;
000060  f8857026          STRB     r7,[r5,#0x26]
;;;269                    transfer_update_state(ERROR_SUCCESS);
000064  2000              MOVS     r0,#0
000066  f7fffffe          BL       transfer_update_state
                  |L20.106|
;;;270                }
;;;271    
;;;272                util_assert(TRASNFER_FINISHED == file_transfer_state.transfer_state);
00006a  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
00006e  2803              CMP      r0,#3
000070  d012              BEQ      |L20.152|
000072  2000              MOVS     r0,#0
                  |L20.116|
000074  f44f7288          MOV      r2,#0x110
000078  a10b              ADR      r1,|L20.168|
00007a  f7fffffe          BL       _util_assert
;;;273                vfs_user_disconnecting();
00007e  f7fffffe          BL       vfs_user_disconnecting
                  |L20.130|
;;;274                break;
;;;275        }
;;;276    
;;;277        // Processing when entering a state
;;;278        switch (vfs_state_local) {
;;;279            case VFS_MNGR_STATE_DISCONNECTED:
;;;280                USBD_MSC_MediaReady = 0;
000082  4d16              LDR      r5,|L20.220|
000084  b154              CBZ      r4,|L20.156|
000086  2c01              CMP      r4,#1                 ;278
000088  d008              BEQ      |L20.156|
00008a  2c02              CMP      r4,#2                 ;278
00008c  d102              BNE      |L20.148|
;;;281                break;
;;;282    
;;;283            case VFS_MNGR_STATE_RECONNECTING:
;;;284                USBD_MSC_MediaReady = 0;
;;;285                break;
;;;286    
;;;287            case VFS_MNGR_STATE_CONNECTED:
;;;288                build_filesystem();
00008e  f7fffffe          BL       build_filesystem
;;;289                USBD_MSC_MediaReady = 1;
;;;290                break;
000092  602f              STR      r7,[r5,#0]  ; USBD_MSC_MediaReady
                  |L20.148|
;;;291        }
;;;292    
;;;293        return;
;;;294    }
000094  e8bd81f0          POP      {r4-r8,pc}
                  |L20.152|
000098  2001              MOVS     r0,#1                 ;272
00009a  e7eb              B        |L20.116|
                  |L20.156|
00009c  602e              STR      r6,[r5,#0]            ;284  ; USBD_MSC_MediaReady
00009e  e7f9              B        |L20.148|
;;;295    
                          ENDP

                  |L20.160|
                          DCD      ||.data||
                  |L20.164|
                          DCD      ||.bss||+0x200
                  |L20.168|
0000a8  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
0000ac  2e5c2e2e
0000b0  5c736f75
0000b4  7263655c
0000b8  6461706c
0000bc  696e6b5c
0000c0  64726167
0000c4  2d6e2d64
0000c8  726f705c
0000cc  7666735f
0000d0  6d616e61
0000d4  6765722e
0000d8  63      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L20.220|
                          DCD      USBD_MSC_MediaReady

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  usb_buffer
                          %        512
                  file_transfer_state
                          %        40

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  default_transfer_state
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  00000003          DCB      0x00,0x00,0x00,0x03

                          AREA ||.data||, DATA, ALIGN=2

                  fail_reason
000000  00                DCB      0x00
                  vfs_state
000001  00                DCB      0x00
                  vfs_state_next
000002  0000              DCB      0x00,0x00
                  sync_thread
                          DCD      0x00000000
                  time_usb_idle
                          DCD      0x00000000
                  sync_mutex
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_vfs_manager_c_bf9123bc____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___13_vfs_manager_c_bf9123bc____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_vfs_manager_c_bf9123bc____REVSH|
#line 495
|__asm___13_vfs_manager_c_bf9123bc____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_vfs_manager_c_bf9123bc____RRX|
#line 682
|__asm___13_vfs_manager_c_bf9123bc____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
