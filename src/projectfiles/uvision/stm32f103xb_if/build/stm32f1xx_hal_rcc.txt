; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\stm32f1xx_hal_rcc.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f1xx_hal_rcc.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\stm32f1xx_hal_rcc.crf ..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1245     */
;;;1246   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1247   {
;;;1248     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1249       the HAL_RCC_CSSCallback could be implemented in the user file
;;;1250       */ 
;;;1251   }
;;;1252   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;694      */
;;;695    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;696    {
;;;697      uint32_t tickstart = 0;
;;;698      
;;;699      /* Check the parameters */
;;;700      assert_param(RCC_ClkInitStruct != NULL);
;;;701      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;702      assert_param(IS_FLASH_LATENCY(FLatency));
;;;703    
;;;704      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;705      must be correctly programmed according to the frequency of the CPU clock 
;;;706        (HCLK) of the device. */
;;;707    
;;;708    #if defined(FLASH_ACR_LATENCY)
;;;709      /* Increasing the number of wait states because of higher CPU frequency */
;;;710      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  f8df8168          LDR      r8,|L2.368|
000008  4604              MOV      r4,r0                 ;696
00000a  460e              MOV      r6,r1                 ;696
00000c  f8d80000          LDR      r0,[r8,#0]
000010  f0000007          AND      r0,r0,#7
000014  42b0              CMP      r0,r6
000016  d20c              BCS      |L2.50|
;;;711      {    
;;;712        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;713        __HAL_FLASH_SET_LATENCY(FLatency);
000018  f8d81000          LDR      r1,[r8,#0]
00001c  f0210107          BIC      r1,r1,#7
000020  4331              ORRS     r1,r1,r6
000022  f8c81000          STR      r1,[r8,#0]
;;;714        
;;;715        /* Check that the new number of wait states is taken into account to access the Flash
;;;716        memory by reading the FLASH_ACR register */
;;;717        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
000026  f8d80000          LDR      r0,[r8,#0]
00002a  f0000007          AND      r0,r0,#7
00002e  42b0              CMP      r0,r6
000030  d173              BNE      |L2.282|
                  |L2.50|
;;;718        {
;;;719          return HAL_ERROR;
;;;720        }
;;;721      }
;;;722    
;;;723    #endif /* FLASH_ACR_LATENCY */
;;;724      /*-------------------------- HCLK Configuration --------------------------*/
;;;725      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
000032  7820              LDRB     r0,[r4,#0]
;;;726      {
;;;727        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;728        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
000034  4f4f              LDR      r7,|L2.372|
000036  0780              LSLS     r0,r0,#30             ;725
000038  d505              BPL      |L2.70|
00003a  6878              LDR      r0,[r7,#4]
00003c  68a1              LDR      r1,[r4,#8]
00003e  f02000f0          BIC      r0,r0,#0xf0
000042  4308              ORRS     r0,r0,r1
000044  6078              STR      r0,[r7,#4]
                  |L2.70|
;;;729      }
;;;730    
;;;731      /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;732      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
000046  7820              LDRB     r0,[r4,#0]
000048  07c0              LSLS     r0,r0,#31
00004a  d055              BEQ      |L2.248|
;;;733      {    
;;;734        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;735        
;;;736        /* HSE is selected as System Clock Source */
;;;737        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
00004c  6860              LDR      r0,[r4,#4]
00004e  2201              MOVS     r2,#1                 ;719
000050  2801              CMP      r0,#1
000052  d00c              BEQ      |L2.110|
;;;738        {
;;;739          /* Check the HSE ready flag */  
;;;740          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;741          {
;;;742            return HAL_ERROR;
;;;743          }
;;;744        }
;;;745        /* PLL is selected as System Clock Source */
;;;746        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
000054  2802              CMP      r0,#2
000056  d028              BEQ      |L2.170|
;;;747        {
;;;748          /* Check the PLL ready flag */  
;;;749          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;750          {
;;;751            return HAL_ERROR;
;;;752          }
;;;753        }
;;;754        /* HSI is selected as System Clock Source */
;;;755        else
;;;756        {
;;;757          /* Check the HSI ready flag */  
;;;758          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
000058  2302              MOVS     r3,#2
                  |L2.90|
00005a  fa93f1a3          RBIT     r1,r3
00005e  fab1f181          CLZ      r1,r1
000062  f0410120          ORR      r1,r1,#0x20
000066  0949              LSRS     r1,r1,#5
000068  d004              BEQ      |L2.116|
00006a  6839              LDR      r1,[r7,#0]            ;740
00006c  e003              B        |L2.118|
                  |L2.110|
00006e  f44f3300          MOV      r3,#0x20000           ;740
000072  e7f2              B        |L2.90|
                  |L2.116|
000074  6a79              LDR      r1,[r7,#0x24]         ;740
                  |L2.118|
000076  fa93f3a3          RBIT     r3,r3
00007a  fab3f383          CLZ      r3,r3
00007e  f003031f          AND      r3,r3,#0x1f
000082  409a              LSLS     r2,r2,r3
000084  4211              TST      r1,r2
000086  d048              BEQ      |L2.282|
;;;759          {
;;;760            return HAL_ERROR;
;;;761          }
;;;762        }
;;;763        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
000088  6879              LDR      r1,[r7,#4]
00008a  f0210103          BIC      r1,r1,#3
00008e  4301              ORRS     r1,r1,r0
000090  6079              STR      r1,[r7,#4]
;;;764    
;;;765        /* Get Start Tick */
;;;766        tickstart = HAL_GetTick();
000092  f7fffffe          BL       HAL_GetTick
000096  4605              MOV      r5,r0
;;;767        
;;;768        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000098  6860              LDR      r0,[r4,#4]
;;;769        {
;;;770          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;771          {
;;;772            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00009a  f2413188          MOV      r1,#0x1388
00009e  2801              CMP      r0,#1                 ;768
0000a0  d00c              BEQ      |L2.188|
;;;773            {
;;;774              return HAL_TIMEOUT;
;;;775            }
;;;776          }
;;;777        }
;;;778        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
0000a2  2802              CMP      r0,#2
0000a4  4689              MOV      r9,r1                 ;772
0000a6  d015              BEQ      |L2.212|
0000a8  e022              B        |L2.240|
                  |L2.170|
0000aa  f04f7300          MOV      r3,#0x2000000         ;749
0000ae  e7d4              B        |L2.90|
                  |L2.176|
0000b0  f7fffffe          BL       HAL_GetTick
0000b4  1b41              SUBS     r1,r0,r5              ;772
0000b6  4549              CMP      r1,r9                 ;772
0000b8  d901              BLS      |L2.190|
0000ba  e016              B        |L2.234|
                  |L2.188|
0000bc  4689              MOV      r9,r1                 ;772
                  |L2.190|
0000be  6878              LDR      r0,[r7,#4]            ;770
0000c0  f3c00081          UBFX     r0,r0,#2,#2           ;770
0000c4  2801              CMP      r0,#1                 ;770
0000c6  d1f3              BNE      |L2.176|
0000c8  e016              B        |L2.248|
                  |L2.202|
;;;779        {
;;;780          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;781          {
;;;782            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
0000ca  f7fffffe          BL       HAL_GetTick
0000ce  1b41              SUBS     r1,r0,r5
0000d0  4549              CMP      r1,r9
0000d2  d80a              BHI      |L2.234|
                  |L2.212|
0000d4  6878              LDR      r0,[r7,#4]            ;780
0000d6  f3c00081          UBFX     r0,r0,#2,#2           ;780
0000da  2802              CMP      r0,#2                 ;780
0000dc  d1f5              BNE      |L2.202|
0000de  e00b              B        |L2.248|
                  |L2.224|
;;;783            {
;;;784              return HAL_TIMEOUT;
;;;785            }
;;;786          }
;;;787        }
;;;788        else
;;;789        {
;;;790          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
;;;791          {
;;;792            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
0000e0  f7fffffe          BL       HAL_GetTick
0000e4  1b41              SUBS     r1,r0,r5
0000e6  4549              CMP      r1,r9
0000e8  d902              BLS      |L2.240|
                  |L2.234|
;;;793            {
;;;794              return HAL_TIMEOUT;
0000ea  2003              MOVS     r0,#3
                  |L2.236|
;;;795            }
;;;796          }
;;;797        }      
;;;798      }    
;;;799    #if defined(FLASH_ACR_LATENCY)
;;;800      /* Decreasing the number of wait states because of lower CPU frequency */
;;;801      if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
;;;802      {    
;;;803        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;804        __HAL_FLASH_SET_LATENCY(FLatency);
;;;805        
;;;806        /* Check that the new number of wait states is taken into account to access the Flash
;;;807        memory by reading the FLASH_ACR register */
;;;808        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;809        {
;;;810          return HAL_ERROR;
;;;811        }
;;;812      }    
;;;813    #endif /* FLASH_ACR_LATENCY */
;;;814    
;;;815      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;816      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;817      {
;;;818        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;819        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;820      }
;;;821      
;;;822      /*-------------------------- PCLK2 Configuration ---------------------------*/ 
;;;823      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;824      {
;;;825        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;826        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;827      }
;;;828     
;;;829      /* Update the SystemCoreClock global variable */
;;;830      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
;;;831    
;;;832      /* Configure the source of time base considering new system clocks settings*/
;;;833      HAL_InitTick (TICK_INT_PRIORITY);
;;;834      
;;;835      return HAL_OK;
;;;836    }
0000ec  e8bd87f0          POP      {r4-r10,pc}
                  |L2.240|
0000f0  6878              LDR      r0,[r7,#4]            ;790
0000f2  f0100f0c          TST      r0,#0xc               ;790
0000f6  d1f3              BNE      |L2.224|
                  |L2.248|
0000f8  f8d81000          LDR      r1,[r8,#0]            ;801
0000fc  4640              MOV      r0,r8                 ;801
0000fe  f0010107          AND      r1,r1,#7              ;801
000102  42b1              CMP      r1,r6                 ;801
000104  d90b              BLS      |L2.286|
000106  6801              LDR      r1,[r0,#0]            ;804
000108  f0210107          BIC      r1,r1,#7              ;804
00010c  4331              ORRS     r1,r1,r6              ;804
00010e  6001              STR      r1,[r0,#0]            ;804
000110  6800              LDR      r0,[r0,#0]            ;808
000112  f0000007          AND      r0,r0,#7              ;808
000116  42b0              CMP      r0,r6                 ;808
000118  d001              BEQ      |L2.286|
                  |L2.282|
00011a  2001              MOVS     r0,#1                 ;810
00011c  e7e6              B        |L2.236|
                  |L2.286|
00011e  7820              LDRB     r0,[r4,#0]            ;816
000120  0740              LSLS     r0,r0,#29             ;816
000122  d505              BPL      |L2.304|
000124  6878              LDR      r0,[r7,#4]            ;819
000126  68e1              LDR      r1,[r4,#0xc]          ;819
000128  f42060e0          BIC      r0,r0,#0x700          ;819
00012c  4308              ORRS     r0,r0,r1              ;819
00012e  6078              STR      r0,[r7,#4]            ;819
                  |L2.304|
000130  7820              LDRB     r0,[r4,#0]            ;823
000132  0700              LSLS     r0,r0,#28             ;823
000134  d506              BPL      |L2.324|
000136  6878              LDR      r0,[r7,#4]            ;826
000138  6921              LDR      r1,[r4,#0x10]         ;826
00013a  f4205060          BIC      r0,r0,#0x3800         ;826
00013e  ea4000c1          ORR      r0,r0,r1,LSL #3       ;826
000142  6078              STR      r0,[r7,#4]            ;826
                  |L2.324|
000144  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000148  6879              LDR      r1,[r7,#4]            ;830
00014a  22f0              MOVS     r2,#0xf0              ;830
00014c  fa92f2a2          RBIT     r2,r2                 ;830
000150  f00101f0          AND      r1,r1,#0xf0           ;830
000154  fab2f282          CLZ      r2,r2                 ;830
000158  40d1              LSRS     r1,r1,r2              ;830
00015a  4a07              LDR      r2,|L2.376|
00015c  5c51              LDRB     r1,[r2,r1]            ;830
00015e  40c8              LSRS     r0,r0,r1              ;830
000160  4906              LDR      r1,|L2.380|
000162  6008              STR      r0,[r1,#0]            ;833  ; SystemCoreClock
000164  200f              MOVS     r0,#0xf               ;833
000166  f7fffffe          BL       HAL_InitTick
00016a  2000              MOVS     r0,#0                 ;835
00016c  e7be              B        |L2.236|
;;;837    
                          ENDP

00016e  0000              DCW      0x0000
                  |L2.368|
                          DCD      0x40022000
                  |L2.372|
                          DCD      0x40021000
                  |L2.376|
                          DCD      AHBPrescTable
                  |L2.380|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;220      */
;;;221    void HAL_RCC_DeInit(void)
000000  4810              LDR      r0,|L3.68|
;;;222    {
000002  b510              PUSH     {r4,lr}
;;;223      /* Switch SYSCLK to HSI */
;;;224      CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
000004  6841              LDR      r1,[r0,#4]
000006  f0210103          BIC      r1,r1,#3
00000a  6041              STR      r1,[r0,#4]
;;;225    
;;;226      /* Reset HSEON, CSSON, & PLLON bits */
;;;227      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
00000c  6801              LDR      r1,[r0,#0]
00000e  4a0e              LDR      r2,|L3.72|
000010  4011              ANDS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;228      
;;;229      /* Reset HSEBYP bit */
;;;230      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
000014  6801              LDR      r1,[r0,#0]
000016  f4212180          BIC      r1,r1,#0x40000
00001a  6001              STR      r1,[r0,#0]
;;;231      
;;;232      /* Reset CFGR register */
;;;233      CLEAR_REG(RCC->CFGR);
00001c  2100              MOVS     r1,#0
00001e  6041              STR      r1,[r0,#4]
;;;234      
;;;235      /* Set HSITRIM bits to the reset value */
;;;236      MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, ((uint32_t)0x10 << POSITION_VAL(RCC_CR_HSITRIM)));
000020  6802              LDR      r2,[r0,#0]
000022  24f8              MOVS     r4,#0xf8
000024  fa94f4a4          RBIT     r4,r4
000028  2310              MOVS     r3,#0x10
00002a  fab4f484          CLZ      r4,r4
00002e  f02202f8          BIC      r2,r2,#0xf8
000032  40a3              LSLS     r3,r3,r4
000034  431a              ORRS     r2,r2,r3
000036  6002              STR      r2,[r0,#0]
;;;237      
;;;238    #if (defined(STM32F105xC) || defined(STM32F107xC) || defined (STM32F100xB) || defined (STM32F100xE))
;;;239      /* Reset CFGR2 register */
;;;240      CLEAR_REG(RCC->CFGR2);
;;;241    
;;;242    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;243      /* Disable all interrupts */
;;;244      CLEAR_REG(RCC->CIR);
000038  6081              STR      r1,[r0,#8]
;;;245    
;;;246      /* Update the SystemCoreClock global variable */
;;;247      SystemCoreClock = HSI_VALUE;
00003a  4905              LDR      r1,|L3.80|
00003c  4803              LDR      r0,|L3.76|
00003e  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;248    }
000040  bd10              POP      {r4,pc}
;;;249    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      0x40021000
                  |L3.72|
                          DCD      0xfef6ffff
                  |L3.76|
                          DCD      0x007a1200
                  |L3.80|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;929      */
;;;930    void HAL_RCC_DisableCSS(void)
000000  f44f2100          MOV      r1,#0x80000
;;;931    {
;;;932      *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
000004  fa91f1a1          RBIT     r1,r1
000008  4a03              LDR      r2,|L4.24|
00000a  fab1f181          CLZ      r1,r1
00000e  2000              MOVS     r0,#0
000010  f8420021          STR      r0,[r2,r1,LSL #2]
;;;933    }
000014  4770              BX       lr
;;;934    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;920      */
;;;921    void HAL_RCC_EnableCSS(void)
000000  2001              MOVS     r0,#1
;;;922    {
;;;923      *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
000002  04c1              LSLS     r1,r0,#19
000004  fa91f1a1          RBIT     r1,r1
000008  4a02              LDR      r2,|L5.20|
00000a  fab1f181          CLZ      r1,r1
00000e  f8420021          STR      r0,[r2,r1,LSL #2]
;;;924    }
000012  4770              BX       lr
;;;925    
                          ENDP

                  |L5.20|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1193     */
;;;1194   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1195   {
;;;1196     /* Check the parameters */
;;;1197     assert_param(RCC_ClkInitStruct != NULL);
;;;1198     assert_param(pFLatency != NULL);
;;;1199   
;;;1200     /* Set all possible values for the Clock type parameter --------------------*/
;;;1201     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;1202     
;;;1203     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1204     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
000002  6002              STR      r2,[r0,#0]
000004  4a0c              LDR      r2,|L6.56|
000006  6853              LDR      r3,[r2,#4]
000008  f0030303          AND      r3,r3,#3
;;;1205     
;;;1206     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1207     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
00000c  6043              STR      r3,[r0,#4]
00000e  6853              LDR      r3,[r2,#4]
000010  f00303f0          AND      r3,r3,#0xf0
;;;1208     
;;;1209     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1210     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
000014  6083              STR      r3,[r0,#8]
000016  6853              LDR      r3,[r2,#4]
000018  f40363e0          AND      r3,r3,#0x700
;;;1211     
;;;1212     /* Get the APB2 configuration ----------------------------------------------*/ 
;;;1213     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
00001c  60c3              STR      r3,[r0,#0xc]
00001e  6852              LDR      r2,[r2,#4]
;;;1214     
;;;1215   #if   defined(FLASH_ACR_LATENCY)
;;;1216     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1217     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
;;;1218   #else
;;;1219     /* For VALUE lines devices, only LATENCY_0 can be set*/
;;;1220     *pFLatency = (uint32_t)FLASH_LATENCY_0; 
;;;1221   #endif
;;;1222   }
000020  f44f63e0          MOV      r3,#0x700
000024  ea0302d2          AND      r2,r3,r2,LSR #3
000028  6102              STR      r2,[r0,#0x10]         ;1217
00002a  4804              LDR      r0,|L6.60|
00002c  6800              LDR      r0,[r0,#0]            ;1217
00002e  f0000007          AND      r0,r0,#7              ;1217
000032  6008              STR      r0,[r1,#0]            ;1217
000034  4770              BX       lr
;;;1223   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40021000
                  |L6.60|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1057     */
;;;1058   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;1059   {
;;;1060     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1061   }
000004  4770              BX       lr
;;;1062   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1093     */
;;;1094   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;1095   {
;;;1096     /* Check the parameters */
;;;1097     assert_param(RCC_OscInitStruct != NULL);
;;;1098   
;;;1099     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1100     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
;;;1101                     | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1102   
;;;1103   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1104     /* Get the Prediv1 source --------------------------------------------------*/
;;;1105     RCC_OscInitStruct->Prediv1Source = READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC);
;;;1106   #endif /* RCC_CFGR2_PREDIV1SRC */
;;;1107   
;;;1108     /* Get the HSE configuration -----------------------------------------------*/
;;;1109     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000002  4b25              LDR      r3,|L8.152|
000004  210f              MOVS     r1,#0xf               ;1100
000006  6001              STR      r1,[r0,#0]
000008  6819              LDR      r1,[r3,#0]
00000a  034a              LSLS     r2,r1,#13
00000c  f04f0100          MOV      r1,#0
000010  d502              BPL      |L8.24|
;;;1110     {
;;;1111       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000012  f44f22a0          MOV      r2,#0x50000
000016  e004              B        |L8.34|
                  |L8.24|
;;;1112     }
;;;1113     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
000018  681a              LDR      r2,[r3,#0]
00001a  03d2              LSLS     r2,r2,#15
00001c  d503              BPL      |L8.38|
;;;1114     {
;;;1115       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
00001e  f44f3280          MOV      r2,#0x10000
                  |L8.34|
000022  6042              STR      r2,[r0,#4]
000024  e000              B        |L8.40|
                  |L8.38|
;;;1116     }
;;;1117     else
;;;1118     {
;;;1119       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000026  6041              STR      r1,[r0,#4]
                  |L8.40|
;;;1120     }
;;;1121     RCC_OscInitStruct->HSEPredivValue = __HAL_RCC_HSE_GET_PREDIV();
000028  685a              LDR      r2,[r3,#4]
00002a  f4023200          AND      r2,r2,#0x20000
;;;1122   
;;;1123     /* Get the HSI configuration -----------------------------------------------*/
;;;1124     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
00002e  6082              STR      r2,[r0,#8]
000030  681a              LDR      r2,[r3,#0]
000032  07d4              LSLS     r4,r2,#31
;;;1125     {
;;;1126       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000034  f04f0201          MOV      r2,#1
000038  d001              BEQ      |L8.62|
00003a  6102              STR      r2,[r0,#0x10]
00003c  e000              B        |L8.64|
                  |L8.62|
;;;1127     }
;;;1128     else
;;;1129     {
;;;1130       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
00003e  6101              STR      r1,[r0,#0x10]
                  |L8.64|
;;;1131     }
;;;1132     
;;;1133     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
000040  681c              LDR      r4,[r3,#0]
000042  25f8              MOVS     r5,#0xf8
000044  fa95f5a5          RBIT     r5,r5
000048  f00404f8          AND      r4,r4,#0xf8
00004c  fab5f585          CLZ      r5,r5
000050  40ec              LSRS     r4,r4,r5
;;;1134     
;;;1135     /* Get the LSE configuration -----------------------------------------------*/
;;;1136     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000052  6144              STR      r4,[r0,#0x14]
000054  6a1c              LDR      r4,[r3,#0x20]
000056  0764              LSLS     r4,r4,#29
000058  d502              BPL      |L8.96|
;;;1137     {
;;;1138       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
00005a  2405              MOVS     r4,#5
00005c  60c4              STR      r4,[r0,#0xc]
00005e  e005              B        |L8.108|
                  |L8.96|
;;;1139     }
;;;1140     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
000060  6a1c              LDR      r4,[r3,#0x20]
000062  07e4              LSLS     r4,r4,#31
000064  d001              BEQ      |L8.106|
;;;1141     {
;;;1142       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
000066  60c2              STR      r2,[r0,#0xc]
000068  e000              B        |L8.108|
                  |L8.106|
;;;1143     }
;;;1144     else
;;;1145     {
;;;1146       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
00006a  60c1              STR      r1,[r0,#0xc]
                  |L8.108|
;;;1147     }
;;;1148     
;;;1149     /* Get the LSI configuration -----------------------------------------------*/
;;;1150     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
00006c  6a5c              LDR      r4,[r3,#0x24]
00006e  07e4              LSLS     r4,r4,#31
000070  d001              BEQ      |L8.118|
;;;1151     {
;;;1152       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000072  6182              STR      r2,[r0,#0x18]
000074  e000              B        |L8.120|
                  |L8.118|
;;;1153     }
;;;1154     else
;;;1155     {
;;;1156       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000076  6181              STR      r1,[r0,#0x18]
                  |L8.120|
;;;1157     }
;;;1158     
;;;1159   
;;;1160     /* Get the PLL configuration -----------------------------------------------*/
;;;1161     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
000078  6819              LDR      r1,[r3,#0]
00007a  01c9              LSLS     r1,r1,#7
00007c  d502              BPL      |L8.132|
;;;1162     {
;;;1163       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
00007e  2102              MOVS     r1,#2
000080  61c1              STR      r1,[r0,#0x1c]
000082  e000              B        |L8.134|
                  |L8.132|
;;;1164     }
;;;1165     else
;;;1166     {
;;;1167       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
000084  61c2              STR      r2,[r0,#0x1c]
                  |L8.134|
;;;1168     }
;;;1169     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
000086  6859              LDR      r1,[r3,#4]
000088  f4013180          AND      r1,r1,#0x10000
;;;1170     RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMULL);
00008c  6201              STR      r1,[r0,#0x20]
00008e  6859              LDR      r1,[r3,#4]
000090  f4011170          AND      r1,r1,#0x3c0000
000094  6241              STR      r1,[r0,#0x24]
;;;1171   #if defined(RCC_CR_PLL2ON)
;;;1172     /* Get the PLL2 configuration -----------------------------------------------*/
;;;1173     if((RCC->CR &RCC_CR_PLL2ON) == RCC_CR_PLL2ON)
;;;1174     {
;;;1175       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_ON;
;;;1176     }
;;;1177     else
;;;1178     {
;;;1179       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_OFF;
;;;1180     }
;;;1181     RCC_OscInitStruct->PLL2.HSEPrediv2Value = __HAL_RCC_HSE_GET_PREDIV2();
;;;1182     RCC_OscInitStruct->PLL2.PLL2MUL = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PLL2MUL);
;;;1183   #endif /* RCC_CR_PLL2ON */
;;;1184   }
000096  bd30              POP      {r4,r5,pc}
;;;1185   
                          ENDP

                  |L8.152|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1068     */
;;;1069   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4808              LDR      r0,|L9.36|
;;;1070   {
;;;1071     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1072     return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
000002  4909              LDR      r1,|L9.40|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  f44f62e0          MOV      r2,#0x700
00000c  fa92f2a2          RBIT     r2,r2
000010  f40161e0          AND      r1,r1,#0x700
000014  fab2f282          CLZ      r2,r2
000018  40d1              LSRS     r1,r1,r2
00001a  4a04              LDR      r2,|L9.44|
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
;;;1073   }    
000020  4770              BX       lr
;;;1074   
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      SystemCoreClock
                  |L9.40|
                          DCD      0x40021000
                  |L9.44|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1080     */
;;;1081   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4808              LDR      r0,|L10.36|
;;;1082   {
;;;1083     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1084     return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
000002  4909              LDR      r1,|L10.40|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  f44f5260          MOV      r2,#0x3800
00000c  fa92f2a2          RBIT     r2,r2
000010  f4015160          AND      r1,r1,#0x3800
000014  fab2f282          CLZ      r2,r2
000018  40d1              LSRS     r1,r1,r2
00001a  4a04              LDR      r2,|L10.44|
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
;;;1085   } 
000020  4770              BX       lr
;;;1086   
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      SystemCoreClock
                  |L10.40|
                          DCD      0x40021000
                  |L10.44|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;963      */
;;;964    uint32_t HAL_RCC_GetSysClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;965    {
;;;966    #if   defined(RCC_CFGR2_PREDIV1SRC)
;;;967      const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
;;;968      const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;969    #else
;;;970      const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
000002  a019              ADR      r0,|L11.104|
000004  b085              SUB      sp,sp,#0x14           ;965
000006  c80f              LDM      r0,{r0-r3}
000008  e88d000f          STM      sp,{r0-r3}
;;;971    #if defined(RCC_CFGR2_PREDIV1)
;;;972      const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;973    #else
;;;974      const uint8_t aPredivFactorTable[2] = { 1, 2};
00000c  a01a              ADR      r0,|L11.120|
;;;975    #endif /*RCC_CFGR2_PREDIV1*/
;;;976    
;;;977    #endif
;;;978      uint32_t tmpreg = 0, prediv = 0, pllclk = 0, pllmul = 0;
;;;979      uint32_t sysclockfreq = 0;
;;;980    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;981      uint32_t prediv2 = 0, pll2mul = 0;
;;;982    #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;983      
;;;984      tmpreg = RCC->CFGR;
00000e  4b1b              LDR      r3,|L11.124|
000010  6800              LDR      r0,[r0,#0]            ;974
000012  9004              STR      r0,[sp,#0x10]
000014  6859              LDR      r1,[r3,#4]
;;;985      
;;;986      /* Get SYSCLK source -------------------------------------------------------*/
;;;987      switch (tmpreg & RCC_CFGR_SWS)
;;;988      {
;;;989        case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
;;;990        {
;;;991          sysclockfreq = HSE_VALUE;
000016  481a              LDR      r0,|L11.128|
000018  f001020c          AND      r2,r1,#0xc            ;987
00001c  2a04              CMP      r2,#4                 ;987
00001e  d01d              BEQ      |L11.92|
000020  2a08              CMP      r2,#8                 ;987
000022  d11b              BNE      |L11.92|
;;;992          break;
;;;993        }
;;;994        case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
;;;995        {
;;;996          pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
000024  f44f1470          MOV      r4,#0x3c0000
000028  fa94f4a4          RBIT     r4,r4
00002c  f4011270          AND      r2,r1,#0x3c0000
000030  fab4f484          CLZ      r4,r4
000034  40e2              LSRS     r2,r2,r4
;;;997          if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
000036  03c9              LSLS     r1,r1,#15
000038  f81d2002          LDRB     r2,[sp,r2]            ;996
00003c  d510              BPL      |L11.96|
;;;998          {
;;;999    #if defined(RCC_CFGR2_PREDIV1)
;;;1000           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
;;;1001   #else
;;;1002           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
00003e  6859              LDR      r1,[r3,#4]
000040  f44f3300          MOV      r3,#0x20000
000044  fa93f3a3          RBIT     r3,r3
000048  f4013100          AND      r1,r1,#0x20000
00004c  fab3f383          CLZ      r3,r3
000050  40d9              LSRS     r1,r1,r3
000052  ab04              ADD      r3,sp,#0x10
000054  5c59              LDRB     r1,[r3,r1]
;;;1003   #endif /*RCC_CFGR2_PREDIV1*/
;;;1004   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1005   
;;;1006           if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;1007           {
;;;1008             /* PLL2 selected as Prediv1 source */
;;;1009             /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;1010             prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;1011             pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> POSITION_VAL(RCC_CFGR2_PLL2MUL)) + 2;
;;;1012             pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv) * pllmul);
;;;1013           }
;;;1014           else
;;;1015           {
;;;1016             /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1017             pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
;;;1018           }
;;;1019           
;;;1020           /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;1021           /* In this case need to divide pllclk by 2 */
;;;1022           if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> POSITION_VAL(RCC_CFGR_PLLMULL)])
;;;1023           {
;;;1024               pllclk = pllclk / 2;
;;;1025           }
;;;1026   #else
;;;1027           /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1028           pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
000056  fbb0f0f1          UDIV     r0,r0,r1
00005a  4350              MULS     r0,r2,r0
                  |L11.92|
;;;1029   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1030         }
;;;1031         else
;;;1032         {
;;;1033           /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;1034           pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
;;;1035         }
;;;1036         sysclockfreq = pllclk;
;;;1037         break;
;;;1038       }
;;;1039       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1040       default: /* HSI used as system clock */
;;;1041       {
;;;1042         sysclockfreq = HSI_VALUE;
;;;1043         break;
;;;1044       }
;;;1045     }
;;;1046     return sysclockfreq;
;;;1047   }
00005c  b005              ADD      sp,sp,#0x14
00005e  bd10              POP      {r4,pc}
                  |L11.96|
000060  4808              LDR      r0,|L11.132|
000062  4350              MULS     r0,r2,r0              ;1034
000064  e7fa              B        |L11.92|
;;;1048   
                          ENDP

000066  0000              DCW      0x0000
                  |L11.104|
000068  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
00006c  06070809
000070  0a0b0c0d
000074  0e0f1010
                  |L11.120|
000078  010200            DCB      1,2,0
00007b  00                DCB      0
                  |L11.124|
                          DCD      0x40021000
                  |L11.128|
                          DCD      0x007a1200
                  |L11.132|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;887      */
;;;888    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b530              PUSH     {r4,r5,lr}
;;;889    {
000002  b085              SUB      sp,sp,#0x14
;;;890      GPIO_InitTypeDef gpio = {0};
000004  2000              MOVS     r0,#0
;;;891    
;;;892      /* Check the parameters */
;;;893      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;894      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;895      assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;896      
;;;897      /* Configure the MCO1 pin in alternate function mode */
;;;898      gpio.Mode      = GPIO_MODE_AF_PP;
000006  9002              STR      r0,[sp,#8]
000008  2002              MOVS     r0,#2
;;;899      gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
00000a  9001              STR      r0,[sp,#4]
00000c  2003              MOVS     r0,#3
;;;900      gpio.Pull      = GPIO_NOPULL;
;;;901      gpio.Pin       = MCO1_PIN;
00000e  9003              STR      r0,[sp,#0xc]
;;;902    
;;;903      /* MCO1 Clock Enable */
;;;904      MCO1_CLK_ENABLE();
000010  4c0b              LDR      r4,|L12.64|
000012  f44f7080          MOV      r0,#0x100             ;901
000016  9000              STR      r0,[sp,#0]
000018  69a0              LDR      r0,[r4,#0x18]
00001a  460d              MOV      r5,r1                 ;889
00001c  f0400004          ORR      r0,r0,#4
000020  61a0              STR      r0,[r4,#0x18]
000022  69a0              LDR      r0,[r4,#0x18]
;;;905      
;;;906      HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
000024  4669              MOV      r1,sp
000026  f0000004          AND      r0,r0,#4              ;904
00002a  9004              STR      r0,[sp,#0x10]
00002c  4805              LDR      r0,|L12.68|
00002e  f7fffffe          BL       HAL_GPIO_Init
;;;907      
;;;908      /* Configure the MCO clock source */
;;;909      __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
000032  6860              LDR      r0,[r4,#4]
000034  f02060e0          BIC      r0,r0,#0x7000000
000038  4328              ORRS     r0,r0,r5
00003a  6060              STR      r0,[r4,#4]
;;;910    }
00003c  b005              ADD      sp,sp,#0x14
00003e  bd30              POP      {r4,r5,pc}
;;;911    
                          ENDP

                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0x40010800

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1228     */
;;;1229   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1230   {
;;;1231     /* Check RCC CSSF flag  */
;;;1232     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c04              LDR      r4,|L13.20|
000004  68a0              LDR      r0,[r4,#8]
000006  0600              LSLS     r0,r0,#24
000008  d503              BPL      |L13.18|
;;;1233     {
;;;1234       /* RCC Clock Security System interrupt user callback */
;;;1235       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1236       
;;;1237       /* Clear RCC CSS pending bit */
;;;1238       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  2080              MOVS     r0,#0x80
000010  72a0              STRB     r0,[r4,#0xa]
                  |L13.18|
;;;1239     }
;;;1240   }
000012  bd10              POP      {r4,pc}
;;;1241   
                          ENDP

                  |L13.20|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;264      */
;;;265    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;266    {
000004  4604              MOV      r4,r0
;;;267       uint32_t tickstart = 0;
;;;268      
;;;269      /* Check the parameters */
;;;270      assert_param(RCC_OscInitStruct != NULL);
;;;271      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;272      
;;;273      /*------------------------------- HSE Configuration ------------------------*/ 
;;;274      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
000006  7800              LDRB     r0,[r0,#0]
;;;275      {
;;;276        /* Check the parameters */
;;;277        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;278            
;;;279        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;280        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
000008  4efe              LDR      r6,|L14.1028|
00000a  07c0              LSLS     r0,r0,#31             ;274
;;;281           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
;;;282        {
;;;283          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
00000c  f04f0501          MOV      r5,#1
000010  d07f              BEQ      |L14.274|
000012  6870              LDR      r0,[r6,#4]            ;280
000014  f44f3800          MOV      r8,#0x20000
000018  f3c00081          UBFX     r0,r0,#2,#2           ;280
00001c  2801              CMP      r0,#1                 ;280
00001e  d007              BEQ      |L14.48|
000020  6870              LDR      r0,[r6,#4]            ;281
000022  f3c00081          UBFX     r0,r0,#2,#2           ;281
000026  2802              CMP      r0,#2                 ;281
000028  d11b              BNE      |L14.98|
00002a  6870              LDR      r0,[r6,#4]            ;281
00002c  03c0              LSLS     r0,r0,#15             ;281
00002e  d518              BPL      |L14.98|
                  |L14.48|
000030  fa98f0a8          RBIT     r0,r8
000034  fab0f080          CLZ      r0,r0
000038  f0400020          ORR      r0,r0,#0x20
00003c  0940              LSRS     r0,r0,#5
00003e  d001              BEQ      |L14.68|
000040  6830              LDR      r0,[r6,#0]
000042  e000              B        |L14.70|
                  |L14.68|
000044  6a70              LDR      r0,[r6,#0x24]
                  |L14.70|
000046  fa98f1a8          RBIT     r1,r8
00004a  fab1f181          CLZ      r1,r1
00004e  f001011f          AND      r1,r1,#0x1f
000052  fa05f101          LSL      r1,r5,r1
000056  4208              TST      r0,r1
000058  d05b              BEQ      |L14.274|
00005a  6860              LDR      r0,[r4,#4]
00005c  2800              CMP      r0,#0
00005e  d079              BEQ      |L14.340|
000060  e057              B        |L14.274|
                  |L14.98|
;;;284          {
;;;285            return HAL_ERROR;
;;;286          }
;;;287        }
;;;288        else
;;;289        {
;;;290          /* Set the new HSE configuration ---------------------------------------*/
;;;291          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
000062  6860              LDR      r0,[r4,#4]
000064  f5b03f80          CMP      r0,#0x10000
000068  d00b              BEQ      |L14.130|
00006a  b110              CBZ      r0,|L14.114|
00006c  f5b02fa0          CMP      r0,#0x50000
000070  d011              BEQ      |L14.150|
                  |L14.114|
000072  6830              LDR      r0,[r6,#0]
000074  f4203080          BIC      r0,r0,#0x10000
000078  6030              STR      r0,[r6,#0]
00007a  6830              LDR      r0,[r6,#0]
00007c  f4202080          BIC      r0,r0,#0x40000
000080  e002              B        |L14.136|
                  |L14.130|
000082  6830              LDR      r0,[r6,#0]
000084  f4403080          ORR      r0,r0,#0x10000
                  |L14.136|
000088  6030              STR      r0,[r6,#0]
;;;292          
;;;293    
;;;294           /* Check the HSE State */
;;;295          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
00008a  6860              LDR      r0,[r4,#4]
00008c  b318              CBZ      r0,|L14.214|
;;;296          {
;;;297            /* Get Start Tick */
;;;298            tickstart = HAL_GetTick();
00008e  f7fffffe          BL       HAL_GetTick
000092  4607              MOV      r7,r0
;;;299            
;;;300            /* Wait till HSE is ready */
;;;301            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000094  e009              B        |L14.170|
                  |L14.150|
000096  6830              LDR      r0,[r6,#0]            ;291
000098  f4402080          ORR      r0,r0,#0x40000        ;291
00009c  6030              STR      r0,[r6,#0]            ;291
00009e  e7f0              B        |L14.130|
                  |L14.160|
;;;302            {
;;;303              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  1bc0              SUBS     r0,r0,r7
0000a6  2864              CMP      r0,#0x64
                  |L14.168|
0000a8  d870              BHI      |L14.396|
                  |L14.170|
0000aa  fa98f0a8          RBIT     r0,r8                 ;301
0000ae  fab0f080          CLZ      r0,r0                 ;301
0000b2  f0400020          ORR      r0,r0,#0x20           ;301
0000b6  0940              LSRS     r0,r0,#5              ;301
0000b8  d001              BEQ      |L14.190|
0000ba  6830              LDR      r0,[r6,#0]            ;301
0000bc  e000              B        |L14.192|
                  |L14.190|
0000be  6a70              LDR      r0,[r6,#0x24]         ;301
                  |L14.192|
0000c0  fa98f1a8          RBIT     r1,r8                 ;301
0000c4  fab1f181          CLZ      r1,r1                 ;301
0000c8  f001011f          AND      r1,r1,#0x1f           ;301
0000cc  fa05f101          LSL      r1,r5,r1              ;301
0000d0  4208              TST      r0,r1                 ;301
0000d2  d0e5              BEQ      |L14.160|
0000d4  e01d              B        |L14.274|
                  |L14.214|
;;;304              {
;;;305                return HAL_TIMEOUT;
;;;306              }
;;;307            }
;;;308          }
;;;309          else
;;;310          {
;;;311            /* Get Start Tick */
;;;312            tickstart = HAL_GetTick();
0000d6  f7fffffe          BL       HAL_GetTick
0000da  4607              MOV      r7,r0
;;;313            
;;;314            /* Wait till HSE is disabled */
;;;315            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
0000dc  e004              B        |L14.232|
                  |L14.222|
;;;316            {
;;;317               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000de  f7fffffe          BL       HAL_GetTick
0000e2  1bc0              SUBS     r0,r0,r7
0000e4  2864              CMP      r0,#0x64
0000e6  d8df              BHI      |L14.168|
                  |L14.232|
0000e8  fa98f0a8          RBIT     r0,r8                 ;315
0000ec  fab0f080          CLZ      r0,r0                 ;315
0000f0  f0400020          ORR      r0,r0,#0x20           ;315
0000f4  0940              LSRS     r0,r0,#5              ;315
0000f6  d001              BEQ      |L14.252|
0000f8  6830              LDR      r0,[r6,#0]            ;315
0000fa  e000              B        |L14.254|
                  |L14.252|
0000fc  6a70              LDR      r0,[r6,#0x24]         ;315
                  |L14.254|
0000fe  fa98f1a8          RBIT     r1,r8                 ;315
000102  fab1f181          CLZ      r1,r1                 ;315
000106  f001011f          AND      r1,r1,#0x1f           ;315
00010a  fa05f101          LSL      r1,r5,r1              ;315
00010e  4208              TST      r0,r1                 ;315
000110  d1e5              BNE      |L14.222|
                  |L14.274|
;;;318              {
;;;319                return HAL_TIMEOUT;
;;;320              }
;;;321            }
;;;322          }
;;;323        }
;;;324      }
;;;325      /*----------------------------- HSI Configuration --------------------------*/ 
;;;326      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
000112  7820              LDRB     r0,[r4,#0]
;;;327      {
;;;328        /* Check the parameters */
;;;329        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;330        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;331        
;;;332        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
;;;333        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
;;;334           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
;;;335        {
;;;336          /* When HSI is used as system clock it will not disabled */
;;;337          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;338          {
;;;339            return HAL_ERROR;
;;;340          }
;;;341          /* Otherwise, just the calibration is allowed */
;;;342          else
;;;343          {
;;;344            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;345            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;346          }
;;;347        }
;;;348        else
;;;349        {
;;;350          /* Check the HSI State */
;;;351          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
;;;352          {
;;;353           /* Enable the Internal High Speed oscillator (HSI). */
;;;354            __HAL_RCC_HSI_ENABLE();
000114  f8df82f0          LDR      r8,|L14.1032|
000118  0780              LSLS     r0,r0,#30             ;326
00011a  f04f0a00          MOV      r10,#0                ;326
00011e  f04f0702          MOV      r7,#2                 ;337
000122  d55a              BPL      |L14.474|
000124  6870              LDR      r0,[r6,#4]            ;333
000126  f04f0bf8          MOV      r11,#0xf8             ;345
00012a  f0100f0c          TST      r0,#0xc               ;333
00012e  d007              BEQ      |L14.320|
000130  6870              LDR      r0,[r6,#4]            ;334
000132  f3c00081          UBFX     r0,r0,#2,#2           ;334
000136  2802              CMP      r0,#2                 ;334
000138  d11c              BNE      |L14.372|
00013a  6870              LDR      r0,[r6,#4]            ;334
00013c  03c0              LSLS     r0,r0,#15             ;334
00013e  d419              BMI      |L14.372|
                  |L14.320|
000140  fa97f0a7          RBIT     r0,r7                 ;337
000144  fab0f080          CLZ      r0,r0                 ;337
000148  f0400020          ORR      r0,r0,#0x20           ;337
00014c  0940              LSRS     r0,r0,#5              ;337
00014e  d002              BEQ      |L14.342|
000150  6830              LDR      r0,[r6,#0]            ;337
000152  e001              B        |L14.344|
                  |L14.340|
000154  e08a              B        |L14.620|
                  |L14.342|
000156  6a70              LDR      r0,[r6,#0x24]         ;337
                  |L14.344|
000158  fa97f1a7          RBIT     r1,r7                 ;337
00015c  fab1f181          CLZ      r1,r1                 ;337
000160  f001011f          AND      r1,r1,#0x1f           ;337
000164  fa05f101          LSL      r1,r5,r1              ;337
000168  4208              TST      r0,r1                 ;337
00016a  d02b              BEQ      |L14.452|
00016c  6920              LDR      r0,[r4,#0x10]         ;337
00016e  2801              CMP      r0,#1                 ;337
000170  d17c              BNE      |L14.620|
000172  e027              B        |L14.452|
                  |L14.372|
000174  6920              LDR      r0,[r4,#0x10]         ;351
000176  b388              CBZ      r0,|L14.476|
000178  fa95f0a5          RBIT     r0,r5
00017c  fab0f080          CLZ      r0,r0
000180  f8485020          STR      r5,[r8,r0,LSL #2]
;;;355            
;;;356            /* Get Start Tick */
;;;357            tickstart = HAL_GetTick();
000184  f7fffffe          BL       HAL_GetTick
000188  4681              MOV      r9,r0
;;;358            
;;;359            /* Wait till HSI is ready */
;;;360            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
00018a  e006              B        |L14.410|
                  |L14.396|
00018c  e14d              B        |L14.1066|
                  |L14.398|
;;;361            {
;;;362              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
00018e  f7fffffe          BL       HAL_GetTick
000192  eba00009          SUB      r0,r0,r9
000196  2802              CMP      r0,#2
                  |L14.408|
000198  d886              BHI      |L14.168|
                  |L14.410|
00019a  fa97f0a7          RBIT     r0,r7                 ;360
00019e  fab0f080          CLZ      r0,r0                 ;360
0001a2  f0400020          ORR      r0,r0,#0x20           ;360
0001a6  0940              LSRS     r0,r0,#5              ;360
0001a8  d001              BEQ      |L14.430|
0001aa  6830              LDR      r0,[r6,#0]            ;360
0001ac  e000              B        |L14.432|
                  |L14.430|
0001ae  6a70              LDR      r0,[r6,#0x24]         ;360
                  |L14.432|
0001b0  fa97f1a7          RBIT     r1,r7                 ;360
0001b4  fab1f181          CLZ      r1,r1                 ;360
0001b8  f001011f          AND      r1,r1,#0x1f           ;360
0001bc  fa05f101          LSL      r1,r5,r1              ;360
0001c0  4208              TST      r0,r1                 ;360
0001c2  d0e4              BEQ      |L14.398|
                  |L14.452|
;;;363              {
;;;364                return HAL_TIMEOUT;
;;;365              }
;;;366            }
;;;367                    
;;;368            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;369            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
0001c4  6830              LDR      r0,[r6,#0]
0001c6  fa9bf2ab          RBIT     r2,r11
0001ca  f02001f8          BIC      r1,r0,#0xf8
0001ce  6960              LDR      r0,[r4,#0x14]
0001d0  fab2f282          CLZ      r2,r2
0001d4  4090              LSLS     r0,r0,r2
0001d6  4301              ORRS     r1,r1,r0
0001d8  6031              STR      r1,[r6,#0]
                  |L14.474|
0001da  e025              B        |L14.552|
                  |L14.476|
0001dc  e7ff              B        |L14.478|
                  |L14.478|
;;;370          }
;;;371          else
;;;372          {
;;;373            /* Disable the Internal High Speed oscillator (HSI). */
;;;374            __HAL_RCC_HSI_DISABLE();
0001de  fa95f1a5          RBIT     r1,r5
0001e2  fab1f181          CLZ      r1,r1
0001e6  f848a021          STR      r10,[r8,r1,LSL #2]
;;;375            
;;;376            /* Get Start Tick */
;;;377            tickstart = HAL_GetTick();
0001ea  f7fffffe          BL       HAL_GetTick
0001ee  4681              MOV      r9,r0
;;;378            
;;;379            /* Wait till HSI is disabled */
;;;380            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
0001f0  e005              B        |L14.510|
                  |L14.498|
;;;381            {
;;;382              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
0001f2  f7fffffe          BL       HAL_GetTick
0001f6  eba00009          SUB      r0,r0,r9
0001fa  2802              CMP      r0,#2
                  |L14.508|
0001fc  d8cc              BHI      |L14.408|
                  |L14.510|
0001fe  fa97f0a7          RBIT     r0,r7                 ;380
000202  fab0f080          CLZ      r0,r0                 ;380
000206  f0400020          ORR      r0,r0,#0x20           ;380
00020a  0940              LSRS     r0,r0,#5              ;380
00020c  d001              BEQ      |L14.530|
00020e  6830              LDR      r0,[r6,#0]            ;380
000210  e000              B        |L14.532|
                  |L14.530|
000212  6a70              LDR      r0,[r6,#0x24]         ;380
                  |L14.532|
000214  fa97f1a7          RBIT     r1,r7                 ;380
000218  fab1f181          CLZ      r1,r1                 ;380
00021c  f001011f          AND      r1,r1,#0x1f           ;380
000220  fa05f101          LSL      r1,r5,r1              ;380
000224  4208              TST      r0,r1                 ;380
000226  d1e4              BNE      |L14.498|
                  |L14.552|
;;;383              {
;;;384                return HAL_TIMEOUT;
;;;385              }
;;;386            }
;;;387          }
;;;388        }
;;;389      }
;;;390      /*------------------------------ LSI Configuration -------------------------*/ 
;;;391      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
000228  7820              LDRB     r0,[r4,#0]
00022a  0700              LSLS     r0,r0,#28
00022c  d56d              BPL      |L14.778|
;;;392      {
;;;393        /* Check the parameters */
;;;394        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;395        
;;;396        /* Check the LSI State */
;;;397        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
00022e  69a0              LDR      r0,[r4,#0x18]
000230  b3b8              CBZ      r0,|L14.674|
;;;398        {
;;;399          /* Enable the Internal Low Speed oscillator (LSI). */
;;;400          __HAL_RCC_LSI_ENABLE();
000232  fa95f0a5          RBIT     r0,r5
000236  fab0f080          CLZ      r0,r0
00023a  eb080080          ADD      r0,r8,r0,LSL #2
00023e  f8c05480          STR      r5,[r0,#0x480]
;;;401          
;;;402          /* Get Start Tick */
;;;403          tickstart = HAL_GetTick();
000242  f7fffffe          BL       HAL_GetTick
000246  4681              MOV      r9,r0
;;;404          
;;;405          /* Wait till LSI is ready */  
;;;406          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
000248  e005              B        |L14.598|
                  |L14.586|
;;;407          {
;;;408            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
00024a  f7fffffe          BL       HAL_GetTick
00024e  eba00009          SUB      r0,r0,r9
000252  2802              CMP      r0,#2
000254  d8a0              BHI      |L14.408|
                  |L14.598|
000256  fa97f0a7          RBIT     r0,r7                 ;406
00025a  fab0f080          CLZ      r0,r0                 ;406
00025e  f0400060          ORR      r0,r0,#0x60           ;406
000262  ebb51f50          CMP      r5,r0,LSR #5          ;406
000266  d102              BNE      |L14.622|
000268  6830              LDR      r0,[r6,#0]            ;406
00026a  e00c              B        |L14.646|
                  |L14.620|
00026c  e163              B        |L14.1334|
                  |L14.622|
00026e  fa97f0a7          RBIT     r0,r7                 ;406
000272  fab0f080          CLZ      r0,r0                 ;406
000276  f0400060          ORR      r0,r0,#0x60           ;406
00027a  ebb71f50          CMP      r7,r0,LSR #5          ;406
00027e  d101              BNE      |L14.644|
000280  6a30              LDR      r0,[r6,#0x20]         ;406
000282  e000              B        |L14.646|
                  |L14.644|
000284  6a70              LDR      r0,[r6,#0x24]         ;406
                  |L14.646|
000286  fa97f1a7          RBIT     r1,r7                 ;406
00028a  fab1f181          CLZ      r1,r1                 ;406
00028e  f001011f          AND      r1,r1,#0x1f           ;406
000292  fa05f201          LSL      r2,r5,r1              ;406
000296  4210              TST      r0,r2                 ;406
000298  d0d7              BEQ      |L14.586|
;;;409            {
;;;410              return HAL_TIMEOUT;
;;;411            }
;;;412          }
;;;413          /*  To have a fully stabilized clock in the specified range, a software delay of 1ms 
;;;414              should be added.*/
;;;415          HAL_Delay(1);
00029a  2001              MOVS     r0,#1
00029c  f7fffffe          BL       HAL_Delay
0002a0  e033              B        |L14.778|
                  |L14.674|
0002a2  e7ff              B        |L14.676|
                  |L14.676|
;;;416        }
;;;417        else
;;;418        {
;;;419          /* Disable the Internal Low Speed oscillator (LSI). */
;;;420          __HAL_RCC_LSI_DISABLE();
0002a4  fa95f1a5          RBIT     r1,r5
0002a8  fab1f181          CLZ      r1,r1
0002ac  eb080181          ADD      r1,r8,r1,LSL #2
0002b0  f8c1a480          STR      r10,[r1,#0x480]
;;;421          
;;;422          /* Get Start Tick */
;;;423          tickstart = HAL_GetTick();
0002b4  f7fffffe          BL       HAL_GetTick
0002b8  4681              MOV      r9,r0
;;;424          
;;;425          /* Wait till LSI is disabled */  
;;;426          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
0002ba  e005              B        |L14.712|
                  |L14.700|
;;;427          {
;;;428            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
0002bc  f7fffffe          BL       HAL_GetTick
0002c0  eba00009          SUB      r0,r0,r9
0002c4  2802              CMP      r0,#2
0002c6  d899              BHI      |L14.508|
                  |L14.712|
0002c8  fa97f0a7          RBIT     r0,r7                 ;426
0002cc  fab0f080          CLZ      r0,r0                 ;426
0002d0  f0400060          ORR      r0,r0,#0x60           ;426
0002d4  ebb51f50          CMP      r5,r0,LSR #5          ;426
0002d8  d101              BNE      |L14.734|
0002da  6830              LDR      r0,[r6,#0]            ;426
0002dc  e00b              B        |L14.758|
                  |L14.734|
0002de  fa97f0a7          RBIT     r0,r7                 ;426
0002e2  fab0f080          CLZ      r0,r0                 ;426
0002e6  f0400060          ORR      r0,r0,#0x60           ;426
0002ea  ebb71f50          CMP      r7,r0,LSR #5          ;426
0002ee  d101              BNE      |L14.756|
0002f0  6a30              LDR      r0,[r6,#0x20]         ;426
0002f2  e000              B        |L14.758|
                  |L14.756|
0002f4  6a70              LDR      r0,[r6,#0x24]         ;426
                  |L14.758|
0002f6  fa97f1a7          RBIT     r1,r7                 ;426
0002fa  fab1f181          CLZ      r1,r1                 ;426
0002fe  f001011f          AND      r1,r1,#0x1f           ;426
000302  fa05f201          LSL      r2,r5,r1              ;426
000306  4210              TST      r0,r2                 ;426
000308  d1d8              BNE      |L14.700|
                  |L14.778|
;;;429            {
;;;430              return HAL_TIMEOUT;
;;;431            }
;;;432          }
;;;433        }
;;;434      }
;;;435      /*------------------------------ LSE Configuration -------------------------*/ 
;;;436      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
00030a  7820              LDRB     r0,[r4,#0]
00030c  0740              LSLS     r0,r0,#29
00030e  d563              BPL      |L14.984|
;;;437      {
;;;438        /* Check the parameters */
;;;439        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;440    
;;;441        /* Enable Power Clock*/
;;;442          __HAL_RCC_PWR_CLK_ENABLE();
000310  69f0              LDR      r0,[r6,#0x1c]
000312  f0405080          ORR      r0,r0,#0x10000000
000316  61f0              STR      r0,[r6,#0x1c]
000318  69f0              LDR      r0,[r6,#0x1c]
;;;443        
;;;444          /* Enable write access to Backup domain */
;;;445          SET_BIT(PWR->CR, PWR_CR_DBP);
00031a  f8dfb0f0          LDR      r11,|L14.1036|
00031e  f0005080          AND      r0,r0,#0x10000000     ;442
000322  9000              STR      r0,[sp,#0]
000324  f8db1000          LDR      r1,[r11,#0]
000328  f4417180          ORR      r1,r1,#0x100
00032c  f8cb1000          STR      r1,[r11,#0]
;;;446          
;;;447          /* Wait for Backup domain Write protection disable */
;;;448          tickstart = HAL_GetTick();
000330  f7fffffe          BL       HAL_GetTick
000334  4681              MOV      r9,r0
;;;449    
;;;450        while((PWR->CR & PWR_CR_DBP) == RESET)
000336  e005              B        |L14.836|
                  |L14.824|
;;;451          {
;;;452            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000338  f7fffffe          BL       HAL_GetTick
00033c  eba00009          SUB      r0,r0,r9
000340  2864              CMP      r0,#0x64
000342  d872              BHI      |L14.1066|
                  |L14.836|
000344  f8db0000          LDR      r0,[r11,#0]           ;450
000348  05c0              LSLS     r0,r0,#23             ;450
00034a  d5f5              BPL      |L14.824|
;;;453            {
;;;454              return HAL_TIMEOUT;
;;;455            }
;;;456          }
;;;457    
;;;458        /* Set the new LSE configuration -----------------------------------------*/
;;;459        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
00034c  68e0              LDR      r0,[r4,#0xc]
00034e  2801              CMP      r0,#1
000350  d00a              BEQ      |L14.872|
000352  b108              CBZ      r0,|L14.856|
000354  2805              CMP      r0,#5
000356  d013              BEQ      |L14.896|
                  |L14.856|
000358  6a30              LDR      r0,[r6,#0x20]
00035a  f0200001          BIC      r0,r0,#1
00035e  6230              STR      r0,[r6,#0x20]
000360  6a30              LDR      r0,[r6,#0x20]
000362  f0200004          BIC      r0,r0,#4
000366  e002              B        |L14.878|
                  |L14.872|
000368  6a30              LDR      r0,[r6,#0x20]
00036a  f0400001          ORR      r0,r0,#1
                  |L14.878|
00036e  6230              STR      r0,[r6,#0x20]
;;;460        /* Check the LSE State */
;;;461        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
;;;462        {
;;;463          /* Get Start Tick */
;;;464          tickstart = HAL_GetTick();
;;;465          
;;;466          /* Wait till LSE is ready */  
;;;467          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;468          {
;;;469            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000370  68e0              LDR      r0,[r4,#0xc]
000372  f2413b88          MOV      r11,#0x1388
000376  b380              CBZ      r0,|L14.986|
000378  f7fffffe          BL       HAL_GetTick
00037c  4681              MOV      r9,r0                 ;464
00037e  e00a              B        |L14.918|
                  |L14.896|
000380  6a30              LDR      r0,[r6,#0x20]         ;459
000382  f0400004          ORR      r0,r0,#4              ;459
000386  6230              STR      r0,[r6,#0x20]         ;459
000388  e7ee              B        |L14.872|
                  |L14.906|
00038a  f7fffffe          BL       HAL_GetTick
00038e  eba00109          SUB      r1,r0,r9
000392  4559              CMP      r1,r11
000394  d849              BHI      |L14.1066|
                  |L14.918|
000396  fa97f0a7          RBIT     r0,r7                 ;467
00039a  fab0f080          CLZ      r0,r0                 ;467
00039e  f0400040          ORR      r0,r0,#0x40           ;467
0003a2  ebb51f50          CMP      r5,r0,LSR #5          ;467
0003a6  d101              BNE      |L14.940|
0003a8  6830              LDR      r0,[r6,#0]            ;467
0003aa  e00b              B        |L14.964|
                  |L14.940|
0003ac  fa97f0a7          RBIT     r0,r7                 ;467
0003b0  fab0f080          CLZ      r0,r0                 ;467
0003b4  f0400040          ORR      r0,r0,#0x40           ;467
0003b8  ebb71f50          CMP      r7,r0,LSR #5          ;467
0003bc  d101              BNE      |L14.962|
0003be  6a30              LDR      r0,[r6,#0x20]         ;467
0003c0  e000              B        |L14.964|
                  |L14.962|
0003c2  6a70              LDR      r0,[r6,#0x24]         ;467
                  |L14.964|
0003c4  fa97f1a7          RBIT     r1,r7                 ;467
0003c8  fab1f181          CLZ      r1,r1                 ;467
0003cc  f001021f          AND      r2,r1,#0x1f           ;467
0003d0  fa05f102          LSL      r1,r5,r2              ;467
0003d4  4208              TST      r0,r1                 ;467
0003d6  d0d8              BEQ      |L14.906|
                  |L14.984|
0003d8  e033              B        |L14.1090|
                  |L14.986|
0003da  e7ff              B        |L14.988|
                  |L14.988|
;;;470            {
;;;471              return HAL_TIMEOUT;
;;;472            }
;;;473          }
;;;474        }
;;;475        else
;;;476        {
;;;477          /* Get Start Tick */
;;;478          tickstart = HAL_GetTick();
0003dc  f7fffffe          BL       HAL_GetTick
0003e0  4681              MOV      r9,r0
;;;479          
;;;480          /* Wait till LSE is disabled */  
;;;481          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
0003e2  e005              B        |L14.1008|
                  |L14.996|
;;;482          {
;;;483            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0003e4  f7fffffe          BL       HAL_GetTick
0003e8  eba00109          SUB      r1,r0,r9
0003ec  4559              CMP      r1,r11
0003ee  d81c              BHI      |L14.1066|
                  |L14.1008|
0003f0  fa97f0a7          RBIT     r0,r7                 ;481
0003f4  fab0f080          CLZ      r0,r0                 ;481
0003f8  f0400040          ORR      r0,r0,#0x40           ;481
0003fc  ebb51f50          CMP      r5,r0,LSR #5          ;481
000400  d108              BNE      |L14.1044|
000402  e005              B        |L14.1040|
                  |L14.1028|
                          DCD      0x40021000
                  |L14.1032|
                          DCD      0x42420000
                  |L14.1036|
                          DCD      0x40007000
                  |L14.1040|
000410  6830              LDR      r0,[r6,#0]            ;481
000412  e00c              B        |L14.1070|
                  |L14.1044|
000414  fa97f0a7          RBIT     r0,r7                 ;481
000418  fab0f080          CLZ      r0,r0                 ;481
00041c  f0400040          ORR      r0,r0,#0x40           ;481
000420  ebb71f50          CMP      r7,r0,LSR #5          ;481
000424  d102              BNE      |L14.1068|
000426  6a30              LDR      r0,[r6,#0x20]         ;481
000428  e001              B        |L14.1070|
                  |L14.1066|
00042a  e08a              B        |L14.1346|
                  |L14.1068|
00042c  6a70              LDR      r0,[r6,#0x24]         ;481
                  |L14.1070|
00042e  fa97f1a7          RBIT     r1,r7                 ;481
000432  fab1f181          CLZ      r1,r1                 ;481
000436  f001021f          AND      r2,r1,#0x1f           ;481
00043a  fa05f102          LSL      r1,r5,r2              ;481
00043e  4208              TST      r0,r1                 ;481
000440  d1d0              BNE      |L14.996|
                  |L14.1090|
;;;484            {
;;;485              return HAL_TIMEOUT;
;;;486            }
;;;487          }
;;;488        }
;;;489      }
;;;490    
;;;491    #if defined(RCC_CR_PLL2ON)
;;;492      /*-------------------------------- PLL2 Configuration -----------------------*/
;;;493      /* Check the parameters */
;;;494      assert_param(IS_RCC_PLL2(RCC_OscInitStruct->PLL2.PLL2State));
;;;495      if ((RCC_OscInitStruct->PLL2.PLL2State) != RCC_PLL2_NONE)
;;;496      {
;;;497        /* This bit can not be cleared if the PLL2 clock is used indirectly as system 
;;;498          clock (i.e. it is used as PLL clock entry that is used as system clock). */
;;;499        if((__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE) && \
;;;500            (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && \
;;;501            ((READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC)) == RCC_CFGR2_PREDIV1SRC_PLL2))
;;;502        {
;;;503          return HAL_ERROR;
;;;504        }
;;;505        else
;;;506        {
;;;507          if((RCC_OscInitStruct->PLL2.PLL2State) == RCC_PLL2_ON)
;;;508          {
;;;509            /* Check the parameters */
;;;510            assert_param(IS_RCC_PLL2_MUL(RCC_OscInitStruct->PLL2.PLL2MUL));
;;;511            assert_param(IS_RCC_HSE_PREDIV2(RCC_OscInitStruct->PLL2.HSEPrediv2Value));
;;;512    
;;;513            /* Prediv2 can be written only when the PLLI2S is disabled. */
;;;514            /* Return an error only if new value is different from the programmed value */
;;;515            if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL3ON) && \
;;;516              (__HAL_RCC_HSE_GET_PREDIV2() != RCC_OscInitStruct->PLL2.HSEPrediv2Value))
;;;517            {
;;;518              return HAL_ERROR;
;;;519            }
;;;520            
;;;521            /* Disable the main PLL2. */
;;;522            __HAL_RCC_PLL2_DISABLE();
;;;523            
;;;524            /* Get Start Tick */
;;;525            tickstart = HAL_GetTick();
;;;526            
;;;527            /* Wait till PLL2 is disabled */
;;;528            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
;;;529            {
;;;530              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;531              {
;;;532                return HAL_TIMEOUT;
;;;533              }
;;;534            }
;;;535            
;;;536            /* Configure the HSE prediv2 factor --------------------------------*/
;;;537            __HAL_RCC_HSE_PREDIV2_CONFIG(RCC_OscInitStruct->PLL2.HSEPrediv2Value);
;;;538    
;;;539            /* Configure the main PLL2 multiplication factors. */
;;;540            __HAL_RCC_PLL2_CONFIG(RCC_OscInitStruct->PLL2.PLL2MUL);
;;;541            
;;;542            /* Enable the main PLL2. */
;;;543            __HAL_RCC_PLL2_ENABLE();
;;;544            
;;;545            /* Get Start Tick */
;;;546            tickstart = HAL_GetTick();
;;;547            
;;;548            /* Wait till PLL2 is ready */
;;;549            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  == RESET)
;;;550            {
;;;551              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;552              {
;;;553                return HAL_TIMEOUT;
;;;554              }
;;;555            }
;;;556          }
;;;557          else
;;;558          {
;;;559           /* Set PREDIV1 source to HSE */
;;;560            CLEAR_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC);
;;;561    
;;;562            /* Disable the main PLL2. */
;;;563            __HAL_RCC_PLL2_DISABLE();
;;;564     
;;;565            /* Get Start Tick */
;;;566            tickstart = HAL_GetTick();
;;;567            
;;;568            /* Wait till PLL2 is disabled */  
;;;569            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  != RESET)
;;;570            {
;;;571              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;572              {
;;;573                return HAL_TIMEOUT;
;;;574              }
;;;575            }
;;;576          }
;;;577        }
;;;578      }
;;;579    
;;;580    #endif /* RCC_CR_PLL2ON */
;;;581      /*-------------------------------- PLL Configuration -----------------------*/
;;;582      /* Check the parameters */
;;;583      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;584      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
000442  69e0              LDR      r0,[r4,#0x1c]
000444  b398              CBZ      r0,|L14.1198|
;;;585      {
;;;586        /* Check if the PLL is used as system clock or not */
;;;587        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
000446  6871              LDR      r1,[r6,#4]
000448  f3c10181          UBFX     r1,r1,#2,#2
00044c  2902              CMP      r1,#2
00044e  d072              BEQ      |L14.1334|
;;;588        { 
;;;589          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
000450  2802              CMP      r0,#2
;;;590          {
;;;591            /* Check the parameters */
;;;592            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;593            assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
;;;594      
;;;595            /* Disable the main PLL. */
;;;596            __HAL_RCC_PLL_DISABLE();
000452  f04f7180          MOV      r1,#0x1000000
;;;597            
;;;598            /* Get Start Tick */
;;;599            tickstart = HAL_GetTick();
;;;600            
;;;601            /* Wait till PLL is disabled */
;;;602            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
000456  f04f7b00          MOV      r11,#0x2000000
;;;603            {
;;;604              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;605              {
;;;606                return HAL_TIMEOUT;
;;;607              }
;;;608            }
;;;609    
;;;610            /* Configure the HSE prediv factor --------------------------------*/
;;;611            /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
;;;612            if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
;;;613            {
;;;614              /* Check the parameter */
;;;615              assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
;;;616    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;617              assert_param(IS_RCC_PREDIV1_SOURCE(RCC_OscInitStruct->Prediv1Source));
;;;618              
;;;619              /* Set PREDIV1 source */
;;;620              SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
;;;621    #endif /* RCC_CFGR2_PREDIV1SRC */
;;;622    
;;;623              /* Set PREDIV1 Value */
;;;624              __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
;;;625            }
;;;626    
;;;627            /* Configure the main PLL clock source and multiplication factors. */
;;;628            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;629                                 RCC_OscInitStruct->PLL.PLLMUL);
;;;630            /* Enable the main PLL. */
;;;631            __HAL_RCC_PLL_ENABLE();
;;;632            
;;;633            /* Get Start Tick */
;;;634            tickstart = HAL_GetTick();
;;;635            
;;;636            /* Wait till PLL is ready */
;;;637            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
;;;638            {
;;;639              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;640              {
;;;641                return HAL_TIMEOUT;
;;;642              }
;;;643            }
;;;644          }
;;;645          else
;;;646          {
;;;647            /* Disable the main PLL. */
;;;648            __HAL_RCC_PLL_DISABLE();
00045a  4650              MOV      r0,r10
00045c  d00a              BEQ      |L14.1140|
00045e  fa91f1a1          RBIT     r1,r1
000462  fab1f181          CLZ      r1,r1
000466  f8480021          STR      r0,[r8,r1,LSL #2]
;;;649     
;;;650            /* Get Start Tick */
;;;651            tickstart = HAL_GetTick();
00046a  f7fffffe          BL       HAL_GetTick
00046e  4604              MOV      r4,r0
000470  465f              MOV      r7,r11                ;602
;;;652            
;;;653            /* Wait till PLL is disabled */  
;;;654            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
000472  e069              B        |L14.1352|
                  |L14.1140|
000474  468a              MOV      r10,r1                ;596
000476  fa91f1a1          RBIT     r1,r1                 ;596
00047a  fab1f181          CLZ      r1,r1                 ;596
00047e  46c1              MOV      r9,r8                 ;596
000480  f8480021          STR      r0,[r8,r1,LSL #2]     ;596
000484  f7fffffe          BL       HAL_GetTick
000488  46a8              MOV      r8,r5                 ;283
00048a  4607              MOV      r7,r0                 ;599
00048c  465d              MOV      r5,r11                ;602
00048e  e004              B        |L14.1178|
                  |L14.1168|
000490  f7fffffe          BL       HAL_GetTick
000494  1bc0              SUBS     r0,r0,r7              ;604
000496  2802              CMP      r0,#2                 ;604
000498  d853              BHI      |L14.1346|
                  |L14.1178|
00049a  fa95f0a5          RBIT     r0,r5                 ;602
00049e  fab0f080          CLZ      r0,r0                 ;602
0004a2  f0400020          ORR      r0,r0,#0x20           ;602
0004a6  0940              LSRS     r0,r0,#5              ;602
0004a8  d002              BEQ      |L14.1200|
0004aa  6830              LDR      r0,[r6,#0]            ;602
0004ac  e001              B        |L14.1202|
                  |L14.1198|
0004ae  e060              B        |L14.1394|
                  |L14.1200|
0004b0  6a70              LDR      r0,[r6,#0x24]         ;602
                  |L14.1202|
0004b2  fa95f1a5          RBIT     r1,r5                 ;602
0004b6  fab1f181          CLZ      r1,r1                 ;602
0004ba  f001021f          AND      r2,r1,#0x1f           ;602
0004be  fa08f102          LSL      r1,r8,r2              ;602
0004c2  4208              TST      r0,r1                 ;602
0004c4  d1e4              BNE      |L14.1168|
0004c6  6a20              LDR      r0,[r4,#0x20]         ;612
0004c8  f5b03f80          CMP      r0,#0x10000           ;612
0004cc  d105              BNE      |L14.1242|
0004ce  6870              LDR      r0,[r6,#4]            ;624
0004d0  68a1              LDR      r1,[r4,#8]            ;624
0004d2  f4203000          BIC      r0,r0,#0x20000        ;624
0004d6  4308              ORRS     r0,r0,r1              ;624
0004d8  6070              STR      r0,[r6,#4]            ;624
                  |L14.1242|
0004da  e9d40108          LDRD     r0,r1,[r4,#0x20]      ;624
0004de  4308              ORRS     r0,r0,r1              ;628
0004e0  6871              LDR      r1,[r6,#4]            ;628
0004e2  f4211174          BIC      r1,r1,#0x3d0000       ;628
0004e6  4308              ORRS     r0,r0,r1              ;628
0004e8  6070              STR      r0,[r6,#4]            ;628
0004ea  fa9af0aa          RBIT     r0,r10                ;631
0004ee  fab0f080          CLZ      r0,r0                 ;631
0004f2  4647              MOV      r7,r8                 ;631
0004f4  f8498020          STR      r8,[r9,r0,LSL #2]     ;631
0004f8  f7fffffe          BL       HAL_GetTick
0004fc  4604              MOV      r4,r0                 ;634
0004fe  e004              B        |L14.1290|
                  |L14.1280|
000500  f7fffffe          BL       HAL_GetTick
000504  1b00              SUBS     r0,r0,r4              ;639
000506  2802              CMP      r0,#2                 ;639
000508  d81b              BHI      |L14.1346|
                  |L14.1290|
00050a  fa95f0a5          RBIT     r0,r5                 ;637
00050e  fab0f080          CLZ      r0,r0                 ;637
000512  f0400020          ORR      r0,r0,#0x20           ;637
000516  0940              LSRS     r0,r0,#5              ;637
000518  d001              BEQ      |L14.1310|
00051a  6830              LDR      r0,[r6,#0]            ;637
00051c  e000              B        |L14.1312|
                  |L14.1310|
00051e  6a70              LDR      r0,[r6,#0x24]         ;637
                  |L14.1312|
000520  fa95f1a5          RBIT     r1,r5                 ;637
000524  fab1f181          CLZ      r1,r1                 ;637
000528  f001011f          AND      r1,r1,#0x1f           ;637
00052c  fa07f101          LSL      r1,r7,r1              ;637
000530  4208              TST      r0,r1                 ;637
000532  d0e5              BEQ      |L14.1280|
000534  e01d              B        |L14.1394|
                  |L14.1334|
000536  e01e              B        |L14.1398|
                  |L14.1336|
;;;655            {
;;;656              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
000538  f7fffffe          BL       HAL_GetTick
00053c  1b00              SUBS     r0,r0,r4
00053e  2802              CMP      r0,#2
000540  d902              BLS      |L14.1352|
                  |L14.1346|
;;;657              {
;;;658                return HAL_TIMEOUT;
000542  2003              MOVS     r0,#3
                  |L14.1348|
;;;659              }
;;;660            }
;;;661          }
;;;662        }
;;;663        else
;;;664        {
;;;665          return HAL_ERROR;
;;;666        }
;;;667      }
;;;668      
;;;669      return HAL_OK;
;;;670    }
000544  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.1352|
000548  fa97f0a7          RBIT     r0,r7                 ;654
00054c  fab0f080          CLZ      r0,r0                 ;654
000550  f0400020          ORR      r0,r0,#0x20           ;654
000554  0940              LSRS     r0,r0,#5              ;654
000556  d001              BEQ      |L14.1372|
000558  6830              LDR      r0,[r6,#0]            ;654
00055a  e000              B        |L14.1374|
                  |L14.1372|
00055c  6a70              LDR      r0,[r6,#0x24]         ;654
                  |L14.1374|
00055e  fa97f1a7          RBIT     r1,r7                 ;654
000562  fab1f181          CLZ      r1,r1                 ;654
000566  f001011f          AND      r1,r1,#0x1f           ;654
00056a  fa05f101          LSL      r1,r5,r1              ;654
00056e  4208              TST      r0,r1                 ;654
000570  d1e2              BNE      |L14.1336|
                  |L14.1394|
000572  2000              MOVS     r0,#0                 ;669
000574  e7e6              B        |L14.1348|
                  |L14.1398|
000576  2001              MOVS     r0,#1                 ;665
000578  e7e4              B        |L14.1348|
;;;671    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH|
#line 495
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX|
#line 682
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
