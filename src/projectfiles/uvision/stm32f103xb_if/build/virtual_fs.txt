; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\virtual_fs.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\virtual_fs.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\virtual_fs.crf ..\..\..\source\daplink\drag-n-drop\virtual_fs.c]
                          THUMB

                          AREA ||i.file_change_cb_stub||, CODE, READONLY, ALIGN=1

                  file_change_cb_stub PROC
;;;675    
;;;676    static void file_change_cb_stub(const vfs_filename_t filename, vfs_file_change_t change, vfs_file_t file, vfs_file_t new_file_data)
000000  4770              BX       lr
;;;677    {
;;;678        // Do nothing
;;;679    }
;;;680    
                          ENDP


                          AREA ||i.filename_valid||, CODE, READONLY, ALIGN=2

                  filename_valid PROC
;;;686    
;;;687    static bool filename_valid(const vfs_filename_t  filename)
000000  b5f0              PUSH     {r4-r7,lr}
;;;688    {
;;;689        // Information on valid 8.3 filenames can be found in
;;;690        // the microsoft hardware whitepaper:
;;;691        //
;;;692        // Microsoft Extensible Firmware Initiative
;;;693        // FAT32 File System Specification
;;;694        // FAT: General Overview of On-Disk Format
;;;695        const char invalid_starting_chars[] = {
000002  a118              ADR      r1,|L2.100|
000004  b085              SUB      sp,sp,#0x14           ;688
000006  6809              LDR      r1,[r1,#0]
;;;696            0xE5, // Deleted
;;;697            0x00, // Deleted (and all following entries are free)
;;;698            0x20, // Space not allowed as first character
;;;699        };
;;;700        uint32_t i;
;;;701    
;;;702        // Check for invalid starting characters
;;;703        for (i = 0; i < sizeof(invalid_starting_chars); i++) {
000008  9104              STR      r1,[sp,#0x10]
;;;704            if (invalid_starting_chars[i] == filename[0]) {
00000a  7802              LDRB     r2,[r0,#0]
00000c  2100              MOVS     r1,#0                 ;703
00000e  ab04              ADD      r3,sp,#0x10           ;695
                  |L2.16|
000010  5c5c              LDRB     r4,[r3,r1]
000012  4294              CMP      r4,r2
000014  d024              BEQ      |L2.96|
000016  1c49              ADDS     r1,r1,#1
000018  2903              CMP      r1,#3                 ;703
00001a  d3f9              BCC      |L2.16|
00001c  a112              ADR      r1,|L2.104|
;;;705                return false;
;;;706            }
;;;707        }
;;;708    
;;;709        // Make sure all the characters are valid
;;;710        for (i = 0; i < sizeof(vfs_filename_t); i++) {
00001e  2200              MOVS     r2,#0
000020  e8910078          LDM      r1,{r3-r6}
000024  466f              MOV      r7,sp
                  |L2.38|
;;;711            if (!filename_character_valid(filename[i])) {
000026  5c81              LDRB     r1,[r0,r2]
000028  e88d0078          STM      sp,{r3-r6}
00002c  f1a10c61          SUB      r12,r1,#0x61
000030  f1bc0f19          CMP      r12,#0x19
000034  d914              BLS      |L2.96|
000036  2920              CMP      r1,#0x20
000038  d201              BCS      |L2.62|
00003a  2905              CMP      r1,#5
00003c  d110              BNE      |L2.96|
                  |L2.62|
00003e  f04f0c00          MOV      r12,#0
                  |L2.66|
000042  f817e00c          LDRB     lr,[r7,r12]
000046  458e              CMP      lr,r1
000048  d00a              BEQ      |L2.96|
00004a  f10c0c01          ADD      r12,r12,#1
00004e  f1bc0f10          CMP      r12,#0x10
000052  d3f6              BCC      |L2.66|
000054  1c52              ADDS     r2,r2,#1
000056  2a0b              CMP      r2,#0xb               ;710
000058  d3e5              BCC      |L2.38|
;;;712                return false;
;;;713            }
;;;714        }
;;;715    
;;;716        // All checks have passed so filename is valid
;;;717        return true;
00005a  2001              MOVS     r0,#1
                  |L2.92|
;;;718    }
00005c  b005              ADD      sp,sp,#0x14
00005e  bdf0              POP      {r4-r7,pc}
                  |L2.96|
000060  2000              MOVS     r0,#0                 ;712
000062  e7fb              B        |L2.92|
;;;719    
                          ENDP

                  |L2.100|
000064  e500              DCB      229,0
000066  2000              DCB      " ",0
                  |L2.104|
000068  222a2b2c          DCB      """*+,./:;<=>?[\\]|"
00006c  2e2f3a3b
000070  3c3d3e3f
000074  5b5c5d7c

                          AREA ||i.read_dir||, CODE, READONLY, ALIGN=2

                  read_dir PROC
;;;607    
;;;608    static uint32_t read_dir(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b570              PUSH     {r4-r6,lr}
;;;609    {
000002  4614              MOV      r4,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;610        if ((sector_offset + num_sectors) * VFS_SECTOR_SIZE > sizeof(dir_current)) {
000008  4420              ADD      r0,r0,r4
00000a  f44f6180          MOV      r1,#0x400
00000e  ebb12f40          CMP      r1,r0,LSL #9
000012  d207              BCS      |L3.36|
;;;611            // Trying to read too much of the root directory
;;;612            util_assert(0);
000014  f44f7219          MOV      r2,#0x264
000018  a10a              ADR      r1,|L3.68|
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       _util_assert
;;;613            return 0;
000020  2000              MOVS     r0,#0
;;;614        }
;;;615    
;;;616        // Zero buffer data is VFS_SECTOR_SIZE max
;;;617        memset(data, 0, VFS_SECTOR_SIZE);
;;;618    
;;;619        if (sector_offset == 0) { //Handle the first 512 bytes
;;;620            // Copy data that is actually created in the directory
;;;621            memcpy(data, &dir_current.f[0], dir_idx*sizeof(FatDirectoryEntry_t));
;;;622        }
;;;623    
;;;624        return num_sectors * VFS_SECTOR_SIZE;
;;;625    }
000022  bd70              POP      {r4-r6,pc}
                  |L3.36|
000024  f44f7100          MOV      r1,#0x200             ;617
000028  4630              MOV      r0,r6                 ;617
00002a  f7fffffe          BL       __aeabi_memclr
00002e  b935              CBNZ     r5,|L3.62|
000030  4811              LDR      r0,|L3.120|
000032  4912              LDR      r1,|L3.124|
000034  6900              LDR      r0,[r0,#0x10]         ;621  ; dir_idx
000036  0142              LSLS     r2,r0,#5              ;621
000038  4630              MOV      r0,r6                 ;621
00003a  f7fffffe          BL       __aeabi_memcpy
                  |L3.62|
00003e  0260              LSLS     r0,r4,#9              ;624
000040  bd70              POP      {r4-r6,pc}
;;;626    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
000044  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
000048  2e5c2e2e
00004c  5c736f75
000050  7263655c
000054  6461706c
000058  696e6b5c
00005c  64726167
000060  2d6e2d64
000064  726f705c
000068  76697274
00006c  75616c5f
000070  66732e63
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L3.120|
                          DCD      ||.data||
                  |L3.124|
                          DCD      ||.bss||+0x4c0

                          AREA ||i.read_fat||, CODE, READONLY, ALIGN=2

                  read_fat PROC
;;;591    
;;;592    static uint32_t read_fat(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b510              PUSH     {r4,lr}
;;;593    {
000002  460b              MOV      r3,r1
;;;594        uint32_t read_size = sizeof(file_allocation_table_t);
000004  f44f7400          MOV      r4,#0x200
000008  b108              CBZ      r0,|L4.14|
;;;595        COMPILER_ASSERT(sizeof(file_allocation_table_t) <= VFS_SECTOR_SIZE);
;;;596    
;;;597        if (sector_offset != 0) {
;;;598            // Don't worry about reading other sectors
;;;599            return 0;
00000a  2000              MOVS     r0,#0
;;;600        }
;;;601    
;;;602        memcpy(data, &fat, read_size);
;;;603        return read_size;
;;;604    }
00000c  bd10              POP      {r4,pc}
                  |L4.14|
00000e  4622              MOV      r2,r4                 ;602
000010  4902              LDR      r1,|L4.28|
000012  4618              MOV      r0,r3                 ;602
000014  f7fffffe          BL       __aeabi_memcpy
000018  4620              MOV      r0,r4                 ;603
00001a  bd10              POP      {r4,pc}
;;;605    
                          ENDP

                  |L4.28|
                          DCD      ||.bss||+0x200

                          AREA ||i.read_mbr||, CODE, READONLY, ALIGN=2

                  read_mbr PROC
;;;575    
;;;576    static uint32_t read_mbr(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b510              PUSH     {r4,lr}
;;;577    {
000002  460b              MOV      r3,r1
;;;578        uint32_t read_size = sizeof(mbr_t);
000004  f44f7400          MOV      r4,#0x200
000008  b108              CBZ      r0,|L5.14|
;;;579        COMPILER_ASSERT(sizeof(mbr_t) <= VFS_SECTOR_SIZE);
;;;580    
;;;581        if (sector_offset != 0) {
;;;582            // Don't worry about reading other sectors
;;;583            return 0;
00000a  2000              MOVS     r0,#0
;;;584        }
;;;585    
;;;586        memcpy(data, &mbr, read_size);
;;;587        return read_size;
;;;588    }
00000c  bd10              POP      {r4,pc}
                  |L5.14|
00000e  4622              MOV      r2,r4                 ;586
000010  4902              LDR      r1,|L5.28|
000012  4618              MOV      r0,r3                 ;586
000014  f7fffffe          BL       __aeabi_memcpy
000018  4620              MOV      r0,r4                 ;587
00001a  bd10              POP      {r4,pc}
;;;589    
                          ENDP

                  |L5.28|
                          DCD      ||.bss||

                          AREA ||i.read_zero||, CODE, READONLY, ALIGN=1

                  read_zero PROC
;;;563    
;;;564    static uint32_t read_zero(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b510              PUSH     {r4,lr}
;;;565    {
000002  4608              MOV      r0,r1
;;;566        uint32_t read_size = VFS_SECTOR_SIZE * num_sectors;
000004  0254              LSLS     r4,r2,#9
;;;567        memset(data, 0, read_size);
000006  4621              MOV      r1,r4
000008  f7fffffe          BL       __aeabi_memclr
;;;568        return read_size;
00000c  4620              MOV      r0,r4
;;;569    }
00000e  bd10              POP      {r4,pc}
;;;570    
                          ENDP


                          AREA ||i.vfs_create_file||, CODE, READONLY, ALIGN=2

                  vfs_create_file PROC
;;;398    
;;;399    vfs_file_t vfs_create_file(const vfs_filename_t filename, vfs_read_cb_t read_cb, vfs_write_cb_t write_cb, uint32_t len)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;400    {
000004  4699              MOV      r9,r3
000006  4692              MOV      r10,r2
000008  468b              MOV      r11,r1
;;;401        uint32_t first_cluster;
;;;402        FatDirectoryEntry_t *de;
;;;403        uint32_t clusters;
;;;404        uint32_t cluster_size;
;;;405        uint32_t i;
;;;406        util_assert(filename_valid(filename));
00000a  9800              LDR      r0,[sp,#0]
00000c  f7fffffe          BL       filename_valid
000010  f44f72cb          MOV      r2,#0x196
000014  a140              ADR      r1,|L7.280|
000016  f7fffffe          BL       _util_assert
;;;407        // Compute the number of clusters in the file
;;;408        cluster_size = mbr.bytes_per_sector * mbr.sectors_per_cluster;
00001a  494c              LDR      r1,|L7.332|
;;;409        clusters = (len + cluster_size - 1) / cluster_size;
;;;410        // Write the cluster chain to the fat table
;;;411        first_cluster = 0;
00001c  2600              MOVS     r6,#0
;;;412    
;;;413        if (len > 0) {
;;;414            first_cluster = fat_idx;
00001e  4d4c              LDR      r5,|L7.336|
000020  7b08              LDRB     r0,[r1,#0xc]          ;408  ; mbr
000022  7aca              LDRB     r2,[r1,#0xb]          ;408  ; mbr
000024  7b49              LDRB     r1,[r1,#0xd]          ;408  ; mbr
000026  ea422000          ORR      r0,r2,r0,LSL #8       ;408
00002a  4348              MULS     r0,r1,r0              ;408
00002c  eb090100          ADD      r1,r9,r0              ;409
000030  1e49              SUBS     r1,r1,#1              ;409
000032  fbb1f7f0          UDIV     r7,r1,r0              ;409
000036  f1b90f00          CMP      r9,#0                 ;413
00003a  d019              BEQ      |L7.112|
;;;415    
;;;416            for (i = 0; i < clusters - 1; i++) {
00003c  2400              MOVS     r4,#0
00003e  f1a70801          SUB      r8,r7,#1
000042  68ee              LDR      r6,[r5,#0xc]  ; fat_idx
000044  e009              B        |L7.90|
                  |L7.70|
;;;417                write_fat(&fat, fat_idx, fat_idx + 1);
000046  68e9              LDR      r1,[r5,#0xc]  ; fat_idx
000048  1c48              ADDS     r0,r1,#1
00004a  b282              UXTH     r2,r0
00004c  4841              LDR      r0,|L7.340|
00004e  f7fffffe          BL       write_fat
;;;418                fat_idx++;
000052  68e8              LDR      r0,[r5,#0xc]  ; fat_idx
000054  1c40              ADDS     r0,r0,#1
000056  1c64              ADDS     r4,r4,#1
000058  60e8              STR      r0,[r5,#0xc]  ; fat_idx
                  |L7.90|
00005a  4544              CMP      r4,r8                 ;416
00005c  d3f3              BCC      |L7.70|
;;;419            }
;;;420    
;;;421            write_fat(&fat, fat_idx, 0xFFFF);
00005e  f64f72ff          MOV      r2,#0xffff
000062  483c              LDR      r0,|L7.340|
000064  68e9              LDR      r1,[r5,#0xc]  ; fat_idx
000066  f7fffffe          BL       write_fat
;;;422            fat_idx++;
00006a  68e8              LDR      r0,[r5,#0xc]  ; fat_idx
00006c  1c40              ADDS     r0,r0,#1
00006e  60e8              STR      r0,[r5,#0xc]  ; fat_idx
                  |L7.112|
;;;423        }
;;;424    
;;;425        // Update directory entry
;;;426        if (dir_idx >= ARRAY_SIZE(dir_current.f)) {
000070  6928              LDR      r0,[r5,#0x10]  ; dir_idx
000072  2820              CMP      r0,#0x20
000074  d302              BCC      |L7.124|
;;;427            util_assert(0);
000076  f24012ab          MOV      r2,#0x1ab
;;;428            return VFS_FILE_INVALID;
00007a  e01f              B        |L7.188|
                  |L7.124|
;;;429        }
;;;430    
;;;431        de = &dir_current.f[dir_idx];
00007c  4936              LDR      r1,|L7.344|
;;;432        dir_idx++;
;;;433        memcpy(de, &dir_entry_tmpl, sizeof(dir_entry_tmpl));
00007e  2220              MOVS     r2,#0x20
000080  eb011440          ADD      r4,r1,r0,LSL #5       ;431
000084  1c40              ADDS     r0,r0,#1              ;431
000086  6128              STR      r0,[r5,#0x10]  ; dir_idx
000088  4934              LDR      r1,|L7.348|
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       __aeabi_memcpy
;;;434        memcpy(de->filename, filename, 11);
000090  220b              MOVS     r2,#0xb
000092  4620              MOV      r0,r4
000094  9900              LDR      r1,[sp,#0]
000096  f7fffffe          BL       __aeabi_memcpy
;;;435        de->filesize = len;
00009a  f104011c          ADD      r1,r4,#0x1c
00009e  4648              MOV      r0,r9
0000a0  f7fffffe          BL       __aeabi_uwrite4
;;;436        de->first_cluster_high_16 = (first_cluster >> 16) & 0xFFFF;
0000a4  0c30              LSRS     r0,r6,#16
0000a6  7520              STRB     r0,[r4,#0x14]
0000a8  0a00              LSRS     r0,r0,#8
0000aa  7560              STRB     r0,[r4,#0x15]
;;;437        de->first_cluster_low_16 = (first_cluster >> 0) & 0xFFFF;
0000ac  76a6              STRB     r6,[r4,#0x1a]
0000ae  0a30              LSRS     r0,r6,#8
0000b0  76e0              STRB     r0,[r4,#0x1b]
;;;438    
;;;439        // Update virtual media
;;;440        if (virtual_media_idx >= ARRAY_SIZE(virtual_media)) {
0000b2  68a9              LDR      r1,[r5,#8]  ; virtual_media_idx
0000b4  2910              CMP      r1,#0x10
0000b6  d309              BCC      |L7.204|
;;;441            util_assert(0);
0000b8  f24012b9          MOV      r2,#0x1b9
                  |L7.188|
0000bc  a116              ADR      r1,|L7.280|
0000be  2000              MOVS     r0,#0
0000c0  f7fffffe          BL       _util_assert
;;;442            return VFS_FILE_INVALID;
0000c4  2000              MOVS     r0,#0
                  |L7.198|
;;;443        }
;;;444    
;;;445        virtual_media[virtual_media_idx].read_cb = read_zero;
;;;446        virtual_media[virtual_media_idx].write_cb = write_none;
;;;447    
;;;448        if (0 != read_cb) {
;;;449            virtual_media[virtual_media_idx].read_cb = read_cb;
;;;450        }
;;;451    
;;;452        if (0 != write_cb) {
;;;453            virtual_media[virtual_media_idx].write_cb = write_cb;
;;;454        }
;;;455    
;;;456        virtual_media[virtual_media_idx].length = clusters * mbr.bytes_per_sector * mbr.sectors_per_cluster;
;;;457        virtual_media_idx++;
;;;458        file_count += 1;
;;;459        return de;
;;;460    }
0000c6  b004              ADD      sp,sp,#0x10
0000c8  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.204|
0000cc  4b22              LDR      r3,|L7.344|
0000ce  eb010041          ADD      r0,r1,r1,LSL #1       ;445
0000d2  3bc0              SUBS     r3,r3,#0xc0           ;445
0000d4  4a22              LDR      r2,|L7.352|
0000d6  f8432020          STR      r2,[r3,r0,LSL #2]     ;445
0000da  eb030280          ADD      r2,r3,r0,LSL #2       ;446
0000de  4e21              LDR      r6,|L7.356|
0000e0  6056              STR      r6,[r2,#4]            ;448
0000e2  f1bb0f00          CMP      r11,#0                ;448
0000e6  d001              BEQ      |L7.236|
0000e8  f843b020          STR      r11,[r3,r0,LSL #2]    ;449
                  |L7.236|
0000ec  f1ba0f00          CMP      r10,#0                ;452
0000f0  d001              BEQ      |L7.246|
0000f2  f8c2a004          STR      r10,[r2,#4]           ;453
                  |L7.246|
0000f6  4815              LDR      r0,|L7.332|
0000f8  1c49              ADDS     r1,r1,#1              ;456
0000fa  7b03              LDRB     r3,[r0,#0xc]          ;456  ; mbr
0000fc  7ac6              LDRB     r6,[r0,#0xb]          ;456  ; mbr
0000fe  7b40              LDRB     r0,[r0,#0xd]          ;456  ; mbr
000100  ea462303          ORR      r3,r6,r3,LSL #8       ;456
000104  4343              MULS     r3,r0,r3              ;456
000106  437b              MULS     r3,r7,r3              ;456
000108  6093              STR      r3,[r2,#8]            ;457
00010a  60a9              STR      r1,[r5,#8]            ;458  ; virtual_media_idx
00010c  7828              LDRB     r0,[r5,#0]            ;458  ; file_count
00010e  1c40              ADDS     r0,r0,#1              ;458
000110  7028              STRB     r0,[r5,#0]            ;458
000112  4620              MOV      r0,r4                 ;459
000114  e7d7              B        |L7.198|
;;;461    
                          ENDP

000116  0000              DCW      0x0000
                  |L7.280|
000118  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
00011c  2e5c2e2e
000120  5c736f75
000124  7263655c
000128  6461706c
00012c  696e6b5c
000130  64726167
000134  2d6e2d64
000138  726f705c
00013c  76697274
000140  75616c5f
000144  66732e63
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0
                  |L7.332|
                          DCD      ||.bss||
                  |L7.336|
                          DCD      ||.data||
                  |L7.340|
                          DCD      ||.bss||+0x200
                  |L7.344|
                          DCD      ||.bss||+0x4c0
                  |L7.348|
                          DCD      ||.constdata||+0x250
                  |L7.352|
                          DCD      read_zero
                  |L7.356|
                          DCD      write_none

                          AREA ||i.vfs_file_get_attr||, CODE, READONLY, ALIGN=1

                  vfs_file_get_attr PROC
;;;484    
;;;485    vfs_file_attr_bit_t vfs_file_get_attr(vfs_file_t file)
000000  7ac0              LDRB     r0,[r0,#0xb]
;;;486    {
;;;487        FatDirectoryEntry_t *de = file;
;;;488        return (vfs_file_attr_bit_t)de->attributes;
;;;489    }
000002  4770              BX       lr
;;;490    
                          ENDP


                          AREA ||i.vfs_file_get_size||, CODE, READONLY, ALIGN=1

                  vfs_file_get_size PROC
;;;478    
;;;479    uint32_t vfs_file_get_size(vfs_file_t file)
000000  301c              ADDS     r0,r0,#0x1c
;;;480    {
;;;481        FatDirectoryEntry_t *de = file;
;;;482        return de->filesize;
000002  f7ffbffe          B.W      __aeabi_uread4
;;;483    }
;;;484    
                          ENDP


                          AREA ||i.vfs_file_get_start_sector||, CODE, READONLY, ALIGN=2

                  vfs_file_get_start_sector PROC
;;;467    
;;;468    vfs_sector_t vfs_file_get_start_sector(vfs_file_t file)
000000  b510              PUSH     {r4,lr}
;;;469    {
;;;470        FatDirectoryEntry_t *de = file;
000002  4604              MOV      r4,r0
;;;471    
;;;472        if (vfs_file_get_size(file) == 0) {
000004  f7fffffe          BL       vfs_file_get_size
000008  b188              CBZ      r0,|L10.46|
;;;473            return VFS_INVALID_SECTOR;
;;;474        }
;;;475    
;;;476        return cluster_to_sector(de->first_cluster_low_16);
00000a  7ee0              LDRB     r0,[r4,#0x1b]
00000c  7ea1              LDRB     r1,[r4,#0x1a]
00000e  ea412200          ORR      r2,r1,r0,LSL #8
000012  4808              LDR      r0,|L10.52|
000014  1e92              SUBS     r2,r2,#2
000016  7b01              LDRB     r1,[r0,#0xc]  ; mbr
000018  7ac3              LDRB     r3,[r0,#0xb]  ; mbr
00001a  7b40              LDRB     r0,[r0,#0xd]  ; mbr
00001c  ea432101          ORR      r1,r3,r1,LSL #8
000020  4b05              LDR      r3,|L10.56|
000022  695b              LDR      r3,[r3,#0x14]  ; data_start
000024  fbb3f1f1          UDIV     r1,r3,r1
000028  fb021000          MLA      r0,r2,r0,r1
;;;477    }
00002c  bd10              POP      {r4,pc}
                  |L10.46|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;473
000032  bd10              POP      {r4,pc}
;;;478    
                          ENDP

                  |L10.52|
                          DCD      ||.bss||
                  |L10.56|
                          DCD      ||.data||

                          AREA ||i.vfs_file_set_attr||, CODE, READONLY, ALIGN=1

                  vfs_file_set_attr PROC
;;;461    
;;;462    void vfs_file_set_attr(vfs_file_t file, vfs_file_attr_bit_t attr)
000000  72c1              STRB     r1,[r0,#0xb]
;;;463    {
;;;464        FatDirectoryEntry_t *de = file;
;;;465        de->attributes = attr;
;;;466    }
000002  4770              BX       lr
;;;467    
                          ENDP


                          AREA ||i.vfs_get_total_size||, CODE, READONLY, ALIGN=2

                  vfs_get_total_size PROC
;;;384    
;;;385    uint32_t vfs_get_total_size()
000000  b570              PUSH     {r4-r6,lr}
;;;386    {
;;;387        uint32_t size;
;;;388        if (mbr.total_logical_sectors > 0) {
000002  480f              LDR      r0,|L12.64|
000004  7d01              LDRB     r1,[r0,#0x14]  ; mbr
000006  7cc0              LDRB     r0,[r0,#0x13]  ; mbr
000008  ea502401          ORRS     r4,r0,r1,LSL #8
00000c  480c              LDR      r0,|L12.64|
;;;389            size = mbr.total_logical_sectors * mbr.bytes_per_sector;
00000e  7b01              LDRB     r1,[r0,#0xc]
000010  7ac0              LDRB     r0,[r0,#0xb]
000012  ea402501          ORR      r5,r0,r1,LSL #8
000016  d001              BEQ      |L12.28|
000018  436c              MULS     r4,r5,r4
00001a  e00e              B        |L12.58|
                  |L12.28|
;;;390        } else if (mbr.big_sectors_on_drive > 0) {
00001c  4808              LDR      r0,|L12.64|
00001e  3020              ADDS     r0,r0,#0x20
000020  f7fffffe          BL       __aeabi_uread4
000024  b110              CBZ      r0,|L12.44|
;;;391            size = mbr.big_sectors_on_drive * mbr.bytes_per_sector;
000026  fb00f405          MUL      r4,r0,r5
00002a  e006              B        |L12.58|
                  |L12.44|
;;;392        } else {
;;;393            size = 0;
00002c  2400              MOVS     r4,#0
;;;394            util_assert(0);
00002e  f44f72c5          MOV      r2,#0x18a
000032  a104              ADR      r1,|L12.68|
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       _util_assert
                  |L12.58|
;;;395        }
;;;396        return size;
00003a  4620              MOV      r0,r4
;;;397    }
00003c  bd70              POP      {r4-r6,pc}
;;;398    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      ||.bss||
                  |L12.68|
000044  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
000048  2e5c2e2e
00004c  5c736f75
000050  7263655c
000054  6461706c
000058  696e6b5c
00005c  64726167
000060  2d6e2d64
000064  726f705c
000068  76697274
00006c  75616c5f
000070  66732e63
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.vfs_init||, CODE, READONLY, ALIGN=2

                  vfs_init PROC
;;;321    
;;;322    void vfs_init(const vfs_filename_t drive_name, uint32_t disk_size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;323    {
000004  460f              MOV      r7,r1
000006  4680              MOV      r8,r0
;;;324        uint32_t i;
;;;325        uint32_t num_clusters;
;;;326        uint32_t total_sectors;
;;;327        // Clear everything
;;;328        memset(&mbr, 0, sizeof(mbr));
000008  f44f7600          MOV      r6,#0x200
00000c  4631              MOV      r1,r6
00000e  484e              LDR      r0,|L13.328|
000010  f7fffffe          BL       __aeabi_memclr4
;;;329        memset(&fat, 0, sizeof(fat));
000014  4631              MOV      r1,r6
000016  484d              LDR      r0,|L13.332|
000018  f7fffffe          BL       __aeabi_memclr4
;;;330        fat_idx = 0;
00001c  4c4c              LDR      r4,|L13.336|
00001e  2500              MOVS     r5,#0
;;;331        memset(&virtual_media, 0, sizeof(virtual_media));
000020  21c0              MOVS     r1,#0xc0
000022  484c              LDR      r0,|L13.340|
000024  60e5              STR      r5,[r4,#0xc]  ; fat_idx
000026  f7fffffe          BL       __aeabi_memclr4
;;;332        memset(&dir_current, 0, sizeof(dir_current));
00002a  484a              LDR      r0,|L13.340|
00002c  0071              LSLS     r1,r6,#1
00002e  30c0              ADDS     r0,r0,#0xc0
000030  f7fffffe          BL       __aeabi_memclr4
;;;333        dir_idx = 0;
;;;334        file_count = 0;
000034  6125              STR      r5,[r4,#0x10]  ; dir_idx
000036  7025              STRB     r5,[r4,#0]
;;;335        file_change_cb = file_change_cb_stub;
000038  4847              LDR      r0,|L13.344|
00003a  e9c40501          STRD     r0,r5,[r4,#4]
;;;336        virtual_media_idx = 0;
;;;337        data_start = 0;
;;;338        // Initialize MBR
;;;339        memcpy(&mbr, &mbr_tmpl, sizeof(mbr_t));
00003e  4632              MOV      r2,r6
000040  4946              LDR      r1,|L13.348|
000042  4841              LDR      r0,|L13.328|
000044  6165              STR      r5,[r4,#0x14]  ; data_start
000046  f7fffffe          BL       __aeabi_memcpy4
;;;340        total_sectors = ((disk_size + KB(64)) / mbr.bytes_per_sector);
00004a  4e3f              LDR      r6,|L13.328|
00004c  f5073780          ADD      r7,r7,#0x10000
000050  7b30              LDRB     r0,[r6,#0xc]  ; mbr
000052  7af1              LDRB     r1,[r6,#0xb]  ; mbr
000054  ea412000          ORR      r0,r1,r0,LSL #8
000058  fbb7f7f0          UDIV     r7,r7,r0
;;;341        // Make sure this is the right size for a FAT16 volume
;;;342        if (total_sectors < FAT_CLUSTERS_MIN * mbr.sectors_per_cluster) {
00005c  7b70              LDRB     r0,[r6,#0xd]  ; mbr
00005e  f640012d          MOV      r1,#0x82d
000062  4341              MULS     r1,r0,r1
000064  ebb70f41          CMP      r7,r1,LSL #1
000068  d209              BCS      |L13.126|
;;;343            util_assert(0);
00006a  f2401257          MOV      r2,#0x157
00006e  a13c              ADR      r1,|L13.352|
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       _util_assert
;;;344            total_sectors = FAT_CLUSTERS_MIN * mbr.sectors_per_cluster;
000076  7b77              LDRB     r7,[r6,#0xd]  ; mbr
000078  f241005a          MOV      r0,#0x105a
00007c  e00d              B        |L13.154|
                  |L13.126|
;;;345        } else if (total_sectors > FAT_CLUSTERS_MAX * mbr.sectors_per_cluster) {
00007e  f64f7191          MOV      r1,#0xff91
000082  4348              MULS     r0,r1,r0
000084  42b8              CMP      r0,r7
000086  d209              BCS      |L13.156|
;;;346            util_assert(0);
000088  f44f72ad          MOV      r2,#0x15a
00008c  a134              ADR      r1,|L13.352|
00008e  2000              MOVS     r0,#0
000090  f7fffffe          BL       _util_assert
;;;347            total_sectors = FAT_CLUSTERS_MAX * mbr.sectors_per_cluster;
000094  7b77              LDRB     r7,[r6,#0xd]  ; mbr
000096  f64f7091          MOV      r0,#0xff91
                  |L13.154|
00009a  4347              MULS     r7,r0,r7
                  |L13.156|
00009c  492a              LDR      r1,|L13.328|
00009e  3120              ADDS     r1,r1,#0x20           ;328
;;;348        }
;;;349        if (total_sectors >= 0x10000) {
0000a0  f5b73f80          CMP      r7,#0x10000
0000a4  d304              BCC      |L13.176|
;;;350            mbr.total_logical_sectors = 0;
0000a6  74f5              STRB     r5,[r6,#0x13]
0000a8  0a28              LSRS     r0,r5,#8
0000aa  7530              STRB     r0,[r6,#0x14]
;;;351            mbr.big_sectors_on_drive  = total_sectors;
0000ac  4638              MOV      r0,r7
0000ae  e003              B        |L13.184|
                  |L13.176|
;;;352        } else {
;;;353            mbr.total_logical_sectors = total_sectors;
0000b0  74f7              STRB     r7,[r6,#0x13]
0000b2  0a38              LSRS     r0,r7,#8
0000b4  7530              STRB     r0,[r6,#0x14]
;;;354            mbr.big_sectors_on_drive  = 0;
0000b6  2000              MOVS     r0,#0
                  |L13.184|
0000b8  f7fffffe          BL       __aeabi_uwrite4
;;;355        }
;;;356        // FAT table will likely be larger than needed, but this is allowed by the
;;;357        // fat specification
;;;358        num_clusters = total_sectors / mbr.sectors_per_cluster;
0000bc  7b70              LDRB     r0,[r6,#0xd]  ; mbr
;;;359        mbr.logical_sectors_per_fat = (num_clusters * 2 + VFS_SECTOR_SIZE - 1) / VFS_SECTOR_SIZE;
0000be  f24011ff          MOV      r1,#0x1ff
0000c2  fbb7f0f0          UDIV     r0,r7,r0              ;358
0000c6  eb010040          ADD      r0,r1,r0,LSL #1
0000ca  f3c0274f          UBFX     r7,r0,#9,#16
0000ce  82f7              STRH     r7,[r6,#0x16]
;;;360        // Initailize virtual media
;;;361        memcpy(&virtual_media, &virtual_media_tmpl, sizeof(virtual_media_tmpl));
0000d0  2230              MOVS     r2,#0x30
0000d2  4930              LDR      r1,|L13.404|
0000d4  481f              LDR      r0,|L13.340|
0000d6  f7fffffe          BL       __aeabi_memcpy4
;;;362        virtual_media[MEDIA_IDX_FAT1].length = VFS_SECTOR_SIZE * mbr.logical_sectors_per_fat;
0000da  491e              LDR      r1,|L13.340|
0000dc  0278              LSLS     r0,r7,#9
;;;363        virtual_media[MEDIA_IDX_FAT2].length = VFS_SECTOR_SIZE * mbr.logical_sectors_per_fat;
0000de  6148              STR      r0,[r1,#0x14]  ; virtual_media
;;;364        // Initialize indexes
;;;365        virtual_media_idx = MEDIA_IDX_COUNT;
0000e0  6208              STR      r0,[r1,#0x20]  ; virtual_media
0000e2  2004              MOVS     r0,#4
;;;366        data_start = 0;
;;;367    
;;;368        for (i = 0; i < ARRAY_SIZE(virtual_media_tmpl); i++) {
0000e4  6165              STR      r5,[r4,#0x14]  ; data_start
0000e6  60a0              STR      r0,[r4,#8]  ; virtual_media_idx
0000e8  2000              MOVS     r0,#0
                  |L13.234|
;;;369            data_start += virtual_media[i].length;
0000ea  eb000240          ADD      r2,r0,r0,LSL #1
0000ee  eb010282          ADD      r2,r1,r2,LSL #2
0000f2  6963              LDR      r3,[r4,#0x14]  ; data_start
0000f4  6892              LDR      r2,[r2,#8]
0000f6  1c40              ADDS     r0,r0,#1
0000f8  441a              ADD      r2,r2,r3
0000fa  6162              STR      r2,[r4,#0x14]         ;368  ; data_start
0000fc  2804              CMP      r0,#4                 ;368
0000fe  d3f4              BCC      |L13.234|
;;;370        }
;;;371    
;;;372        // Initialize FAT
;;;373        fat_idx = 0;
;;;374        write_fat(&fat, fat_idx, 0xFFF8);    // Media type "media_descriptor"
000100  f64f72f8          MOV      r2,#0xfff8
000104  4629              MOV      r1,r5
000106  4811              LDR      r0,|L13.332|
000108  60e5              STR      r5,[r4,#0xc]  ; fat_idx
00010a  f7fffffe          BL       write_fat
;;;375        fat_idx++;
00010e  68e1              LDR      r1,[r4,#0xc]  ; fat_idx
;;;376        write_fat(&fat, fat_idx, 0xFFFF);    // FAT12 - always 0xFFF (no meaning), FAT16 - dirty/clean (clean = 0xFFFF)
000110  f64f72ff          MOV      r2,#0xffff
000114  1c49              ADDS     r1,r1,#1              ;375
000116  480d              LDR      r0,|L13.332|
000118  60e1              STR      r1,[r4,#0xc]  ; fat_idx
00011a  f7fffffe          BL       write_fat
;;;377        fat_idx++;
00011e  68e0              LDR      r0,[r4,#0xc]  ; fat_idx
;;;378        // Initialize root dir
;;;379        dir_idx = 0;
;;;380        dir_current.f[dir_idx] = root_dir_entry;
000120  491c              LDR      r1,|L13.404|
000122  1c40              ADDS     r0,r0,#1              ;377
000124  e9c40503          STRD     r0,r5,[r4,#0xc]       ;377
000128  4d0a              LDR      r5,|L13.340|
00012a  2220              MOVS     r2,#0x20
00012c  35c0              ADDS     r5,r5,#0xc0
00012e  4628              MOV      r0,r5
000130  3130              ADDS     r1,r1,#0x30
000132  f7fffffe          BL       __aeabi_memcpy
;;;381        memcpy(dir_current.f[dir_idx].filename, drive_name, sizeof(dir_current.f[0].filename));
000136  4628              MOV      r0,r5
000138  220b              MOVS     r2,#0xb
00013a  4641              MOV      r1,r8
00013c  f7fffffe          BL       __aeabi_memcpy
;;;382        dir_idx++;
000140  2001              MOVS     r0,#1
000142  6120              STR      r0,[r4,#0x10]  ; dir_idx
;;;383    }
000144  e8bd81f0          POP      {r4-r8,pc}
;;;384    
                          ENDP

                  |L13.328|
                          DCD      ||.bss||
                  |L13.332|
                          DCD      ||.bss||+0x200
                  |L13.336|
                          DCD      ||.data||
                  |L13.340|
                          DCD      ||.bss||+0x400
                  |L13.344|
                          DCD      file_change_cb_stub
                  |L13.348|
                          DCD      ||.constdata||
                  |L13.352|
000160  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
000164  2e5c2e2e
000168  5c736f75
00016c  7263655c
000170  6461706c
000174  696e6b5c
000178  64726167
00017c  2d6e2d64
000180  726f705c
000184  76697274
000188  75616c5f
00018c  66732e63
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L13.404|
                          DCD      ||.constdata||+0x200

                          AREA ||i.vfs_read||, CODE, READONLY, ALIGN=2

                  vfs_read PROC
;;;495    
;;;496    void vfs_read(uint32_t requested_sector, uint8_t *buf, uint32_t num_sectors)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;497    {
000004  468a              MOV      r10,r1
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
;;;498        uint8_t i = 0;
00000a  2600              MOVS     r6,#0
;;;499        uint32_t current_sector;
;;;500        // Zero out the buffer
;;;501        memset(buf, 0, num_sectors * VFS_SECTOR_SIZE);
00000c  0251              LSLS     r1,r2,#9
00000e  4650              MOV      r0,r10
000010  f7fffffe          BL       __aeabi_memclr
;;;502        current_sector = 0;
;;;503    
;;;504        for (i = 0; i < ARRAY_SIZE(virtual_media); i++) {
;;;505            uint32_t vm_sectors = virtual_media[i].length / VFS_SECTOR_SIZE;
000014  f8df9048          LDR      r9,|L14.96|
000018  2000              MOVS     r0,#0                 ;502
                  |L14.26|
00001a  eb060246          ADD      r2,r6,r6,LSL #1
00001e  eb090182          ADD      r1,r9,r2,LSL #2
;;;506            uint32_t vm_start = current_sector;
;;;507            uint32_t vm_end = current_sector + vm_sectors;
;;;508    
;;;509            // Data can be used in this sector
;;;510            if ((requested_sector >= vm_start) && (requested_sector < vm_end)) {
000022  4284              CMP      r4,r0
000024  6889              LDR      r1,[r1,#8]            ;505
000026  eb002151          ADD      r1,r0,r1,LSR #9       ;507
00002a  4688              MOV      r8,r1                 ;507
00002c  d30e              BCC      |L14.76|
00002e  428c              CMP      r4,r1
000030  d20c              BCS      |L14.76|
;;;511                uint32_t sector_offset;
;;;512                uint32_t sectors_to_write = vm_end - requested_sector;
000032  eba80704          SUB      r7,r8,r4
;;;513                sectors_to_write = MIN(sectors_to_write, num_sectors);
000036  42af              CMP      r7,r5
000038  d300              BCC      |L14.60|
00003a  462f              MOV      r7,r5
                  |L14.60|
;;;514                sector_offset = requested_sector - current_sector;
;;;515                virtual_media[i].read_cb(sector_offset, buf, sectors_to_write);
00003c  f8593022          LDR      r3,[r9,r2,LSL #2]
000040  1a20              SUBS     r0,r4,r0              ;514
000042  463a              MOV      r2,r7
000044  4651              MOV      r1,r10
000046  4798              BLX      r3
;;;516                // Update requested sector
;;;517                requested_sector += sectors_to_write;
000048  443c              ADD      r4,r4,r7
;;;518                num_sectors -= sectors_to_write;
00004a  1bed              SUBS     r5,r5,r7
                  |L14.76|
;;;519            }
;;;520    
;;;521            // If there is no more data to be read then break
;;;522            if (num_sectors == 0) {
00004c  2d00              CMP      r5,#0
00004e  d004              BEQ      |L14.90|
000050  1c76              ADDS     r6,r6,#1
000052  b2f6              UXTB     r6,r6                 ;504
000054  4640              MOV      r0,r8
000056  2e10              CMP      r6,#0x10              ;504
000058  d3df              BCC      |L14.26|
                  |L14.90|
;;;523                break;
;;;524            }
;;;525    
;;;526            // Move to the next virtual media entry
;;;527            current_sector += vm_sectors;
;;;528        }
;;;529    }
00005a  e8bd87f0          POP      {r4-r10,pc}
;;;530    
                          ENDP

00005e  0000              DCW      0x0000
                  |L14.96|
                          DCD      ||.bss||+0x400

                          AREA ||i.vfs_set_file_change_callback||, CODE, READONLY, ALIGN=2

                  vfs_set_file_change_callback PROC
;;;490    
;;;491    void vfs_set_file_change_callback(vfs_file_change_cb_t cb)
000000  4901              LDR      r1,|L15.8|
;;;492    {
;;;493        file_change_cb = cb;
000002  6048              STR      r0,[r1,#4]  ; file_change_cb
;;;494    }
000004  4770              BX       lr
;;;495    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.data||

                          AREA ||i.vfs_write||, CODE, READONLY, ALIGN=2

                  vfs_write PROC
;;;530    
;;;531    void vfs_write(uint32_t requested_sector, const uint8_t *buf, uint32_t num_sectors)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;532    {
000004  4604              MOV      r4,r0
;;;533        uint8_t i = 0;
000006  2600              MOVS     r6,#0
000008  4615              MOV      r5,r2                 ;532
00000a  468b              MOV      r11,r1                ;532
;;;534        uint32_t current_sector;
;;;535        current_sector = 0;
00000c  4630              MOV      r0,r6
;;;536    
;;;537        for (i = 0; i < virtual_media_idx; i++) {
;;;538            uint32_t vm_sectors = virtual_media[i].length / VFS_SECTOR_SIZE;
00000e  f8df9050          LDR      r9,|L16.96|
000012  f8dfa050          LDR      r10,|L16.100|
000016  e01c              B        |L16.82|
                  |L16.24|
000018  eb060246          ADD      r2,r6,r6,LSL #1
00001c  eb090282          ADD      r2,r9,r2,LSL #2
;;;539            uint32_t vm_start = current_sector;
;;;540            uint32_t vm_end = current_sector + vm_sectors;
;;;541    
;;;542            // Data can be used in this sector
;;;543            if ((requested_sector >= vm_start) && (requested_sector < vm_end)) {
000020  4284              CMP      r4,r0
000022  6891              LDR      r1,[r2,#8]            ;540
000024  eb002151          ADD      r1,r0,r1,LSR #9       ;540
000028  4688              MOV      r8,r1                 ;540
00002a  d30d              BCC      |L16.72|
00002c  428c              CMP      r4,r1
00002e  d20b              BCS      |L16.72|
;;;544                uint32_t sector_offset;
;;;545                uint32_t sectors_to_read = vm_end - requested_sector;
000030  eba80704          SUB      r7,r8,r4
;;;546                sectors_to_read = MIN(sectors_to_read, num_sectors);
000034  42af              CMP      r7,r5
000036  d300              BCC      |L16.58|
000038  462f              MOV      r7,r5
                  |L16.58|
;;;547                sector_offset = requested_sector - current_sector;
;;;548                virtual_media[i].write_cb(sector_offset, buf, sectors_to_read);
00003a  6853              LDR      r3,[r2,#4]
00003c  1a20              SUBS     r0,r4,r0              ;547
00003e  463a              MOV      r2,r7
000040  4659              MOV      r1,r11
000042  4798              BLX      r3
;;;549                // Update requested sector
;;;550                requested_sector += sectors_to_read;
000044  443c              ADD      r4,r4,r7
;;;551                num_sectors -= sectors_to_read;
000046  1bed              SUBS     r5,r5,r7
                  |L16.72|
;;;552            }
;;;553    
;;;554            // If there is no more data to be read then break
;;;555            if (num_sectors == 0) {
000048  2d00              CMP      r5,#0
00004a  d006              BEQ      |L16.90|
00004c  1c76              ADDS     r6,r6,#1
00004e  4640              MOV      r0,r8
000050  b2f6              UXTB     r6,r6                 ;537
                  |L16.82|
000052  f8da1008          LDR      r1,[r10,#8]           ;537  ; virtual_media_idx
000056  428e              CMP      r6,r1                 ;537
000058  d3de              BCC      |L16.24|
                  |L16.90|
;;;556                break;
;;;557            }
;;;558    
;;;559            // Move to the next virtual media entry
;;;560            current_sector += vm_sectors;
;;;561        }
;;;562    }
00005a  e8bd9ff0          POP      {r4-r12,pc}
;;;563    
                          ENDP

00005e  0000              DCW      0x0000
                  |L16.96|
                          DCD      ||.bss||+0x400
                  |L16.100|
                          DCD      ||.data||

                          AREA ||i.write_dir||, CODE, READONLY, ALIGN=2

                  write_dir PROC
;;;626    
;;;627    static void write_dir(uint32_t sector_offset, const uint8_t *data, uint32_t num_sectors)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;628    {
000004  4689              MOV      r9,r1
;;;629        FatDirectoryEntry_t *old_entry;
;;;630        FatDirectoryEntry_t *new_entry;
;;;631        uint32_t start_index;
;;;632        uint32_t num_entries;
;;;633        uint32_t i;
;;;634    
;;;635        if ((sector_offset + num_sectors) * VFS_SECTOR_SIZE > sizeof(dir_current)) {
000006  1881              ADDS     r1,r0,r2
000008  f44f6380          MOV      r3,#0x400
00000c  ebb32f41          CMP      r3,r1,LSL #9
000010  d207              BCS      |L17.34|
;;;636            // Trying to write too much of the root directory
;;;637            util_assert(0);
000012  e8bd4ff8          POP      {r3-r11,lr}
000016  f240227d          MOV      r2,#0x27d
00001a  a127              ADR      r1,|L17.184|
00001c  2000              MOVS     r0,#0
00001e  f7ffbffe          B.W      _util_assert
                  |L17.34|
;;;638            return;
;;;639        }
;;;640    
;;;641        start_index = sector_offset * VFS_SECTOR_SIZE / sizeof(FatDirectoryEntry_t);
000022  0241              LSLS     r1,r0,#9
000024  094b              LSRS     r3,r1,#5
;;;642        num_entries = num_sectors * VFS_SECTOR_SIZE / sizeof(FatDirectoryEntry_t);
000026  0251              LSLS     r1,r2,#9
000028  ea4f1b51          LSR      r11,r1,#5
;;;643        old_entry = &dir_current.f[start_index];
00002c  9100              STR      r1,[sp,#0]
00002e  492f              LDR      r1,|L17.236|
000030  eb011a43          ADD      r10,r1,r3,LSL #5
;;;644        new_entry = (FatDirectoryEntry_t *)data;
;;;645        // If this is the first sector start at index 1 to get past drive name
;;;646        i = 0 == sector_offset ? 1 : 0;
000034  b110              CBZ      r0,|L17.60|
000036  2600              MOVS     r6,#0
                  |L17.56|
;;;647    
;;;648        for (; i < num_entries; i++) {
;;;649            bool same_name;
;;;650    
;;;651            if (0 == memcmp(&old_entry[i], &new_entry[i], sizeof(FatDirectoryEntry_t))) {
;;;652                continue;
;;;653            }
;;;654    
;;;655            // If were at this point then something has changed in the file
;;;656            same_name = (0 == memcmp(old_entry[i].filename, new_entry[i].filename, sizeof(new_entry[i].filename))) ? 1 : 0;
;;;657            // Changed
;;;658            file_change_cb(new_entry[i].filename, VFS_FILE_CHANGED, (vfs_file_t)&old_entry[i], (vfs_file_t)&new_entry[i]);
000038  4f2d              LDR      r7,|L17.240|
00003a  e033              B        |L17.164|
                  |L17.60|
00003c  2601              MOVS     r6,#1                 ;646
00003e  e7fb              B        |L17.56|
                  |L17.64|
000040  eb091446          ADD      r4,r9,r6,LSL #5       ;651
000044  eb0a1546          ADD      r5,r10,r6,LSL #5      ;651
000048  2220              MOVS     r2,#0x20              ;651
00004a  4621              MOV      r1,r4                 ;651
00004c  4628              MOV      r0,r5                 ;651
00004e  f7fffffe          BL       memcmp
000052  b330              CBZ      r0,|L17.162|
000054  4621              MOV      r1,r4                 ;651
000056  4628              MOV      r0,r5                 ;651
000058  220b              MOVS     r2,#0xb               ;656
00005a  f7fffffe          BL       memcmp
00005e  b178              CBZ      r0,|L17.128|
000060  2000              MOVS     r0,#0                 ;656
                  |L17.98|
000062  4680              MOV      r8,r0                 ;656
000064  f8d7c004          LDR      r12,[r7,#4]  ; file_change_cb
000068  4623              MOV      r3,r4
00006a  462a              MOV      r2,r5
00006c  4620              MOV      r0,r4
00006e  2102              MOVS     r1,#2
000070  47e0              BLX      r12
;;;659    
;;;660            // Deleted
;;;661            if (0xe5 == (uint8_t)new_entry[i].filename[0]) {
000072  7820              LDRB     r0,[r4,#0]
000074  28e5              CMP      r0,#0xe5
000076  d005              BEQ      |L17.132|
;;;662                file_change_cb(old_entry[i].filename, VFS_FILE_DELETED, (vfs_file_t)&old_entry[i], (vfs_file_t)&new_entry[i]);
;;;663                continue;
;;;664            }
;;;665    
;;;666            // Created
;;;667            if (!same_name && filename_valid(new_entry[i].filename)) {
000078  f1b80f00          CMP      r8,#0
00007c  d007              BEQ      |L17.142|
00007e  e010              B        |L17.162|
                  |L17.128|
000080  2001              MOVS     r0,#1                 ;656
000082  e7ee              B        |L17.98|
                  |L17.132|
000084  462a              MOV      r2,r5                 ;656
000086  4623              MOV      r3,r4                 ;656
000088  4610              MOV      r0,r2                 ;656
00008a  2101              MOVS     r1,#1                 ;662
00008c  e007              B        |L17.158|
                  |L17.142|
00008e  4620              MOV      r0,r4                 ;663
000090  f7fffffe          BL       filename_valid
000094  b128              CBZ      r0,|L17.162|
000096  4623              MOV      r3,r4
000098  462a              MOV      r2,r5
00009a  4618              MOV      r0,r3
;;;668                file_change_cb(new_entry[i].filename, VFS_FILE_CREATED, (vfs_file_t)&old_entry[i], (vfs_file_t)&new_entry[i]);
00009c  2100              MOVS     r1,#0
                  |L17.158|
00009e  687c              LDR      r4,[r7,#4]  ; file_change_cb
0000a0  47a0              BLX      r4
                  |L17.162|
0000a2  1c76              ADDS     r6,r6,#1
                  |L17.164|
0000a4  455e              CMP      r6,r11                ;648
0000a6  d3cb              BCC      |L17.64|
0000a8  4650              MOV      r0,r10                ;648
;;;669                continue;
;;;670            }
;;;671        }
;;;672    
;;;673        memcpy(&dir_current.f[start_index], data, num_sectors * VFS_SECTOR_SIZE);
0000aa  4649              MOV      r1,r9
0000ac  9a00              LDR      r2,[sp,#0]
0000ae  e8bd4ff8          POP      {r3-r11,lr}
0000b2  f7ffbffe          B.W      __aeabi_memcpy
;;;674    }
;;;675    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L17.184|
0000b8  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
0000bc  2e5c2e2e
0000c0  5c736f75
0000c4  7263655c
0000c8  6461706c
0000cc  696e6b5c
0000d0  64726167
0000d4  2d6e2d64
0000d8  726f705c
0000dc  76697274
0000e0  75616c5f
0000e4  66732e63
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L17.236|
                          DCD      ||.bss||+0x4c0
                  |L17.240|
                          DCD      ||.data||

                          AREA ||i.write_fat||, CODE, READONLY, ALIGN=2

                  write_fat PROC
;;;304    
;;;305    static void write_fat(file_allocation_table_t *fat, uint32_t idx, uint16_t val)
000000  b430              PUSH     {r4,r5}
;;;306    {
;;;307        uint32_t low_idx;
;;;308        uint32_t high_idx;
;;;309        low_idx = idx * 2 + 0;
000002  004b              LSLS     r3,r1,#1
;;;310        high_idx = idx * 2 + 1;
000004  2401              MOVS     r4,#1
000006  eb040141          ADD      r1,r4,r1,LSL #1
;;;311    
;;;312        // Assert that this is still within the fat table
;;;313        if (high_idx >= ARRAY_SIZE(fat->f)) {
00000a  f5b17f00          CMP      r1,#0x200
00000e  d306              BCC      |L18.30|
;;;314            util_assert(0);
000010  bc30              POP      {r4,r5}
000012  f44f729d          MOV      r2,#0x13a
000016  a104              ADR      r1,|L18.40|
000018  2000              MOVS     r0,#0
00001a  f7ffbffe          B.W      _util_assert
                  |L18.30|
;;;315            return;
;;;316        }
;;;317    
;;;318        fat->f[low_idx] = (val >> 0) & 0xFF;
00001e  54c2              STRB     r2,[r0,r3]
;;;319        fat->f[high_idx] = (val >> 8) & 0xFF;
000020  0a12              LSRS     r2,r2,#8
000022  5442              STRB     r2,[r0,r1]
;;;320    }
000024  bc30              POP      {r4,r5}
000026  4770              BX       lr
;;;321    
                          ENDP

                  |L18.40|
000028  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
00002c  2e5c2e2e
000030  5c736f75
000034  7263655c
000038  6461706c
00003c  696e6b5c
000040  64726167
000044  2d6e2d64
000048  726f705c
00004c  76697274
000050  75616c5f
000054  66732e63
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.write_none||, CODE, READONLY, ALIGN=1

                  write_none PROC
;;;570    
;;;571    static void write_none(uint32_t sector_offset, const uint8_t *data, uint32_t num_sectors)
000000  4770              BX       lr
;;;572    {
;;;573        // Do nothing
;;;574    }
;;;575    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mbr
                          %        512
                  ||fat||
                          %        512
                  virtual_media
                          %        192
                  dir_current
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  mbr_tmpl
000000  eb3c904d          DCB      0xeb,0x3c,0x90,0x4d
000004  53443053          DCB      0x53,0x44,0x30,0x53
000008  342e31            DCB      0x34,0x2e,0x31
00000b  0200              DCWU     0x0200
00000d  08                DCB      0x08
00000e  0001              DCW      0x0001
000010  02                DCB      0x02
000011  0020              DCWU     0x0020
000013  1f50              DCWU     0x1f50
000015  f8                DCB      0xf8
000016  0001              DCW      0x0001
000018  00010001          DCW      0x0001,0x0001
                          DCD      0x00000000
                          DCD      0x00000000
000024  000029            DCB      0x00,0x00,0x29
                          DCDU     0x27021974
00002b  44                DCB      0x44
00002c  41504c49          DCB      0x41,0x50,0x4c,0x49
000030  4e4b2d44          DCB      0x4e,0x4b,0x2d,0x44
000034  4e444641          DCB      0x4e,0x44,0x46,0x41
000038  54313620          DCB      0x54,0x31,0x36,0x20
00003c  2020fab8          DCB      0x20,0x20,0xfa,0xb8
000040  c0070520          DCB      0xc0,0x07,0x05,0x20
000044  018ed0bc          DCB      0x01,0x8e,0xd0,0xbc
000048  0010b8c0          DCB      0x00,0x10,0xb8,0xc0
00004c  078ed8be          DCB      0x07,0x8e,0xd8,0xbe
000050  6d00e80b          DCB      0x6d,0x00,0xe8,0x0b
000054  00ebfeb4          DCB      0x00,0xeb,0xfe,0xb4
000058  0eb700b3          DCB      0x0e,0xb7,0x00,0xb3
00005c  07cd10c3          DCB      0x07,0xcd,0x10,0xc3
000060  8a044608          DCB      0x8a,0x04,0x46,0x08
000064  c07405e8          DCB      0xc0,0x74,0x05,0xe8
000068  edffebf4          DCB      0xed,0xff,0xeb,0xf4
00006c  c3504c45          DCB      0xc3,0x50,0x4c,0x45
000070  41534520          DCB      0x41,0x53,0x45,0x20
000074  52454d4f          DCB      0x52,0x45,0x4d,0x4f
000078  56452054          DCB      0x56,0x45,0x20,0x54
00007c  48452041          DCB      0x48,0x45,0x20,0x41
000080  524d204d          DCB      0x52,0x4d,0x20,0x4d
000084  42454420          DCB      0x42,0x45,0x44,0x20
000088  4441504c          DCB      0x44,0x41,0x50,0x4c
00008c  494e4b20          DCB      0x49,0x4e,0x4b,0x20
000090  55534220          DCB      0x55,0x53,0x42,0x20
000094  44455649          DCB      0x44,0x45,0x56,0x49
000098  43452041          DCB      0x43,0x45,0x20,0x41
00009c  4e442052          DCB      0x4e,0x44,0x20,0x52
0000a0  45424f4f          DCB      0x45,0x42,0x4f,0x4f
0000a4  54205448          DCB      0x54,0x20,0x54,0x48
0000a8  45205359          DCB      0x45,0x20,0x53,0x59
0000ac  5354454d          DCB      0x53,0x54,0x45,0x4d
0000b0  2e2e0000          DCB      0x2e,0x2e,0x00,0x00
0000b4  00000000          DCB      0x00,0x00,0x00,0x00
0000b8  00000000          DCB      0x00,0x00,0x00,0x00
0000bc  00000000          DCB      0x00,0x00,0x00,0x00
0000c0  00000000          DCB      0x00,0x00,0x00,0x00
0000c4  00000000          DCB      0x00,0x00,0x00,0x00
0000c8  00000000          DCB      0x00,0x00,0x00,0x00
0000cc  00000000          DCB      0x00,0x00,0x00,0x00
0000d0  00000000          DCB      0x00,0x00,0x00,0x00
0000d4  00000000          DCB      0x00,0x00,0x00,0x00
0000d8  00000000          DCB      0x00,0x00,0x00,0x00
0000dc  00000000          DCB      0x00,0x00,0x00,0x00
0000e0  00000000          DCB      0x00,0x00,0x00,0x00
0000e4  00000000          DCB      0x00,0x00,0x00,0x00
0000e8  00000000          DCB      0x00,0x00,0x00,0x00
0000ec  00000000          DCB      0x00,0x00,0x00,0x00
0000f0  00000000          DCB      0x00,0x00,0x00,0x00
0000f4  00000000          DCB      0x00,0x00,0x00,0x00
0000f8  00000000          DCB      0x00,0x00,0x00,0x00
0000fc  00000000          DCB      0x00,0x00,0x00,0x00
000100  00000000          DCB      0x00,0x00,0x00,0x00
000104  00000000          DCB      0x00,0x00,0x00,0x00
000108  00000000          DCB      0x00,0x00,0x00,0x00
00010c  00000000          DCB      0x00,0x00,0x00,0x00
000110  00000000          DCB      0x00,0x00,0x00,0x00
000114  00000000          DCB      0x00,0x00,0x00,0x00
000118  00000000          DCB      0x00,0x00,0x00,0x00
00011c  00000000          DCB      0x00,0x00,0x00,0x00
000120  00000000          DCB      0x00,0x00,0x00,0x00
000124  00000000          DCB      0x00,0x00,0x00,0x00
000128  00000000          DCB      0x00,0x00,0x00,0x00
00012c  00000000          DCB      0x00,0x00,0x00,0x00
000130  00000000          DCB      0x00,0x00,0x00,0x00
000134  00000000          DCB      0x00,0x00,0x00,0x00
000138  00000000          DCB      0x00,0x00,0x00,0x00
00013c  00000000          DCB      0x00,0x00,0x00,0x00
000140  00000000          DCB      0x00,0x00,0x00,0x00
000144  00000000          DCB      0x00,0x00,0x00,0x00
000148  00000000          DCB      0x00,0x00,0x00,0x00
00014c  00000000          DCB      0x00,0x00,0x00,0x00
000150  00000000          DCB      0x00,0x00,0x00,0x00
000154  00000000          DCB      0x00,0x00,0x00,0x00
000158  00000000          DCB      0x00,0x00,0x00,0x00
00015c  00000000          DCB      0x00,0x00,0x00,0x00
000160  00000000          DCB      0x00,0x00,0x00,0x00
000164  00000000          DCB      0x00,0x00,0x00,0x00
000168  00000000          DCB      0x00,0x00,0x00,0x00
00016c  00000000          DCB      0x00,0x00,0x00,0x00
000170  00000000          DCB      0x00,0x00,0x00,0x00
000174  00000000          DCB      0x00,0x00,0x00,0x00
000178  00000000          DCB      0x00,0x00,0x00,0x00
00017c  00000000          DCB      0x00,0x00,0x00,0x00
000180  00000000          DCB      0x00,0x00,0x00,0x00
000184  00000000          DCB      0x00,0x00,0x00,0x00
000188  00000000          DCB      0x00,0x00,0x00,0x00
00018c  00000000          DCB      0x00,0x00,0x00,0x00
000190  00000000          DCB      0x00,0x00,0x00,0x00
000194  00000000          DCB      0x00,0x00,0x00,0x00
000198  00000000          DCB      0x00,0x00,0x00,0x00
00019c  00000000          DCB      0x00,0x00,0x00,0x00
0001a0  00000000          DCB      0x00,0x00,0x00,0x00
0001a4  00000000          DCB      0x00,0x00,0x00,0x00
0001a8  00000000          DCB      0x00,0x00,0x00,0x00
0001ac  00000000          DCB      0x00,0x00,0x00,0x00
0001b0  00000000          DCB      0x00,0x00,0x00,0x00
0001b4  00000000          DCB      0x00,0x00,0x00,0x00
0001b8  00000000          DCB      0x00,0x00,0x00,0x00
0001bc  00000000          DCB      0x00,0x00,0x00,0x00
0001c0  00000000          DCB      0x00,0x00,0x00,0x00
0001c4  00000000          DCB      0x00,0x00,0x00,0x00
0001c8  00000000          DCB      0x00,0x00,0x00,0x00
0001cc  00000000          DCB      0x00,0x00,0x00,0x00
0001d0  00000000          DCB      0x00,0x00,0x00,0x00
0001d4  00000000          DCB      0x00,0x00,0x00,0x00
0001d8  00000000          DCB      0x00,0x00,0x00,0x00
0001dc  00000000          DCB      0x00,0x00,0x00,0x00
0001e0  00000000          DCB      0x00,0x00,0x00,0x00
0001e4  00000000          DCB      0x00,0x00,0x00,0x00
0001e8  00000000          DCB      0x00,0x00,0x00,0x00
0001ec  00000000          DCB      0x00,0x00,0x00,0x00
0001f0  00000000          DCB      0x00,0x00,0x00,0x00
0001f4  00000000          DCB      0x00,0x00,0x00,0x00
0001f8  00000000          DCB      0x00,0x00,0x00,0x00
0001fc  0000              DCB      0x00,0x00
0001fe  aa55              DCW      0xaa55
                  virtual_media_tmpl
                          DCD      read_mbr
                          DCD      write_none
                          DCD      0x00000200
                          DCD      read_fat
                          DCD      write_none
                          DCD      0x00000000
                          DCD      read_fat
                          DCD      write_none
                          DCD      0x00000000
                          DCD      read_dir
                          DCD      write_dir
                          DCD      0x00000400
                  root_dir_entry
000230  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000238  00000028          DCB      0x00,0x00,0x00,0x28
00023c  0000              DCB      0x00,0x00
00023e  0000              DCW      0x0000
000240  00000000          DCW      0x0000,0x0000
000244  00008e41          DCW      0x0000,0x8e41
000248  32bb0000          DCW      0x32bb,0x0000
                          DCD      0x00000000
                  dir_entry_tmpl
000250  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000258  00000001          DCB      0x00,0x00,0x00,0x01
00025c  0000              DCB      0x00,0x00
00025e  0000              DCW      0x0000
000260  48764876          DCW      0x4876,0x4876
000264  000083dc          DCW      0x0000,0x83dc
000268  48760000          DCW      0x4876,0x0000
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  file_count
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  file_change_cb
                          DCD      0x00000000
                  virtual_media_idx
                          DCD      0x00000000
                  fat_idx
                          DCD      0x00000000
                  dir_idx
                          DCD      0x00000000
                  data_start
                          DCD      0x00000000
