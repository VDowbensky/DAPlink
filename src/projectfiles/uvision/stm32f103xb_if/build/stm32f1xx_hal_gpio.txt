; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\stm32f1xx_hal_gpio.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f1xx_hal_gpio.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\stm32f1xx_hal_gpio.crf ..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;366      */
;;;367    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;368    { 
;;;369      uint32_t position = 0x00;
000004  2200              MOVS     r2,#0
;;;370      uint32_t iocurrent = 0x00;
;;;371      uint32_t tmp = 0x00;
;;;372      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;373      uint32_t registeroffset = 0;
;;;374     
;;;375      /* Check the parameters */
;;;376      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;377      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;378    
;;;379      /* Configure the port pins */
;;;380      while ((GPIO_Pin >> position) != 0)
;;;381      {
;;;382        /* Get current io position */
;;;383        iocurrent = (GPIO_Pin) & ((uint32_t)1 << position);
;;;384    
;;;385        if (iocurrent)
;;;386        {
;;;387          /*------------------------- GPIO Mode Configuration --------------------*/
;;;388          /* Check if the current bit belongs to first half or last half of the pin count number
;;;389           in order to address CRH or CRL register */
;;;390          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
;;;391          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
;;;392          
;;;393          /* CRL/CRH default value is floating input(0x04) shifted to correct position */
;;;394          MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), GPIO_CRL_CNF0_0 << registeroffset);
000006  270f              MOVS     r7,#0xf
;;;395          
;;;396          /* ODR default value is 0 */
;;;397          CLEAR_BIT(GPIOx->ODR, iocurrent);
;;;398          
;;;399          /*------------------------- EXTI Mode Configuration --------------------*/
;;;400          /* Clear the External Interrupt or Event for the current IO */
;;;401          
;;;402          tmp = AFIO->EXTICR[position >> 2];
000008  f8df90c0          LDR      r9,|L1.204|
00000c  e059              B        |L1.194|
                  |L1.14|
00000e  2301              MOVS     r3,#1                 ;383
000010  4093              LSLS     r3,r3,r2              ;383
000012  400b              ANDS     r3,r3,r1              ;383
000014  d054              BEQ      |L1.192|
000016  2bff              CMP      r3,#0xff              ;390
000018  d801              BHI      |L1.30|
00001a  4605              MOV      r5,r0                 ;390
00001c  e001              B        |L1.34|
                  |L1.30|
00001e  f1000504          ADD      r5,r0,#4              ;390
                  |L1.34|
000022  ea4f0482          LSL      r4,r2,#2              ;391
000026  d901              BLS      |L1.44|
000028  f1a40420          SUB      r4,r4,#0x20           ;391
                  |L1.44|
00002c  f8d5c000          LDR      r12,[r5,#0]           ;394
000030  fa07f804          LSL      r8,r7,r4              ;394
000034  ea2c0c08          BIC      r12,r12,r8            ;394
000038  f04f0804          MOV      r8,#4                 ;394
00003c  fa08f804          LSL      r8,r8,r4              ;394
000040  ea4c0c08          ORR      r12,r12,r8            ;394
000044  f8c5c000          STR      r12,[r5,#0]           ;394
000048  68c4              LDR      r4,[r0,#0xc]          ;397
00004a  ea240403          BIC      r4,r4,r3              ;397
00004e  60c4              STR      r4,[r0,#0xc]          ;397
000050  f0220503          BIC      r5,r2,#3
000054  444d              ADD      r5,r5,r9
000056  68ac              LDR      r4,[r5,#8]
;;;403          tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
000058  ea4f7c82          LSL      r12,r2,#30
00005c  ea4f7c1c          LSR      r12,r12,#28
000060  fa07f60c          LSL      r6,r7,r12
000064  ea060804          AND      r8,r6,r4
;;;404          if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
000068  4c19              LDR      r4,|L1.208|
00006a  42a0              CMP      r0,r4
00006c  d101              BNE      |L1.114|
00006e  2400              MOVS     r4,#0
000070  e00f              B        |L1.146|
                  |L1.114|
000072  4c18              LDR      r4,|L1.212|
000074  42a0              CMP      r0,r4
000076  d101              BNE      |L1.124|
000078  2401              MOVS     r4,#1
00007a  e00a              B        |L1.146|
                  |L1.124|
00007c  4c16              LDR      r4,|L1.216|
00007e  42a0              CMP      r0,r4
000080  d101              BNE      |L1.134|
000082  2402              MOVS     r4,#2
000084  e005              B        |L1.146|
                  |L1.134|
000086  4c15              LDR      r4,|L1.220|
000088  42a0              CMP      r0,r4
00008a  d101              BNE      |L1.144|
00008c  2403              MOVS     r4,#3
00008e  e000              B        |L1.146|
                  |L1.144|
000090  2404              MOVS     r4,#4
                  |L1.146|
000092  fa04f40c          LSL      r4,r4,r12
000096  4544              CMP      r4,r8
000098  d112              BNE      |L1.192|
;;;405          {
;;;406            tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
;;;407            CLEAR_BIT(AFIO->EXTICR[position >> 2], tmp);
00009a  68ac              LDR      r4,[r5,#8]
00009c  43b4              BICS     r4,r4,r6
00009e  60ac              STR      r4,[r5,#8]
;;;408              
;;;409            /* Clear EXTI line configuration */
;;;410            CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
0000a0  4c0f              LDR      r4,|L1.224|
0000a2  6825              LDR      r5,[r4,#0]
0000a4  439d              BICS     r5,r5,r3
0000a6  6025              STR      r5,[r4,#0]
;;;411            CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
0000a8  1d24              ADDS     r4,r4,#4
0000aa  6825              LDR      r5,[r4,#0]
0000ac  439d              BICS     r5,r5,r3
0000ae  6025              STR      r5,[r4,#0]
;;;412            
;;;413            /* Clear Rising Falling edge configuration */
;;;414            CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
0000b0  1d24              ADDS     r4,r4,#4
0000b2  6825              LDR      r5,[r4,#0]
0000b4  439d              BICS     r5,r5,r3
0000b6  6025              STR      r5,[r4,#0]
;;;415            CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
0000b8  1d24              ADDS     r4,r4,#4
0000ba  6825              LDR      r5,[r4,#0]
0000bc  439d              BICS     r5,r5,r3
0000be  6025              STR      r5,[r4,#0]
                  |L1.192|
0000c0  1c52              ADDS     r2,r2,#1
                  |L1.194|
0000c2  fa31f302          LSRS     r3,r1,r2              ;380
0000c6  d1a2              BNE      |L1.14|
;;;416          }
;;;417        }
;;;418        
;;;419        position++;
;;;420      }
;;;421    }
0000c8  e8bd83f0          POP      {r4-r9,pc}
;;;422    
                          ENDP

                  |L1.204|
                          DCD      0x40010000
                  |L1.208|
                          DCD      0x40010800
                  |L1.212|
                          DCD      0x40010c00
                  |L1.216|
                          DCD      0x40011000
                  |L1.220|
                          DCD      0x40011400
                  |L1.224|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;569      */
;;;570    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;571    {
;;;572      /* Prevent unused argument(s) compilation warning */
;;;573      UNUSED(GPIO_Pin);
;;;574      /* NOTE : This function Should not be modified, when the callback is needed,
;;;575                the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;576       */ 
;;;577    }
;;;578    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;554      */
;;;555    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  4904              LDR      r1,|L3.20|
;;;556    {
000002  b510              PUSH     {r4,lr}
;;;557      /* EXTI line interrupt detected */
;;;558      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
000004  680a              LDR      r2,[r1,#0]
000006  4202              TST      r2,r0
000008  d002              BEQ      |L3.16|
;;;559      { 
;;;560        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000a  6008              STR      r0,[r1,#0]
;;;561        HAL_GPIO_EXTI_Callback(GPIO_Pin);
00000c  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.16|
;;;562      }
;;;563    }
000010  bd10              POP      {r4,pc}
;;;564    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40010414

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;195      */
;;;196    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;197    {
;;;198      uint32_t position;
;;;199      uint32_t ioposition = 0x00;
;;;200      uint32_t iocurrent = 0x00;
;;;201      uint32_t temp = 0x00;
;;;202      uint32_t config = 0x00;
;;;203      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;204      uint32_t registeroffset = 0; /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */
;;;205      
;;;206      /* Check the parameters */
;;;207      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;208      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;209      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;210    
;;;211      /* Configure the port pins */
;;;212      for (position = 0; position < GPIO_NUMBER; position++)
;;;213      {
;;;214        /* Get the IO position */
;;;215        ioposition = ((uint32_t)0x01) << position;
;;;216        
;;;217        /* Get the current IO position */
;;;218        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
;;;219    
;;;220        if (iocurrent == ioposition)
;;;221        {
;;;222          /* Check the Alternate function parameters */
;;;223          assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
;;;224    
;;;225          /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
;;;226          switch (GPIO_Init->Mode)
;;;227          {
;;;228            /* If we are configuring the pin in OUTPUT push-pull mode */
;;;229            case GPIO_MODE_OUTPUT_PP:
;;;230              /* Check the GPIO speed parameter */
;;;231              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;232              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
;;;233              break;
;;;234              
;;;235            /* If we are configuring the pin in OUTPUT open-drain mode */
;;;236            case GPIO_MODE_OUTPUT_OD:
;;;237              /* Check the GPIO speed parameter */
;;;238              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;239              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
;;;240              break;
;;;241              
;;;242            /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
;;;243            case GPIO_MODE_AF_PP:
;;;244              /* Check the GPIO speed parameter */
;;;245              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;246              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
;;;247              break;
;;;248              
;;;249            /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
;;;250            case GPIO_MODE_AF_OD:
;;;251              /* Check the GPIO speed parameter */
;;;252              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;253              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
;;;254              break;
;;;255              
;;;256            /* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */
;;;257            case GPIO_MODE_INPUT:
;;;258            case GPIO_MODE_IT_RISING:
;;;259            case GPIO_MODE_IT_FALLING:
;;;260            case GPIO_MODE_IT_RISING_FALLING:
;;;261            case GPIO_MODE_EVT_RISING:
;;;262            case GPIO_MODE_EVT_FALLING:
;;;263            case GPIO_MODE_EVT_RISING_FALLING:
;;;264              /* Check the GPIO pull parameter */
;;;265              assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;266              if(GPIO_Init->Pull == GPIO_NOPULL)
;;;267              {  
;;;268                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
;;;269              }
;;;270              else if(GPIO_Init->Pull == GPIO_PULLUP)
;;;271              {
;;;272                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;273                
;;;274                /* Set the corresponding ODR bit */
;;;275                GPIOx->BSRR = ioposition;
;;;276              }
;;;277              else /* GPIO_PULLDOWN */
;;;278              {
;;;279                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;280                
;;;281                /* Reset the corresponding ODR bit */
;;;282                GPIOx->BRR = ioposition;
;;;283              }
;;;284              break; 
;;;285              
;;;286            /* If we are configuring the pin in INPUT analog mode */
;;;287            case GPIO_MODE_ANALOG:
;;;288                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
;;;289              break;
;;;290            
;;;291            /* Parameters are checked with assert_param */
;;;292            default:
;;;293              break;
;;;294          }
;;;295          
;;;296          /* Check if the current bit belongs to first half or last half of the pin count number
;;;297           in order to address CRH or CRL register*/
;;;298          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
;;;299          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
;;;300          
;;;301          /* Apply the new configuration of the pin to the register */
;;;302          MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), (config << registeroffset));
;;;303          
;;;304          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;305          /* Configure the External Interrupt or event for the current IO */
;;;306          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
;;;307          {
;;;308            /* Enable AFIO Clock */
;;;309            __HAL_RCC_AFIO_CLK_ENABLE();
;;;310            temp = AFIO->EXTICR[position >> 2];
;;;311            CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
;;;312            SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
;;;313            AFIO->EXTICR[position >> 2] = temp;
;;;314            
;;;315    
;;;316            /* Configure the interrupt mask */
;;;317            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
;;;318            {
;;;319              SET_BIT(EXTI->IMR, iocurrent); 
000004  f8df91a0          LDR      r9,|L4.424|
000008  2300              MOVS     r3,#0                 ;202
;;;320            } 
;;;321            else
;;;322            {
;;;323              CLEAR_BIT(EXTI->IMR, iocurrent); 
;;;324            } 
;;;325            
;;;326            /* Configure the event mask */
;;;327            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
;;;328            {
;;;329              SET_BIT(EXTI->EMR, iocurrent); 
00000a  f1090a04          ADD      r10,r9,#4
;;;330            } 
;;;331            else
;;;332            {
;;;333              CLEAR_BIT(EXTI->EMR, iocurrent); 
;;;334            }
;;;335            
;;;336            /* Enable or disable the rising trigger */
;;;337            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
;;;338            {
;;;339              SET_BIT(EXTI->RTSR, iocurrent); 
00000e  f10a0b04          ADD      r11,r10,#4
000012  461c              MOV      r4,r3                 ;212
000014  f04f080f          MOV      r8,#0xf               ;302
;;;340            } 
;;;341            else
;;;342            {
;;;343              CLEAR_BIT(EXTI->RTSR, iocurrent); 
;;;344            }
;;;345            
;;;346            /* Enable or disable the falling trigger */
;;;347            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
;;;348            {
;;;349              SET_BIT(EXTI->FTSR, iocurrent); 
000018  f10b0e04          ADD      lr,r11,#4
                  |L4.28|
00001c  2701              MOVS     r7,#1                 ;215
00001e  680a              LDR      r2,[r1,#0]            ;218
000020  40a7              LSLS     r7,r7,r4              ;215
000022  403a              ANDS     r2,r2,r7              ;218
000024  42ba              CMP      r2,r7                 ;220
000026  d172              BNE      |L4.270|
000028  f8dfc180          LDR      r12,|L4.428|
00002c  684d              LDR      r5,[r1,#4]            ;226
00002e  eba5060c          SUB      r6,r5,r12             ;226
000032  4565              CMP      r5,r12                ;226
000034  d02b              BEQ      |L4.142|
000036  dc0d              BGT      |L4.84|
000038  2d03              CMP      r5,#3                 ;226
00003a  d034              BEQ      |L4.166|
00003c  dc05              BGT      |L4.74|
00003e  b335              CBZ      r5,|L4.142|
000040  2d01              CMP      r5,#1                 ;226
000042  d019              BEQ      |L4.120|
000044  2d02              CMP      r5,#2                 ;226
000046  d12f              BNE      |L4.168|
000048  e01b              B        |L4.130|
                  |L4.74|
00004a  2d11              CMP      r5,#0x11              ;226
00004c  d016              BEQ      |L4.124|
00004e  2d12              CMP      r5,#0x12              ;226
000050  d12a              BNE      |L4.168|
000052  e019              B        |L4.136|
                  |L4.84|
000054  f5b61f88          CMP      r6,#0x110000          ;226
000058  d019              BEQ      |L4.142|
00005a  dc06              BGT      |L4.106|
00005c  f5b63f80          CMP      r6,#0x10000           ;226
000060  d015              BEQ      |L4.142|
000062  f5b61f80          CMP      r6,#0x100000          ;226
000066  d11f              BNE      |L4.168|
000068  e011              B        |L4.142|
                  |L4.106|
00006a  f5b61f00          CMP      r6,#0x200000          ;226
00006e  d00e              BEQ      |L4.142|
000070  f5b61f04          CMP      r6,#0x210000          ;226
000074  d118              BNE      |L4.168|
000076  e00a              B        |L4.142|
                  |L4.120|
000078  68cb              LDR      r3,[r1,#0xc]          ;233
00007a  e015              B        |L4.168|
                  |L4.124|
00007c  68cb              LDR      r3,[r1,#0xc]          ;239
00007e  1d1b              ADDS     r3,r3,#4              ;239
000080  e012              B        |L4.168|
                  |L4.130|
000082  68cb              LDR      r3,[r1,#0xc]          ;246
000084  3308              ADDS     r3,r3,#8              ;246
000086  e00f              B        |L4.168|
                  |L4.136|
000088  68cb              LDR      r3,[r1,#0xc]          ;253
00008a  330c              ADDS     r3,r3,#0xc            ;253
00008c  e00c              B        |L4.168|
                  |L4.142|
00008e  688b              LDR      r3,[r1,#8]            ;266
000090  b12b              CBZ      r3,|L4.158|
000092  2b01              CMP      r3,#1                 ;270
000094  f04f0308          MOV      r3,#8                 ;279
000098  d003              BEQ      |L4.162|
00009a  6147              STR      r7,[r0,#0x14]         ;282
00009c  e004              B        |L4.168|
                  |L4.158|
00009e  2304              MOVS     r3,#4                 ;268
0000a0  e002              B        |L4.168|
                  |L4.162|
0000a2  6107              STR      r7,[r0,#0x10]         ;275
0000a4  e000              B        |L4.168|
                  |L4.166|
0000a6  2300              MOVS     r3,#0                 ;288
                  |L4.168|
0000a8  2aff              CMP      r2,#0xff              ;298
0000aa  d801              BHI      |L4.176|
0000ac  4606              MOV      r6,r0                 ;298
0000ae  e001              B        |L4.180|
                  |L4.176|
0000b0  f1000604          ADD      r6,r0,#4              ;298
                  |L4.180|
0000b4  ea4f0584          LSL      r5,r4,#2              ;299
0000b8  d901              BLS      |L4.190|
0000ba  f1a50520          SUB      r5,r5,#0x20           ;299
                  |L4.190|
0000be  6837              LDR      r7,[r6,#0]            ;302
0000c0  fa08fc05          LSL      r12,r8,r5             ;302
0000c4  ea27070c          BIC      r7,r7,r12             ;302
0000c8  fa03f505          LSL      r5,r3,r5              ;302
0000cc  ea470705          ORR      r7,r7,r5              ;302
0000d0  6037              STR      r7,[r6,#0]            ;302
0000d2  684d              LDR      r5,[r1,#4]            ;306
0000d4  00ed              LSLS     r5,r5,#3              ;306
0000d6  d560              BPL      |L4.410|
0000d8  4d35              LDR      r5,|L4.432|
0000da  69ae              LDR      r6,[r5,#0x18]         ;309
0000dc  f0460601          ORR      r6,r6,#1              ;309
0000e0  61ae              STR      r6,[r5,#0x18]         ;309
0000e2  69ad              LDR      r5,[r5,#0x18]         ;309
0000e4  f0240603          BIC      r6,r4,#3              ;310
0000e8  f0050501          AND      r5,r5,#1              ;309
0000ec  9500              STR      r5,[sp,#0]            ;310
0000ee  4d31              LDR      r5,|L4.436|
0000f0  1977              ADDS     r7,r6,r5              ;310
0000f2  68be              LDR      r6,[r7,#8]            ;310
0000f4  07a5              LSLS     r5,r4,#30             ;311
0000f6  0f2d              LSRS     r5,r5,#28             ;311
0000f8  fa08fc05          LSL      r12,r8,r5             ;311
0000fc  ea26060c          BIC      r6,r6,r12             ;311
000100  f8dfc0b4          LDR      r12,|L4.440|
000104  4560              CMP      r0,r12                ;312
000106  d103              BNE      |L4.272|
000108  f04f0c00          MOV      r12,#0                ;312
00010c  e017              B        |L4.318|
                  |L4.270|
00010e  e044              B        |L4.410|
                  |L4.272|
000110  f8dfc0a8          LDR      r12,|L4.444|
000114  4560              CMP      r0,r12                ;312
000116  d102              BNE      |L4.286|
000118  f04f0c01          MOV      r12,#1                ;312
00011c  e00f              B        |L4.318|
                  |L4.286|
00011e  f8dfc0a0          LDR      r12,|L4.448|
000122  4560              CMP      r0,r12                ;312
000124  d102              BNE      |L4.300|
000126  f04f0c02          MOV      r12,#2                ;312
00012a  e008              B        |L4.318|
                  |L4.300|
00012c  f8dfc094          LDR      r12,|L4.452|
000130  4560              CMP      r0,r12                ;312
000132  d102              BNE      |L4.314|
000134  f04f0c03          MOV      r12,#3                ;312
000138  e001              B        |L4.318|
                  |L4.314|
00013a  f04f0c04          MOV      r12,#4                ;312
                  |L4.318|
00013e  fa0cfc05          LSL      r12,r12,r5            ;312
000142  ea4c0c06          ORR      r12,r12,r6            ;312
000146  f8c7c008          STR      r12,[r7,#8]           ;313
00014a  684d              LDR      r5,[r1,#4]            ;317
00014c  f8d96000          LDR      r6,[r9,#0]            ;323
000150  03ed              LSLS     r5,r5,#15             ;317
000152  464d              MOV      r5,r9                 ;323
000154  d501              BPL      |L4.346|
000156  4316              ORRS     r6,r6,r2              ;319
000158  e000              B        |L4.348|
                  |L4.346|
00015a  4396              BICS     r6,r6,r2              ;323
                  |L4.348|
00015c  602e              STR      r6,[r5,#0]            ;323
00015e  684d              LDR      r5,[r1,#4]            ;327
000160  f8da6000          LDR      r6,[r10,#0]           ;333
000164  03ad              LSLS     r5,r5,#14             ;327
000166  4655              MOV      r5,r10                ;333
000168  d501              BPL      |L4.366|
00016a  4316              ORRS     r6,r6,r2              ;329
00016c  e000              B        |L4.368|
                  |L4.366|
00016e  4396              BICS     r6,r6,r2              ;333
                  |L4.368|
000170  602e              STR      r6,[r5,#0]            ;333
000172  684d              LDR      r5,[r1,#4]            ;337
000174  f8db6000          LDR      r6,[r11,#0]           ;343
000178  02ed              LSLS     r5,r5,#11             ;337
00017a  465d              MOV      r5,r11                ;343
00017c  d501              BPL      |L4.386|
00017e  4316              ORRS     r6,r6,r2              ;339
000180  e000              B        |L4.388|
                  |L4.386|
000182  4396              BICS     r6,r6,r2              ;343
                  |L4.388|
000184  602e              STR      r6,[r5,#0]            ;343
000186  684d              LDR      r5,[r1,#4]            ;347
;;;350            } 
;;;351            else
;;;352            {
;;;353              CLEAR_BIT(EXTI->FTSR, iocurrent); 
000188  f8de6000          LDR      r6,[lr,#0]
00018c  02ad              LSLS     r5,r5,#10             ;347
00018e  4675              MOV      r5,lr
000190  d501              BPL      |L4.406|
000192  4316              ORRS     r6,r6,r2              ;349
000194  e000              B        |L4.408|
                  |L4.406|
000196  4396              BICS     r6,r6,r2
                  |L4.408|
000198  602e              STR      r6,[r5,#0]            ;349
                  |L4.410|
00019a  1c64              ADDS     r4,r4,#1              ;349
00019c  2c10              CMP      r4,#0x10              ;212
00019e  f4ffaf3d          BCC      |L4.28|
;;;354            }
;;;355          }
;;;356        }
;;;357      }
;;;358    }
0001a2  e8bd8ff8          POP      {r3-r11,pc}
;;;359    
                          ENDP

0001a6  0000              DCW      0x0000
                  |L4.424|
                          DCD      0x40010400
                  |L4.428|
                          DCD      0x10110000
                  |L4.432|
                          DCD      0x40021000
                  |L4.436|
                          DCD      0x40010000
                  |L4.440|
                          DCD      0x40010800
                  |L4.444|
                          DCD      0x40010c00
                  |L4.448|
                          DCD      0x40011000
                  |L4.452|
                          DCD      0x40011400

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;520    */
;;;521    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;522    {
;;;523      __IO uint32_t tmp = GPIO_LCKR_LCKK;
;;;524    
;;;525      /* Check the parameters */
;;;526      assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
;;;527      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;528    
;;;529      /* Apply lock key write sequence */
;;;530      SET_BIT(tmp, GPIO_Pin);
000002  f4413280          ORR      r2,r1,#0x10000
;;;531      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;532      GPIOx->LCKR = tmp;
000006  9200              STR      r2,[sp,#0]
000008  6182              STR      r2,[r0,#0x18]
;;;533      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;534      GPIOx->LCKR = GPIO_Pin;
00000a  6181              STR      r1,[r0,#0x18]
;;;535      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;536      GPIOx->LCKR = tmp;
00000c  9900              LDR      r1,[sp,#0]
00000e  6181              STR      r1,[r0,#0x18]
;;;537      /* Read LCKK bit*/
;;;538      tmp = GPIOx->LCKR;
000010  6981              LDR      r1,[r0,#0x18]
;;;539    
;;;540      if((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
000012  9100              STR      r1,[sp,#0]
000014  6980              LDR      r0,[r0,#0x18]
000016  03c0              LSLS     r0,r0,#15
000018  d501              BPL      |L5.30|
;;;541      {
;;;542        return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;543      }
;;;544      else
;;;545      {
;;;546        return HAL_ERROR;
;;;547      }
;;;548    }
00001c  bd08              POP      {r3,pc}
                  |L5.30|
00001e  2001              MOVS     r0,#1                 ;546
000020  bd08              POP      {r3,pc}
;;;549    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;446      */
;;;447    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6880              LDR      r0,[r0,#8]
;;;448    {
;;;449      GPIO_PinState bitstatus;
;;;450    
;;;451      /* Check the parameters */
;;;452      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;453    
;;;454      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  4008              ANDS     r0,r0,r1
000004  d000              BEQ      |L6.8|
;;;455      {
;;;456        bitstatus = GPIO_PIN_SET;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;457      }
;;;458      else
;;;459      {
;;;460        bitstatus = GPIO_PIN_RESET;
;;;461      }
;;;462      return bitstatus;
;;;463    }
000008  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;502      */
;;;503    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  68c2              LDR      r2,[r0,#0xc]
;;;504    {
;;;505      /* Check the parameters */
;;;506      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;507    
;;;508      GPIOx->ODR ^= GPIO_Pin;
000002  404a              EORS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;509    }
000006  4770              BX       lr
;;;510    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;480      */
;;;481    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
                  |L8.2|
;;;482    {
;;;483      /* Check the parameters */
;;;484      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;485      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;486    
;;;487      if(PinState != GPIO_PIN_RESET)
;;;488      {
;;;489        GPIOx->BSRR = GPIO_Pin;
000002  6101              STR      r1,[r0,#0x10]
;;;490      }
;;;491      else
;;;492      {
;;;493        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
;;;494      }
;;;495    }
000004  4770              BX       lr
                  |L8.6|
000006  0409              LSLS     r1,r1,#16             ;493
000008  e7fb              B        |L8.2|
;;;496    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH|
#line 495
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX|
#line 682
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
