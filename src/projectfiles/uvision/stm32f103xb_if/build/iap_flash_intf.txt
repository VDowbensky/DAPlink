; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\iap_flash_intf.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\iap_flash_intf.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\iap_flash_intf.crf ..\..\..\source\daplink\drag-n-drop\iap_flash_intf.c]
                          THUMB

                          AREA ||i.critical_erase_and_program||, CODE, READONLY, ALIGN=2

                  critical_erase_and_program PROC
;;;471    
;;;472    static error_t critical_erase_and_program(uint32_t addr, const uint8_t *data, uint32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;473    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;474        uint32_t iap_status;
;;;475    
;;;476        if (size < DAPLINK_MIN_WRITE_SIZE) {
000008  f5b26f80          CMP      r2,#0x400
00000c  d207              BCS      |L1.30|
;;;477            util_assert(0);
00000e  f24012dd          MOV      r2,#0x1dd
000012  a10a              ADR      r1,|L1.60|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       _util_assert
;;;478            return ERROR_INTERNAL;
00001a  2002              MOVS     r0,#2
;;;479        }
;;;480    
;;;481        // CRITICAL SECTION BELOW HERE!
;;;482        // If something goes wrong with either
;;;483        // the erase or write then the device
;;;484        // will no longer be bootable.
;;;485        // Erase the first sector
;;;486        iap_status = flash_erase_sector(addr);
;;;487    
;;;488        if (iap_status != 0) {
;;;489            return ERROR_ERASE_ALL;
;;;490        }
;;;491    
;;;492        // Program the interface's vector table
;;;493        iap_status = flash_program_page(addr, size, (uint8_t *)data);
;;;494    
;;;495        if (iap_status != 0) {
;;;496            return ERROR_IAP_WRITE;
;;;497        }
;;;498    
;;;499        return ERROR_SUCCESS;
;;;500    }
00001c  bd70              POP      {r4-r6,pc}
                  |L1.30|
00001e  f7fffffe          BL       flash_erase_sector
000022  b108              CBZ      r0,|L1.40|
000024  2010              MOVS     r0,#0x10              ;489
                  |L1.38|
000026  bd70              POP      {r4-r6,pc}
                  |L1.40|
000028  462a              MOV      r2,r5                 ;493
00002a  4621              MOV      r1,r4                 ;493
00002c  4630              MOV      r0,r6                 ;493
00002e  f7fffffe          BL       flash_program_page
000032  2800              CMP      r0,#0                 ;495
000034  d0f7              BEQ      |L1.38|
000036  201f              MOVS     r0,#0x1f              ;496
000038  bd70              POP      {r4-r6,pc}
;;;501    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
00003c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000040  2e5c2e2e
000044  5c736f75
000048  7263655c
00004c  6461706c
000050  696e6b5c
000054  64726167
000058  2d6e2d64
00005c  726f705c
000060  6961705f
000064  666c6173
000068  685f696e
00006c  74      
00006d  662e6300          DCB      "f.c",0
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.erase_chip||, CODE, READONLY, ALIGN=2

                  erase_chip PROC
;;;304    
;;;305    static error_t erase_chip(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;306    {
;;;307        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;308        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;309    
;;;310        if (state != STATE_OPEN) {
000004  4e15              LDR      r6,|L2.92|
000006  4d14              LDR      r5,|L2.88|
000008  f04f6400          MOV      r4,#0x8000000         ;307
00000c  7830              LDRB     r0,[r6,#0]  ; state
00000e  2801              CMP      r0,#1
000010  d006              BEQ      |L2.32|
;;;311            util_assert(0);
000012  f2401237          MOV      r2,#0x137
000016  a112              ADR      r1,|L2.96|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       _util_assert
;;;312            return ERROR_INTERNAL;
00001e  e009              B        |L2.52|
                  |L2.32|
;;;313        }
;;;314    
;;;315        if (mass_erase_performed) {
000020  78b0              LDRB     r0,[r6,#2]  ; mass_erase_performed
000022  2702              MOVS     r7,#2                 ;312
000024  b148              CBZ      r0,|L2.58|
;;;316            // Mass erase only allowed once
;;;317            util_assert(0);
000026  f240123d          MOV      r2,#0x13d
00002a  a10d              ADR      r1,|L2.96|
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       _util_assert
;;;318            state = STATE_ERROR;
000032  7037              STRB     r7,[r6,#0]
                  |L2.52|
;;;319            return ERROR_INTERNAL;
000034  2002              MOVS     r0,#2
                  |L2.54|
;;;320        }
;;;321    
;;;322        for (uint32_t addr = updt_start; addr < updt_end; addr += DAPLINK_SECTOR_SIZE) {
;;;323            error_t status;
;;;324            status = erase_sector(addr);
;;;325    
;;;326            if (status != ERROR_SUCCESS) {
;;;327                state = STATE_ERROR;
;;;328                return ERROR_IAP_ERASE_ALL;
;;;329            }
;;;330        }
;;;331    
;;;332        mass_erase_performed = true;
;;;333        return ERROR_SUCCESS;
;;;334    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L2.58|
00003a  4620              MOV      r0,r4                 ;324
00003c  f7fffffe          BL       erase_sector
000040  b110              CBZ      r0,|L2.72|
000042  7037              STRB     r7,[r6,#0]            ;327
000044  2021              MOVS     r0,#0x21              ;328
000046  e7f6              B        |L2.54|
                  |L2.72|
000048  f5046480          ADD      r4,r4,#0x400
00004c  42ac              CMP      r4,r5                 ;322
00004e  d3f4              BCC      |L2.58|
000050  2001              MOVS     r0,#1                 ;332
000052  70b0              STRB     r0,[r6,#2]            ;332
000054  2000              MOVS     r0,#0                 ;333
000056  e7ee              B        |L2.54|
;;;335    
                          ENDP

                  |L2.88|
                          DCD      0x0800bc00
                  |L2.92|
                          DCD      ||.data||
                  |L2.96|
000060  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000064  2e5c2e2e
000068  5c736f75
00006c  7263655c
000070  6461706c
000074  696e6b5c
000078  64726167
00007c  2d6e2d64
000080  726f705c
000084  6961705f
000088  666c6173
00008c  685f696e
000090  74      
000091  662e6300          DCB      "f.c",0
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.erase_sector||, CODE, READONLY, ALIGN=2

                  erase_sector PROC
;;;247    
;;;248    static error_t erase_sector(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;249    {
;;;250        uint32_t iap_status;
;;;251        error_t status;
;;;252        uint32_t sector_size;
;;;253    
;;;254        if (state != STATE_OPEN) {
000002  4e20              LDR      r6,|L3.132|
000004  4604              MOV      r4,r0                 ;249
000006  7830              LDRB     r0,[r6,#0]  ; state
000008  2801              CMP      r0,#1
00000a  d005              BEQ      |L3.24|
;;;255            util_assert(0);
00000c  22ff              MOVS     r2,#0xff
00000e  a11e              ADR      r1,|L3.136|
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       _util_assert
;;;256            return ERROR_INTERNAL;
000016  e018              B        |L3.74|
                  |L3.24|
000018  f44f6080          MOV      r0,#0x400
;;;257        }
;;;258    
;;;259        // Address must be on a sector boundary
;;;260        sector_size = erase_sector_size(addr);
;;;261    
;;;262        if (addr % sector_size != 0) {
00001c  fbb4f1f0          UDIV     r1,r4,r0
000020  fb004111          MLS      r1,r0,r1,r4
000024  2502              MOVS     r5,#2                 ;256
000026  b111              CBZ      r1,|L3.46|
;;;263            util_assert(0);
000028  f2401207          MOV      r2,#0x107
;;;264            state = STATE_ERROR;
;;;265            return ERROR_INTERNAL;
00002c  e008              B        |L3.64|
                  |L3.46|
;;;266        }
;;;267    
;;;268        // Address must be sequential - no gaps
;;;269        if (current_sector_set && (addr != current_sector + current_sector_size)) {
00002e  78f1              LDRB     r1,[r6,#3]  ; current_sector_set
000030  b169              CBZ      r1,|L3.78|
000032  e9d61202          LDRD     r1,r2,[r6,#8]
000036  4411              ADD      r1,r1,r2
000038  42a1              CMP      r1,r4
00003a  d008              BEQ      |L3.78|
;;;270            util_assert(0);
00003c  f44f7287          MOV      r2,#0x10e
                  |L3.64|
000040  a111              ADR      r1,|L3.136|
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       _util_assert
;;;271            state = STATE_ERROR;
000048  7035              STRB     r5,[r6,#0]
                  |L3.74|
;;;272            return ERROR_INTERNAL;
00004a  2002              MOVS     r0,#2
                  |L3.76|
;;;273        }
;;;274    
;;;275        if (!sector_erase_allowed(addr)) {
;;;276            state = STATE_ERROR;
;;;277            return ERROR_IAP_ERASE_SECTOR;
;;;278        }
;;;279    
;;;280        current_sector_set = true;
;;;281        current_sector = addr;
;;;282        current_sector_size = sector_size;
;;;283        status = intercept_sector_erase(addr);
;;;284    
;;;285        if (status != ERROR_IAP_NO_INTERCEPT) {
;;;286            // The operation has been intercepted so
;;;287            // return the result
;;;288            if (ERROR_SUCCESS != status) {
;;;289                state = STATE_ERROR;
;;;290            }
;;;291    
;;;292            return status;
;;;293        }
;;;294    
;;;295        iap_status = flash_erase_sector(addr);
;;;296    
;;;297        if (iap_status != 0) {
;;;298            state = STATE_ERROR;
;;;299            return ERROR_IAP_ERASE_SECTOR;
;;;300        }
;;;301    
;;;302        return ERROR_SUCCESS;
;;;303    }
00004c  bd70              POP      {r4-r6,pc}
                  |L3.78|
00004e  4a1c              LDR      r2,|L3.192|
000050  491c              LDR      r1,|L3.196|
000052  4294              CMP      r4,r2
000054  d301              BCC      |L3.90|
000056  428c              CMP      r4,r1
000058  d311              BCC      |L3.126|
                  |L3.90|
00005a  2101              MOVS     r1,#1
00005c  70f1              STRB     r1,[r6,#3]            ;280
00005e  e9c64002          STRD     r4,r0,[r6,#8]         ;280
000062  4620              MOV      r0,r4                 ;283
000064  f7fffffe          BL       intercept_sector_erase
000068  2825              CMP      r0,#0x25              ;285
00006a  d003              BEQ      |L3.116|
00006c  2800              CMP      r0,#0                 ;288
00006e  d0ed              BEQ      |L3.76|
000070  7035              STRB     r5,[r6,#0]            ;289
                  |L3.114|
000072  bd70              POP      {r4-r6,pc}
                  |L3.116|
000074  4620              MOV      r0,r4                 ;295
000076  f7fffffe          BL       flash_erase_sector
00007a  2800              CMP      r0,#0                 ;297
00007c  d0f9              BEQ      |L3.114|
                  |L3.126|
00007e  7035              STRB     r5,[r6,#0]            ;298
000080  2020              MOVS     r0,#0x20              ;299
000082  bd70              POP      {r4-r6,pc}
;;;304    
                          ENDP

                  |L3.132|
                          DCD      ||.data||
                  |L3.136|
000088  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
00008c  2e5c2e2e
000090  5c736f75
000094  7263655c
000098  6461706c
00009c  696e6b5c
0000a0  64726167
0000a4  2d6e2d64
0000a8  726f705c
0000ac  6961705f
0000b0  666c6173
0000b4  685f696e
0000b8  74      
0000b9  662e6300          DCB      "f.c",0
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L3.192|
                          DCD      0x0800c000
                  |L3.196|
                          DCD      0x0801fc00

                          AREA ||i.erase_sector_size||, CODE, READONLY, ALIGN=1

                  erase_sector_size PROC
;;;340    
;;;341    static uint32_t erase_sector_size(uint32_t addr)
000000  f44f6080          MOV      r0,#0x400
;;;342    {
;;;343        return DAPLINK_SECTOR_SIZE;
;;;344    }
000004  4770              BX       lr
;;;345    
                          ENDP


                          AREA ||i.init||, CODE, READONLY, ALIGN=2

                  init PROC
;;;91     
;;;92     static error_t init()
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94         int iap_status;
;;;95         bool update_supported = DAPLINK_ROM_UPDATE_SIZE != 0;
;;;96     
;;;97         if (state != STATE_CLOSED) {
000002  4c12              LDR      r4,|L5.76|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L5.22|
;;;98             util_assert(0);
000008  2262              MOVS     r2,#0x62
00000a  a111              ADR      r1,|L5.80|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       _util_assert
;;;99             return ERROR_INTERNAL;
000012  2002              MOVS     r0,#2
;;;100        }
;;;101    
;;;102        if (!update_supported) {
;;;103            return ERROR_IAP_UPDT_NOT_SUPPORTED;
;;;104        }
;;;105    
;;;106        iap_status = Init(0, 0, 0);
;;;107    
;;;108        if (iap_status != 0) {
;;;109            return ERROR_IAP_INIT;
;;;110        }
;;;111    
;;;112        update_complete = false;
;;;113        mass_erase_performed = false;
;;;114        current_sector_set = false;
;;;115        current_sector = 0;
;;;116        current_sector_size = 0;
;;;117        current_page_set = false;
;;;118        current_page = 0;
;;;119        current_page_write_size = 0;
;;;120        crc = 0;
;;;121        memset(sector_buf, 0, sizeof(sector_buf));
;;;122        state = STATE_OPEN;
;;;123        return ERROR_SUCCESS;
;;;124    }
000014  bd10              POP      {r4,pc}
                  |L5.22|
000016  2200              MOVS     r2,#0                 ;106
000018  4611              MOV      r1,r2                 ;106
00001a  4610              MOV      r0,r2                 ;106
00001c  f7fffffe          BL       Init
000020  b108              CBZ      r0,|L5.38|
000022  201d              MOVS     r0,#0x1d              ;109
000024  bd10              POP      {r4,pc}
                  |L5.38|
000026  2000              MOVS     r0,#0                 ;112
000028  7060              STRB     r0,[r4,#1]            ;112
00002a  70a0              STRB     r0,[r4,#2]            ;113
00002c  70e0              STRB     r0,[r4,#3]            ;114
00002e  60a0              STR      r0,[r4,#8]            ;116  ; current_sector
000030  60e0              STR      r0,[r4,#0xc]          ;117  ; current_sector_size
000032  7120              STRB     r0,[r4,#4]            ;117
000034  6120              STR      r0,[r4,#0x10]         ;119  ; current_page
000036  6160              STR      r0,[r4,#0x14]         ;120  ; current_page_write_size
000038  61a0              STR      r0,[r4,#0x18]         ;121  ; crc
00003a  f44f6180          MOV      r1,#0x400             ;121
00003e  4812              LDR      r0,|L5.136|
000040  f7fffffe          BL       __aeabi_memclr
000044  2001              MOVS     r0,#1                 ;122
000046  7020              STRB     r0,[r4,#0]            ;122
000048  2000              MOVS     r0,#0                 ;123
00004a  bd10              POP      {r4,pc}
;;;125    
                          ENDP

                  |L5.76|
                          DCD      ||.data||
                  |L5.80|
000050  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000054  2e5c2e2e
000058  5c736f75
00005c  7263655c
000060  6461706c
000064  696e6b5c
000068  64726167
00006c  2d6e2d64
000070  726f705c
000074  6961705f
000078  666c6173
00007c  685f696e
000080  74      
000081  662e6300          DCB      "f.c",0
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L5.136|
                          DCD      ||.bss||

                          AREA ||i.intercept_page_write||, CODE, READONLY, ALIGN=2

                  intercept_page_write PROC
;;;368    
;;;369    static error_t intercept_page_write(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;370    {
;;;371        error_t status;
;;;372        uint32_t crc_size;
;;;373        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;374        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;375    
;;;376        if (state != STATE_OPEN) {
000004  f8df80d4          LDR      r8,|L6.220|
000008  4604              MOV      r4,r0                 ;370
00000a  468a              MOV      r10,r1                ;370
00000c  f8980000          LDRB     r0,[r8,#0]  ; state
000010  4d31              LDR      r5,|L6.216|
000012  4617              MOV      r7,r2                 ;370
000014  f04f6100          MOV      r1,#0x8000000         ;373
000018  2801              CMP      r0,#1
00001a  d008              BEQ      |L6.46|
;;;377            util_assert(0);
00001c  f2401279          MOV      r2,#0x179
000020  a12f              ADR      r1,|L6.224|
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       _util_assert
;;;378            return ERROR_INTERNAL;
000028  2002              MOVS     r0,#2
                  |L6.42|
;;;379        }
;;;380    
;;;381        if ((addr < updt_start) || (addr >= updt_end)) {
;;;382            return ERROR_IAP_OUT_OF_BOUNDS;
;;;383        }
;;;384    
;;;385        if (!daplink_is_interface()) {
;;;386            return ERROR_IAP_NO_INTERCEPT;
;;;387        }
;;;388    
;;;389        /* Everything below here is interface specific */
;;;390        crc_size = MIN(size, updt_end - addr - 4);
;;;391        crc = crc32_continue(crc, buf, crc_size);
;;;392    
;;;393        // Intercept the data if it is in the first sector
;;;394        if ((addr >= updt_start) && (addr < updt_start + DAPLINK_SECTOR_SIZE)) {
;;;395            uint32_t buf_offset = addr - updt_start;
;;;396            memcpy(sector_buf + buf_offset, buf, size);
;;;397            // Intercept was successful
;;;398            return ERROR_SUCCESS;
;;;399        }
;;;400    
;;;401        // Finalize update if this is the last sector
;;;402        if (updt_end == addr + size) {
;;;403            uint32_t iap_status;
;;;404            uint32_t size_left = updt_end - addr;
;;;405            uint32_t crc_in_image = (buf[size_left - 4] << 0) |
;;;406                                    (buf[size_left - 3] << 8) |
;;;407                                    (buf[size_left - 2] << 16) |
;;;408                                    (buf[size_left - 1] << 24);
;;;409    
;;;410            if (crc != crc_in_image) {
;;;411                return ERROR_BL_UPDT_BAD_CRC;
;;;412            }
;;;413    
;;;414            // Program the current buffer
;;;415            iap_status = flash_program_page(addr, size, (uint8_t *)buf);
;;;416    
;;;417            if (iap_status != 0) {
;;;418                return ERROR_IAP_WRITE;
;;;419            }
;;;420    
;;;421            status = critical_erase_and_program(DAPLINK_ROM_UPDATE_START, sector_buf, DAPLINK_SECTOR_SIZE);
;;;422    
;;;423            if (ERROR_SUCCESS == status) {
;;;424                status = ERROR_SUCCESS;
;;;425            }
;;;426    
;;;427            // The bootloader has been updated so recompute the crc
;;;428            info_crc_compute();
;;;429            update_complete = true;
;;;430            return status;
;;;431        }
;;;432    
;;;433        return ERROR_IAP_NO_INTERCEPT;
;;;434    }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L6.46|
00002e  4689              MOV      r9,r1                 ;381
000030  454c              CMP      r4,r9                 ;381
000032  d301              BCC      |L6.56|
000034  42ac              CMP      r4,r5                 ;381
000036  d301              BCC      |L6.60|
                  |L6.56|
000038  2022              MOVS     r0,#0x22              ;382
00003a  e7f6              B        |L6.42|
                  |L6.60|
00003c  f7fffffe          BL       daplink_is_interface
000040  b390              CBZ      r0,|L6.168|
000042  1b2e              SUBS     r6,r5,r4              ;390
000044  1f30              SUBS     r0,r6,#4              ;390
000046  42b8              CMP      r0,r7                 ;390
000048  d901              BLS      |L6.78|
00004a  463a              MOV      r2,r7                 ;390
00004c  e000              B        |L6.80|
                  |L6.78|
00004e  1f32              SUBS     r2,r6,#4              ;390
                  |L6.80|
000050  4651              MOV      r1,r10                ;391
000052  f8d80018          LDR      r0,[r8,#0x18]         ;391  ; crc
000056  f7fffffe          BL       crc32_continue
00005a  4601              MOV      r1,r0                 ;391
00005c  f8c80018          STR      r0,[r8,#0x18]         ;394  ; crc
000060  482d              LDR      r0,|L6.280|
000062  4284              CMP      r4,r0                 ;394
000064  d209              BCS      |L6.122|
000066  482d              LDR      r0,|L6.284|
000068  f1a46400          SUB      r4,r4,#0x8000000      ;396
00006c  4420              ADD      r0,r0,r4              ;396
00006e  463a              MOV      r2,r7                 ;396
000070  4651              MOV      r1,r10                ;396
000072  f7fffffe          BL       __aeabi_memcpy
000076  2000              MOVS     r0,#0                 ;398
000078  e7d7              B        |L6.42|
                  |L6.122|
00007a  19e0              ADDS     r0,r4,r7              ;402
00007c  42a8              CMP      r0,r5                 ;402
00007e  d129              BNE      |L6.212|
000080  eb0a0006          ADD      r0,r10,r6             ;405
000084  f8103c02          LDRB     r3,[r0,#-2]           ;405
000088  f8102c03          LDRB     r2,[r0,#-3]           ;405
00008c  f8105d04          LDRB     r5,[r0,#-4]!          ;405
000090  ea452202          ORR      r2,r5,r2,LSL #8       ;405
000094  78c0              LDRB     r0,[r0,#3]            ;405
000096  f363421f          BFI      r2,r3,#16,#16         ;405
00009a  ea426000          ORR      r0,r2,r0,LSL #24      ;405
00009e  4645              MOV      r5,r8                 ;410
0000a0  4281              CMP      r1,r0                 ;410
0000a2  d002              BEQ      |L6.170|
0000a4  2026              MOVS     r0,#0x26              ;411
0000a6  e7c0              B        |L6.42|
                  |L6.168|
0000a8  e014              B        |L6.212|
                  |L6.170|
0000aa  4652              MOV      r2,r10                ;415
0000ac  4639              MOV      r1,r7                 ;415
0000ae  4620              MOV      r0,r4                 ;415
0000b0  f7fffffe          BL       flash_program_page
0000b4  b108              CBZ      r0,|L6.186|
0000b6  201f              MOVS     r0,#0x1f              ;418
0000b8  e7b7              B        |L6.42|
                  |L6.186|
0000ba  f44f6280          MOV      r2,#0x400             ;421
0000be  4917              LDR      r1,|L6.284|
0000c0  4648              MOV      r0,r9                 ;421
0000c2  f7fffffe          BL       critical_erase_and_program
0000c6  4604              MOV      r4,r0                 ;421
0000c8  f7fffffe          BL       info_crc_compute
0000cc  2001              MOVS     r0,#1                 ;429
0000ce  7068              STRB     r0,[r5,#1]            ;429
0000d0  4620              MOV      r0,r4                 ;430
0000d2  e7aa              B        |L6.42|
                  |L6.212|
0000d4  2025              MOVS     r0,#0x25              ;433
0000d6  e7a8              B        |L6.42|
;;;435    
                          ENDP

                  |L6.216|
                          DCD      0x0800bc00
                  |L6.220|
                          DCD      ||.data||
                  |L6.224|
0000e0  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
0000e4  2e5c2e2e
0000e8  5c736f75
0000ec  7263655c
0000f0  6461706c
0000f4  696e6b5c
0000f8  64726167
0000fc  2d6e2d64
000100  726f705c
000104  6961705f
000108  666c6173
00010c  685f696e
000110  74      
000111  662e6300          DCB      "f.c",0
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L6.280|
                          DCD      0x08000400
                  |L6.284|
                          DCD      ||.bss||

                          AREA ||i.intercept_sector_erase||, CODE, READONLY, ALIGN=2

                  intercept_sector_erase PROC
;;;435    
;;;436    static error_t intercept_sector_erase(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;437    {
;;;438        error_t status;
;;;439        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;440        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;441    
;;;442        if (state != STATE_OPEN) {
000002  4913              LDR      r1,|L7.80|
000004  4604              MOV      r4,r0                 ;437
000006  4811              LDR      r0,|L7.76|
000008  7809              LDRB     r1,[r1,#0]  ; state
00000a  f04f6500          MOV      r5,#0x8000000         ;439
00000e  2901              CMP      r1,#1
000010  d007              BEQ      |L7.34|
;;;443            util_assert(0);
000012  f24012bb          MOV      r2,#0x1bb
000016  a10f              ADR      r1,|L7.84|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       _util_assert
;;;444            return ERROR_INTERNAL;
00001e  2002              MOVS     r0,#2
;;;445        }
;;;446    
;;;447        if ((addr < updt_start) || (addr >= updt_end)) {
;;;448            return ERROR_IAP_OUT_OF_BOUNDS;
;;;449        }
;;;450    
;;;451        if (!daplink_is_interface()) {
;;;452            return ERROR_IAP_NO_INTERCEPT;
;;;453        }
;;;454    
;;;455        /* Everything below here is interface specific */
;;;456    
;;;457        if (DAPLINK_ROM_UPDATE_START == addr) {
;;;458            uint32_t addr = DAPLINK_ROM_UPDATE_START;
;;;459            status = critical_erase_and_program(addr, (uint8_t *)DAPLINK_ROM_IF_START, DAPLINK_MIN_WRITE_SIZE);
;;;460    
;;;461            if (ERROR_SUCCESS == status) {
;;;462                // Intercept was successful
;;;463                status = ERROR_SUCCESS;
;;;464            }
;;;465    
;;;466            return status;
;;;467        }
;;;468    
;;;469        return ERROR_IAP_NO_INTERCEPT;
;;;470    }
000020  bd70              POP      {r4-r6,pc}
                  |L7.34|
000022  42ac              CMP      r4,r5                 ;447
000024  d301              BCC      |L7.42|
000026  4284              CMP      r4,r0                 ;447
000028  d301              BCC      |L7.46|
                  |L7.42|
00002a  2022              MOVS     r0,#0x22              ;448
00002c  bd70              POP      {r4-r6,pc}
                  |L7.46|
00002e  f7fffffe          BL       daplink_is_interface
000032  b148              CBZ      r0,|L7.72|
000034  42ac              CMP      r4,r5                 ;457
000036  d107              BNE      |L7.72|
000038  4628              MOV      r0,r5                 ;458
00003a  e8bd4070          POP      {r4-r6,lr}            ;459
00003e  f44f6280          MOV      r2,#0x400             ;459
000042  4912              LDR      r1,|L7.140|
000044  f7ffbffe          B.W      critical_erase_and_program
                  |L7.72|
000048  2025              MOVS     r0,#0x25              ;469
00004a  bd70              POP      {r4-r6,pc}
;;;471    
                          ENDP

                  |L7.76|
                          DCD      0x0800bc00
                  |L7.80|
                          DCD      ||.data||
                  |L7.84|
000054  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000058  2e5c2e2e
00005c  5c736f75
000060  7263655c
000064  6461706c
000068  696e6b5c
00006c  64726167
000070  2d6e2d64
000074  726f705c
000078  6961705f
00007c  666c6173
000080  685f696e
000084  74      
000085  662e6300          DCB      "f.c",0
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L7.140|
                          DCD      0x0800c000

                          AREA ||i.program_page||, CODE, READONLY, ALIGN=2

                  program_page PROC
;;;152    
;;;153    static error_t program_page(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;154    {
;;;155        uint32_t iap_status;
;;;156        error_t status;
;;;157        uint32_t min_prog_size;
;;;158        uint32_t sector_size;
;;;159        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;160    
;;;161        if (state != STATE_OPEN) {
000004  f8df8100          LDR      r8,|L8.264|
000008  4604              MOV      r4,r0                 ;154
00000a  f8df90f8          LDR      r9,|L8.260|
00000e  f8980000          LDRB     r0,[r8,#0]  ; state
000012  4615              MOV      r5,r2                 ;154
000014  468b              MOV      r11,r1                ;154
000016  2801              CMP      r0,#1
000018  d005              BEQ      |L8.38|
;;;162            util_assert(0);
00001a  22a2              MOVS     r2,#0xa2
00001c  a13b              ADR      r1,|L8.268|
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       _util_assert
;;;163            return ERROR_INTERNAL;
000024  e03f              B        |L8.166|
                  |L8.38|
000026  f44f6080          MOV      r0,#0x400
;;;164        }
;;;165    
;;;166        min_prog_size = program_page_min_size(addr);
;;;167        sector_size = erase_sector_size(addr);
;;;168    
;;;169        // Address must be on a write size boundary
;;;170        if (addr % min_prog_size != 0) {
00002a  fbb4f3f0          UDIV     r3,r4,r0
00002e  fb004313          MLS      r3,r0,r3,r4
000032  4601              MOV      r1,r0                 ;167
000034  2602              MOVS     r6,#2                 ;163
000036  b10b              CBZ      r3,|L8.60|
;;;171            util_assert(0);
000038  22ab              MOVS     r2,#0xab
;;;172            state = STATE_ERROR;
;;;173            return ERROR_INTERNAL;
00003a  e02e              B        |L8.154|
                  |L8.60|
;;;174        }
;;;175    
;;;176        // Programming size must be a non-zero multiple of the minimum write size
;;;177        if ((size < min_prog_size) || (size % min_prog_size != 0)) {
00003c  460a              MOV      r2,r1
00003e  4295              CMP      r5,r2
000040  d304              BCC      |L8.76|
000042  fbb5f3f0          UDIV     r3,r5,r0
000046  fb025013          MLS      r0,r2,r3,r5
00004a  b108              CBZ      r0,|L8.80|
                  |L8.76|
;;;178            util_assert(0);
00004c  22b2              MOVS     r2,#0xb2
;;;179            state = STATE_ERROR;
;;;180            return ERROR_INTERNAL;
00004e  e024              B        |L8.154|
                  |L8.80|
;;;181        }
;;;182    
;;;183        // Write must not cross a sector boundary
;;;184        if ((addr % sector_size) + size > sector_size) {
000050  fbb4f0f1          UDIV     r0,r4,r1
000054  fb024010          MLS      r0,r2,r0,r4
000058  4428              ADD      r0,r0,r5
00005a  4288              CMP      r0,r1
00005c  d901              BLS      |L8.98|
;;;185            util_assert(0);
00005e  22b9              MOVS     r2,#0xb9
;;;186            state = STATE_ERROR;
;;;187            return ERROR_INTERNAL;
000060  e01b              B        |L8.154|
                  |L8.98|
;;;188        }
;;;189    
;;;190        // Write must be in an erased sector (current_sector is always erased if it is set)
;;;191        if (!mass_erase_performed) {
000062  f8980002          LDRB     r0,[r8,#2]  ; mass_erase_performed
000066  b978              CBNZ     r0,|L8.136|
;;;192            if (!current_sector_set) {
000068  f8980003          LDRB     r0,[r8,#3]  ; current_sector_set
00006c  b150              CBZ      r0,|L8.132|
;;;193                util_assert(0);
;;;194                state = STATE_ERROR;
;;;195                return ERROR_INTERNAL;
;;;196            }
;;;197    
;;;198            if ((addr < current_sector) || (addr >= current_sector + current_sector_size)) {
00006e  f8d80008          LDR      r0,[r8,#8]  ; current_sector
000072  4284              CMP      r4,r0
000074  d304              BCC      |L8.128|
000076  f8d8100c          LDR      r1,[r8,#0xc]  ; current_sector_size
00007a  4408              ADD      r0,r0,r1
00007c  42a0              CMP      r0,r4
00007e  d803              BHI      |L8.136|
                  |L8.128|
;;;199                util_assert(0);
000080  22c7              MOVS     r2,#0xc7
;;;200                state = STATE_ERROR;
;;;201                return ERROR_INTERNAL;
000082  e00a              B        |L8.154|
                  |L8.132|
000084  22c1              MOVS     r2,#0xc1              ;193
000086  e008              B        |L8.154|
                  |L8.136|
;;;202            }
;;;203        }
;;;204    
;;;205        // Address must be sequential - no gaps
;;;206        if (current_page_set && (addr != current_page + current_page_write_size)) {
000088  f8980004          LDRB     r0,[r8,#4]  ; current_page_set
00008c  b170              CBZ      r0,|L8.172|
00008e  e9d80104          LDRD     r0,r1,[r8,#0x10]
000092  4408              ADD      r0,r0,r1
000094  42a0              CMP      r0,r4
000096  d009              BEQ      |L8.172|
;;;207            util_assert(0);
000098  22cf              MOVS     r2,#0xcf
                  |L8.154|
00009a  a11c              ADR      r1,|L8.268|
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       _util_assert
;;;208            state = STATE_ERROR;
0000a2  f8886000          STRB     r6,[r8,#0]
                  |L8.166|
;;;209            return ERROR_INTERNAL;
0000a6  2002              MOVS     r0,#2
                  |L8.168|
;;;210        }
;;;211    
;;;212        if (!page_program_allowed(addr, size)) {
;;;213            state = STATE_ERROR;
;;;214            return ERROR_IAP_WRITE;
;;;215        }
;;;216    
;;;217        current_page_set = true;
;;;218        current_page = addr;
;;;219        current_page_write_size = size;
;;;220        status = intercept_page_write(addr, buf, size);
;;;221    
;;;222        if (status != ERROR_IAP_NO_INTERCEPT) {
;;;223            // The operation has been intercepted so
;;;224            // return the result
;;;225            if (ERROR_SUCCESS != status) {
;;;226                state = STATE_ERROR;
;;;227            }
;;;228    
;;;229            return status;
;;;230        }
;;;231    
;;;232        iap_status = flash_program_page(addr, size, (uint8_t *)buf);
;;;233    
;;;234        if (iap_status != 0) {
;;;235            state = STATE_ERROR;
;;;236            return ERROR_IAP_WRITE;
;;;237        }
;;;238    
;;;239        if (addr + size >= updt_end) {
;;;240            // Something has been updated so recompute the crc
;;;241            info_crc_compute();
;;;242            update_complete = true;
;;;243        }
;;;244    
;;;245        return ERROR_SUCCESS;
;;;246    }
0000a8  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.172|
0000ac  4825              LDR      r0,|L8.324|
0000ae  1967              ADDS     r7,r4,r5
0000b0  4284              CMP      r4,r0
0000b2  d202              BCS      |L8.186|
0000b4  4824              LDR      r0,|L8.328|
0000b6  4287              CMP      r7,r0
0000b8  d817              BHI      |L8.234|
                  |L8.186|
0000ba  f04f0a01          MOV      r10,#1                ;217
0000be  f888a004          STRB     r10,[r8,#4]           ;217
0000c2  462a              MOV      r2,r5                 ;220
0000c4  4659              MOV      r1,r11                ;220
0000c6  4620              MOV      r0,r4                 ;220
0000c8  e9c84504          STRD     r4,r5,[r8,#0x10]      ;220
0000cc  f7fffffe          BL       intercept_page_write
0000d0  2825              CMP      r0,#0x25              ;222
0000d2  d004              BEQ      |L8.222|
0000d4  2800              CMP      r0,#0                 ;225
0000d6  d0e7              BEQ      |L8.168|
0000d8  f8886000          STRB     r6,[r8,#0]            ;226
0000dc  e7e4              B        |L8.168|
                  |L8.222|
0000de  465a              MOV      r2,r11                ;232
0000e0  4629              MOV      r1,r5                 ;232
0000e2  4620              MOV      r0,r4                 ;232
0000e4  f7fffffe          BL       flash_program_page
0000e8  b118              CBZ      r0,|L8.242|
                  |L8.234|
0000ea  f8886000          STRB     r6,[r8,#0]            ;235
0000ee  201f              MOVS     r0,#0x1f              ;236
0000f0  e7da              B        |L8.168|
                  |L8.242|
0000f2  454f              CMP      r7,r9                 ;239
0000f4  d303              BCC      |L8.254|
0000f6  f7fffffe          BL       info_crc_compute
0000fa  f888a001          STRB     r10,[r8,#1]           ;242
                  |L8.254|
0000fe  2000              MOVS     r0,#0                 ;245
000100  e7d2              B        |L8.168|
;;;247    
                          ENDP

000102  0000              DCW      0x0000
                  |L8.260|
                          DCD      0x0800bc00
                  |L8.264|
                          DCD      ||.data||
                  |L8.268|
00010c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000110  2e5c2e2e
000114  5c736f75
000118  7263655c
00011c  6461706c
000120  696e6b5c
000124  64726167
000128  2d6e2d64
00012c  726f705c
000130  6961705f
000134  666c6173
000138  685f696e
00013c  74      
00013d  662e6300          DCB      "f.c",0
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0
                  |L8.324|
                          DCD      0x0801fc00
                  |L8.328|
                          DCD      0x0800c000

                          AREA ||i.program_page_min_size||, CODE, READONLY, ALIGN=1

                  program_page_min_size PROC
;;;335    
;;;336    static uint32_t program_page_min_size(uint32_t addr)
000000  f44f6080          MOV      r0,#0x400
;;;337    {
;;;338        return DAPLINK_MIN_WRITE_SIZE;
;;;339    }
000004  4770              BX       lr
;;;340    
                          ENDP


                          AREA ||i.target_flash_busy||, CODE, READONLY, ALIGN=2

                  target_flash_busy PROC
;;;501    
;;;502    static uint8_t target_flash_busy(void){
000000  4802              LDR      r0,|L10.12|
;;;503        return (state == STATE_OPEN);
000002  7800              LDRB     r0,[r0,#0]  ; state
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L10.10|
000008  2000              MOVS     r0,#0
                  |L10.10|
;;;504    }
00000a  4770              BX       lr
                          ENDP

                  |L10.12|
                          DCD      ||.data||

                          AREA ||i.uninit||, CODE, READONLY, ALIGN=2

                  uninit PROC
;;;125    
;;;126    static error_t uninit(void)
000000  b510              PUSH     {r4,lr}
;;;127    {
;;;128        int iap_status;
;;;129    
;;;130        if (STATE_CLOSED == state) {
000002  4c0d              LDR      r4,|L11.56|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L11.22|
;;;131            util_assert(0);
;;;132            return ERROR_INTERNAL;
;;;133        }
;;;134    
;;;135        state = STATE_CLOSED;
000008  2000              MOVS     r0,#0
00000a  7020              STRB     r0,[r4,#0]
;;;136        iap_status = UnInit(0);
00000c  f7fffffe          BL       UnInit
;;;137    
;;;138        if (iap_status != 0) {
000010  b140              CBZ      r0,|L11.36|
;;;139            return ERROR_IAP_UNINIT;
000012  201e              MOVS     r0,#0x1e
;;;140        }
;;;141    
;;;142        if (!update_complete && !daplink_is_bootloader()) {
;;;143            // Interface - Error if the bootloader update is not complete
;;;144            // Bootloader - For 3rd party applications the end of the update
;;;145            //              is unknown so it is not an error if the transfer
;;;146            //              ends early.
;;;147            return ERROR_IAP_UPDT_INCOMPLETE;
;;;148        }
;;;149    
;;;150        return ERROR_SUCCESS;
;;;151    }
000014  bd10              POP      {r4,pc}
                  |L11.22|
000016  2283              MOVS     r2,#0x83              ;131
000018  a108              ADR      r1,|L11.60|
00001a  2000              MOVS     r0,#0                 ;131
00001c  f7fffffe          BL       _util_assert
000020  2002              MOVS     r0,#2                 ;132
000022  bd10              POP      {r4,pc}
                  |L11.36|
000024  7860              LDRB     r0,[r4,#1]            ;142  ; update_complete
000026  b910              CBNZ     r0,|L11.46|
000028  f7fffffe          BL       daplink_is_bootloader
00002c  b108              CBZ      r0,|L11.50|
                  |L11.46|
00002e  2000              MOVS     r0,#0                 ;150
000030  bd10              POP      {r4,pc}
                  |L11.50|
000032  2024              MOVS     r0,#0x24              ;147
000034  bd10              POP      {r4,pc}
;;;152    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      ||.data||
                  |L11.60|
00003c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000040  2e5c2e2e
000044  5c736f75
000048  7263655c
00004c  6461706c
000050  696e6b5c
000054  64726167
000058  2d6e2d64
00005c  726f705c
000060  6961705f
000064  666c6173
000068  685f696e
00006c  74      
00006d  662e6300          DCB      "f.c",0
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  sector_buf
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  flash_intf
                          DCD      init
                          DCD      uninit
                          DCD      program_page
                          DCD      erase_sector
                          DCD      erase_chip
                          DCD      program_page_min_size
                          DCD      erase_sector_size
                          DCD      target_flash_busy
                          DCD      0x00000000

                          AREA ||area_number.16||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.constdata||
                  flash_intf_iap_protected
                          DCD      flash_intf

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00                DCB      0x00
                  update_complete
000001  00                DCB      0x00
                  mass_erase_performed
000002  00                DCB      0x00
                  current_sector_set
000003  00                DCB      0x00
                  current_page_set
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  current_sector
                          DCD      0x00000000
                  current_sector_size
                          DCD      0x00000000
                  current_page
                          DCD      0x00000000
                  current_page_write_size
                          DCD      0x00000000
                  ||crc||
                          DCD      0x00000000
