L 1 "..\..\..\source\hic_hal\stm32\stm32f103xb\usb_config.c"
N/**
N * @file    usb_config.h
N * @brief
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#include "util.h"
L 1 "..\..\..\source\daplink\util.h" 1
N/**
N * @file    util.h
N * @brief   useful things
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2020, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef UTIL_H
N#define UTIL_H
N
N#include <stdbool.h>
L 1 "C:\Keil_v535\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 26 "..\..\..\source\daplink\util.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v535\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 27 "..\..\..\source\daplink\util.h" 2
N
N// Protect commonly-defined macros with ifdefs, to prevent conflicts if redefined
N// in imported sources (mostly vendor SDKs).
N
N#if !defined(ARRAY_SIZE)
X#if !0L
N//! @brief Get number of elements in the array.
N#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
N#endif
N
N#if !defined(MIN)
X#if !0L
N#define MIN(a,b)                        ((a) < (b) ? (a) : (b))
N#endif
N
N#if !defined(MAX)
X#if !0L
N#define MAX(a,b)                        ((a) > (b) ? (a) : (b))
N#endif
N
N#define MB(size)                        ((size) * 1024 * 1024)
N
N#define KB(size)                        ((size) * 1024)
N
N#define ROUND_UP(value, boundary)       ((value) + ((boundary) - (value)) % (boundary))
N
N#define ROUND_DOWN(value, boundary)     ((value) - ((value) % (boundary)))
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N// Write the value to the address specified and return the size
Nuint32_t util_write_hex8(char *str, uint8_t value);
Nuint32_t util_write_hex16(char *str, uint16_t value);
Nuint32_t util_write_hex32(char *str, uint32_t value);
Nuint32_t util_write_uint32(char *str, uint32_t value);
Nuint32_t util_write_uint32(char *str, uint32_t value);
Nuint32_t util_write_uint32_zp(char *str, uint32_t value, uint16_t total_size);
Nuint32_t util_write_string(char *str, const char *data);
N
Nuint32_t util_div_round_up(uint32_t dividen, uint32_t divisor);
Nuint32_t util_div_round_down(uint32_t dividen, uint32_t divisor);
Nuint32_t util_div_round(uint32_t dividen, uint32_t divisor);
N
N#if !(defined(DAPLINK_NO_ASSERT_FILENAMES) && defined(DAPLINK_BL))
X#if !(1L && 0L)
N// With the filename enabled.
N#define util_assert(expression) _util_assert((expression), __FILE__, __LINE__)
N#else
S// Filename disabled to save code size.
S#define util_assert(expression) _util_assert((expression), "(file)", __LINE__)
N#endif
Nvoid _util_assert(bool expression, const char *filename, uint16_t line);
Xvoid _util_assert(_Bool expression, const char *filename, uint16_t line);
N
Nvoid util_assert_clear(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 23 "..\..\..\source\hic_hal\stm32\stm32f103xb\usb_config.c" 2
N
N// <e> USB Device
N//   <i> Enable the USB Device functionality
N#define USBD_ENABLE                 1
N#define USBD_RTX_CORE_STACK         0
N#define USBD_RTX_DEVICE_STACK       0
N#define USBD_RTX_ENDPOINT0_STACK    0
N
N//   <o0.0> High-speed
N//     <i> Enable high-speed functionality (if device supports it)
N#define USBD_HS_ENABLE              0
N#if (defined(WEBUSB_INTERFACE) || defined(WINUSB_INTERFACE) || defined(BULK_ENDPOINT))
X#if (1L || 1L || 1L)
N#define USBD_BOS_ENABLE             1
N#else
S#define USBD_BOS_ENABLE             0
N#endif
N//   <h> Device Settings
N//     <i> These settings affect Device Descriptor
N//     <o0> Power
N//       <i> Default Power Setting
N//       <0=> Bus-powered
N//       <1=> Self-powered
N//     <o1> Max Endpoint 0 Packet Size
N//       <i> Maximum packet size for endpoint zero (bMaxPacketSize0)
N//       <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes
N//     <o2.0..15> Vendor ID <0x0000-0xFFFF>
N//       <i> Vendor ID assigned by the USB-IF (idVendor)
N//     <o3.0..15> Product ID <0x0000-0xFFFF>
N//       <i> Product ID assigned by the manufacturer (idProduct)
N//     <o4.0..15> Device Release Number <0x0000-0xFFFF>
N//       <i> Device release number in binary-coded decimal (bcdDevice)
N//   </h>
N#define USBD_POWER                  0
N#define USBD_MAX_PACKET0            64
N#define USBD_DEVDESC_IDVENDOR       0x0D28
N#define USBD_DEVDESC_IDPRODUCT      0x0204
N#define USBD_DEVDESC_BCDDEVICE      0x0100 //was 0x0100
N
N//   <h> Configuration Settings
N//     <i> These settings affect Configuration Descriptor
N//     <o0.5> Remote Wakeup
N//       <i> Configuration support for remote wakeup (D5: of bmAttributes)
N//     <o1.0..7> Maximum Power Consumption (in mA) <0-510><#/2>
N//       <i> Maximum power consumption of the USB device
N//       <i> from the bus in this specific configuration
N//       <i> when the device is fully operational (bMaxPower)
N//   </h>
N#define USBD_CFGDESC_BMATTRIBUTES   0x80
N#define USBD_CFGDESC_BMAXPOWER      0xFA
N
N//   <h> String Settings
N//     <i> These settings affect String Descriptor
N//     <o0.0..15> Language ID <0x0000-0xFCFF>
N//       <i> English (United States) = 0x0409
N//     <s0.126> Manufacturer String
N//       <i> String descriptor describing manufacturer
N//     <s1.126> Product String
N//       <i> String descriptor describing product
N//     <e1.0> Serial Number
N//       <i> Enable serial number string
N//       <i> If disabled serial number string will not be assigned to the USB Device
N//       <s2.126> Serial Number String
N//         <i> String descriptor describing device's serial number
N//     </e>
N//   </h>
N#define USBD_STRDESC_LANGID         0x0409
N#define USBD_STRDESC_MAN            L"ARM"
N#define USBD_STRDESC_PROD           L"DAPLink CMSIS-DAP"
N#define USBD_STRDESC_SER_ENABLE     1
N#define USBD_STRDESC_SER            L"0001A0000000"
N
N//   <e0> Class Support
N//     <i> Enables USB Device Class specific Requests
N#define USBD_CLASS_ENABLE           1
N
N//     <e0.0> Human Interface Device (HID)
N//       <i> Enable class support for Human Interface Device (HID)
N//       <h> Interrupt Endpoint Settings
N//         <o1.0..4> Interrupt In Endpoint Number                  <1=>   1 <2=>   2 <3=>   3
N//                                                 <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                                 <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                                 <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//         <o2.0..4> Interrupt Out Endpoint Number <0=>   Not used <1=>   1 <2=>   2 <3=>   3
N//                                                 <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                                 <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                                 <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//           <i> If interrupt out endpoint is not used select "Not used"
N//         <h> Endpoint Settings
N//           <o3.0..7> Maximum Endpoint Packet Size (in bytes) <0-64>
N//           <o4.0..7> Endpoint polling Interval (in ms) <1-255>
N//           <e5> High-speed
N//             <i> If high-speed is enabled set endpoint settings for it
N//             <o6.0..10> Maximum Endpoint Packet Size (in bytes) <0-1024>
N//             <o6.11..12> Additional transactions per microframe <0=> None <1=> 1 additional <2=> 2 additional
N//             <o7.0..7> Endpoint polling Interval (in ms) <1=>      1 <2=>      2 <3=>      4 <4=>      8
N//                                                         <5=>     16 <6=>     32 <7=>     64 <8=>    128
N//                                                         <9=>    256 <10=>   512 <11=>  1024 <12=>  2048
N//                                                         <13=>  4096 <14=>  8192 <15=> 16384 <16=> 32768
N//           </e>
N//         </h>
N//       </h>
N//       <h> Human Interface Device Settings
N//         <i> Device specific settings
N//         <s0.126> HID Interface String
N//         <o8.0..4> Number of Input Reports <1-32>
N//         <o9.0..4> Number of Output Reports <1-32>
N//         <o10.0..15> Maximum Input Report Size (in bytes) <1-65535>
N//         <o11.0..15> Maximum Output Report Size (in bytes) <1-65535>
N//         <o12.0..15> Maximum Feature Report Size (in bytes) <1-65535>
N//       </h>
N//     </e>
N#ifndef HID_ENDPOINT
S#define HID_ENDPOINT 0
N#else
N#define HID_ENDPOINT 1
N#endif
N
N#ifndef WEBUSB_INTERFACE
S#define WEBUSB_INTERFACE 0
N#else
N#define WEBUSB_INTERFACE 1
N#endif
N
N#define USBD_HID_ENABLE             HID_ENDPOINT
N#ifndef BULK_ENDPOINT               //check if bulk endpoint is not enabled
S#define USBD_HID_EP_INTIN           1
S#define USBD_HID_EP_INTOUT          1
N#else                               //if bulk endpoint is enabled remove interrupt endpoints from the hid
N#define USBD_HID_EP_INTIN           0
N#define USBD_HID_EP_INTOUT          0
N#endif
N#define USBD_HID_EP_INTIN_STACK     0
N#define USBD_HID_WMAXPACKETSIZE     64
N#define USBD_HID_BINTERVAL          1
N#define USBD_HID_HS_ENABLE          0
N#define USBD_HID_HS_WMAXPACKETSIZE  64
N#define USBD_HID_HS_BINTERVAL       6
N#define USBD_HID_STRDESC            L"CMSIS-DAP v1"
N#define USBD_WEBUSB_STRDESC         L"WebUSB: CMSIS-DAP"
N#define USBD_HID_INREPORT_NUM       1
N#define USBD_HID_OUTREPORT_NUM      1
N#define USBD_HID_INREPORT_MAX_SZ    64
N#define USBD_HID_OUTREPORT_MAX_SZ   64
N#define USBD_HID_FEATREPORT_MAX_SZ  1
N
N//     <e0.0> Mass Storage Device (MSC)
N//       <i> Enable class support for Mass Storage Device (MSC)
N//       <h> Bulk Endpoint Settings
N//         <o1.0..4> Bulk In Endpoint Number                  <1=>   1 <2=>   2 <3=>   3
N//                                            <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                            <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                            <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//         <o2.0..4> Bulk Out Endpoint Number                 <1=>   1 <2=>   2 <3=>   3
N//                                            <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                            <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                            <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//         <h> Endpoint Settings
N//           <o3> Maximum Packet Size <1-1024>
N//           <e4> High-speed
N//             <i> If high-speed is enabled set endpoint settings for it
N//             <o5> Maximum Packet Size <1-1024>
N//             <o6> Maximum NAK Rate <0-255>
N//           </e>
N//         </h>
N//       </h>
N//       <h> Mass Storage Device Settings
N//         <i> Device specific settings
N//         <s0.126> MSC Interface String
N//         <h> Inquiry Data
N//           <s1.8>  Vendor Identification
N//           <s2.16> Product Identification
N//           <s3.4>  Product Revision Level
N//         </h>
N//       </h>
N//     </e>
N#ifndef MSC_ENDPOINT
S#define MSC_ENDPOINT 0
N#else
N#define MSC_ENDPOINT 1
N#endif
N#define USBD_MSC_ENABLE             MSC_ENDPOINT
N#define USBD_MSC_EP_BULKIN          2
N#define USBD_MSC_EP_BULKOUT         2
N#define USBD_MSC_EP_BULKIN_STACK    0
N#define USBD_MSC_WMAXPACKETSIZE     64
N#define USBD_MSC_HS_ENABLE          0
N#define USBD_MSC_HS_WMAXPACKETSIZE  512
N#define USBD_MSC_HS_BINTERVAL       0
N#define USBD_MSC_STRDESC            L"USB_MSC"
N// Make sure changes to USBD_MSC_INQUIRY_DATA are coordinated with mbed-ls
N// since this is used to detect DAPLink drives
N#define USBD_MSC_INQUIRY_DATA       "MBED    "         \
N                                    "VFS             " \
N                                    "0.1"
X#define USBD_MSC_INQUIRY_DATA       "MBED    "                                             "VFS             "                                     "0.1"
N
N//     <e0.0> Audio Device (ADC)
N//       <i> Enable class support for Audio Device (ADC)
N//       <h> Isochronous Endpoint Settings
N//         <o1.0..4> Isochronous Out Endpoint Number                 <1=>   1 <2=>   2 <3=>   3
N//                                                   <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                                   <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                                   <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//         <h> Endpoint Settings
N//           <o2.0..10> Maximum Endpoint Packet Size (in bytes) <0-1024>
N//           <o3.0..10> Endpoint polling Interval (in ms) <1=>      1 <2=>      2 <3=>      4 <4=>      8
N//                                                        <5=>     16 <6=>     32 <7=>     64 <8=>    128
N//                                                        <9=>    256 <10=>   512 <11=>  1024 <12=>  2048
N//                                                        <13=>  4096 <14=>  8192 <15=> 16384 <16=> 32768
N//           <e4> High-speed
N//             <i> If high-speed is enabled set endpoint settings for it
N//             <o5.0..10> Maximum Endpoint Packet Size (in bytes) <0-1024>
N//             <o5.11..12> Additional transactions per microframe <0=> None <1=> 1 additional <2=> 2 additional
N//           </e>
N//         </h>
N//       </h>
N//       <h> Audio Device Settings
N//         <i> Device specific settings
N//         <s0.126> Audio Control Interface String
N//         <s1.126> Audio Streaming (Zero Bandwidth) Interface String
N//         <s2.126> Audio Streaming (Operational) Interface String
N//         <o6.0..7> Audio Subframe Size (in bytes) <0-255>
N//         <o7.0..7> Sample Resolution (in bits) <0-255>
N//         <o8.0..23> Sample Frequency (in Hz) <0-16777215>
N//         <o9> Packet Size (in bytes) <1-256>
N//         <o10> Packet Count <1-16>
N//       </h>
N//     </e>
N#define USBD_ADC_ENABLE             0
N#define USBD_ADC_EP_ISOOUT          3
N#define USBD_ADC_WMAXPACKETSIZE     64
N#define USBD_ADC_BINTERVAL          1
N#define USBD_ADC_HS_ENABLE          0
N#define USBD_ADC_HS_WMAXPACKETSIZE  64
N#define USBD_ADC_CIF_STRDESC        L"USB_ADC"
N#define USBD_ADC_SIF1_STRDESC       L"USB_ADC1"
N#define USBD_ADC_SIF2_STRDESC       L"USB_ADC2"
N#define USBD_ADC_BSUBFRAMESIZE      2
N#define USBD_ADC_BBITRESOLUTION     16
N#define USBD_ADC_TSAMFREQ           32000
N#define USBD_ADC_CFG_P_S            32
N#define USBD_ADC_CFG_P_C            1
N
N//     <e0> Communication Device (CDC) - Abstract Control Model (ACM)
N//       <i> Enable class support for Communication Device (CDC) - Abstract Control Model (ACM)
N//       <h> Interrupt Endpoint Settings
N//         <o1.0..4> Interrupt In Endpoint Number                 <1=>   1 <2=>   2 <3=>   3
N//                                                <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                                <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                                <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//         <h> Endpoint Settings
N//           <o2.0..10> Maximum Endpoint Packet Size (in bytes) <0-1024>
N//           <o3.0..10> Endpoint polling Interval (in ms) <0-255>
N//           <e4> High-speed
N//             <i> If high-speed is enabled set endpoint settings for it
N//             <o5.0..10> Maximum Endpoint Packet Size (in bytes) <0-1024>
N//             <o5.11..12> Additional transactions per microframe <0=> None <1=> 1 additional <2=> 2 additional
N//             <o6.0..10> Endpoint polling Interval (in ms) <1=>      1 <2=>      2 <3=>      4 <4=>      8
N//                                                          <5=>     16 <6=>     32 <7=>     64 <8=>    128
N//                                                          <9=>    256 <10=>   512 <11=>  1024 <12=>  2048
N//                                                          <13=>  4096 <14=>  8192 <15=> 16384 <16=> 32768
N//           </e4>
N//         </h>
N//       </h>
N//       <h> Bulk Endpoint Settings
N//         <o7.0..4> Bulk In Endpoint Number                  <1=>   1 <2=>   2 <3=>   3
N//                                            <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                            <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                            <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//         <o8.0..4> Bulk Out Endpoint Number                 <1=>   1 <2=>   2 <3=>   3
N//                                            <4=>   4        <5=>   5 <6=>   6 <7=>   7
N//                                            <8=>   8        <9=>   9 <10=> 10 <11=> 11
N//                                            <12=>  12       <13=> 13 <14=> 14 <15=> 15
N//         <h> Endpoint Settings
N//           <o9> Maximum Packet Size <1-1024>
N//           <e10> High-speed
N//             <i> If high-speed is enabled set endpoint settings for it
N//             <o11> Maximum Packet Size <1-1024>
N//             <o12> Maximum NAK Rate <0-255>
N//           </e10>
N//         </h>
N//       </h>
N//       <h> Communication Device Settings
N//         <i> Device specific settings
N//         <s0.126> Communication Class Interface String
N//         <s1.126> Data Class Interface String
N//         <o13> Maximum Communication Device Send Buffer Size
N//            <8=>     8 Bytes <16=>   16 Bytes <32=>     32 Bytes <64=>  64 Bytes <128=> 128 Bytes
N//            <256=> 256 Bytes <512=> 512 Bytes <1024=> 1024 Bytes
N//         <o14> Maximum Communication Device Receive Buffer Size
N//            <i> Minimum size must be as big as maximum packet size for Bulk Out Endpoint
N//            <8=>     8 Bytes <16=>   16 Bytes <32=>     32 Bytes <64=>  64 Bytes <128=> 128 Bytes
N//            <256=> 256 Bytes <512=> 512 Bytes <1024=> 1024 Bytes
N//       </h>
N//     </e>
N
N#ifndef CDC_ENDPOINT
S#define CDC_ENDPOINT 0
N#else
N#define CDC_ENDPOINT 1
N#endif
N#define USBD_CDC_ACM_ENABLE             CDC_ENDPOINT
N#define USBD_CDC_ACM_EP_INTIN           3
N#define USBD_CDC_ACM_EP_INTIN_STACK     0
N#define USBD_CDC_ACM_WMAXPACKETSIZE     16
N#define USBD_CDC_ACM_BINTERVAL          32
N#define USBD_CDC_ACM_HS_ENABLE          0
N#define USBD_CDC_ACM_HS_WMAXPACKETSIZE  16
N#define USBD_CDC_ACM_HS_BINTERVAL       2
N#define USBD_CDC_ACM_EP_BULKIN          4
N#define USBD_CDC_ACM_EP_BULKOUT         4
N#define USBD_CDC_ACM_EP_BULKIN_STACK    0
N#define USBD_CDC_ACM_WMAXPACKETSIZE1    16
N#define USBD_CDC_ACM_HS_ENABLE1         0
N#define USBD_CDC_ACM_HS_WMAXPACKETSIZE1 16
N#define USBD_CDC_ACM_HS_BINTERVAL1      0
N#define USBD_CDC_ACM_CIF_STRDESC        L"mbed Serial Port"
N#define USBD_CDC_ACM_DIF_STRDESC        L"mbed Serial Port"
N#define USBD_CDC_ACM_SENDBUF_SIZE       64
N#define USBD_CDC_ACM_RECEIVEBUF_SIZE    64
N#if (((USBD_CDC_ACM_HS_ENABLE1) && (USBD_CDC_ACM_SENDBUF_SIZE    < USBD_CDC_ACM_HS_WMAXPACKETSIZE1)) || (USBD_CDC_ACM_SENDBUF_SIZE    < USBD_CDC_ACM_WMAXPACKETSIZE1))
X#if (((0) && (64    < 16)) || (64    < 16))
S#error "Send Buffer size must be larger or equal to Bulk In maximum packet size!"
N#endif
N#if (((USBD_CDC_ACM_HS_ENABLE1) && (USBD_CDC_ACM_RECEIVEBUF_SIZE < USBD_CDC_ACM_HS_WMAXPACKETSIZE1)) || (USBD_CDC_ACM_RECEIVEBUF_SIZE < USBD_CDC_ACM_WMAXPACKETSIZE1))
X#if (((0) && (64 < 16)) || (64 < 16))
S#error "Receive Buffer size must be larger or equal to Bulk Out maximum packet size!"
N#endif
N
N//     <e0> Custom Class Device
N//       <i> Enables USB Custom Class Requests
N//       <i> Class IDs:
N//       <i> 0x00 - Class Reserved ID
N//       <i> 0x01 - Class Audio ID
N//       <i> 0x02 - Class Communications ID
N//       <i> 0x03 - Class Human Interface ID
N//       <i> 0x04 - Class Monitor ID
N//       <i> 0x05 - Class Physical Interface ID
N//       <i> 0x06 - Class Power ID
N//       <i> 0x07 - Class Printer ID
N//       <i> 0x08 - Class Storage ID
N//       <i> 0x09 - Class HUB ID
N//       <i> 0xEF - Class Miscellaneous ID
N//       <i> 0xFF - Class Vendor Specific ID
N//     </e>
N#define USBD_CLS_ENABLE             0
N
N//     WebUSB support
N#define USBD_WEBUSB_ENABLE          WEBUSB_INTERFACE
N#define USBD_WEBUSB_VENDOR_CODE     0x21
N#define USBD_WEBUSB_LANDING_URL     "os.mbed.com/webusb/landing-page/?bid="
N#define USBD_WEBUSB_ORIGIN_URL      "os.mbed.com/"
N
N//     Microsoft OS Descriptors 2.0 (WinUSB) support
N#define USBD_WINUSB_ENABLE          WINUSB_INTERFACE
N#define USBD_WINUSB_VENDOR_CODE     0x20
N//   </e>
N// </e>
N
N#ifndef BULK_ENDPOINT
S#define BULK_ENDPOINT 0
N#else
N#define BULK_ENDPOINT 1
N#endif
N#define USBD_BULK_ENABLE             BULK_ENDPOINT
N#define USBD_BULK_EP_BULKIN          1 // fixme: both bulk and hid ep cannot be both enabled in a single build
N#define USBD_BULK_EP_BULKOUT         1
N#define USBD_BULK_EP_BULKIN_SWO      6
N#define USBD_BULK_WMAXPACKETSIZE     64
N#define USBD_BULK_HS_ENABLE          0
N#define USBD_BULK_HS_WMAXPACKETSIZE  512
N#define USBD_BULK_STRDESC            L"CMSIS-DAP v2"
N
N/* USB Device Calculations ---------------------------------------------------*/
N
N#define USBD_IF_NUM_MAX             (USBD_BULK_ENABLE+USBD_WEBUSB_ENABLE+USBD_HID_ENABLE+USBD_MSC_ENABLE+(USBD_ADC_ENABLE*2)+(USBD_CDC_ACM_ENABLE*2)+USBD_CLS_ENABLE)
N#define USBD_MULTI_IF               (USBD_CDC_ACM_ENABLE*(USBD_HID_ENABLE|USBD_MSC_ENABLE|USBD_ADC_ENABLE|USBD_CLS_ENABLE|USBD_WEBUSB_ENABLE|USBD_BULK_ENABLE))
N// #define MAX(x, y)                   (((x) < (y)) ? (y) : (x))
N#define USBD_EP_NUM_CALC0           MAX((USBD_HID_ENABLE    *(USBD_HID_EP_INTIN     )), (USBD_HID_ENABLE    *(USBD_HID_EP_INTOUT)))
N#define USBD_EP_NUM_CALC1           MAX((USBD_MSC_ENABLE    *(USBD_MSC_EP_BULKIN    )), (USBD_MSC_ENABLE    *(USBD_MSC_EP_BULKOUT)))
N#define USBD_EP_NUM_CALC2           MAX((USBD_ADC_ENABLE    *(USBD_ADC_EP_ISOOUT    )), (USBD_CDC_ACM_ENABLE*(USBD_CDC_ACM_EP_INTIN)))
N#define USBD_EP_NUM_CALC3           MAX((USBD_CDC_ACM_ENABLE*(USBD_CDC_ACM_EP_BULKIN)), (USBD_CDC_ACM_ENABLE*(USBD_CDC_ACM_EP_BULKOUT)))
N#define USBD_EP_NUM_CALC4           MAX(USBD_EP_NUM_CALC0, USBD_EP_NUM_CALC1)
N#define USBD_EP_NUM_CALC5           MAX(USBD_EP_NUM_CALC2, USBD_EP_NUM_CALC3)
N#define USBD_EP_NUM_CALC6           MAX(USBD_EP_NUM_CALC4, USBD_EP_NUM_CALC5)
N#define USBD_EP_NUM_CALC7           MAX((USBD_BULK_ENABLE*(USBD_BULK_EP_BULKIN)), (USBD_BULK_ENABLE*(USBD_BULK_EP_BULKOUT)))
N#define USBD_EP_NUM                 MAX(USBD_EP_NUM_CALC6, USBD_EP_NUM_CALC7)
N
N
N#if    (USBD_HID_ENABLE)
X#if    (1)
N#if    (USBD_MSC_ENABLE)
X#if    (1)
N#if ((((USBD_HID_EP_INTIN   == USBD_MSC_EP_BULKIN)  || \
N       (USBD_HID_EP_INTIN   == USBD_MSC_EP_BULKIN)))|| \
N      ((USBD_HID_EP_INTOUT  != 0)                   && \
N       (USBD_HID_EP_INTOUT  == USBD_MSC_EP_BULKIN)  || \
N       (USBD_HID_EP_INTOUT  == USBD_MSC_EP_BULKOUT)))
X#if ((((0   == 2)  ||        (0   == 2)))||       ((0  != 0)                   &&        (0  == 2)  ||        (0  == 2)))
S#error "HID and Mass Storage Device Interface can not use same Endpoints!"
N#endif
N#endif
N#if    (USBD_ADC_ENABLE)
X#if    (0)
S#if   ((USBD_HID_EP_INTIN   == USBD_ADC_EP_ISOOUT)  || \
S      ((USBD_HID_EP_INTOUT  != 0)                   && \
S       (USBD_HID_EP_INTOUT  == USBD_ADC_EP_ISOOUT)))
X#if   ((USBD_HID_EP_INTIN   == USBD_ADC_EP_ISOOUT)  ||       ((USBD_HID_EP_INTOUT  != 0)                   &&        (USBD_HID_EP_INTOUT  == USBD_ADC_EP_ISOOUT)))
S#error "HID and Audio Device Interface can not use same Endpoints!"
S#endif
N#endif
N#if    (USBD_CDC_ACM_ENABLE)
X#if    (1)
N#if  (((USBD_HID_EP_INTIN   == USBD_CDC_ACM_EP_INTIN)   || \
N       (USBD_HID_EP_INTIN   == USBD_CDC_ACM_EP_BULKIN)  || \
N       (USBD_HID_EP_INTIN   == USBD_CDC_ACM_EP_BULKOUT))|| \
N      ((USBD_HID_EP_INTOUT  != 0)                       && \
N      ((USBD_HID_EP_INTOUT  == USBD_CDC_ACM_EP_INTIN)   || \
N       (USBD_HID_EP_INTOUT  == USBD_CDC_ACM_EP_BULKIN)  || \
N       (USBD_HID_EP_INTOUT  == USBD_CDC_ACM_EP_BULKOUT))))
X#if  (((0   == 3)   ||        (0   == 4)  ||        (0   == 4))||       ((0  != 0)                       &&       ((0  == 3)   ||        (0  == 4)  ||        (0  == 4))))
S#error "HID and Communication Device Interface can not use same Endpoints!"
N#endif
N#endif
N#endif
N
N#if    (USBD_MSC_ENABLE)
X#if    (1)
N#if    (USBD_ADC_ENABLE)
X#if    (0)
S#if   ((USBD_MSC_EP_BULKIN  == USBD_ADC_EP_ISOOUT)  || \
S       (USBD_MSC_EP_BULKOUT == USBD_ADC_EP_ISOOUT))
X#if   ((USBD_MSC_EP_BULKIN  == USBD_ADC_EP_ISOOUT)  ||        (USBD_MSC_EP_BULKOUT == USBD_ADC_EP_ISOOUT))
S#error "Mass Storage Device and Audio Device Interface can not use same Endpoints!"
S#endif
N#endif
N#if    (USBD_CDC_ACM_ENABLE)
X#if    (1)
N#if   ((USBD_MSC_EP_BULKIN  == USBD_CDC_ACM_EP_INTIN)   || \
N       (USBD_MSC_EP_BULKIN  == USBD_CDC_ACM_EP_BULKIN)  || \
N       (USBD_MSC_EP_BULKIN  == USBD_CDC_ACM_EP_BULKOUT) || \
N       (USBD_MSC_EP_BULKOUT == USBD_CDC_ACM_EP_INTIN)   || \
N       (USBD_MSC_EP_BULKOUT == USBD_CDC_ACM_EP_BULKIN)  || \
N       (USBD_MSC_EP_BULKOUT == USBD_CDC_ACM_EP_BULKOUT))
X#if   ((2  == 3)   ||        (2  == 4)  ||        (2  == 4) ||        (2 == 3)   ||        (2 == 4)  ||        (2 == 4))
S#error "Mass Storage Device and Communication Device Interface can not use same Endpoints!"
N#endif
N#endif
N#endif
N
N#if    (USBD_ADC_ENABLE)
X#if    (0)
S#if    (USBD_CDC_ACM_ENABLE)
S#if   ((USBD_ADC_EP_ISOOUT  == USBD_CDC_ACM_EP_INTIN)   || \
S       (USBD_ADC_EP_ISOOUT  == USBD_CDC_ACM_EP_BULKIN)  || \
S       (USBD_ADC_EP_ISOOUT  == USBD_CDC_ACM_EP_BULKOUT))
X#if   ((USBD_ADC_EP_ISOOUT  == USBD_CDC_ACM_EP_INTIN)   ||        (USBD_ADC_EP_ISOOUT  == USBD_CDC_ACM_EP_BULKIN)  ||        (USBD_ADC_EP_ISOOUT  == USBD_CDC_ACM_EP_BULKOUT))
S#error "Audio Device and Communication Device Interface can not use same Endpoints!"
S#endif
S#endif
N#endif
N
N#define USBD_ADC_CIF_NUM           (0)
N#define USBD_ADC_SIF1_NUM          (1)
N#define USBD_ADC_SIF2_NUM          (2)
N
N
N#define USBD_ADC_CIF_STR_NUM       (3+USBD_STRDESC_SER_ENABLE+0)
N#define USBD_ADC_SIF1_STR_NUM      (3+USBD_STRDESC_SER_ENABLE+1)
N#define USBD_ADC_SIF2_STR_NUM      (3+USBD_STRDESC_SER_ENABLE+2)
N#define USBD_CDC_ACM_CIF_STR_NUM   (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+0)
N#define USBD_CDC_ACM_DIF_STR_NUM   (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+1)
N#define USBD_HID_IF_STR_NUM        (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2)
N#define USBD_WEBUSB_IF_STR_NUM     (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_HID_ENABLE)
N#define USBD_MSC_IF_STR_NUM        (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_HID_ENABLE+USBD_WEBUSB_ENABLE)
N#define USBD_BULK_IF_STR_NUM       (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_HID_ENABLE+USBD_WEBUSB_ENABLE+USBD_BULK_ENABLE)
N
N
N#if    (USBD_HID_ENABLE)
X#if    (1)
N#if    (USBD_HID_HS_ENABLE)
X#if    (0)
S#define USBD_HID_MAX_PACKET       ((USBD_HID_HS_WMAXPACKETSIZE > USBD_HID_WMAXPACKETSIZE) ? USBD_HID_HS_WMAXPACKETSIZE : USBD_HID_WMAXPACKETSIZE)
N#else
N#define USBD_HID_MAX_PACKET        (USBD_HID_WMAXPACKETSIZE)
N#endif
N#else
S#define USBD_HID_MAX_PACKET        (0)
N#endif
N#if    (USBD_MSC_ENABLE)
X#if    (1)
N#if    (USBD_MSC_HS_ENABLE)
X#if    (0)
S#define USBD_MSC_MAX_PACKET       ((USBD_MSC_HS_WMAXPACKETSIZE > USBD_MSC_WMAXPACKETSIZE) ? USBD_MSC_HS_WMAXPACKETSIZE : USBD_MSC_WMAXPACKETSIZE)
N#else
N#define USBD_MSC_MAX_PACKET        (USBD_MSC_WMAXPACKETSIZE)
N#endif
N#else
S#define USBD_MSC_MAX_PACKET        (0)
N#endif
N#if    (USBD_ADC_ENABLE)
X#if    (0)
S#if    (USBD_ADC_HS_ENABLE)
S#define USBD_ADC_MAX_PACKET       ((USBD_ADC_HS_WMAXPACKETSIZE > USBD_ADC_WMAXPACKETSIZE) ? USBD_ADC_HS_WMAXPACKETSIZE : USBD_ADC_WMAXPACKETSIZE)
S#else
S#define USBD_ADC_MAX_PACKET        (USBD_ADC_WMAXPACKETSIZE)
S#endif
N#else
N#define USBD_ADC_MAX_PACKET        (0)
N#endif
N#if    (USBD_CDC_ACM_ENABLE)
X#if    (1)
N#if    (USBD_CDC_ACM_HS_ENABLE)
X#if    (0)
S#define USBD_CDC_ACM_MAX_PACKET   ((USBD_CDC_ACM_HS_WMAXPACKETSIZE > USBD_CDC_ACM_WMAXPACKETSIZE) ? USBD_CDC_ACM_HS_WMAXPACKETSIZE : USBD_CDC_ACM_WMAXPACKETSIZE)
N#else
N#define USBD_CDC_ACM_MAX_PACKET    (USBD_CDC_ACM_WMAXPACKETSIZE)
N#endif
N#if    (USBD_CDC_ACM_HS_ENABLE1)
X#if    (0)
S#define USBD_CDC_ACM_MAX_PACKET1  ((USBD_CDC_ACM_HS_WMAXPACKETSIZE1 > USBD_CDC_ACM_WMAXPACKETSIZE1) ? USBD_CDC_ACM_HS_WMAXPACKETSIZE1 : USBD_CDC_ACM_WMAXPACKETSIZE1)
N#else
N#define USBD_CDC_ACM_MAX_PACKET1   (USBD_CDC_ACM_WMAXPACKETSIZE1)
N#endif
N#else
S#define USBD_CDC_ACM_MAX_PACKET    (0)
S#define USBD_CDC_ACM_MAX_PACKET1   (0)
N#endif
N#if    (USBD_BULK_ENABLE)
X#if    (1)
N#if    (USBD_BULK_HS_ENABLE)
X#if    (0)
S#define USBD_BULK_MAX_PACKET       ((USBD_BULK_HS_WMAXPACKETSIZE > USBD_BULK_WMAXPACKETSIZE) ? USBD_BULK_HS_WMAXPACKETSIZE : USBD_BULK_WMAXPACKETSIZE)
N#else
N#define USBD_BULK_MAX_PACKET        (USBD_BULK_WMAXPACKETSIZE)
N#endif
N#else
S#define USBD_BULK_MAX_PACKET        (0)
N#endif
N
N#define USBD_MAX_PACKET_CALC0     ((USBD_HID_MAX_PACKET   > USBD_HID_MAX_PACKET      ) ? (USBD_HID_MAX_PACKET  ) : (USBD_HID_MAX_PACKET      ))
N#define USBD_MAX_PACKET_CALC1     ((USBD_ADC_MAX_PACKET   > USBD_CDC_ACM_MAX_PACKET  ) ? (USBD_ADC_MAX_PACKET  ) : (USBD_CDC_ACM_MAX_PACKET  ))
N#define USBD_MAX_PACKET_CALC2     ((USBD_MAX_PACKET_CALC0 > USBD_MAX_PACKET_CALC1    ) ? (USBD_MAX_PACKET_CALC0) : (USBD_MAX_PACKET_CALC1    ))
N#define USBD_MAX_PACKET_CALC3     ((USBD_BULK_MAX_PACKET > USBD_CDC_ACM_MAX_PACKET1 ) ? (USBD_BULK_MAX_PACKET) : (USBD_CDC_ACM_MAX_PACKET1 ))
N#define USBD_MAX_PACKET           ((USBD_MAX_PACKET_CALC3 > USBD_MAX_PACKET_CALC2    ) ? (USBD_MAX_PACKET_CALC3) : (USBD_MAX_PACKET_CALC2    ))
N
N
N/*------------------------------------------------------------------------------
N *      USB Config Functions
N *----------------------------------------------------------------------------*/
N
N#ifndef  __USB_CONFIG___
N#define  __USB_CONFIG__
N
N#ifndef  __NO_USB_LIB_C
N#include "usb_lib.c"
L 1 "..\..\..\source\usb\usb_lib.c" 1
N/**
N * @file    usb_lib.c
N * @brief   USB library
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#include <string.h>
L 1 "C:\Keil_v535\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 23 "..\..\..\source\usb\usb_lib.c" 2
N#include "rl_usb.h"
L 1 "..\..\..\source\usb\rl_usb.h" 1
N/**
N * @file    rl_usb.h
N * @brief   USB Device Library header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __RL_USB_H__
N#define __RL_USB_H__
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N#include <stdint.h>
N#include "usb.h"
L 1 "..\..\..\source\usb\usb.h" 1
N/**
N * @file    usb.h
N * @brief   USB Header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USB_H__
N#define __USB_H__
N
N/* General USB header files                                                   */
N#include "usb_def.h"
L 1 "..\..\..\source\usb\usb_def.h" 1
N/**
N * @file    usb_def.h
N * @brief   USB defines
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USB_DEF_H__
N#define __USB_DEF_H__
N
N#pragma anon_unions
N
N#include <stdint.h>
N#include <stddef.h>
L 1 "C:\Keil_v535\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 29 "..\..\..\source\usb\usb_def.h" 2
N
N#ifndef NULL
S #ifdef __cplusplus
S  #define NULL          0
S #else
S  #define NULL          ((void *) 0)
S #endif
N#endif
N
N#ifndef EOF
N #define EOF            (-1)
N#endif
N
N#ifndef __size_t
N #define __size_t       1
N typedef unsigned int   size_t;
N#endif
N
Ntypedef signed char     S8;
Ntypedef unsigned char   U8;
Ntypedef short           S16;
Ntypedef unsigned short  U16;
Ntypedef int             S32;
Ntypedef unsigned int    U32;
Ntypedef long long       S64;
Ntypedef unsigned long long U64;
Ntypedef unsigned char   BIT;
Ntypedef unsigned int    BOOL;
N
N#ifndef __TRUE
N #define __TRUE         1
N#endif
N#ifndef __FALSE
N #define __FALSE        0
N#endif
N
N
N/* bmRequestType.Dir */
N#define REQUEST_HOST_TO_DEVICE     0
N#define REQUEST_DEVICE_TO_HOST     1
N
N/* bmRequestType.Type */
N#define REQUEST_STANDARD           0
N#define REQUEST_CLASS              1
N#define REQUEST_VENDOR             2
N#define REQUEST_RESERVED           3
N
N/* bmRequestType.Recipient */
N#define REQUEST_TO_DEVICE          0
N#define REQUEST_TO_INTERFACE       1
N#define REQUEST_TO_ENDPOINT        2
N#define REQUEST_TO_OTHER           3
N
N/* bmRequestType Definition */
Ntypedef __packed struct _REQUEST_TYPE {
Xtypedef __packed struct _REQUEST_TYPE {
N    U8 Recipient : 5;                     /* D4..0: Recipient */
N    U8 Type      : 2;                     /* D6..5: Type */
N    U8 Dir       : 1;                     /* D7:    Data Phase Txsfer Direction */
N} REQUEST_TYPE;
N
N/* USB Standard Request Codes */
N#define USB_REQUEST_GET_STATUS                 0
N#define USB_REQUEST_CLEAR_FEATURE              1
N#define USB_REQUEST_SET_FEATURE                3
N#define USB_REQUEST_SET_ADDRESS                5
N#define USB_REQUEST_GET_DESCRIPTOR             6
N#define USB_REQUEST_SET_DESCRIPTOR             7
N#define USB_REQUEST_GET_CONFIGURATION          8
N#define USB_REQUEST_SET_CONFIGURATION          9
N#define USB_REQUEST_GET_INTERFACE              10
N#define USB_REQUEST_SET_INTERFACE              11
N#define USB_REQUEST_SYNC_FRAME                 12
N
N/* USB GET_STATUS Bit Values */
N#define USB_GETSTATUS_SELF_POWERED             0x01
N#define USB_GETSTATUS_REMOTE_WAKEUP            0x02
N#define USB_GETSTATUS_ENDPOINT_STALL           0x01
N
N/* USB Standard Feature selectors */
N#define USB_FEATURE_ENDPOINT_STALL             0
N#define USB_FEATURE_REMOTE_WAKEUP              1
N
N/* USB Default Control Pipe Setup Packet */
Ntypedef __packed struct _USB_SETUP_PACKET {
Xtypedef __packed struct _USB_SETUP_PACKET {
N    REQUEST_TYPE bmRequestType;           /* bmRequestType */
N    U8  bRequest;                         /* bRequest */
N    __packed union {
X    __packed union {
N        U16        wValue;                  /* wValue */
N        __packed struct {
X        __packed struct {
N            U8         wValueL;
N            U8         wValueH;
N        };
N    };
N    __packed union {
X    __packed union {
N        U16        wIndex;                  /* wIndex */
N        __packed struct {
X        __packed struct {
N            U8         wIndexL;
N            U8         wIndexH;
N        };
N    };
N    U16          wLength;                 /* wLength */
N} USB_SETUP_PACKET;
N
N
N/* USB Descriptor Types */
N#define USB_DEVICE_DESCRIPTOR_TYPE                  1
N#define USB_CONFIGURATION_DESCRIPTOR_TYPE           2
N#define USB_STRING_DESCRIPTOR_TYPE                  3
N#define USB_INTERFACE_DESCRIPTOR_TYPE               4
N#define USB_ENDPOINT_DESCRIPTOR_TYPE                5
N#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE        6
N#define USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE      7
N#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE         8
N#define USB_OTG_DESCRIPTOR_TYPE                     9
N#define USB_DEBUG_DESCRIPTOR_TYPE                  10
N#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE  11
N#define USB_BINARY_OBJECT_STORE_DESCRIPTOR_TYPE    15
N#define USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE      16
N
N/* USB Device Classes */
N#define USB_DEVICE_CLASS_RESERVED              0x00
N#define USB_DEVICE_CLASS_AUDIO                 0x01
N#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
N#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
N#define USB_DEVICE_CLASS_MONITOR               0x04
N#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE    0x05
N#define USB_DEVICE_CLASS_POWER                 0x06
N#define USB_DEVICE_CLASS_PRINTER               0x07
N#define USB_DEVICE_CLASS_STORAGE               0x08
N#define USB_DEVICE_CLASS_HUB                   0x09
N#define USB_DEVICE_CLASS_MISCELLANEOUS         0xEF
N#define USB_DEVICE_CLASS_APPLICATION_SPECIFIC  0xFE
N#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
N
N/* bmAttributes in Configuration Descriptor */
N#define USB_CONFIG_POWERED_MASK                0x40
N#define USB_CONFIG_BUS_POWERED                 0x80
N#define USB_CONFIG_SELF_POWERED                0xC0
N#define USB_CONFIG_REMOTE_WAKEUP               0x20
N
N/* bMaxPower in Configuration Descriptor */
N#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
N
N/* bEndpointAddress in Endpoint Descriptor */
N#define USB_ENDPOINT_DIRECTION_MASK            0x80
N#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
N#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
N
N/* bmAttributes in Endpoint Descriptor */
N#define USB_ENDPOINT_TYPE_MASK                 0x03
N#define USB_ENDPOINT_TYPE_CONTROL              0x00
N#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
N#define USB_ENDPOINT_TYPE_BULK                 0x02
N#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
N#define USB_ENDPOINT_SYNC_MASK                 0x0C
N#define USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION   0x00
N#define USB_ENDPOINT_SYNC_ASYNCHRONOUS         0x04
N#define USB_ENDPOINT_SYNC_ADAPTIVE             0x08
N#define USB_ENDPOINT_SYNC_SYNCHRONOUS          0x0C
N#define USB_ENDPOINT_USAGE_MASK                0x30
N#define USB_ENDPOINT_USAGE_DATA                0x00
N#define USB_ENDPOINT_USAGE_FEEDBACK            0x10
N#define USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK   0x20
N#define USB_ENDPOINT_USAGE_RESERVED            0x30
N
N/* bDevCapabilityType in Device Capability Descriptor */
N#define USB_DEVICE_CAPABILITY_WIRELESS_USB                  1
N#define USB_DEVICE_CAPABILITY_USB_2_0_EXTENSION             2
N#define USB_DEVICE_CAPABILITY_SUPERSPEED_USB                3
N#define USB_DEVICE_CAPABILITY_CONTAINER_ID                  4
N#define USB_DEVICE_CAPABILITY_PLATFORM                      5
N#define USB_DEVICE_CAPABILITY_POWER_DELIVERY_CAPABILITY     6
N#define USB_DEVICE_CAPABILITY_BATTERY_INFO_CAPABILITY       7
N#define USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT_CAPABILITY   8
N#define USB_DEVICE_CAPABILITY_PD_PROVIDER_PORT_CAPABILITY   9
N#define USB_DEVICE_CAPABILITY_SUPERSPEED_PLUS               10
N#define USB_DEVICE_CAPABILITY_PRECISION_TIME_MEASUREMENT    11
N#define USB_DEVICE_CAPABILITY_WIRELESS_USB_EXT              12
N
N/* USB Standard Device Descriptor */
Ntypedef __packed struct _USB_DEVICE_DESCRIPTOR {
Xtypedef __packed struct _USB_DEVICE_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U16 bcdUSB;
N    U8  bDeviceClass;
N    U8  bDeviceSubClass;
N    U8  bDeviceProtocol;
N    U8  bMaxPacketSize0;
N    U16 idVendor;
N    U16 idProduct;
N    U16 bcdDevice;
N    U8  iManufacturer;
N    U8  iProduct;
N    U8  iSerialNumber;
N    U8  bNumConfigurations;
N} USB_DEVICE_DESCRIPTOR;
N
N/* USB 2.0 Device Qualifier Descriptor */
Ntypedef __packed struct _USB_DEVICE_QUALIFIER_DESCRIPTOR {
Xtypedef __packed struct _USB_DEVICE_QUALIFIER_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U16 bcdUSB;
N    U8  bDeviceClass;
N    U8  bDeviceSubClass;
N    U8  bDeviceProtocol;
N    U8  bMaxPacketSize0;
N    U8  bNumConfigurations;
N    U8  bReserved;
N} USB_DEVICE_QUALIFIER_DESCRIPTOR;
N
N/* USB Standard Configuration Descriptor */
Ntypedef __packed struct _USB_CONFIGURATION_DESCRIPTOR {
Xtypedef __packed struct _USB_CONFIGURATION_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U16 wTotalLength;
N    U8  bNumInterfaces;
N    U8  bConfigurationValue;
N    U8  iConfiguration;
N    U8  bmAttributes;
N    U8  bMaxPower;
N} USB_CONFIGURATION_DESCRIPTOR;
N
N/* USB Standard Interface Descriptor */
Ntypedef __packed struct _USB_INTERFACE_DESCRIPTOR {
Xtypedef __packed struct _USB_INTERFACE_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bInterfaceNumber;
N    U8  bAlternateSetting;
N    U8  bNumEndpoints;
N    U8  bInterfaceClass;
N    U8  bInterfaceSubClass;
N    U8  bInterfaceProtocol;
N    U8  iInterface;
N} USB_INTERFACE_DESCRIPTOR;
N
N/* USB Standard Endpoint Descriptor */
Ntypedef __packed struct _USB_ENDPOINT_DESCRIPTOR {
Xtypedef __packed struct _USB_ENDPOINT_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bEndpointAddress;
N    U8  bmAttributes;
N    U16 wMaxPacketSize;
N    U8  bInterval;
N} USB_ENDPOINT_DESCRIPTOR;
N
N/* USB String Descriptor */
Ntypedef __packed struct _USB_STRING_DESCRIPTOR {
Xtypedef __packed struct _USB_STRING_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U16 bString/*[]*/;
N} USB_STRING_DESCRIPTOR;
N
N/* USB Common Descriptor */
Ntypedef __packed struct _USB_COMMON_DESCRIPTOR {
Xtypedef __packed struct _USB_COMMON_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N} USB_COMMON_DESCRIPTOR;
N
N/* USB Interface Association Descriptor */
Ntypedef __packed struct _USB_INTERFACE_ASSOCIATION_DESCRIPTOR {
Xtypedef __packed struct _USB_INTERFACE_ASSOCIATION_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bFirstInterface;
N    U8  bInterfaceCount;
N    U8  bFunctionClass;
N    U8  bFunctionSubclass;
N    U8  bFunctionProtocol;
N    U8  iFunction;
N} USB_INTERFACE_ASSOCIATION_DESCRIPTOR;
N
N/* USB Binary Object Store Descriptor */
Ntypedef __packed struct _USB_BINARY_OBJECT_STORE_DESCRIPTOR {
Xtypedef __packed struct _USB_BINARY_OBJECT_STORE_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U16 wTotalLength;
N    U8  bNumDeviceCaps;
N} USB_BINARY_OBJECT_STORE_DESCRIPTOR;
N
N/* Union Functional Descriptor */ 
Ntypedef __packed struct _UNION_FUNCTIONAL_DESCRIPTOR {
Xtypedef __packed struct _UNION_FUNCTIONAL_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bDescriptorSubtype;
N    U8  bMasterInterface;
N    U8  bSlaveInterface0;
N} UNION_FUNCTIONAL_DESCRIPTOR;
N
Ntypedef __packed struct _WINUSB_FUNCTION_SUBSET_HEADER {
Xtypedef __packed struct _WINUSB_FUNCTION_SUBSET_HEADER {
N    U16 wLength;
N    U16 wDescriptorType; 
N    U8  bFirstInterface;
N    U8  bReserved;
N} WINUSB_FUNCTION_SUBSET_HEADER;
N
N/* USB Device Capability Descriptor */
Ntypedef __packed struct _USB_DEVICE_CAPABILITY_DESCRIPTOR {
Xtypedef __packed struct _USB_DEVICE_CAPABILITY_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bDevCapabilityType;
N} USB_DEVICE_CAPABILITY_DESCRIPTOR;
N
N#endif  /* __USB_DEF_H__ */
L 27 "..\..\..\source\usb\usb.h" 2
N#include "usb_cdc.h"
L 1 "..\..\..\source\usb\usb_cdc.h" 1
N/**
N * @file    usb_cdc.h
N * @brief   USB CDC driver header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USB_CDC_H
N#define __USB_CDC_H
N
N/*------------------------------------------------------------------------------
N *      Definitions  based on usbcdc11.pdf (www.usb.org)
N *----------------------------------------------------------------------------*/
N/* Communication device class specification version 1.10 */
N#define CDC_V1_10                               0x0110
N
N/* Communication interface class code */
N/* (usbcdc11.pdf, 4.2, Table 15) */
N#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
N
N/* Communication interface class subclass codes */
N/* (usbcdc11.pdf, 4.3, Table 16) */
N#define CDC_DIRECT_LINE_CONTROL_MODEL           0x01
N#define CDC_ABSTRACT_CONTROL_MODEL              0x02
N#define CDC_TELEPHONE_CONTROL_MODEL             0x03
N#define CDC_MULTI_CHANNEL_CONTROL_MODEL         0x04
N#define CDC_CAPI_CONTROL_MODEL                  0x05
N#define CDC_ETHERNET_NETWORKING_CONTROL_MODEL   0x06
N#define CDC_ATM_NETWORKING_CONTROL_MODEL        0x07
N
N/* Communication interface class control protocol codes */
N/* (usbcdc11.pdf, 4.4, Table 17) */
N#define CDC_PROTOCOL_COMMON_AT_COMMANDS         0x01
N
N/* Data interface class code */
N/* (usbcdc11.pdf, 4.5, Table 18) */
N#define CDC_DATA_INTERFACE_CLASS                0x0A
N
N/* Data interface class protocol codes */
N/* (usbcdc11.pdf, 4.7, Table 19) */
N#define CDC_PROTOCOL_ISDN_BRI                   0x30
N#define CDC_PROTOCOL_HDLC                       0x31
N#define CDC_PROTOCOL_TRANSPARENT                0x32
N#define CDC_PROTOCOL_Q921_MANAGEMENT            0x50
N#define CDC_PROTOCOL_Q921_DATA_LINK             0x51
N#define CDC_PROTOCOL_Q921_MULTIPLEXOR           0x52
N#define CDC_PROTOCOL_V42                        0x90
N#define CDC_PROTOCOL_EURO_ISDN                  0x91
N#define CDC_PROTOCOL_V24_RATE_ADAPTATION        0x92
N#define CDC_PROTOCOL_CAPI                       0x93
N#define CDC_PROTOCOL_HOST_BASED_DRIVER          0xFD
N#define CDC_PROTOCOL_DESCRIBED_IN_PUFD          0xFE
N
N/* Type values for bDescriptorType field of functional descriptors */
N/* (usbcdc11.pdf, 5.2.3, Table 24) */
N#define CDC_CS_INTERFACE                        0x24
N#define CDC_CS_ENDPOINT                         0x25
N
N/* Type values for bDescriptorSubtype field of functional descriptors */
N/* (usbcdc11.pdf, 5.2.3, Table 25) */
N#define CDC_HEADER                              0x00
N#define CDC_CALL_MANAGEMENT                     0x01
N#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
N#define CDC_DIRECT_LINE_MANAGEMENT              0x03
N#define CDC_TELEPHONE_RINGER                    0x04
N#define CDC_REPORTING_CAPABILITIES              0x05
N#define CDC_UNION                               0x06
N#define CDC_COUNTRY_SELECTION                   0x07
N#define CDC_TELEPHONE_OPERATIONAL_MODES         0x08
N#define CDC_USB_TERMINAL                        0x09
N#define CDC_NETWORK_CHANNEL                     0x0A
N#define CDC_PROTOCOL_UNIT                       0x0B
N#define CDC_EXTENSION_UNIT                      0x0C
N#define CDC_MULTI_CHANNEL_MANAGEMENT            0x0D
N#define CDC_CAPI_CONTROL_MANAGEMENT             0x0E
N#define CDC_ETHERNET_NETWORKING                 0x0F
N#define CDC_ATM_NETWORKING                      0x10
N
N/* CDC class-specific request codes */
N/* (usbcdc11.pdf, 6.2, Table 46) */
N/* see Table 45 for info about the specific requests. */
N#define CDC_SEND_ENCAPSULATED_COMMAND           0x00
N#define CDC_GET_ENCAPSULATED_RESPONSE           0x01
N#define CDC_SET_COMM_FEATURE                    0x02
N#define CDC_GET_COMM_FEATURE                    0x03
N#define CDC_CLEAR_COMM_FEATURE                  0x04
N#define CDC_SET_AUX_LINE_STATE                  0x10
N#define CDC_SET_HOOK_STATE                      0x11
N#define CDC_PULSE_SETUP                         0x12
N#define CDC_SEND_PULSE                          0x13
N#define CDC_SET_PULSE_TIME                      0x14
N#define CDC_RING_AUX_JACK                       0x15
N#define CDC_SET_LINE_CODING                     0x20
N#define CDC_GET_LINE_CODING                     0x21
N#define CDC_SET_CONTROL_LINE_STATE              0x22
N#define CDC_SEND_BREAK                          0x23
N#define CDC_SET_RINGER_PARMS                    0x30
N#define CDC_GET_RINGER_PARMS                    0x31
N#define CDC_SET_OPERATION_PARMS                 0x32
N#define CDC_GET_OPERATION_PARMS                 0x33
N#define CDC_SET_LINE_PARMS                      0x34
N#define CDC_GET_LINE_PARMS                      0x35
N#define CDC_DIAL_DIGITS                         0x36
N#define CDC_SET_UNIT_PARAMETER                  0x37
N#define CDC_GET_UNIT_PARAMETER                  0x38
N#define CDC_CLEAR_UNIT_PARAMETER                0x39
N#define CDC_GET_PROFILE                         0x3A
N#define CDC_SET_ETHERNET_MULTICAST_FILTERS      0x40
N#define CDC_SET_ETHERNET_PMP_FILTER             0x41
N#define CDC_GET_ETHERNET_PMP_FILTER             0x42
N#define CDC_SET_ETHERNET_PACKET_FILTER          0x43
N#define CDC_GET_ETHERNET_STATISTIC              0x44
N#define CDC_SET_ATM_DATA_FORMAT                 0x50
N#define CDC_GET_ATM_DEVICE_STATISTICS           0x51
N#define CDC_SET_ATM_DEFAULT_VC                  0x52
N#define CDC_GET_ATM_VC_STATISTICS               0x53
N
N/* Communication feature selector codes */
N/* (usbcdc11.pdf, 6.2.2..6.2.4, Table 47) */
N#define CDC_ABSTRACT_STATE                      0x01
N#define CDC_COUNTRY_SETTING                     0x02
N
N/* Feature Status returned for ABSTRACT_STATE Selector */
N/* (usbcdc11.pdf, 6.2.3, Table 48) */
N#define CDC_IDLE_SETTING                        (1 << 0)
N#define CDC_DATA_MULTPLEXED_STATE               (1 << 1)
N
N
N/* Control signal bitmap values for the SetControlLineState request */
N/* (usbcdc11.pdf, 6.2.14, Table 51) */
N#define CDC_DTE_PRESENT                         (1 << 0)
N#define CDC_ACTIVATE_CARRIER                    (1 << 1)
N
N/* CDC class-specific notification codes */
N/* (usbcdc11.pdf, 6.3, Table 68) */
N/* see Table 67 for Info about class-specific notifications */
N#define CDC_NOTIFICATION_NETWORK_CONNECTION     0x00
N#define CDC_RESPONSE_AVAILABLE                  0x01
N#define CDC_AUX_JACK_HOOK_STATE                 0x08
N#define CDC_RING_DETECT                         0x09
N#define CDC_NOTIFICATION_SERIAL_STATE           0x20
N#define CDC_CALL_STATE_CHANGE                   0x28
N#define CDC_LINE_STATE_CHANGE                   0x29
N#define CDC_CONNECTION_SPEED_CHANGE             0x2A
N
N/* UART state bitmap values (Serial state notification). */
N/* (usbcdc11.pdf, 6.3.5, Table 69) */
N#define CDC_SERIAL_STATE_OVERRUN                (1 << 6)  /* receive data overrun error has occurred */
N#define CDC_SERIAL_STATE_OVERRUN_Pos            (     6)
N#define CDC_SERIAL_STATE_OVERRUN_Msk            (1 << CDC_SERIAL_STATE_OVERRUN_Pos)
N#define CDC_SERIAL_STATE_PARITY                 (1 << 5)  /* parity error has occurred */
N#define CDC_SERIAL_STATE_PARITY_Pos             (     5)
N#define CDC_SERIAL_STATE_PARITY_Msk             (1 << CDC_SERIAL_STATE_PARITY_Pos)
N#define CDC_SERIAL_STATE_FRAMING                (1 << 4)  /* framing error has occurred */
N#define CDC_SERIAL_STATE_FRAMING_Pos            (     4)
N#define CDC_SERIAL_STATE_FRAMING_Msk            (1 << CDC_SERIAL_STATE_FRAMING_Pos)
N#define CDC_SERIAL_STATE_RING                   (1 << 3)  /* state of ring signal detection */
N#define CDC_SERIAL_STATE_RING_Pos               (     3)
N#define CDC_SERIAL_STATE_RING_Msk               (1 << CDC_SERIAL_STATE_RING_Pos)
N#define CDC_SERIAL_STATE_BREAK                  (1 << 2)  /* state of break detection */
N#define CDC_SERIAL_STATE_BREAK_Pos              (     2)
N#define CDC_SERIAL_STATE_BREAK_Msk              (1 << CDC_SERIAL_STATE_BREAK_Pos)
N#define CDC_SERIAL_STATE_TX_CARRIER             (1 << 1)  /* state of transmission carrier */
N#define CDC_SERIAL_STATE_TX_CARRIER_Pos         (     1)
N#define CDC_SERIAL_STATE_TX_CARRIER_Msk         (1 << CDC_SERIAL_STATE_TX_CARRIER_Pos)
N#define CDC_SERIAL_STATE_RX_CARRIER             (1 << 0)  /* state of receiver carrier */
N#define CDC_SERIAL_STATE_RX_CARRIER_Pos         (     0)
N#define CDC_SERIAL_STATE_RX_CARRIER_Msk         (1 << CDC_SERIAL_STATE_RX_CARRIER_Pos)
N
N
N/*------------------------------------------------------------------------------
N *      Structures  based on usbcdc11.pdf (www.usb.org)
N *----------------------------------------------------------------------------*/
N
N/* Header functional descriptor */
N/* (usbcdc11.pdf, 5.2.3.1) */
N/* This header must precede any list of class-specific descriptors. */
Ntypedef __packed struct _CDC_HEADER_DESCRIPTOR {
Xtypedef __packed struct _CDC_HEADER_DESCRIPTOR {
N    U8  bFunctionLength;                      /* size of this descriptor in bytes */
N    U8  bDescriptorType;                      /* CS_INTERFACE descriptor type */
N    U8  bDescriptorSubtype;                   /* Header functional descriptor subtype */
N    U16 bcdCDC;                               /* USB CDC specification release version */
N} CDC_HEADER_DESCRIPTOR;
N
N/* Call management functional descriptor */
N/* (usbcdc11.pdf, 5.2.3.2) */
N/* Describes the processing of calls for the communication class interface. */
Ntypedef __packed struct _CDC_CALL_MANAGEMENT_DESCRIPTOR {
Xtypedef __packed struct _CDC_CALL_MANAGEMENT_DESCRIPTOR {
N    U8  bFunctionLength;                      /* size of this descriptor in bytes */
N    U8  bDescriptorType;                      /* CS_INTERFACE descriptor type */
N    U8  bDescriptorSubtype;                   /* call management functional descriptor subtype */
N    U8  bmCapabilities;                       /* capabilities that this configuration supports */
N    U8  bDataInterface;                       /* interface number of the data class interface used for call management (optional) */
N} CDC_CALL_MANAGEMENT_DESCRIPTOR;
N
N/* Abstract control management functional descriptor */
N/* (usbcdc11.pdf, 5.2.3.3) */
N/* Describes the command supported by the communication interface class with the Abstract Control Model subclass code. */
Ntypedef __packed struct _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR {
Xtypedef __packed struct _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR {
N    U8  bFunctionLength;                      /* size of this descriptor in bytes */
N    U8  bDescriptorType;                      /* CS_INTERFACE descriptor type */
N    U8  bDescriptorSubtype;                   /* abstract control management functional descriptor subtype */
N    U8  bmCapabilities;                       /* capabilities supported by this configuration */
N} CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR;
N
N/* Union functional descriptors */
N/* (usbcdc11.pdf, 5.2.3.8) */
N/* Describes the relationship between a group of interfaces that can be considered to form a functional unit. */
Ntypedef __packed struct _CDC_UNION_DESCRIPTOR {
Xtypedef __packed struct _CDC_UNION_DESCRIPTOR {
N    U8  bFunctionLength;                      /* size of this descriptor in bytes */
N    U8  bDescriptorType;                      /* CS_INTERFACE descriptor type */
N    U8  bDescriptorSubtype;                   /* union functional descriptor subtype */
N    U8  bMasterInterface;                     /* interface number designated as master */
N} CDC_UNION_DESCRIPTOR;
N
N/* Union functional descriptors with one slave interface */
N/* (usbcdc11.pdf, 5.2.3.8) */
Ntypedef __packed struct _CDC_UNION_1SLAVE_DESCRIPTOR {
Xtypedef __packed struct _CDC_UNION_1SLAVE_DESCRIPTOR {
N    CDC_UNION_DESCRIPTOR sUnion;              /* Union functional descriptor */
N    U8                   bSlaveInterfaces[1]; /* Slave interface 0 */
N} CDC_UNION_1SLAVE_DESCRIPTOR;
N
N/* Line coding structure */
N/* Format of the data returned when a GetLineCoding request is received */
N/* (usbcdc11.pdf, 6.2.13) */
Ntypedef __packed struct _CDC_LINE_CODING {
Xtypedef __packed struct _CDC_LINE_CODING {
N    U32 dwDTERate;                            /* Data terminal rate in bits per second */
N    U8  bCharFormat;                          /* Number of stop bits */
N    U8  bParityType;                          /* Parity bit type */
N    U8  bDataBits;                            /* Number of data bits */
N} CDC_LINE_CODING;
N
N/* Notification header */
N/* Data sent on the notification endpoint must follow this header. */
N/* see  USB_SETUP_PACKET in file usb.h */
Ntypedef USB_SETUP_PACKET CDC_NOTIFICATION_HEADER;
N
N#endif /* __USB_CDC_H */
N
L 28 "..\..\..\source\usb\usb.h" 2
N#include "usb_hid.h"
L 1 "..\..\..\source\usb\usb_hid.h" 1
N/**
N * @file    usb_hid.h
N * @brief   USB hid driver header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USB_HID_H__
N#define __USB_HID_H__
N
N
N/* HID Subclass Codes */
N#define HID_SUBCLASS_NONE               0x00
N#define HID_SUBCLASS_BOOT               0x01
N
N/* HID Protocol Codes */
N#define HID_PROTOCOL_NONE               0x00
N#define HID_PROTOCOL_BOOT               0x00
N#define HID_PROTOCOL_KEYBOARD           0x01
N#define HID_PROTOCOL_REPORT             0x01
N#define HID_PROTOCOL_MOUSE              0x02
N
N
N/* HID Descriptor Types */
N#define HID_HID_DESCRIPTOR_TYPE         0x21
N#define HID_REPORT_DESCRIPTOR_TYPE      0x22
N#define HID_PHYSICAL_DESCRIPTOR_TYPE    0x23
N
N
N/* HID Descriptor */
Ntypedef __packed struct _HID_DESCRIPTOR {
Xtypedef __packed struct _HID_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U16 bcdHID;
N    U8  bCountryCode;
N    U8  bNumDescriptors;
N    /* Array of one or more descriptors */
N    __packed struct _HID_DESCRIPTOR_LIST {
X    __packed struct _HID_DESCRIPTOR_LIST {
N        U8  bDescriptorType;
N        U16 wDescriptorLength;
N    } DescriptorList[1];
N} HID_DESCRIPTOR;
N
N
N/* HID Request Codes */
N#define HID_REQUEST_GET_REPORT          0x01
N#define HID_REQUEST_GET_IDLE            0x02
N#define HID_REQUEST_GET_PROTOCOL        0x03
N#define HID_REQUEST_SET_REPORT          0x09
N#define HID_REQUEST_SET_IDLE            0x0A
N#define HID_REQUEST_SET_PROTOCOL        0x0B
N
N/* HID Report Types */
N#define HID_REPORT_INPUT                0x01
N#define HID_REPORT_OUTPUT               0x02
N#define HID_REPORT_FEATURE              0x03
N
N
N/* Usage Pages */
N#define HID_USAGE_PAGE_UNDEFINED        0x00
N#define HID_USAGE_PAGE_GENERIC          0x01
N#define HID_USAGE_PAGE_SIMULATION       0x02
N#define HID_USAGE_PAGE_VR               0x03
N#define HID_USAGE_PAGE_SPORT            0x04
N#define HID_USAGE_PAGE_GAME             0x05
N#define HID_USAGE_PAGE_DEV_CONTROLS     0x06
N#define HID_USAGE_PAGE_KEYBOARD         0x07
N#define HID_USAGE_PAGE_LED              0x08
N#define HID_USAGE_PAGE_BUTTON           0x09
N#define HID_USAGE_PAGE_ORDINAL          0x0A
N#define HID_USAGE_PAGE_TELEPHONY        0x0B
N#define HID_USAGE_PAGE_CONSUMER         0x0C
N#define HID_USAGE_PAGE_DIGITIZER        0x0D
N#define HID_USAGE_PAGE_UNICODE          0x10
N#define HID_USAGE_PAGE_ALPHANUMERIC     0x14
N/* ... */
N
N
N/* Generic Desktop Page (0x01) */
N#define HID_USAGE_GENERIC_POINTER               0x01
N#define HID_USAGE_GENERIC_MOUSE                 0x02
N#define HID_USAGE_GENERIC_JOYSTICK              0x04
N#define HID_USAGE_GENERIC_GAMEPAD               0x05
N#define HID_USAGE_GENERIC_KEYBOARD              0x06
N#define HID_USAGE_GENERIC_KEYPAD                0x07
N#define HID_USAGE_GENERIC_X                     0x30
N#define HID_USAGE_GENERIC_Y                     0x31
N#define HID_USAGE_GENERIC_Z                     0x32
N#define HID_USAGE_GENERIC_RX                    0x33
N#define HID_USAGE_GENERIC_RY                    0x34
N#define HID_USAGE_GENERIC_RZ                    0x35
N#define HID_USAGE_GENERIC_SLIDER                0x36
N#define HID_USAGE_GENERIC_DIAL                  0x37
N#define HID_USAGE_GENERIC_WHEEL                 0x38
N#define HID_USAGE_GENERIC_HATSWITCH             0x39
N#define HID_USAGE_GENERIC_COUNTED_BUFFER        0x3A
N#define HID_USAGE_GENERIC_BYTE_COUNT            0x3B
N#define HID_USAGE_GENERIC_MOTION_WAKEUP         0x3C
N#define HID_USAGE_GENERIC_VX                    0x40
N#define HID_USAGE_GENERIC_VY                    0x41
N#define HID_USAGE_GENERIC_VZ                    0x42
N#define HID_USAGE_GENERIC_VBRX                  0x43
N#define HID_USAGE_GENERIC_VBRY                  0x44
N#define HID_USAGE_GENERIC_VBRZ                  0x45
N#define HID_USAGE_GENERIC_VNO                   0x46
N#define HID_USAGE_GENERIC_SYSTEM_CTL            0x80
N#define HID_USAGE_GENERIC_SYSCTL_POWER          0x81
N#define HID_USAGE_GENERIC_SYSCTL_SLEEP          0x82
N#define HID_USAGE_GENERIC_SYSCTL_WAKE           0x83
N#define HID_USAGE_GENERIC_SYSCTL_CONTEXT_MENU   0x84
N#define HID_USAGE_GENERIC_SYSCTL_MAIN_MENU      0x85
N#define HID_USAGE_GENERIC_SYSCTL_APP_MENU       0x86
N#define HID_USAGE_GENERIC_SYSCTL_HELP_MENU      0x87
N#define HID_USAGE_GENERIC_SYSCTL_MENU_EXIT      0x88
N#define HID_USAGE_GENERIC_SYSCTL_MENU_SELECT    0x89
N#define HID_USAGE_GENERIC_SYSCTL_MENU_RIGHT     0x8A
N#define HID_USAGE_GENERIC_SYSCTL_MENU_LEFT      0x8B
N#define HID_USAGE_GENERIC_SYSCTL_MENU_UP        0x8C
N#define HID_USAGE_GENERIC_SYSCTL_MENU_DOWN      0x8D
N/* ... */
N
N/* Simulation Controls Page (0x02) */
N/* ... */
N#define HID_USAGE_SIMULATION_RUDDER             0xBA
N#define HID_USAGE_SIMULATION_THROTTLE           0xBB
N/* ... */
N
N/* Virtual Reality Controls Page (0x03) */
N/* ... */
N
N/* Sport Controls Page (0x04) */
N/* ... */
N
N/* Game Controls Page (0x05) */
N/* ... */
N
N/* Generic Device Controls Page (0x06) */
N/* ... */
N
N/* Keyboard/Keypad Page (0x07) */
N
N/* Keyboard Usage Keys */
Nextern const unsigned char HID_KEYBOARD_ID_TO_ASCII[256];
Nextern const unsigned char HID_KEYBOARD_ALT_ID_TO_ASCII[57];
N
N/* Error "Keys" */
N#define HID_USAGE_KEYBOARD_NOEVENT              0x00
N#define HID_USAGE_KEYBOARD_ROLLOVER             0x01
N#define HID_USAGE_KEYBOARD_POSTFAIL             0x02
N#define HID_USAGE_KEYBOARD_UNDEFINED            0x03
N
N/* Letters */
N#define HID_USAGE_KEYBOARD_aA                   0x04
N#define HID_USAGE_KEYBOARD_zZ                   0x1D
N
N/* Numbers */
N#define HID_USAGE_KEYBOARD_ONE                  0x1E
N#define HID_USAGE_KEYBOARD_ZERO                 0x27
N
N#define HID_USAGE_KEYBOARD_RETURN               0x28
N#define HID_USAGE_KEYBOARD_ESCAPE               0x29
N#define HID_USAGE_KEYBOARD_DELETE               0x2A
N
N/* Funtion Keys */
N#define HID_USAGE_KEYBOARD_F1                   0x3A
N#define HID_USAGE_KEYBOARD_F12                  0x45
N
N#define HID_USAGE_KEYBOARD_PRINT_SCREEN         0x46
N
N/* Modifier Keys */
N#define HID_USAGE_KEYBOARD_LCTRL                0xE0
N#define HID_USAGE_KEYBOARD_LSHFT                0xE1
N#define HID_USAGE_KEYBOARD_LALT                 0xE2
N#define HID_USAGE_KEYBOARD_LGUI                 0xE3
N#define HID_USAGE_KEYBOARD_RCTRL                0xE4
N#define HID_USAGE_KEYBOARD_RSHFT                0xE5
N#define HID_USAGE_KEYBOARD_RALT                 0xE6
N#define HID_USAGE_KEYBOARD_RGUI                 0xE7
N#define HID_USAGE_KEYBOARD_SCROLL_LOCK          0x47
N#define HID_USAGE_KEYBOARD_NUM_LOCK             0x53
N#define HID_USAGE_KEYBOARD_CAPS_LOCK            0x39
N
N/* Modifier Keys (values) */
N#define HID_USAGE_KEYBOARD_MOD_LCTRL            0x01
N#define HID_USAGE_KEYBOARD_MOD_LSHIFT           0x02
N#define HID_USAGE_KEYBOARD_MOD_LALTL            0x04
N#define HID_USAGE_KEYBOARD_MOD_LGUI             0x08
N#define HID_USAGE_KEYBOARD_MOD_RCTRL            0x10
N#define HID_USAGE_KEYBOARD_MOD_RSHIFT           0x20
N#define HID_USAGE_KEYBOARD_MOD_RALTL            0x40
N#define HID_USAGE_KEYBOARD_MOD_RGUI             0x80
N
N/* ... */
N
N/* LED Page (0x08) */
N#define HID_USAGE_LED_NUM_LOCK                  0x01
N#define HID_USAGE_LED_CAPS_LOCK                 0x02
N#define HID_USAGE_LED_SCROLL_LOCK               0x03
N#define HID_USAGE_LED_COMPOSE                   0x04
N#define HID_USAGE_LED_KANA                      0x05
N#define HID_USAGE_LED_POWER                     0x06
N#define HID_USAGE_LED_SHIFT                     0x07
N#define HID_USAGE_LED_DO_NOT_DISTURB            0x08
N#define HID_USAGE_LED_MUTE                      0x09
N#define HID_USAGE_LED_TONE_ENABLE               0x0A
N#define HID_USAGE_LED_HIGH_CUT_FILTER           0x0B
N#define HID_USAGE_LED_LOW_CUT_FILTER            0x0C
N#define HID_USAGE_LED_EQUALIZER_ENABLE          0x0D
N#define HID_USAGE_LED_SOUND_FIELD_ON            0x0E
N#define HID_USAGE_LED_SURROUND_FIELD_ON         0x0F
N#define HID_USAGE_LED_REPEAT                    0x10
N#define HID_USAGE_LED_STEREO                    0x11
N#define HID_USAGE_LED_SAMPLING_RATE_DETECT      0x12
N#define HID_USAGE_LED_SPINNING                  0x13
N#define HID_USAGE_LED_CAV                       0x14
N#define HID_USAGE_LED_CLV                       0x15
N#define HID_USAGE_LED_RECORDING_FORMAT_DET      0x16
N#define HID_USAGE_LED_OFF_HOOK                  0x17
N#define HID_USAGE_LED_RING                      0x18
N#define HID_USAGE_LED_MESSAGE_WAITING           0x19
N#define HID_USAGE_LED_DATA_MODE                 0x1A
N#define HID_USAGE_LED_BATTERY_OPERATION         0x1B
N#define HID_USAGE_LED_BATTERY_OK                0x1C
N#define HID_USAGE_LED_BATTERY_LOW               0x1D
N#define HID_USAGE_LED_SPEAKER                   0x1E
N#define HID_USAGE_LED_HEAD_SET                  0x1F
N#define HID_USAGE_LED_HOLD                      0x20
N#define HID_USAGE_LED_MICROPHONE                0x21
N#define HID_USAGE_LED_COVERAGE                  0x22
N#define HID_USAGE_LED_NIGHT_MODE                0x23
N#define HID_USAGE_LED_SEND_CALLS                0x24
N#define HID_USAGE_LED_CALL_PICKUP               0x25
N#define HID_USAGE_LED_CONFERENCE                0x26
N#define HID_USAGE_LED_STAND_BY                  0x27
N#define HID_USAGE_LED_CAMERA_ON                 0x28
N#define HID_USAGE_LED_CAMERA_OFF                0x29
N#define HID_USAGE_LED_ON_LINE                   0x2A
N#define HID_USAGE_LED_OFF_LINE                  0x2B
N#define HID_USAGE_LED_BUSY                      0x2C
N#define HID_USAGE_LED_READY                     0x2D
N#define HID_USAGE_LED_PAPER_OUT                 0x2E
N#define HID_USAGE_LED_PAPER_JAM                 0x2F
N#define HID_USAGE_LED_REMOTE                    0x30
N#define HID_USAGE_LED_FORWARD                   0x31
N#define HID_USAGE_LED_REVERSE                   0x32
N#define HID_USAGE_LED_STOP                      0x33
N#define HID_USAGE_LED_REWIND                    0x34
N#define HID_USAGE_LED_FAST_FORWARD              0x35
N#define HID_USAGE_LED_PLAY                      0x36
N#define HID_USAGE_LED_PAUSE                     0x37
N#define HID_USAGE_LED_RECORD                    0x38
N#define HID_USAGE_LED_ERROR                     0x39
N#define HID_USAGE_LED_SELECTED_INDICATOR        0x3A
N#define HID_USAGE_LED_IN_USE_INDICATOR          0x3B
N#define HID_USAGE_LED_MULTI_MODE_INDICATOR      0x3C
N#define HID_USAGE_LED_INDICATOR_ON              0x3D
N#define HID_USAGE_LED_INDICATOR_FLASH           0x3E
N#define HID_USAGE_LED_INDICATOR_SLOW_BLINK      0x3F
N#define HID_USAGE_LED_INDICATOR_FAST_BLINK      0x40
N#define HID_USAGE_LED_INDICATOR_OFF             0x41
N#define HID_USAGE_LED_FLASH_ON_TIME             0x42
N#define HID_USAGE_LED_SLOW_BLINK_ON_TIME        0x43
N#define HID_USAGE_LED_SLOW_BLINK_OFF_TIME       0x44
N#define HID_USAGE_LED_FAST_BLINK_ON_TIME        0x45
N#define HID_USAGE_LED_FAST_BLINK_OFF_TIME       0x46
N#define HID_USAGE_LED_INDICATOR_COLOR           0x47
N#define HID_USAGE_LED_RED                       0x48
N#define HID_USAGE_LED_GREEN                     0x49
N#define HID_USAGE_LED_AMBER                     0x4A
N#define HID_USAGE_LED_GENERIC_INDICATOR         0x4B
N
N/* Button Page (0x09) */
N/*   There is no need to label these usages. */
N
N/* Ordinal Page (0x0A) */
N/*   There is no need to label these usages. */
N
N/* Telephony Device Page (0x0B) */
N#define HID_USAGE_TELEPHONY_PHONE               0x01
N#define HID_USAGE_TELEPHONY_ANSWERING_MACHINE   0x02
N#define HID_USAGE_TELEPHONY_MESSAGE_CONTROLS    0x03
N#define HID_USAGE_TELEPHONY_HANDSET             0x04
N#define HID_USAGE_TELEPHONY_HEADSET             0x05
N#define HID_USAGE_TELEPHONY_KEYPAD              0x06
N#define HID_USAGE_TELEPHONY_PROGRAMMABLE_BUTTON 0x07
N/* ... */
N
N/* Consumer Page (0x0C) */
N#define HID_USAGE_CONSUMER_CONTROL              0x01
N/* ... */
N
N/* and others ... */
N
N
N/* HID Report Item Macros */
N
N/* Main Items */
N#define HID_Input(x)           0x81,x
N#define HID_Output(x)          0x91,x
N#define HID_Feature(x)         0xB1,x
N#define HID_Collection(x)      0xA1,x
N#define HID_EndCollection      0xC0
N
N/* Data (Input, Output, Feature) */
N#define HID_Data               0<<0
N#define HID_Constant           1<<0
N#define HID_Array              0<<1
N#define HID_Variable           1<<1
N#define HID_Absolute           0<<2
N#define HID_Relative           1<<2
N#define HID_NoWrap             0<<3
N#define HID_Wrap               1<<3
N#define HID_Linear             0<<4
N#define HID_NonLinear          1<<4
N#define HID_PreferredState     0<<5
N#define HID_NoPreferred        1<<5
N#define HID_NoNullPosition     0<<6
N#define HID_NullState          1<<6
N#define HID_NonVolatile        0<<7
N#define HID_Volatile           1<<7
N
N/* Collection Data */
N#define HID_Physical           0x00
N#define HID_Application        0x01
N#define HID_Logical            0x02
N#define HID_Report             0x03
N#define HID_NamedArray         0x04
N#define HID_UsageSwitch        0x05
N#define HID_UsageModifier      0x06
N
N/* Global Items */
N#define HID_UsagePage(x)       0x05,x
N#define HID_UsagePageVendor(x) 0x06,x,0xFF
N#define HID_LogicalMin(x)      0x15,x
N#define HID_LogicalMinS(x)     0x16,(x&0xFF),((x>>8)&0xFF)
N#define HID_LogicalMinL(x)     0x17,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
N#define HID_LogicalMax(x)      0x25,x
N#define HID_LogicalMaxS(x)     0x26,(x&0xFF),((x>>8)&0xFF)
N#define HID_LogicalMaxL(x)     0x27,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
N#define HID_PhysicalMin(x)     0x35,x
N#define HID_PhysicalMinS(x)    0x36,(x&0xFF),((x>>8)&0xFF)
N#define HID_PhysicalMinL(x)    0x37,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
N#define HID_PhysicalMax(x)     0x45,x
N#define HID_PhysicalMaxS(x)    0x46,(x&0xFF),((x>>8)&0xFF)
N#define HID_PhysicalMaxL(x)    0x47,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
N#define HID_UnitExponent(x)    0x55,x
N#define HID_Unit(x)            0x65,x
N#define HID_UnitS(x)           0x66,(x&0xFF),((x>>8)&0xFF)
N#define HID_UnitL(x)           0x67,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
N#define HID_ReportSize(x)      0x75,x
N#define HID_ReportSizeS(x)     0x76,(x&0xFF),((x>>8)&0xFF)
N#define HID_ReportSizeL(x)     0x77,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
N#define HID_ReportID(x)        0x85,x
N#define HID_ReportCount(x)     0x95,x
N#define HID_ReportCountS(x)    0x96,(x&0xFF),((x>>8)&0xFF)
N#define HID_ReportCountL(x)    0x97,(x&0xFF),((x>>8)&0xFF),((x>>16)&0xFF),((x>>24)&0xFF)
N#define HID_Push               0xA4
N#define HID_Pop                0xB4
N
N/* Local Items */
N#define HID_Usage(x)           0x09,x
N#define HID_UsageMin(x)        0x19,x
N#define HID_UsageMax(x)        0x29,x
N
N
N#endif  /* __USB_HID_H__ */
L 29 "..\..\..\source\usb\usb.h" 2
N#include "usb_msc.h"
L 1 "..\..\..\source\usb\usb_msc.h" 1
N/**
N * @file    usb_msc.h
N * @brief   USB mass storage header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USB_MSC_H__
N#define __USB_MSC_H__
N
N
N/* MSC Subclass Codes */
N#define MSC_SUBCLASS_RBC                0x01
N#define MSC_SUBCLASS_SFF8020I_MMC2      0x02
N#define MSC_SUBCLASS_QIC157             0x03
N#define MSC_SUBCLASS_UFI                0x04
N#define MSC_SUBCLASS_SFF8070I           0x05
N#define MSC_SUBCLASS_SCSI               0x06
N
N/* MSC Protocol Codes */
N#define MSC_PROTOCOL_CBI_INT            0x00
N#define MSC_PROTOCOL_CBI_NOINT          0x01
N#define MSC_PROTOCOL_BULK_ONLY          0x50
N
N
N/* MSC Request Codes */
N#define MSC_REQUEST_RESET               0xFF
N#define MSC_REQUEST_GET_MAX_LUN         0xFE
N
N
N/* MSC Bulk-only Stage */
N#define MSC_BS_CBW                      0       /* Command Block Wrapper */
N#define MSC_BS_DATA_OUT                 1       /* Data Out Phase */
N#define MSC_BS_DATA_IN                  2       /* Data In Phase */
N#define MSC_BS_DATA_IN_LAST             3       /* Data In Last Phase */
N#define MSC_BS_DATA_IN_LAST_STALL       4       /* Data In Last Phase with Stall */
N#define MSC_BS_CSW                      5       /* Command Status Wrapper */
N#define MSC_BS_ERROR                    6       /* Error */
N#define MSC_BS_RESET                    7       /* Bulk-Only Mass Storage Reset */
N
N
N/* Bulk-only Command Block Wrapper */
Ntypedef __packed struct _MSC_CBW {
Xtypedef __packed struct _MSC_CBW {
N    U32 dSignature;
N    U32 dTag;
N    U32 dDataLength;
N    U8  bmFlags;
N    U8  bLUN;
N    U8  bCBLength;
N    U8  CB[16];
N} MSC_CBW;
N
N/* Bulk-only Command Status Wrapper */
Ntypedef __packed struct _MSC_CSW {
Xtypedef __packed struct _MSC_CSW {
N    U32 dSignature;
N    U32 dTag;
N    U32 dDataResidue;
N    U8  bStatus;
N} MSC_CSW;
N
N#define MSC_CBW_Signature               0x43425355
N#define MSC_CSW_Signature               0x53425355
N
N
N/* CSW Status Definitions */
N#define CSW_CMD_PASSED                  0x00
N#define CSW_CMD_FAILED                  0x01
N#define CSW_PHASE_ERROR                 0x02
N
N
N/* SCSI Commands */
N#define SCSI_TEST_UNIT_READY            0x00
N#define SCSI_REQUEST_SENSE              0x03
N#define SCSI_FORMAT_UNIT                0x04
N#define SCSI_INQUIRY                    0x12
N#define SCSI_MODE_SELECT6               0x15
N#define SCSI_MODE_SENSE6                0x1A
N#define SCSI_START_STOP_UNIT            0x1B
N#define SCSI_MEDIA_REMOVAL              0x1E
N#define SCSI_READ_FORMAT_CAPACITIES     0x23
N#define SCSI_READ_CAPACITY              0x25
N#define SCSI_READ10                     0x28
N#define SCSI_WRITE10                    0x2A
N#define SCSI_VERIFY10                   0x2F
N#define SCSI_SYNC_CACHE10               0x35
N#define SCSI_READ12                     0xA8
N#define SCSI_WRITE12                    0xAA
N#define SCSI_MODE_SELECT10              0x55
N#define SCSI_MODE_SENSE10               0x5A
N#define SCSI_SYNC_CACHE16               0x91
N#define SCSI_ATA_COMMAND_PASS_THROUGH12 0xA1
N#define SCSI_ATA_COMMAND_PASS_THROUGH16 0x85
N#define SCSI_SERVICE_ACTION_IN12        0xAB
N#define SCSI_SERVICE_ACTION_IN16        0x9E
N#define SCSI_SERVICE_ACTION_OUT12       0xA9
N#define SCSI_SERVICE_ACTION_OUT16       0x9F
N#define SCSI_REPORT_ID_INFO             0xA3
N
N#endif  /* __USB_MSC_H__ */
L 30 "..\..\..\source\usb\usb.h" 2
N#include "usb_bulk.h"
L 1 "..\..\..\source\usb\usb_bulk.h" 1
N/**
N * @file    usbd_bulk.h
N * @brief   USB Device Bulk header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_BULK_H__
N#define __USBD_BULK_H__
N
N/*--------------------------- Event handling routines ------------------------*/
N
Nextern void USBD_BULK_EP_BULKIN_Event(U32 event);
Nextern void USBD_BULK_EP_BULKOUT_Event(U32 event);
Nextern void USBD_BULK_EP_BULK_Event(U32 event);
N
N
N#endif  /* __USBD_BULK_H__ */
L 31 "..\..\..\source\usb\usb.h" 2
N#include "usb_webusb.h"
L 1 "..\..\..\source\usb\usb_webusb.h" 1
N/**
N * @file    usb_webusb.h
N * @brief   WebUSB driver header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USB_WEBUSB_H__
N#define __USB_WEBUSB_H__
N
N/* WebUSB Descriptor Types */
N#define WEBUSB_DESCRIPTOR_SET_HEADER_TYPE       0x00
N#define WEBUSB_CONFIGURATION_SUBSET_HEADER_TYPE 0x01
N#define WEBUSB_FUNCTION_SUBSET_HEADER_TYPE      0x02
N#define WEBUSB_URL_TYPE                         0x03
N
N/* WebUSB Platform Capability Descriptor */
Ntypedef __packed struct _WEBUSB_PLATFORM_CAPABILITY_DESCRIPTOR {
Xtypedef __packed struct _WEBUSB_PLATFORM_CAPABILITY_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bDevCapabilityType;
N    U8  bReserved;
N    U8  platformCapabilityUUID[16];
N    U16 bcdVersion;
N    U8  bVendorCode;
N    U8  iLandingPage;
N} WEBUSB_PLATFORM_CAPABILITY_DESCRIPTOR;
N
Ntypedef __packed struct _WEBUSB_URL_DESCRIPTOR {
Xtypedef __packed struct _WEBUSB_URL_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bScheme;
N    char URL[];
N} WEBUSB_URL_DESCRIPTOR;
N
N/* WebUSB Request Codes */
N#define WEBUSB_REQUEST_GET_URL                  0x02
N
N/* bScheme in URL descriptor */
N#define WEBUSB_URL_SCHEME_HTTP                  0x00
N#define WEBUSB_URL_SCHEME_HTTPS                 0x01
N
N/* WebUSB Descriptor sizes */
N#define WEBUSB_DESCRIPTOR_SET_HEADER_SIZE       5
N#define WEBUSB_CONFIGURATION_SUBSET_HEADER_SIZE 4
N#define WEBUSB_FUNCTION_SUBSET_HEADER_SIZE      3
N
N#endif  /* __USB_WEBUSB_H__ */
L 32 "..\..\..\source\usb\usb.h" 2
N#include "usb_winusb.h"
L 1 "..\..\..\source\usb\usb_winusb.h" 1
N/**
N * @file    usb_winusb.h
N * @brief   WinUSB driver header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USB_WINUSB_H__
N#define __USB_WINUSB_H__
N
N/* WinUSB Microsoft OS 2.0 Descriptor Types */
N#define WINUSB_SET_HEADER_DESCRIPTOR_TYPE           0x00
N#define WINUSB_SUBSET_HEADER_CONFIGURATION_TYPE     0x01
N#define WINUSB_SUBSET_HEADER_FUNCTION_TYPE          0x02
N#define WINUSB_FEATURE_COMPATIBLE_ID_TYPE           0x03
N#define WINUSB_FEATURE_REG_PROPERTY_TYPE            0x04
N#define WINUSB_FEATURE_MIN_RESUME_TIME_TYPE         0x05
N#define WINUSB_FEATURE_MODEL_ID_TYPE                0x06
N#define WINUSB_FEATURE_CCGP_DEVICE_TYPE             0x07
N
N
N#define WINUSB_PROP_DATA_TYPE_REG_SZ                0x01
N#define WINUSB_PROP_DATA_TYPE_REG_MULTI_SZ          0x07
N
N/* WinUSB Microsoft OS 2.0 descriptor Platform Capability Descriptor */
Ntypedef __packed struct _WINUSB_PLATFORM_CAPABILITY_DESCRIPTOR {
Xtypedef __packed struct _WINUSB_PLATFORM_CAPABILITY_DESCRIPTOR {
N    U8  bLength;
N    U8  bDescriptorType;
N    U8  bDevCapabilityType;
N    U8  bReserved;
N    U8  platformCapabilityUUID[16];
N    U32 dwWindowsVersion;
N    U16 wDescriptorSetTotalLength;
N    U8  bVendorCode;
N    U8  bAltEnumCode;
N} WINUSB_PLATFORM_CAPABILITY_DESCRIPTOR;
N
N/* WinUSB Microsoft OS 2.0 descriptor set header */
Ntypedef __packed struct _WINUSB_DESCRIPTOR_SET_HEADER {
Xtypedef __packed struct _WINUSB_DESCRIPTOR_SET_HEADER {
N    U16 wLength;
N    U16 wDescriptorType;
N    U32 dwWindowsVersion;
N    U16 wTotalLength;
N} WINUSB_DESCRIPTOR_SET_HEADER;
N
N/* WinUSB Microsoft OS 2.0 descriptor request codes */
N#define WINUSB_REQUEST_GET_DESCRIPTOR_SET          0x07
N#define WINUSB_REQUEST_SET_ALT_ENUM                0x08
N
N/* WinUSB Microsoft OS 2.0 descriptor sizes */
N#define WINUSB_DESCRIPTOR_SET_HEADER_SIZE          10
N#define WINUSB_FUNCTION_SUBSET_HEADER_SIZE         8
N#define WINUSB_FEATURE_COMPATIBLE_ID_SIZE          20
N#endif // __USB_WINUSB_H__
L 33 "..\..\..\source\usb\usb.h" 2
N
N
N/* USB Device header files                                                    */
N#include "usbd_core.h"
L 1 "..\..\..\source\usb\usbd_core.h" 1
N/**
N * @file    usbd_core.h
N * @brief   USB Device Core header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_CORE_H__
N#define __USBD_CORE_H__
N
N
N/*--------------------------- Data structures --------------------------------*/
N
N/* USB Device Core Endpoint Data Structure */
Ntypedef struct _USBD_EP_DATA {
N    U8 *pData;
N    U16 Count;
N} USBD_EP_DATA;
N
N
N/*--------------------------- Global variables -------------------------------*/
N
N/* USB Device Core Global Variables */
Nextern U16 USBD_DeviceStatus;
Nextern U8 USBD_DeviceAddress;
Nextern U8 USBD_Configuration;
Nextern U32 USBD_EndPointMask;
Nextern U32 USBD_EndPointHalt;
Nextern U32 USBD_EndPointStall;
Nextern U8 USBD_NumInterfaces;
Nextern U8 USBD_HighSpeed;
Nextern U8 USBD_ZLP;
N
Nextern USBD_EP_DATA USBD_EP0Data;
Nextern USB_SETUP_PACKET USBD_SetupPacket;
N
N#ifdef __RTX
Sextern OS_TID USBD_RTX_DevTask;
Sextern OS_TID USBD_RTX_EPTask[];
Sextern OS_TID USBD_RTX_CoreTask;
N#endif
N
N/*--------------------------- Functions exported to class specific files -----*/
N
Nextern void USBD_SetupStage(void);
Nextern void USBD_DataInStage(void);
Nextern void USBD_DataOutStage(void);
Nextern void USBD_StatusInStage(void);
Nextern void USBD_StatusOutStage(void);
N
N
N/*--------------------------- Event handling routines ------------------------*/
N
Nextern void usbd_class_init(void);
Nextern void USBD_EndPoint0(U32 event);
N
N#ifdef __RTX
Sextern void USBD_RTX_EndPoint0(void);
N#endif
N
N#endif  /* __USBD_CORE_H__ */
L 37 "..\..\..\source\usb\usb.h" 2
N#include "usbd_core_cdc.h"
L 1 "..\..\..\source\usb\usbd_core_cdc.h" 1
N/**
N * @file    usbd_core_cdc.h
N * @brief   USB Device Core CDC header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_CORE_CDC_H__
N#define __USBD_CORE_CDC_H__
N
N
N/*--------------------------- Core overridable class specific functions ------*/
N
Nextern BOOL USBD_EndPoint0_Setup_CDC_ReqToIF(void);
Nextern BOOL USBD_EndPoint0_Out_CDC_ReqToIF(void);
N
N
N#endif  /* __USBD_CORE_CDC_H__ */
L 38 "..\..\..\source\usb\usb.h" 2
N#include "usbd_core_hid.h"
L 1 "..\..\..\source\usb\usbd_core_hid.h" 1
N/**
N * @file    usbd_core_hid.h
N * @brief   USB Device Core HID header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_CORE_HID_H__
N#define __USBD_CORE_HID_H__
N
N
N/*--------------------------- Core overridable class specific functions ------*/
N
Nextern BOOL USBD_ReqGetDescriptor_HID(U8 **pD, U32 *len);
Nextern BOOL USBD_EndPoint0_Setup_HID_ReqToIF(void);
Nextern BOOL USBD_EndPoint0_Out_HID_ReqToIF(void);
N
N
N#endif  /* __USBD_CORE_HID_H__ */
L 39 "..\..\..\source\usb\usb.h" 2
N#include "usbd_core_msc.h"
L 1 "..\..\..\source\usb\usbd_core_msc.h" 1
N/**
N * @file    usbd_core_msc.h
N * @brief   USB Device Core CDC header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_CORE_MSC_H__
N#define __USBD_CORE_MSC_H__
N
N
N/*--------------------------- Core overridable class specific functions ------*/
N
Nextern void USBD_ReqClrFeature_MSC(U32 EPNum);
Nextern BOOL USBD_EndPoint0_Setup_MSC_ReqToIF(void);
Nextern BOOL USBD_EndPoint0_Out_MSC_ReqToIF(void);
N
N
N#endif  /* __USBD_CORE_MSC_H__ */
L 40 "..\..\..\source\usb\usb.h" 2
N#include "usbd_core_webusb.h"
L 1 "..\..\..\source\usb\usbd_core_webusb.h" 1
N/**
N * @file    usbd_core_webusb.h
N * @brief   USB Device Core WebUSB header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_CORE_WEBUSB_H__
N#define __USBD_CORE_WEBUSB_H__
N
N
N/*--------------------------- Core overridable vendor specific functions ------*/
N
Nextern BOOL USBD_EndPoint0_Setup_WebUSB_ReqToDevice(void);
N
N#endif  /* __USBD_CORE_WEBUSB_H__ */
L 41 "..\..\..\source\usb\usb.h" 2
N#include "usbd_core_winusb.h"
L 1 "..\..\..\source\usb\usbd_core_winusb.h" 1
N/**
N * @file    usbd_core_winusb.h
N * @brief   USB Device Core WinUSB header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_CORE_WINUSB_H__
N#define __USBD_CORE_WINUSB_H__
N
N
N/*--------------------------- Core overridable vendor specific functions ------*/
N
Nextern BOOL USBD_EndPoint0_Setup_WinUSB_ReqToDevice(void);
N
N#endif  /* __USBD_CORE_WINUSB_H__ */
L 42 "..\..\..\source\usb\usb.h" 2
N
N#include "usbd_desc.h"
L 1 "..\..\..\source\usb\usbd_desc.h" 1
N/**
N * @file    usbd_desc.h
N * @brief   USB Device Descriptor header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_DESC_H__
N#define __USBD_DESC_H__
N
N#define WBVAL(x)                          (x & 0xFF),((x >> 8) & 0xFF)
N#define B3VAL(x)                          (x & 0xFF),((x >> 8) & 0xFF),((x >> 16) & 0xFF)
N#define USB_DEVICE_DESC_SIZE              (sizeof(USB_DEVICE_DESCRIPTOR))
N#define USB_DEVICE_QUALI_SIZE             (sizeof(USB_DEVICE_QUALIFIER_DESCRIPTOR))
N#define USB_CONFIGUARTION_DESC_SIZE       (sizeof(USB_CONFIGURATION_DESCRIPTOR))
N#define USB_INTERFACE_ASSOC_DESC_SIZE     (sizeof(USB_INTERFACE_ASSOCIATION_DESCRIPTOR))
N#define USB_INTERFACE_DESC_SIZE           (sizeof(USB_INTERFACE_DESCRIPTOR))
N#define USB_ENDPOINT_DESC_SIZE            (sizeof(USB_ENDPOINT_DESCRIPTOR))
N#define USB_BOS_DESC_SIZE                 (sizeof(USB_BINARY_OBJECT_STORE_DESCRIPTOR))
N#define USB_HID_DESC_SIZE                 (sizeof(HID_DESCRIPTOR))
N#define USB_HID_REPORT_DESC_SIZE          (sizeof(USBD_HID_ReportDescriptor))
N
N#endif  /* __USBD_DESC_H__ */
L 44 "..\..\..\source\usb\usb.h" 2
N#include "usbd_event.h"
L 1 "..\..\..\source\usb\usbd_event.h" 1
N/**
N * @file    usbd_event.h
N * @brief   USB Device Event header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_EVENT_H__
N#define __USBD_EVENT_H__
N
N
N/* USB Device - Device Events                                                 */
N#define USBD_EVT_POWER_ON    (1 <<  0)  /* USB Power On                       */
N#define USBD_EVT_POWER_OFF   (1 <<  1)  /* USB Power Off                      */
N#define USBD_EVT_RESET       (1 <<  2)  /* USB Bus Reset                      */
N#define USBD_EVT_WAKEUP      (1 <<  3)  /* USB Remote Wakeup                  */
N#define USBD_EVT_SUSPEND     (1 <<  4)  /* USB Suspend                        */
N#define USBD_EVT_RESUME      (1 <<  5)  /* USB Resume                         */
N#define USBD_EVT_SOF         (1 <<  6)  /* USB Start of Frame                 */
N#define USBD_EVT_ERROR       (1 <<  7)  /* USB Error                          */
N
N/* USB Device - Endpoint Events                                               */
N#define USBD_EVT_SETUP       (1 <<  1)  /* Setup Packet                       */
N#define USBD_EVT_OUT         (1 <<  2)  /* OUT Packet                         */
N#define USBD_EVT_IN          (1 <<  3)  /*  IN Packet                         */
N#define USBD_EVT_OUT_NAK     (1 <<  4)  /* OUT Packet - Not Acknowledged      */
N#define USBD_EVT_IN_NAK      (1 <<  5)  /*  IN Packet - Not Acknowledged      */
N#define USBD_EVT_OUT_STALL   (1 <<  6)  /* OUT Packet - Stalled               */
N#define USBD_EVT_IN_STALL    (1 <<  7)  /*  IN Packet - Stalled               */
N#define USBD_EVT_OUT_DMA_EOT (1 <<  8)  /* DMA OUT EP - End of Transfer       */
N#define USBD_EVT_IN_DMA_EOT  (1 <<  9)  /* DMA  IN EP - End of Transfer       */
N#define USBD_EVT_OUT_DMA_NDR (1 << 10)  /* DMA OUT EP - New Descriptor Request*/
N#define USBD_EVT_IN_DMA_NDR  (1 << 11)  /* DMA  IN EP - New Descriptor Request*/
N#define USBD_EVT_OUT_DMA_ERR (1 << 12)  /* DMA OUT EP - Error                 */
N#define USBD_EVT_IN_DMA_ERR  (1 << 13)  /* DMA  IN EP - Error                 */
N
N/* USB Device - Core Events                                                   */
N#define USBD_EVT_SET_CFG     (1 <<  0)  /* Set Configuration                  */
N#define USBD_EVT_SET_IF      (1 <<  1)  /* Set Interface                      */
N#define USBD_EVT_SET_FEATURE (1 <<  2)  /* Set Feature                        */
N#define USBD_EVT_CLR_FEATURE (1 <<  3)  /* Clear Feature                      */
N
N/* USB Device - Device Events Callback Pointers                               */
Nextern void (* const USBD_P_Power_Event)(BOOL power);
Nextern void (* const USBD_P_Reset_Event)(void);
Nextern void (* const USBD_P_Suspend_Event)(void);
Nextern void (* const USBD_P_Resume_Event)(void);
Nextern void (* const USBD_P_WakeUp_Event)(void);
Nextern void (* const USBD_P_SOF_Event)(void);
Nextern void (* const USBD_P_Error_Event)(U32 error);
N
N/* USB Device - Endpoint Events Callback Pointers                             */
Nextern void (* const USBD_P_EP[16])(U32 event);
N
N/* USB Device - Core Events Callback Pointers                                 */
Nextern void (* const USBD_P_Configure_Event)(void);
Nextern void (* const USBD_P_Interface_Event)(void);
Nextern void (* const USBD_P_Feature_Event)(void);
N
N/* USB Device - RTX version RTX tasks initialization                          */
Nextern void USBD_RTX_TaskInit(void);
N
N#endif  /* __USBD_EVENT_H__ */
L 45 "..\..\..\source\usb\usb.h" 2
N#include "usbd_cdc_acm.h"
L 1 "..\..\..\source\usb\usbd_cdc_acm.h" 1
N/**
N * @file    usbd_cdc_acm.h
N * @brief   USB CDC ACM header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_CDC_ACM_H__
N#define __USBD_CDC_ACM_H__
N
N
N/*--------------------------- Event handling routines ------------------------*/
N
Nextern void USBD_CDC_ACM_Reset_Event(void);
N
Nextern void USBD_CDC_ACM_SOF_Event(void);
N
Nextern void USBD_CDC_ACM_EP_INTIN_Event(U32 event);
Nextern void USBD_CDC_ACM_EP_BULKIN_Event(U32 event);
Nextern void USBD_CDC_ACM_EP_BULKOUT_Event(U32 event);
Nextern void USBD_CDC_ACM_EP_BULK_Event(U32 event);
N
N#ifdef __RTX
Sextern void USBD_RTX_CDC_ACM_EP_INTIN_Event(void);
Sextern void USBD_RTX_CDC_ACM_EP_BULKIN_Event(void);
Sextern void USBD_RTX_CDC_ACM_EP_BULKOUT_Event(void);
Sextern void USBD_RTX_CDC_ACM_EP_BULK_Event(void);
N#endif
N
N#endif  /* __USBD_CDC_ACM_H__ */
L 46 "..\..\..\source\usb\usb.h" 2
N#include "usbd_hid.h"
L 1 "..\..\..\source\usb\usbd_hid.h" 1
N/**
N * @file    usbd_hid.h
N * @brief   USB Device HID header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_HID_H__
N#define __USBD_HID_H__
N
N
N/*--------------------------- Global constants -------------------------------*/
N
N/* USB HID Class API enumerated constants                                     */
Nenum {
N    USBD_HID_REQ_EP_CTRL = 0,             /* Request from control endpoint      */
N    USBD_HID_REQ_EP_INT,                  /* Request from interrupt endpoint    */
N    USBD_HID_REQ_PERIOD_UPDATE            /* Request from periodic update       */
N};
N
N
N/*--------------------------- Event handling routines ------------------------*/
N
Nextern void USBD_HID_Configure_Event(void);
Nextern void USBD_HID_SOF_Event(void);
N
Nextern void USBD_HID_EP_INTIN_Event(U32 event);
Nextern void USBD_HID_EP_INTOUT_Event(U32 event);
Nextern void USBD_HID_EP_INT_Event(U32 event);
N#ifdef __RTX
Sextern void USBD_RTX_HID_EP_INTIN_Event(void);
Sextern void USBD_RTX_HID_EP_INTOUT_Event(void);
Sextern void USBD_RTX_HID_EP_INT_Event(void);
N#endif
N
N#endif  /* __USBD_HID_H__ */
L 47 "..\..\..\source\usb\usb.h" 2
N#include "usbd_msc.h"
L 1 "..\..\..\source\usb\usbd_msc.h" 1
N/**
N * @file    usbd_msc.h
N * @brief   USB Device MSC header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_MSC_H__
N#define __USBD_MSC_H__
N
N
N/*--------------------------- Global variables -------------------------------*/
N
N/* USB Device Mass Storage Device Class Global Variables */
Nextern BOOL USBD_MSC_MediaReady;
Nextern BOOL USBD_MSC_ReadOnly;
Nextern U32 USBD_MSC_MemorySize;
Nextern U32 USBD_MSC_BlockSize;
Nextern U32 USBD_MSC_BlockGroup;
Nextern U32 USBD_MSC_BlockCount;
Nextern U8 *USBD_MSC_BlockBuf;
N
N
N/*--------------------------- Event handling routines ------------------------*/
N
Nextern void USBD_MSC_Reset_Event(void);
N
Nextern void USBD_MSC_EP_BULKIN_Event(U32 event);
Nextern void USBD_MSC_EP_BULKOUT_Event(U32 event);
Nextern void USBD_MSC_EP_BULK_Event(U32 event);
N
N#ifdef __RTX
Sextern void USBD_RTX_MSC_EP_BULKIN_Event(void);
Sextern void USBD_RTX_MSC_EP_BULKOUT_Event(void);
Sextern void USBD_RTX_MSC_EP_BULK_Event(void);
N#endif
N
N#endif  /* __USBD_MSC_H__ */
L 48 "..\..\..\source\usb\usb.h" 2
N#include "usbd_hw.h"
L 1 "..\..\..\source\usb\usbd_hw.h" 1
N/**
N * @file    usbd_hw.h
N * @brief   USB Device Hardware header
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __USBD_HW_H__
N#define __USBD_HW_H__
N
N
N/* USB Hardware Functions */
Nextern void USBD_Init(void);
Nextern void USBD_Connect(BOOL con);
Nextern void USBD_Reset(void);
Nextern void USBD_Suspend(void);
Nextern void USBD_Resume(void);
Nextern void USBD_WakeUp(void);
Nextern void USBD_WakeUpCfg(BOOL cfg);
Nextern void USBD_SetAddress(U32 adr, U32 setup);
Nextern void USBD_Configure(BOOL cfg);
Nextern void USBD_ConfigEP(USB_ENDPOINT_DESCRIPTOR *pEPD);
Nextern void USBD_DirCtrlEP(U32 dir);
Nextern void USBD_EnableEP(U32 EPNum);
Nextern void USBD_DisableEP(U32 EPNum);
Nextern void USBD_ResetEP(U32 EPNum);
Nextern void USBD_SetStallEP(U32 EPNum);
Nextern void USBD_ClrStallEP(U32 EPNum);
Nextern void USBD_ClearEPBuf(U32 EPNum);
Nextern U32 USBD_ReadEP(U32 EPNum, U8 *pData, U32 cnt);
Nextern U32 USBD_WriteEP(U32 EPNum, U8 *pData, U32 cnt);
Nextern U32 USBD_GetFrame(void);
Nextern U32 USBD_GetError(void);
Nextern void USBD_SignalHandler(void);
Nextern void USBD_Handler(void);
N
N#endif  /* __USBD_HW_H__ */
L 49 "..\..\..\source\usb\usb.h" 2
N
N#endif  /* __USB_H__ */
L 31 "..\..\..\source\usb\rl_usb.h" 2
N
N/*****************  Functions *************************************************/
N
N/* USB Device functions exported from USB Device Core module                  */
Nextern void  usbd_init(void);
Nextern void  usbd_connect(BOOL con);
Nextern void  usbd_reset_core(void);
Nextern BOOL  usbd_configured(void);
N
N/* USB Device user functions imported to USB HID Class module                 */
Nextern void  usbd_hid_init(void);
Nextern BOOL  usbd_hid_get_report_trigger(U8 rid,   U8 *buf, int len);
Nextern int   usbd_hid_get_report(U8 rtype, U8 rid, U8 *buf, U8  req);
Nextern void  usbd_hid_set_report(U8 rtype, U8 rid, U8 *buf, int len, U8 req);
Nextern U8    usbd_hid_get_protocol(void);
Nextern void  usbd_hid_set_protocol(U8 protocol);
N
N/* USB Device user functions imported to USB Mass Storage Class module        */
Nextern void  usbd_msc_init(void);
Nextern void  usbd_msc_read_sect(U32 block, U8 *buf, U32 num_of_blocks);
Nextern void  usbd_msc_write_sect(U32 block, U8 *buf, U32 num_of_blocks);
Nextern void  usbd_msc_start_stop(BOOL start);
N
N/* USB Device user functions imported to USB Audio Class module               */
Nextern void  usbd_adc_init(void);
N
N/* USB Device CDC ACM class functions called automatically by USBD Core module*/
Nextern int32_t  USBD_CDC_ACM_Initialize(void);
Nextern int32_t  USBD_CDC_ACM_Uninitialize(void);
Nextern int32_t  USBD_CDC_ACM_Reset(void);
N/* USB Device CDC ACM class user functions                                    */
Nextern int32_t  USBD_CDC_ACM_PortInitialize(void);
Nextern int32_t  USBD_CDC_ACM_PortUninitialize(void);
Nextern int32_t  USBD_CDC_ACM_PortReset(void);
Nextern int32_t  USBD_CDC_ACM_PortSetLineCoding(CDC_LINE_CODING *line_coding);
Nextern int32_t  USBD_CDC_ACM_PortGetLineCoding(CDC_LINE_CODING *line_coding);
Nextern int32_t  USBD_CDC_ACM_PortSetControlLineState(uint16_t ctrl_bmp);
Nextern int32_t  USBD_CDC_ACM_DataSend(const uint8_t *buf, int32_t len);
Nextern int32_t  USBD_CDC_ACM_DataFree(void);
Nextern int32_t  USBD_CDC_ACM_PutChar(const uint8_t  ch);
Nextern int32_t  USBD_CDC_ACM_DataRead(uint8_t *buf, int32_t len);
Nextern int32_t  USBD_CDC_ACM_GetChar(void);
Nextern int32_t  USBD_CDC_ACM_DataAvailable(void);
Nextern int32_t  USBD_CDC_ACM_Notify(uint16_t stat);
N/* USB Device CDC ACM class overridable functions                             */
Nextern int32_t  USBD_CDC_ACM_SendEncapsulatedCommand(void);
Nextern int32_t  USBD_CDC_ACM_GetEncapsulatedResponse(void);
Nextern int32_t  USBD_CDC_ACM_SetCommFeature(uint16_t feat);
Nextern int32_t  USBD_CDC_ACM_GetCommFeature(uint16_t feat);
Nextern int32_t  USBD_CDC_ACM_ClearCommFeature(uint16_t feat);
Nextern int32_t  USBD_CDC_ACM_SetLineCoding(void);
Nextern int32_t  USBD_CDC_ACM_GetLineCoding(void);
Nextern int32_t  USBD_CDC_ACM_SetControlLineState(uint16_t ctrl_bmp);
Nextern int32_t  USBD_CDC_ACM_SendBreak(uint16_t dur);
N
N/* USB Device user functions imported to USB Custom Class module              */
Nextern void  usbd_cls_init(void);
Nextern void  usbd_cls_sof(void);
Nextern BOOL  usbd_cls_dev_req(BOOL setup);
Nextern BOOL  usbd_cls_if_req(BOOL setup);
Nextern BOOL  usbd_cls_ep_req(BOOL setup);
N
Nextern void  usbd_bulk_init(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* __RL_USB_H__ */
L 24 "..\..\..\source\usb\usb_lib.c" 2
N#include "usb.h"
N#include "settings.h"
L 1 "..\..\..\source\daplink\settings\settings.h" 1
N/**
N * @file    settings.h
N * @brief   Access to read user configuration settings
N *
N * DAPLink Interface Firmware
N * Copyright (c) 2009-2016, ARM Limited, All Rights Reserved
N * Copyright 2019, Cypress Semiconductor Corporation 
N * or a subsidiary of Cypress Semiconductor Corporation.
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef SETTINGS_H
N#define SETTINGS_H
N
N#include <stdint.h>
N#include <stdbool.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Ntypedef enum {
N    ASSERT_SOURCE_NONE = 0,
N    ASSERT_SOURCE_BL = 1,
N    ASSERT_SOURCE_APP = 2
N} assert_source_t;
N
Nvoid config_init(void);
N
N// Get/set settings residing in flash
Nvoid config_set_auto_rst(bool on);
Xvoid config_set_auto_rst(_Bool on);
Nvoid config_set_automation_allowed(bool on);
Xvoid config_set_automation_allowed(_Bool on);
Nvoid config_set_overflow_detect(bool on);
Xvoid config_set_overflow_detect(_Bool on);
Nbool config_get_auto_rst(void);
X_Bool config_get_auto_rst(void);
Nbool config_get_automation_allowed(void);
X_Bool config_get_automation_allowed(void);
Nbool config_get_overflow_detect(void);
X_Bool config_get_overflow_detect(void);
N
N// Get/set settings residing in shared ram
Nvoid config_ram_set_hold_in_bl(bool hold);
Xvoid config_ram_set_hold_in_bl(_Bool hold);
Nvoid config_ram_set_assert(const char *file, uint16_t line);
Nvoid config_ram_clear_assert(void);
Nbool config_ram_get_hold_in_bl(void);
X_Bool config_ram_get_hold_in_bl(void);
Nbool config_ram_get_initial_hold_in_bl(void);
X_Bool config_ram_get_initial_hold_in_bl(void);
Nbool config_ram_get_assert(char *buf, uint16_t buf_size, uint16_t *line, assert_source_t *source);
X_Bool config_ram_get_assert(char *buf, uint16_t buf_size, uint16_t *line, assert_source_t *source);
Nuint8_t config_ram_add_hexdump(uint32_t hexdump);
Nuint8_t config_ram_get_hexdumps(uint32_t **hexdumps);
Nvoid config_ram_set_disable_msd(bool disable_msd);
Xvoid config_ram_set_disable_msd(_Bool disable_msd);
Nuint8_t config_ram_get_disable_msd(void);
Nvoid config_ram_set_page_erase(bool page_erase_enable);
Xvoid config_ram_set_page_erase(_Bool page_erase_enable);
Nbool config_ram_get_page_erase(void);
X_Bool config_ram_get_page_erase(void);
N
N// Private - should only be called from settings.c
Nvoid config_rom_init(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 26 "..\..\..\source\usb\usb_lib.c" 2
N
N#pragma thumb
N#pragma O3
N
N
N/*------------------------------------------------------------------------------
N *      Library for usb_config.c
N *----------------------------------------------------------------------------*/
N
N#ifdef  __USB_CONFIG__
N
N/*------------------------------------------------------------------------------
N *      USB Device Configuration
N *----------------------------------------------------------------------------*/
N
N#if    (USBD_ENABLE)
X#if    (1)
N
NU8 USBD_AltSetting[USBD_IF_NUM_MAX];
XU8 USBD_AltSetting[(1+1+1+1+(0*2)+(1*2)+0)];
NU8 USBD_EP0Buf[USBD_MAX_PACKET0];
XU8 USBD_EP0Buf[64];
Nconst U8 usbd_power = USBD_POWER;
Xconst U8 usbd_power = 0;
Nconst U8 usbd_hs_enable = USBD_HS_ENABLE;
Xconst U8 usbd_hs_enable = 0;
Nconst U8 usbd_bos_enable = USBD_BOS_ENABLE;
Xconst U8 usbd_bos_enable = 1;
NU16 usbd_if_num = USBD_IF_NUM_MAX;
XU16 usbd_if_num = (1+1+1+1+(0*2)+(1*2)+0);
Nconst U8 usbd_ep_num = USBD_EP_NUM;
Xconst U8 usbd_ep_num = (((((((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) > ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))) ? ((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) : ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))))) > ((((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) > ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))) ? ((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) : ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))))) ? ((((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) > ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))) ? ((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) : ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))))) : ((((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) > ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))) ? ((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) : ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))))))) > ((((1*(1))) > ((1*(1))) ? ((1*(1))) : ((1*(1))))) ? ((((((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) > ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))) ? ((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) : ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))))) > ((((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) > ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))) ? ((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) : ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))))) ? ((((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) > ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))) ? ((((1 *(0 ))) > ((1 *(0))) ? ((1 *(0 ))) : ((1 *(0))))) : ((((1 *(2 ))) > ((1 *(2))) ? ((1 *(2 ))) : ((1 *(2))))))) : ((((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) > ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))) ? ((((0 *(3 ))) > ((1*(3))) ? ((0 *(3 ))) : ((1*(3))))) : ((((1*(4))) > ((1*(4))) ? ((1*(4))) : ((1*(4))))))))) : ((((1*(1))) > ((1*(1))) ? ((1*(1))) : ((1*(1))))));
Nconst U8 usbd_max_packet0 = USBD_MAX_PACKET0;
Xconst U8 usbd_max_packet0 = 64;
N
N
N/*------------------------------------------------------------------------------
N *      USB Device Class Configuration
N *----------------------------------------------------------------------------*/
N
N#if    (!USBD_HID_BINTERVAL)
X#if    (!1)
S#define USBD_HID_INTERVAL                1
N#else
N#define USBD_HID_INTERVAL                USBD_HID_BINTERVAL
N#endif
N#if    (!USBD_HID_HS_BINTERVAL)
X#if    (!6)
S#define USBD_HID_HS_INTERVAL             1
N#else
N#define USBD_HID_HS_INTERVAL            (2 << ((USBD_HID_HS_BINTERVAL & 0x0F)-1))
N#endif
N
N#if    (USBD_HID_ENABLE)
X#if    (1)
NU8 usbd_hid_if_num; //assigned during runtime init
Nconst U8 usbd_hid_ep_intin = USBD_HID_EP_INTIN;
Xconst U8 usbd_hid_ep_intin = 0;
Nconst U8 usbd_hid_ep_intout = USBD_HID_EP_INTOUT;
Xconst U8 usbd_hid_ep_intout = 0;
Nconst U16 usbd_hid_interval[2]  = {USBD_HID_INTERVAL, USBD_HID_HS_INTERVAL};
Xconst U16 usbd_hid_interval[2]  = {1, (2 << ((6 & 0x0F)-1))};
Nconst U16 usbd_hid_maxpacketsize[2] = {USBD_HID_WMAXPACKETSIZE, USBD_HID_HS_WMAXPACKETSIZE};
Xconst U16 usbd_hid_maxpacketsize[2] = {64, 64};
Nconst U8 usbd_hid_inreport_num = USBD_HID_INREPORT_NUM;
Xconst U8 usbd_hid_inreport_num = 1;
Nconst U8 usbd_hid_outreport_num = USBD_HID_OUTREPORT_NUM;
Xconst U8 usbd_hid_outreport_num = 1;
Nconst U16 usbd_hid_inreport_max_sz = USBD_HID_INREPORT_MAX_SZ;
Xconst U16 usbd_hid_inreport_max_sz = 64;
Nconst U16 usbd_hid_outreport_max_sz = USBD_HID_OUTREPORT_MAX_SZ;
Xconst U16 usbd_hid_outreport_max_sz = 64;
Nconst U16 usbd_hid_featreport_max_sz = USBD_HID_FEATREPORT_MAX_SZ;
Xconst U16 usbd_hid_featreport_max_sz = 1;
NU16 USBD_HID_PollingCnt;
NU8 USBD_HID_IdleCnt[USBD_HID_INREPORT_NUM];
XU8 USBD_HID_IdleCnt[1];
NU8 USBD_HID_IdleReload[USBD_HID_INREPORT_NUM];
XU8 USBD_HID_IdleReload[1];
NU8 USBD_HID_IdleSet[USBD_HID_INREPORT_NUM];
XU8 USBD_HID_IdleSet[1];
NU8 USBD_HID_InReport[USBD_HID_INREPORT_MAX_SZ + 1];
XU8 USBD_HID_InReport[64 + 1];
NU8 USBD_HID_OutReport[USBD_HID_OUTREPORT_MAX_SZ + 1];
XU8 USBD_HID_OutReport[64 + 1];
NU8 USBD_HID_FeatReport[USBD_HID_FEATREPORT_MAX_SZ + 1];
XU8 USBD_HID_FeatReport[1 + 1];
N#endif
N
N#if    (USBD_MSC_ENABLE)
X#if    (1)
NU8 usbd_msc_if_num; //assigned during runtime init
Nconst U8 usbd_msc_ep_bulkin = USBD_MSC_EP_BULKIN;
Xconst U8 usbd_msc_ep_bulkin = 2;
Nconst U8 usbd_msc_ep_bulkout = USBD_MSC_EP_BULKOUT;
Xconst U8 usbd_msc_ep_bulkout = 2;
Nconst U16 usbd_msc_maxpacketsize[2] = {USBD_MSC_WMAXPACKETSIZE, USBD_MSC_HS_WMAXPACKETSIZE};
Xconst U16 usbd_msc_maxpacketsize[2] = {64, 512};
Nconst U8 *usbd_msc_inquiry_data = USBD_MSC_INQUIRY_DATA;
Xconst U8 *usbd_msc_inquiry_data = "MBED    " "VFS             " "0.1";
Nconst U16 USBD_MSC_BulkBufSize = USBD_MSC_MAX_PACKET;
Xconst U16 USBD_MSC_BulkBufSize = (64);
NU8 USBD_MSC_BulkBuf[USBD_MSC_MAX_PACKET];
XU8 USBD_MSC_BulkBuf[(64)];
N#endif
N
N#if    (USBD_ADC_ENABLE)
X#if    (0)
Sconst U8 usbd_adc_cif_num = USBD_ADC_CIF_NUM;
Sconst U8 usbd_adc_sif1_num = USBD_ADC_SIF1_NUM;
Sconst U8 usbd_adc_sif2_num = USBD_ADC_SIF2_NUM;
Sconst U8 usbd_adc_ep_isoout = USBD_ADC_EP_ISOOUT;
Sconst U32 usbd_adc_cfg_datafreq = USBD_ADC_TSAMFREQ;
Sconst U32 usbd_adc_cfg_p_s = USBD_ADC_CFG_P_S;
Sconst U32 usbd_adc_cfg_p_c = USBD_ADC_CFG_P_C;
Sconst U32 usbd_adc_cfg_b_s = (8 * USBD_ADC_CFG_P_C *USBD_ADC_CFG_P_S);
SS16  USBD_ADC_DataBuf[8 * USBD_ADC_CFG_P_C * USBD_ADC_CFG_P_S];
N#endif
N
N#ifndef USBD_CDC_ACM_ENABLE
S#if    (USBD_CDC_ENABLE == 1)
S#error "Please update usb_config.c file with new definitions for CDC, as new CDC is incompatible with the old one!"
S#else
S#define USBD_CDC_ACM_ENABLE  0
S#endif
N#endif
N
N#if    (USBD_CDC_ACM_ENABLE)
X#if    (1)
NU8 usbd_cdc_acm_cif_num = 0; //assigned during runtime init
NU8 usbd_cdc_acm_dif_num = 0; //assigned during runtime init
Nconst U8 usbd_cdc_acm_ep_intin = USBD_CDC_ACM_EP_INTIN;
Xconst U8 usbd_cdc_acm_ep_intin = 3;
Nconst U8 usbd_cdc_acm_ep_bulkin = USBD_CDC_ACM_EP_BULKIN;
Xconst U8 usbd_cdc_acm_ep_bulkin = 4;
Nconst U8 usbd_cdc_acm_ep_bulkout = USBD_CDC_ACM_EP_BULKOUT;
Xconst U8 usbd_cdc_acm_ep_bulkout = 4;
Nconst U16 usbd_cdc_acm_sendbuf_sz = USBD_CDC_ACM_SENDBUF_SIZE;
Xconst U16 usbd_cdc_acm_sendbuf_sz = 64;
Nconst U16 usbd_cdc_acm_receivebuf_sz = USBD_CDC_ACM_RECEIVEBUF_SIZE;
Xconst U16 usbd_cdc_acm_receivebuf_sz = 64;
Nconst U16 usbd_cdc_acm_maxpacketsize[2] = {USBD_CDC_ACM_WMAXPACKETSIZE, USBD_CDC_ACM_HS_WMAXPACKETSIZE};
Xconst U16 usbd_cdc_acm_maxpacketsize[2] = {16, 16};
Nconst U16 usbd_cdc_acm_maxpacketsize1[2] = {USBD_CDC_ACM_WMAXPACKETSIZE1, USBD_CDC_ACM_HS_WMAXPACKETSIZE1};
Xconst U16 usbd_cdc_acm_maxpacketsize1[2] = {16, 16};
NU8 USBD_CDC_ACM_SendBuf[USBD_CDC_ACM_SENDBUF_SIZE];
XU8 USBD_CDC_ACM_SendBuf[64];
NU8 USBD_CDC_ACM_ReceiveBuf[USBD_CDC_ACM_RECEIVEBUF_SIZE];
XU8 USBD_CDC_ACM_ReceiveBuf[64];
NU8 USBD_CDC_ACM_NotifyBuf[10];
N#endif
N
N#if    (USBD_WEBUSB_ENABLE)
X#if    (1)
NU8 usbd_webusb_if_num; //assigned during runtime init
Nconst U8 usbd_webusb_vendor_code = USBD_WEBUSB_VENDOR_CODE;
Xconst U8 usbd_webusb_vendor_code = 0x21;
N#else
Sconst U8 usbd_webusb_vendor_code;
N#endif
N
N#if    (USBD_WINUSB_ENABLE)
X#if    (1)
Nconst U8 usbd_winusb_vendor_code = USBD_WINUSB_VENDOR_CODE;
Xconst U8 usbd_winusb_vendor_code = 0x20;
N#else
Sconst U8 usbd_winusb_vendor_code;
N#endif
N
N#if    (USBD_BULK_ENABLE)
X#if    (1)
NU8 usbd_bulk_if_num  = 0; //assigned during runtime init
Nconst U8 usbd_bulk_ep_bulkin = USBD_BULK_EP_BULKIN;
Xconst U8 usbd_bulk_ep_bulkin = 1;
Nconst U8 usbd_bulk_ep_bulkout = USBD_BULK_EP_BULKOUT;
Xconst U8 usbd_bulk_ep_bulkout = 1;
Nconst U16 usbd_bulk_maxpacketsize[2] = {USBD_BULK_WMAXPACKETSIZE, USBD_BULK_HS_WMAXPACKETSIZE};
Xconst U16 usbd_bulk_maxpacketsize[2] = {64, 512};
Nconst U16 USBD_Bulk_BulkBufSize = USBD_BULK_MAX_PACKET;
Xconst U16 USBD_Bulk_BulkBufSize = (64);
NU8 USBD_Bulk_BulkInBuf[USBD_BULK_MAX_PACKET];
XU8 USBD_Bulk_BulkInBuf[(64)];
NU8 USBD_Bulk_BulkOutBuf[USBD_BULK_MAX_PACKET];
XU8 USBD_Bulk_BulkOutBuf[(64)];
N#endif
N
N/*------------------------------------------------------------------------------
N *      USB Device Override Event Handler Fuctions
N *----------------------------------------------------------------------------*/
N
N#if    (USBD_HID_ENABLE)
X#if    (1)
N#ifndef __RTX
Nvoid USBD_Configure_Event(void)
N{
N    USBD_HID_Configure_Event();
N}
N#endif
N#ifdef __RTX
S#if   ((USBD_HID_EP_INTOUT != 0) && (USBD_HID_EP_INTIN != USBD_HID_EP_INTOUT))
S#if    (USBD_HID_EP_INTIN == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_HID_EP_INTIN_Event
S#endif
S
S#if    (USBD_HID_EP_INTOUT == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_HID_EP_INTOUT_Event
S#endif
S#elif    (USBD_HID_EP_INTOUT != 0)
S#if    (USBD_HID_EP_INTIN == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_HID_EP_INT_Event
S#endif
S#else
S#if    (USBD_HID_EP_INTIN == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_HID_EP_INTIN_Event
S#endif
S#endif
N#else
N#if   (USBD_HID_EP_INTIN != USBD_HID_EP_INTOUT)
X#if   (0 != 0)
S#if    (USBD_HID_EP_INTIN == 1)
S#define USBD_EndPoint1                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 2)
S#define USBD_EndPoint2                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 3)
S#define USBD_EndPoint3                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 4)
S#define USBD_EndPoint4                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 5)
S#define USBD_EndPoint5                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 6)
S#define USBD_EndPoint6                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 7)
S#define USBD_EndPoint7                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 8)
S#define USBD_EndPoint8                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 9)
S#define USBD_EndPoint9                 USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 10)
S#define USBD_EndPoint10                USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 11)
S#define USBD_EndPoint11                USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 12)
S#define USBD_EndPoint12                USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 13)
S#define USBD_EndPoint13                USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 14)
S#define USBD_EndPoint14                USBD_HID_EP_INTIN_Event
S#elif  (USBD_HID_EP_INTIN == 15)
S#define USBD_EndPoint15                USBD_HID_EP_INTIN_Event
S#endif
S
S#if    (USBD_HID_EP_INTOUT == 1)
S#define USBD_EndPoint1                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 2)
S#define USBD_EndPoint2                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 3)
S#define USBD_EndPoint3                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 4)
S#define USBD_EndPoint4                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 5)
S#define USBD_EndPoint5                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 6)
S#define USBD_EndPoint6                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 7)
S#define USBD_EndPoint7                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 8)
S#define USBD_EndPoint8                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 9)
S#define USBD_EndPoint9                 USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 10)
S#define USBD_EndPoint10                USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 11)
S#define USBD_EndPoint11                USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 12)
S#define USBD_EndPoint12                USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 13)
S#define USBD_EndPoint13                USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 14)
S#define USBD_EndPoint14                USBD_HID_EP_INTOUT_Event
S#elif  (USBD_HID_EP_INTOUT == 15)
S#define USBD_EndPoint15                USBD_HID_EP_INTOUT_Event
S#endif
S
N#else
N
N#if    (USBD_HID_EP_INTIN == 1)
X#if    (0 == 1)
S#define USBD_EndPoint1                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 2)
X#elif  (0 == 2)
S#define USBD_EndPoint2                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 3)
X#elif  (0 == 3)
S#define USBD_EndPoint3                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 4)
X#elif  (0 == 4)
S#define USBD_EndPoint4                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 5)
X#elif  (0 == 5)
S#define USBD_EndPoint5                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 6)
X#elif  (0 == 6)
S#define USBD_EndPoint6                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 7)
X#elif  (0 == 7)
S#define USBD_EndPoint7                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 8)
X#elif  (0 == 8)
S#define USBD_EndPoint8                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 9)
X#elif  (0 == 9)
S#define USBD_EndPoint9                 USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 10)
X#elif  (0 == 10)
S#define USBD_EndPoint10                USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 11)
X#elif  (0 == 11)
S#define USBD_EndPoint11                USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 12)
X#elif  (0 == 12)
S#define USBD_EndPoint12                USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 13)
X#elif  (0 == 13)
S#define USBD_EndPoint13                USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 14)
X#elif  (0 == 14)
S#define USBD_EndPoint14                USBD_HID_EP_INT_Event
S#elif  (USBD_HID_EP_INTIN == 15)
X#elif  (0 == 15)
S#define USBD_EndPoint15                USBD_HID_EP_INT_Event
N#endif
N
N#endif /* (USBD_HID_EP_INTIN != USBD_HID_EP_INTOUT) */
N
N#endif /*#ifdef __RTX*/
N#else
SBOOL USBD_ReqGetDescriptor_HID(U8 **pD, U32 *len)
S{
S    return (__FALSE);
S}
SBOOL USBD_EndPoint0_Setup_HID_ReqToIF(void)
S{
S    return (__FALSE);
S}
SBOOL USBD_EndPoint0_Out_HID_ReqToIF(void)
S{
S    return (__FALSE);
S}
N#endif  /* (USBD_HID_ENABLE) */
N
N#if    (USBD_MSC_ENABLE)
X#if    (1)
N#ifdef __RTX
S#if    (USBD_MSC_EP_BULKIN != USBD_MSC_EP_BULKOUT)
S#if    (USBD_MSC_EP_BULKIN == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_MSC_EP_BULKIN_Event
S#endif
S
S#if    (USBD_MSC_EP_BULKOUT == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_MSC_EP_BULKOUT_Event
S#endif
S#else
S#if    (USBD_MSC_EP_BULKIN == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_MSC_EP_BULK_Event
S#endif
S#endif
N#else
N#if    (USBD_MSC_EP_BULKIN != USBD_MSC_EP_BULKOUT)
X#if    (2 != 2)
S#if    (USBD_MSC_EP_BULKIN == 1)
S#define USBD_EndPoint1                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 2)
S#define USBD_EndPoint2                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 3)
S#define USBD_EndPoint3                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 4)
S#define USBD_EndPoint4                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 5)
S#define USBD_EndPoint5                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 6)
S#define USBD_EndPoint6                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 7)
S#define USBD_EndPoint7                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 8)
S#define USBD_EndPoint8                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 9)
S#define USBD_EndPoint9                 USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 10)
S#define USBD_EndPoint10                USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 11)
S#define USBD_EndPoint11                USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 12)
S#define USBD_EndPoint12                USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 13)
S#define USBD_EndPoint13                USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 14)
S#define USBD_EndPoint14                USBD_MSC_EP_BULKIN_Event
S#elif  (USBD_MSC_EP_BULKIN == 15)
S#define USBD_EndPoint15                USBD_MSC_EP_BULKIN_Event
S#endif
S
S#if    (USBD_MSC_EP_BULKOUT == 1)
S#define USBD_EndPoint1                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 2)
S#define USBD_EndPoint2                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 3)
S#define USBD_EndPoint3                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 4)
S#define USBD_EndPoint4                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 5)
S#define USBD_EndPoint5                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 6)
S#define USBD_EndPoint6                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 7)
S#define USBD_EndPoint7                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 8)
S#define USBD_EndPoint8                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 9)
S#define USBD_EndPoint9                 USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 10)
S#define USBD_EndPoint10                USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 11)
S#define USBD_EndPoint11                USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 12)
S#define USBD_EndPoint12                USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 13)
S#define USBD_EndPoint13                USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 14)
S#define USBD_EndPoint14                USBD_MSC_EP_BULKOUT_Event
S#elif  (USBD_MSC_EP_BULKOUT == 15)
S#define USBD_EndPoint15                USBD_MSC_EP_BULKOUT_Event
S#endif
N#else
N#if    (USBD_MSC_EP_BULKIN == 1)
X#if    (2 == 1)
S#define USBD_EndPoint1                 USBD_MSC_EP_BULK_Event
N#elif  (USBD_MSC_EP_BULKIN == 2)
X#elif  (2 == 2)
N#define USBD_EndPoint2                 USBD_MSC_EP_BULK_Event
N#elif  (USBD_MSC_EP_BULKIN == 3)
X#elif  (2 == 3)
S#define USBD_EndPoint3                 USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 4)
S#define USBD_EndPoint4                 USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 5)
S#define USBD_EndPoint5                 USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 6)
S#define USBD_EndPoint6                 USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 7)
S#define USBD_EndPoint7                 USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 8)
S#define USBD_EndPoint8                 USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 9)
S#define USBD_EndPoint9                 USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 10)
S#define USBD_EndPoint10                USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 11)
S#define USBD_EndPoint11                USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 12)
S#define USBD_EndPoint12                USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 13)
S#define USBD_EndPoint13                USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 14)
S#define USBD_EndPoint14                USBD_MSC_EP_BULK_Event
S#elif  (USBD_MSC_EP_BULKIN == 15)
S#define USBD_EndPoint15                USBD_MSC_EP_BULK_Event
N#endif
N#endif
N#endif
N#else
Svoid USBD_ReqClrFeature_MSC(U32 EPNum)
S{
S
S}
SBOOL USBD_EndPoint0_Setup_MSC_ReqToIF(void)
S{
S    return (__FALSE);
S}
SBOOL USBD_EndPoint0_Out_MSC_ReqToIF(void)
S{
S    return (__FALSE);
S}
N#endif  /* (USBD_MSC_ENABLE) */
N
N#if    (USBD_ADC_ENABLE == 0)
X#if    (0 == 0)
NBOOL USBD_EndPoint0_Setup_ADC_ReqToIF(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Setup_ADC_ReqToEP(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Out_ADC_ReqToIF(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Out_ADC_ReqToEP(void)
N{
N    return (__FALSE);
X    return (0);
N}
N#endif  /* (USBD_ADC_ENABLE) */
N
N#if    (USBD_CDC_ACM_ENABLE)
X#if    (1)
N#ifdef __RTX
S#if    (USBD_CDC_ACM_EP_INTIN == 1)
S#define USBD_RTX_EndPoint1               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 2)
S#define USBD_RTX_EndPoint2               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 3)
S#define USBD_RTX_EndPoint3               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 4)
S#define USBD_RTX_EndPoint4               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 5)
S#define USBD_RTX_EndPoint5               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 6)
S#define USBD_RTX_EndPoint6               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 7)
S#define USBD_RTX_EndPoint7               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 8)
S#define USBD_RTX_EndPoint8               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 9)
S#define USBD_RTX_EndPoint9               USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 10)
S#define USBD_RTX_EndPoint10              USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 11)
S#define USBD_RTX_EndPoint11              USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 12)
S#define USBD_RTX_EndPoint12              USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 13)
S#define USBD_RTX_EndPoint13              USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 14)
S#define USBD_RTX_EndPoint14              USBD_RTX_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 15)
S#define USBD_RTX_EndPoint15              USBD_RTX_CDC_ACM_EP_INTIN_Event
S#endif
N#else
N#if    (USBD_CDC_ACM_EP_INTIN == 1)
X#if    (3 == 1)
S#define USBD_EndPoint1                   USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 2)
X#elif  (3 == 2)
S#define USBD_EndPoint2                   USBD_CDC_ACM_EP_INTIN_Event
N#elif  (USBD_CDC_ACM_EP_INTIN == 3)
X#elif  (3 == 3)
N#define USBD_EndPoint3                   USBD_CDC_ACM_EP_INTIN_Event
N#elif  (USBD_CDC_ACM_EP_INTIN == 4)
X#elif  (3 == 4)
S#define USBD_EndPoint4                   USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 5)
S#define USBD_EndPoint5                   USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 6)
S#define USBD_EndPoint6                   USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 7)
S#define USBD_EndPoint7                   USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 8)
S#define USBD_EndPoint8                   USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 9)
S#define USBD_EndPoint9                   USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 10)
S#define USBD_EndPoint10                  USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 11)
S#define USBD_EndPoint11                  USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 12)
S#define USBD_EndPoint12                  USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 13)
S#define USBD_EndPoint13                  USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 14)
S#define USBD_EndPoint14                  USBD_CDC_ACM_EP_INTIN_Event
S#elif  (USBD_CDC_ACM_EP_INTIN == 15)
S#define USBD_EndPoint15                  USBD_CDC_ACM_EP_INTIN_Event
N#endif
N#endif
N
N#ifdef __RTX
S#if    (USBD_CDC_ACM_EP_BULKIN != USBD_CDC_ACM_EP_BULKOUT)
S#if    (USBD_CDC_ACM_EP_BULKIN == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_CDC_ACM_EP_BULKIN_Event
S#endif
S
S#if    (USBD_CDC_ACM_EP_BULKOUT == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_CDC_ACM_EP_BULKOUT_Event
S#endif
S#else
S#if    (USBD_CDC_ACM_EP_BULKIN == 1)
S#define USBD_RTX_EndPoint1             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 2)
S#define USBD_RTX_EndPoint2             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 3)
S#define USBD_RTX_EndPoint3             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 4)
S#define USBD_RTX_EndPoint4             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 5)
S#define USBD_RTX_EndPoint5             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 6)
S#define USBD_RTX_EndPoint6             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 7)
S#define USBD_RTX_EndPoint7             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 8)
S#define USBD_RTX_EndPoint8             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 9)
S#define USBD_RTX_EndPoint9             USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 10)
S#define USBD_RTX_EndPoint10            USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 11)
S#define USBD_RTX_EndPoint11            USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 12)
S#define USBD_RTX_EndPoint12            USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 13)
S#define USBD_RTX_EndPoint13            USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 14)
S#define USBD_RTX_EndPoint14            USBD_RTX_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 15)
S#define USBD_RTX_EndPoint15            USBD_RTX_CDC_ACM_EP_BULK_Event
S#endif
S#endif
N#else
N#if    (USBD_CDC_ACM_EP_BULKIN != USBD_CDC_ACM_EP_BULKOUT)
X#if    (4 != 4)
S#if    (USBD_CDC_ACM_EP_BULKIN == 1)
S#define USBD_EndPoint1                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 2)
S#define USBD_EndPoint2                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 3)
S#define USBD_EndPoint3                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 4)
S#define USBD_EndPoint4                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 5)
S#define USBD_EndPoint5                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 6)
S#define USBD_EndPoint6                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 7)
S#define USBD_EndPoint7                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 8)
S#define USBD_EndPoint8                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 9)
S#define USBD_EndPoint9                 USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 10)
S#define USBD_EndPoint10                USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 11)
S#define USBD_EndPoint11                USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 12)
S#define USBD_EndPoint12                USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 13)
S#define USBD_EndPoint13                USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 14)
S#define USBD_EndPoint14                USBD_CDC_ACM_EP_BULKIN_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 15)
S#define USBD_EndPoint15                USBD_CDC_ACM_EP_BULKIN_Event
S#endif
S
S#if    (USBD_CDC_ACM_EP_BULKOUT == 1)
S#define USBD_EndPoint1                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 2)
S#define USBD_EndPoint2                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 3)
S#define USBD_EndPoint3                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 4)
S#define USBD_EndPoint4                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 5)
S#define USBD_EndPoint5                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 6)
S#define USBD_EndPoint6                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 7)
S#define USBD_EndPoint7                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 8)
S#define USBD_EndPoint8                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 9)
S#define USBD_EndPoint9                 USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 10)
S#define USBD_EndPoint10                USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 11)
S#define USBD_EndPoint11                USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 12)
S#define USBD_EndPoint12                USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 13)
S#define USBD_EndPoint13                USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 14)
S#define USBD_EndPoint14                USBD_CDC_ACM_EP_BULKOUT_Event
S#elif  (USBD_CDC_ACM_EP_BULKOUT == 15)
S#define USBD_EndPoint15                USBD_CDC_ACM_EP_BULKOUT_Event
S#endif
N#else
N#if    (USBD_CDC_ACM_EP_BULKIN == 1)
X#if    (4 == 1)
S#define USBD_EndPoint1                 USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 2)
X#elif  (4 == 2)
S#define USBD_EndPoint2                 USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 3)
X#elif  (4 == 3)
S#define USBD_EndPoint3                 USBD_CDC_ACM_EP_BULK_Event
N#elif  (USBD_CDC_ACM_EP_BULKIN == 4)
X#elif  (4 == 4)
N#define USBD_EndPoint4                 USBD_CDC_ACM_EP_BULK_Event
N#elif  (USBD_CDC_ACM_EP_BULKIN == 5)
X#elif  (4 == 5)
S#define USBD_EndPoint5                 USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 6)
S#define USBD_EndPoint6                 USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 7)
S#define USBD_EndPoint7                 USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 8)
S#define USBD_EndPoint8                 USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 9)
S#define USBD_EndPoint9                 USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 10)
S#define USBD_EndPoint10                USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 11)
S#define USBD_EndPoint11                USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 12)
S#define USBD_EndPoint12                USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 13)
S#define USBD_EndPoint13                USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 14)
S#define USBD_EndPoint14                USBD_CDC_ACM_EP_BULK_Event
S#elif  (USBD_CDC_ACM_EP_BULKIN == 15)
S#define USBD_EndPoint15                USBD_CDC_ACM_EP_BULK_Event
N#endif
N#endif
N#endif
N#else
SBOOL USBD_EndPoint0_Setup_CDC_ReqToIF(void)
S{
S    return (__FALSE);
S}
SBOOL USBD_EndPoint0_Out_CDC_ReqToIF(void)
S{
S    return (__FALSE);
S}
N#endif  /* (USBD_CDC_ACM_ENABLE) */
N
N#if    (USBD_BULK_ENABLE)
X#if    (1)
N
N#if    (USBD_BULK_EP_BULKIN != USBD_BULK_EP_BULKOUT)
X#if    (1 != 1)
S
S#if    (USBD_BULK_EP_BULKIN == 1)
S#define USBD_EndPoint1                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 2)
S#define USBD_EndPoint2                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 3)
S#define USBD_EndPoint3                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 4)
S#define USBD_EndPoint4                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 5)
S#define USBD_EndPoint5                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 6)
S#define USBD_EndPoint6                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 7)
S#define USBD_EndPoint7                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 8)
S#define USBD_EndPoint8                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 9)
S#define USBD_EndPoint9                 USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 10)
S#define USBD_EndPoint10                USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 11)
S#define USBD_EndPoint11                USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 12)
S#define USBD_EndPoint12                USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 13)
S#define USBD_EndPoint13                USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 14)
S#define USBD_EndPoint14                USBD_BULK_EP_BULKIN_Event
S#elif  (USBD_BULK_EP_BULKIN == 15)
S#define USBD_EndPoint15                USBD_BULK_EP_BULKIN_Event
S#endif
S
S#if    (USBD_BULK_EP_BULKOUT == 1)
S#define USBD_EndPoint1                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 2)
S#define USBD_EndPoint2                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 3)
S#define USBD_EndPoint3                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 4)
S#define USBD_EndPoint4                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 5)
S#define USBD_EndPoint5                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 6)
S#define USBD_EndPoint6                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 7)
S#define USBD_EndPoint7                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 8)
S#define USBD_EndPoint8                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 9)
S#define USBD_EndPoint9                 USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 10)
S#define USBD_EndPoint10                USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 11)
S#define USBD_EndPoint11                USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 12)
S#define USBD_EndPoint12                USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 13)
S#define USBD_EndPoint13                USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 14)
S#define USBD_EndPoint14                USBD_BULK_EP_BULKOUT_Event
S#elif  (USBD_BULK_EP_BULKOUT == 15)
S#define USBD_EndPoint15                USBD_BULK_EP_BULKOUT_Event
S#endif
S
N#else
N#if    (USBD_BULK_EP_BULKIN == 1)
X#if    (1 == 1)
N#define USBD_EndPoint1                 USBD_BULK_EP_BULK_Event
N#elif  (USBD_BULK_EP_BULKIN == 2)
X#elif  (1 == 2)
S#define USBD_EndPoint2                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 3)
S#define USBD_EndPoint3                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 4)
S#define USBD_EndPoint4                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 5)
S#define USBD_EndPoint5                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 6)
S#define USBD_EndPoint6                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 7)
S#define USBD_EndPoint7                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 8)
S#define USBD_EndPoint8                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 9)
S#define USBD_EndPoint9                 USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 10)
S#define USBD_EndPoint10                USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 11)
S#define USBD_EndPoint11                USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 12)
S#define USBD_EndPoint12                USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 13)
S#define USBD_EndPoint13                USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 14)
S#define USBD_EndPoint14                USBD_BULK_EP_BULK_Event
S#elif  (USBD_BULK_EP_BULKIN == 15)
S#define USBD_EndPoint15                USBD_BULK_EP_BULK_Event
N#endif
N#endif
N
N#endif  /* (USBD_BULK_ENABLE) */
N
N#if    (USBD_CLS_ENABLE)
X#if    (0)
N#else
NBOOL USBD_EndPoint0_Setup_CLS_ReqToDEV(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Setup_CLS_ReqToIF(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Setup_CLS_ReqToEP(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Out_CLS_ReqToDEV(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Out_CLS_ReqToIF(void)
N{
N    return (__FALSE);
X    return (0);
N}
NBOOL USBD_EndPoint0_Out_CLS_ReqToEP(void)
N{
N    return (__FALSE);
X    return (0);
N}
N#endif  /* (USBD_CLS_ENABLE) */
N
N#if   ((USBD_CDC_ACM_ENABLE))
X#if   ((1))
N#ifndef __RTX
Nvoid USBD_Reset_Event(void)
N{
N#if    (USBD_CDC_ACM_ENABLE)
X#if    (1)
N    USBD_CDC_ACM_Reset_Event();
N#endif
N#if    (USBD_MSC_ENABLE)
X#if    (1)
N    USBD_MSC_Reset_Event();
N#endif    
N}
N#endif
N#endif  /* ((USBD_CDC_ACM_ENABLE)) */
N
N#if   ((USBD_HID_ENABLE) || (USBD_ADC_ENABLE) || (USBD_CDC_ACM_ENABLE) || (USBD_CLS_ENABLE))
X#if   ((1) || (0) || (1) || (0))
N#ifndef __RTX
Nvoid USBD_SOF_Event(void)
N{
N#if    (USBD_HID_ENABLE)
X#if    (1)
N    USBD_HID_SOF_Event();
N#endif
N#if    (USBD_ADC_ENABLE)
X#if    (0)
S    USBD_ADC_SOF_Event();
N#endif
N#if    (USBD_CDC_ACM_ENABLE)
X#if    (1)
N    USBD_CDC_ACM_SOF_Event();
N#endif
N#if    (USBD_CLS_ENABLE)
X#if    (0)
S    USBD_CLS_SOF_Event();
N#endif
N}
N#endif
N#endif  /* ((USBD_HID_ENABLE) || (USBD_ADC_ENABLE) || (USBD_CDC_ACM_ENABLE) || (USBD_CLS_ENABLE)) */
N
N/* USB Device - Device Events Callback Functions */
N__weak void USBD_Power_Event(BOOL power);
N__weak void USBD_Reset_Event(void);
N__weak void USBD_Suspend_Event(void);
N__weak void USBD_Resume_Event(void);
N__weak void USBD_WakeUp_Event(void);
N__weak void USBD_SOF_Event(void);
N__weak void USBD_Error_Event(U32 error);
N
N/* USB Device - Device Events Callback Pointers */
Nvoid (* const USBD_P_Power_Event)(BOOL power) = USBD_Power_Event;
Nvoid (* const USBD_P_Reset_Event)(void) = USBD_Reset_Event;
Nvoid (* const USBD_P_Suspend_Event)(void) = USBD_Suspend_Event;
Nvoid (* const USBD_P_Resume_Event)(void) = USBD_Resume_Event;
Nvoid (* const USBD_P_WakeUp_Event)(void) = USBD_WakeUp_Event;
Nvoid (* const USBD_P_SOF_Event)(void) = USBD_SOF_Event;
Nvoid (* const USBD_P_Error_Event)(U32 error) = USBD_Error_Event;
N
N/* USB Device - Endpoint Events Callback Functions */
Nextern void USBD_EndPoint0(U32 event);
N#ifndef       USBD_EndPoint1
S__weak void USBD_EndPoint1(U32 event);
N#endif
N#ifndef       USBD_EndPoint2
S__weak void USBD_EndPoint2(U32 event);
N#endif
N#ifndef       USBD_EndPoint3
S__weak void USBD_EndPoint3(U32 event);
N#endif
N#ifndef       USBD_EndPoint4
S__weak void USBD_EndPoint4(U32 event);
N#endif
N#ifndef       USBD_EndPoint5
N__weak void USBD_EndPoint5(U32 event);
N#endif
N#ifndef       USBD_EndPoint6
N__weak void USBD_EndPoint6(U32 event);
N#endif
N#ifndef       USBD_EndPoint7
N__weak void USBD_EndPoint7(U32 event);
N#endif
N#ifndef       USBD_EndPoint8
N__weak void USBD_EndPoint8(U32 event);
N#endif
N#ifndef       USBD_EndPoint9
N__weak void USBD_EndPoint9(U32 event);
N#endif
N#ifndef       USBD_EndPoint10
N__weak void USBD_EndPoint10(U32 event);
N#endif
N#ifndef       USBD_EndPoint11
N__weak void USBD_EndPoint11(U32 event);
N#endif
N#ifndef       USBD_EndPoint12
N__weak void USBD_EndPoint12(U32 event);
N#endif
N#ifndef       USBD_EndPoint13
N__weak void USBD_EndPoint13(U32 event);
N#endif
N#ifndef       USBD_EndPoint14
N__weak void USBD_EndPoint14(U32 event);
N#endif
N#ifndef       USBD_EndPoint15
N__weak void USBD_EndPoint15(U32 event);
N#endif
N
N/* USB Device - Endpoint Events Callback Pointers */
Nvoid (* const USBD_P_EP[16])(U32 event) = {
N    USBD_EndPoint0,
N    USBD_EndPoint1,
X    USBD_BULK_EP_BULK_Event,
N    USBD_EndPoint2,
X    USBD_MSC_EP_BULK_Event,
N    USBD_EndPoint3,
X    USBD_CDC_ACM_EP_INTIN_Event,
N    USBD_EndPoint4,
X    USBD_CDC_ACM_EP_BULK_Event,
N    USBD_EndPoint5,
N    USBD_EndPoint6,
N    USBD_EndPoint7,
N    USBD_EndPoint8,
N    USBD_EndPoint9,
N    USBD_EndPoint10,
N    USBD_EndPoint11,
N    USBD_EndPoint12,
N    USBD_EndPoint13,
N    USBD_EndPoint14,
N    USBD_EndPoint15
N};
N
N/* USB Device - Core Events Callback Functions */
N__weak void USBD_Configure_Event(void);
N__weak void USBD_Interface_Event(void);
N__weak void USBD_Feature_Event(void);
N
N/* USB Device - Core Events Callback Pointers */
Nvoid (* const USBD_P_Configure_Event)(void) = USBD_Configure_Event;
Nvoid (* const USBD_P_Interface_Event)(void) = USBD_Interface_Event;
Nvoid (* const USBD_P_Feature_Event)(void) = USBD_Feature_Event;
N
N#ifdef __RTX
Sconst BOOL __rtx = __TRUE;
S
S#if   ((USBD_HID_ENABLE) || (USBD_ADC_ENABLE) || (USBD_CDC_ACM_ENABLE) || (USBD_CLS_ENABLE))
S__weak void USBD_RTX_Device(void)
S{
S    U16 evt;
S
S    for (;;) {
S        os_evt_wait_or(0xFFFF, 0xFFFF);         /* Wait for an Event */
S        evt = os_evt_get();                     /* Get Event Flags */
S
S        if (evt & USBD_EVT_RESET) {
S#if (USBD_CDC_ACM_ENABLE)
S            USBD_CDC_ACM_Reset_Event();
S#endif
S#if (USBD_MSC_ENABLE)
S            USBD_MSC_Reset_Event();
S#endif    
S        }
S
S        if (evt & USBD_EVT_SOF) {
S#if (USBD_HID_ENABLE)
S            USBD_HID_SOF_Event();
S#endif
S#if (USBD_ADC_ENABLE)
S            USBD_ADC_SOF_Event();
S#endif
S#if (USBD_CDC_ACM_ENABLE)
S            USBD_CDC_ACM_SOF_Event();
S#endif
S#if (USBD_CLS_ENABLE)
S            USBD_CLS_SOF_Event();
S#endif
S        }
S    }
S}
S#else
S__weak void USBD_RTX_Device(void);
S#endif
S
S/* USB Device - Device Events Callback Pointer */
Svoid (* const USBD_RTX_P_Device)(void) = USBD_RTX_Device;
S
S/* USB Device Endpoint Events Callback Functions */
Sextern void USBD_RTX_EndPoint0(void);
S#ifndef       USBD_RTX_EndPoint1
S__weak void USBD_RTX_EndPoint1(void);
S#endif
S#ifndef       USBD_RTX_EndPoint2
S__weak void USBD_RTX_EndPoint2(void);
S#endif
S#ifndef       USBD_RTX_EndPoint3
S__weak void USBD_RTX_EndPoint3(void);
S#endif
S#ifndef       USBD_RTX_EndPoint4
S__weak void USBD_RTX_EndPoint4(void);
S#endif
S#ifndef       USBD_RTX_EndPoint5
S__weak void USBD_RTX_EndPoint5(void);
S#endif
S#ifndef       USBD_RTX_EndPoint6
S__weak void USBD_RTX_EndPoint6(void);
S#endif
S#ifndef       USBD_RTX_EndPoint7
S__weak void USBD_RTX_EndPoint7(void);
S#endif
S#ifndef       USBD_RTX_EndPoint8
S__weak void USBD_RTX_EndPoint8(void);
S#endif
S#ifndef       USBD_RTX_EndPoint9
S__weak void USBD_RTX_EndPoint9(void);
S#endif
S#ifndef       USBD_RTX_EndPoint10
S__weak void USBD_RTX_EndPoint10(void);
S#endif
S#ifndef       USBD_RTX_EndPoint11
S__weak void USBD_RTX_EndPoint11(void);
S#endif
S#ifndef       USBD_RTX_EndPoint12
S__weak void USBD_RTX_EndPoint12(void);
S#endif
S#ifndef       USBD_RTX_EndPoint13
S__weak void USBD_RTX_EndPoint13(void);
S#endif
S#ifndef       USBD_RTX_EndPoint14
S__weak void USBD_RTX_EndPoint14(void);
S#endif
S#ifndef       USBD_RTX_EndPoint15
S__weak void USBD_RTX_EndPoint15(void);
S#endif
S
S#if    (USBD_HID_ENABLE)
S__weak void USBD_RTX_Core(void)
S{
S    U16 evt;
S
S    for (;;) {
S        os_evt_wait_or(0xFFFF, 0xFFFF);         /* Wait for an Event */
S        evt = os_evt_get();                     /* Get Event Flags */
S
S        if (evt & USBD_EVT_SET_CFG) {
S            USBD_HID_Configure_Event();
S        }
S    }
S}
S#else
S__weak void USBD_RTX_Core(void);
S#endif
S
S/* USB Device - Core Events Callback Pointer */
Svoid (* const USBD_RTX_P_Core)(void)  = USBD_RTX_Core;
S
S/* USB Device Endpoint Events Callback Pointers */
Svoid (* const USBD_RTX_P_EP[16])(void) = {
S    USBD_RTX_EndPoint0,
S    USBD_RTX_EndPoint1,
S    USBD_RTX_EndPoint2,
S    USBD_RTX_EndPoint3,
S    USBD_RTX_EndPoint4,
S    USBD_RTX_EndPoint5,
S    USBD_RTX_EndPoint6,
S    USBD_RTX_EndPoint7,
S    USBD_RTX_EndPoint8,
S    USBD_RTX_EndPoint9,
S    USBD_RTX_EndPoint10,
S    USBD_RTX_EndPoint11,
S    USBD_RTX_EndPoint12,
S    USBD_RTX_EndPoint13,
S    USBD_RTX_EndPoint14,
S    USBD_RTX_EndPoint15,
S};
S
Svoid usbd_os_evt_set(U16 event_flags, U32 task)
S{
S    if (task) {
S        os_evt_set(event_flags, task);
S    }
S}
SU16  usbd_os_evt_get(void)
S{
S    return (os_evt_get());
S}
SU32  usbd_os_evt_wait_or(U16 wait_flags, U16 timeout)
S{
S    return (os_evt_wait_or(wait_flags, timeout));
S}
S
N#else
Nconst BOOL __rtx = __FALSE;
Xconst BOOL __rtx = 0;
N
Nvoid usbd_os_evt_set(U16 event_flags, U32 task)
N{
N    
N}
NU16  usbd_os_evt_get(void)
N{
N    return (0);
N}
NU32  usbd_os_evt_wait_or(U16 wait_flags, U16 timeout)
N{
N    return (0);
N}
N#endif
N
N#ifdef __RTX
S
Stypedef struct {
S    void *stack;
S    U16 size;
S} user_stack_t;
S
S#if USBD_ENABLE && !defined(USBD_RTX_CORE_STACK)
S#error "USB core stack must be defined"
S#endif
S#if USBD_ENABLE && !defined(USBD_RTX_DEVICE_STACK)
S#error "USB device stack must be defined"
S#endif
S#if USBD_ENABLE && !defined(USBD_RTX_ENDPOINT0_STACK)
S#error "USB endpoint 0 must be defined"
S#endif
S
S#if !defined(USBD_HID_EP_INTIN_STACK)
S#define USBD_HID_EP_INTIN_STACK 0
S#endif
S#if !defined(USBD_HID_EP_INTOUT_STACK)
S#define USBD_HID_EP_INTOUT_STACK 0
S#endif
S#if !defined(USBD_MSC_EP_BULKIN_STACK)
S#define USBD_MSC_EP_BULKIN_STACK 0
S#endif
S#if !defined(USBD_MSC_EP_BULKOUT_STACK)
S#define USBD_MSC_EP_BULKOUT_STACK 0
S#endif
S#if !defined(USBD_ADC_EP_ISOOUT_STACK)
S#define USBD_ADC_EP_ISOOUT_STACK 0
S#endif
S#if !defined(USBD_CDC_ACM_EP_INTIN_STACK)
S#define USBD_CDC_ACM_EP_INTIN_STACK 0
S#endif
S#if !defined(USBD_CDC_ACM_EP_BULKIN_STACK)
S#define USBD_CDC_ACM_EP_BULKIN_STACK 0
S#endif
S#if !defined(USBD_CDC_ACM_EP_BULKOUT_STACK)
S#define USBD_CDC_ACM_EP_BULKOUT_STACK 0
S#endif
S
S#if USBD_HID_EP_INTIN == 0 && USBD_HID_EP_INTIN_STACK > 0
S#error "USBD_HID_EP_INTIN stack unused - must be 0"
S#endif
S#if USBD_HID_EP_INTOUT == 0 && USBD_HID_EP_INTOUT_STACK > 0
S#error "USBD_HID_EP_INTOUT stack unused - must be 0"
S#endif
S#if USBD_MSC_EP_BULKIN == 0 && USBD_MSC_EP_BULKIN_STACK > 0
S#error "USBD_MSC_EP_BULKIN stack unused - must be 0"
S#endif
S#if USBD_MSC_EP_BULKOUT == 0 && USBD_MSC_EP_BULKOUT_STACK > 0
S#error "USBD_MSC_EP_BULKOUT stack unused - must be 0"
S#endif
S#if USBD_ADC_EP_ISOOUT == 0 && USBD_ADC_EP_ISOOUT_STACK > 0
S#error "USBD_ADC_EP_ISOOUT stack unused - must be 0"
S#endif
S#if USBD_CDC_ACM_EP_INTIN == 0 && USBD_CDC_ACM_EP_INTIN_STACK > 0
S#error "USBD_CDC_ACM_EP_INTIN stack unused - must be 0"
S#endif
S#if USBD_CDC_ACM_EP_BULKIN == 0 && USBD_CDC_ACM_EP_BULKIN_STACK > 0
S#error "USBD_CDC_ACM_EP_BULKIN stack unused - must be 0"
S#endif
S#if USBD_CDC_ACM_EP_BULKOUT == 0 && USBD_CDC_ACM_EP_BULKOUT_STACK > 0
S#error "USBD_CDC_ACM_EP_BULKOUT stack unused - must be 0"
S#endif
S
S#if USBD_ENABLE
Sstatic U64 usbd_core_stack[USBD_RTX_CORE_STACK / 8];
Sstatic U64 usbd_device_stack[USBD_RTX_DEVICE_STACK / 8];
Sstatic U64 usbd_endpoint0_stack[USBD_RTX_ENDPOINT0_STACK / 8];
S#endif
S
S#if (USBD_HID_EP_INTIN_STACK > 0)
Sstatic U64 usbd_hid_ep_intin_stack[USBD_HID_EP_INTIN_STACK / 8];
S#endif
S#if (USBD_HID_EP_INTOUT_STACK > 0)
Sstatic U64 usbd_hid_ep_intout_stack[USBD_HID_EP_INTOUT_STACK / 8];
S#endif
S#if (USBD_MSC_EP_BULKIN_STACK > 0)
Sstatic U64 usbd_msc_ep_bulkin_stack[USBD_MSC_EP_BULKIN_STACK / 8];
S#endif
S#if (USBD_MSC_EP_BULKOUT_STACK > 0)
Sstatic U64 usbd_msc_ep_bulkout_stack[USBD_MSC_EP_BULKOUT_STACK / 8];
S#endif
S#if (USBD_ADC_EP_ISOOUT_STACK > 0)
Sstatic U64 usbd_adc_ep_isoout_stack[USBD_ADC_EP_ISOOUT_STACK / 8];
S#endif
S#if (USBD_CDC_ACM_EP_INTIN_STACK > 0)
Sstatic U64 usbd_cdc_acm_ep_intin_stack[USBD_CDC_ACM_EP_INTIN_STACK / 8];
S#endif
S#if (USBD_CDC_ACM_EP_BULKIN_STACK > 0)
Sstatic U64 usbd_cdc_acm_ep_bulkin_stack[USBD_CDC_ACM_EP_BULKIN_STACK / 8];
S#endif
S#if (USBD_CDC_ACM_EP_BULKOUT_STACK > 0)
Sstatic U64 usbd_cdc_acm_ep_bulkout_stack[USBD_CDC_ACM_EP_BULKOUT_STACK / 8];
S#endif
S
S// Check HID
S#if (USBD_HID_ENABLE && !USBD_HID_EP_INTIN_STACK && USBD_HID_EP_INTIN != USBD_HID_EP_INTOUT)
S#error "USBD_HID_EP_INTIN_STACK must be defined"
S#endif
S#if (USBD_HID_ENABLE && !USBD_HID_EP_INTOUT_STACK && USBD_HID_EP_INTIN != USBD_HID_EP_INTOUT && USBD_HID_EP_INTOUT != 0)
S#error "USBD_HID_EP_INTOUT_STACK must be defined"
S#endif
S#if (USBD_HID_ENABLE && USBD_HID_EP_INTIN_STACK == 0 && USBD_HID_EP_INTOUT_STACK == 0)
S#error "HID stack must be defined"
S#endif
S#if (USBD_HID_EP_INTIN_STACK > 0 && USBD_HID_EP_INTOUT_STACK > 0 && USBD_HID_EP_INTIN == USBD_HID_EP_INTOUT)
S#error "Multiple HID stacks defined for same EP"
S#endif
S
S// Check MSC
S#if (USBD_MSC_ENABLE && !USBD_MSC_EP_BULKIN_STACK && USBD_MSC_EP_BULKIN != USBD_MSC_EP_BULKOUT)
S#error "USBD_MSC_EP_BULKIN_STACK must be defined"
S#endif
S#if (USBD_MSC_ENABLE && !USBD_MSC_EP_BULKOUT_STACK && USBD_MSC_EP_BULKIN != USBD_MSC_EP_BULKOUT)
S#error "USBD_MSC_EP_BULKIN_STACK must be defined"
S#endif
S#if (USBD_MSC_ENABLE && USBD_MSC_EP_BULKIN_STACK == 0 && USBD_MSC_EP_BULKOUT_STACK == 0)
S#error "MSC stack must be defined"
S#endif
S#if (USBD_MSC_EP_BULKIN_STACK > 0 && USBD_MSC_EP_BULKOUT_STACK > 0 && USBD_MSC_EP_BULKIN == USBD_MSC_EP_BULKOUT)
S#error "Multiple MSC stacks defined for same EP"
S#endif
S
S// Check ADC
S#if (USBD_ADC_ENABLE && !USBD_ADC_EP_ISOOUT_STACK)
S#error "ADC stack must be defined"
S#endif
S
S// Check CDC
S#if (USBD_CDC_ACM_ENABLE && !USBD_CDC_ACM_EP_INTIN_STACK)
S#error "CDC ACM INTIN stack must be defined"
S#endif
S#if (USBD_CDC_ACM_ENABLE && !USBD_CDC_ACM_EP_BULKIN_STACK && USBD_CDC_ACM_EP_BULKIN != USBD_CDC_ACM_EP_BULKOUT)
S#error "USBD_CDC_ACM_EP_BULKIN must be defined"
S#endif
S#if (USBD_CDC_ACM_ENABLE && !USBD_CDC_ACM_EP_BULKOUT_STACK && USBD_CDC_ACM_EP_BULKIN != USBD_CDC_ACM_EP_BULKOUT)
S#error "USBD_CDC_ACM_EP_BULKOUT must be defined"
S#endif
S#if (USBD_CDC_ACM_ENABLE && USBD_CDC_ACM_EP_BULKIN_STACK == 0 && USBD_CDC_ACM_EP_BULKOUT_STACK == 0)
S#error "CDC BULK stack must be defined"
S#endif
S#if (USBD_CDC_ACM_EP_BULKIN_STACK > 0 && USBD_CDC_ACM_EP_BULKOUT_STACK > 0 && USBD_CDC_ACM_EP_BULKIN == USBD_CDC_ACM_EP_BULKOUT)
S#error "Multiple CDC stacks defined for same EP"
S#endif
S
Sstatic const user_stack_t user_stack_list[16] = {
S#if USBD_ENABLE
S    [0] = {usbd_endpoint0_stack, sizeof(usbd_endpoint0_stack)},
S#endif
S#if (USBD_HID_EP_INTIN_STACK > 0)
S    [USBD_HID_EP_INTIN] = {usbd_hid_ep_intin_stack, sizeof(usbd_hid_ep_intin_stack)},
S#endif
S#if (USBD_HID_EP_INTOUT_STACK > 0)
S    [USBD_HID_EP_INTOUT] = {usbd_hid_ep_intout_stack, sizeof(usbd_hid_ep_intout_stack)},
S#endif
S#if (USBD_MSC_EP_BULKIN_STACK > 0)
S    [USBD_MSC_EP_BULKIN] = {usbd_msc_ep_bulkin_stack, sizeof(usbd_msc_ep_bulkin_stack)},
S#endif
S#if (USBD_MSC_EP_BULKOUT_STACK > 0)
S    [USBD_MSC_EP_BULKOUT] = {usbd_msc_ep_bulkout_stack, sizeof(usbd_msc_ep_bulkout_stack)},
S#endif
S#if (USBD_ADC_EP_ISOOUT_STACK > 0)
S    [USBD_ADC_EP_ISOOUT] = {usbd_adc_ep_isoout_stack, sizeof(usbd_adc_ep_isoout_stack)},
S#endif
S#if (USBD_CDC_ACM_EP_INTIN_STACK > 0)
S    [USBD_CDC_ACM_EP_INTIN] = {usbd_cdc_acm_ep_intin_stack, sizeof(usbd_cdc_acm_ep_intin_stack)},
S#endif
S#if (USBD_CDC_ACM_EP_BULKIN_STACK > 0)
S    [USBD_CDC_ACM_EP_BULKIN] = {usbd_cdc_acm_ep_bulkin_stack, sizeof(usbd_cdc_acm_ep_bulkin_stack)},
S#endif
S#if (USBD_CDC_ACM_EP_BULKOUT_STACK > 0)
S    [USBD_CDC_ACM_EP_BULKOUT] = {usbd_cdc_acm_ep_bulkout_stack, sizeof(usbd_cdc_acm_ep_bulkout_stack)},
S#endif
S};
S
N#endif /* __RTX */
N
Nvoid USBD_RTX_TaskInit(void)
N{
N#ifdef __RTX
S    /* Initialize memory pools for endpoints */
S    U32 i;
S    USBD_RTX_DevTask = 0;
S
S    if (USBD_RTX_P_Device) {
S        USBD_RTX_DevTask = os_tsk_create_user(USBD_RTX_Device, 3, usbd_device_stack,
S                                              sizeof(usbd_device_stack));
S    }
S
S    for (i = 0; i <= 15; i++) {
S        USBD_RTX_EPTask[i] = 0;
S
S        if (USBD_RTX_P_EP[i]) {
S            // Set the control endpoint (endpoint 0) thread to a high priority.
S            // According to the USB 2.0 specification, the time to complete standard
S            // request with no data must be under 50ms.  If a long caluclation
S            // such as a CRC is running on a higher priority thread, USB enumeration
S            // can fail because of this timeout.
S            uint8_t priority = 0 == i ? 200 : 20;
S            USBD_RTX_EPTask[i] = os_tsk_create_user(USBD_RTX_P_EP[i], priority, user_stack_list[i].stack,
S                                                    user_stack_list[i].size);
S        }
S    }
S
S    USBD_RTX_CoreTask = 0;
S
S    if (USBD_RTX_P_Core) {
S        USBD_RTX_CoreTask = os_tsk_create_user(USBD_RTX_Core, 2, usbd_core_stack,
S                                               sizeof(usbd_core_stack));
S    }
S
N#endif
N}
N
N/*------------------------------------------------------------------------------
N *      CDC Sizes
N *----------------------------------------------------------------------------*/
N#define CDC_HEADER_SIZE                         5
N#define CDC_CALL_MANAGEMENT_SIZE                5
N#define CDC_ABSTRACT_CONTROL_MANAGEMENT_SIZE    4
N#define CDC_UNION_SIZE                          5
N
N/*------------------------------------------------------------------------------
N *      USB Device Descriptors
N *----------------------------------------------------------------------------*/
N#define USBD_MSC_DESC_LEN                 (USB_INTERFACE_DESC_SIZE + 2*USB_ENDPOINT_DESC_SIZE)
N#define USBD_CDC_ACM_DESC_LEN             (USBD_MULTI_IF * USB_INTERFACE_ASSOC_DESC_SIZE                                                        + \
N                                           /* CDC Interface 1 */                                                                                  \
N                                           USB_INTERFACE_DESC_SIZE + CDC_HEADER_SIZE + CDC_CALL_MANAGEMENT_SIZE                                 + \
N                                           CDC_ABSTRACT_CONTROL_MANAGEMENT_SIZE + CDC_UNION_SIZE + USB_ENDPOINT_DESC_SIZE                       + \
N                                           /* CDC Interface 2 */                                                                                  \
N                                           USB_INTERFACE_DESC_SIZE + USB_ENDPOINT_DESC_SIZE + USB_ENDPOINT_DESC_SIZE)
X#define USBD_CDC_ACM_DESC_LEN             (USBD_MULTI_IF * USB_INTERFACE_ASSOC_DESC_SIZE                                                        +                                                                                                                                                                          USB_INTERFACE_DESC_SIZE + CDC_HEADER_SIZE + CDC_CALL_MANAGEMENT_SIZE                                 +                                            CDC_ABSTRACT_CONTROL_MANAGEMENT_SIZE + CDC_UNION_SIZE + USB_ENDPOINT_DESC_SIZE                       +                                                                                                                                                                          USB_INTERFACE_DESC_SIZE + USB_ENDPOINT_DESC_SIZE + USB_ENDPOINT_DESC_SIZE)
N#define USBD_HID_DESC_LEN                 (USB_INTERFACE_DESC_SIZE + USB_HID_DESC_SIZE                                                          + \
N                                          (USB_ENDPOINT_DESC_SIZE*((USBD_HID_EP_INTIN != 0)+(USBD_HID_EP_INTOUT != 0))))
X#define USBD_HID_DESC_LEN                 (USB_INTERFACE_DESC_SIZE + USB_HID_DESC_SIZE                                                          +                                           (USB_ENDPOINT_DESC_SIZE*((USBD_HID_EP_INTIN != 0)+(USBD_HID_EP_INTOUT != 0))))
N#define USBD_BULK_DESC_LEN                (USB_INTERFACE_DESC_SIZE + 2*USB_ENDPOINT_DESC_SIZE)
N
N#define USBD_HID_DESC_OFS                 (USB_CONFIGUARTION_DESC_SIZE + USB_INTERFACE_DESC_SIZE                                                + \
N                                           USBD_MSC_ENABLE * USBD_MSC_DESC_LEN + USBD_CDC_ACM_ENABLE * USBD_CDC_ACM_DESC_LEN)
X#define USBD_HID_DESC_OFS                 (USB_CONFIGUARTION_DESC_SIZE + USB_INTERFACE_DESC_SIZE                                                +                                            USBD_MSC_ENABLE * USBD_MSC_DESC_LEN + USBD_CDC_ACM_ENABLE * USBD_CDC_ACM_DESC_LEN)
N  
N#define USBD_WTOTALLENGTH_MAX              (USB_CONFIGUARTION_DESC_SIZE +                 \
N                                           USBD_CDC_ACM_DESC_LEN * USBD_CDC_ACM_ENABLE + \
N                                           USBD_HID_DESC_LEN     * USBD_HID_ENABLE     + \
N                                           (USB_INTERFACE_DESC_SIZE) * USBD_WEBUSB_ENABLE + \
N                                           USBD_BULK_DESC_LEN     * USBD_BULK_ENABLE + \
N                                           USBD_MSC_DESC_LEN     * USBD_MSC_ENABLE)
X#define USBD_WTOTALLENGTH_MAX              (USB_CONFIGUARTION_DESC_SIZE +                                                            USBD_CDC_ACM_DESC_LEN * USBD_CDC_ACM_ENABLE +                                            USBD_HID_DESC_LEN     * USBD_HID_ENABLE     +                                            (USB_INTERFACE_DESC_SIZE) * USBD_WEBUSB_ENABLE +                                            USBD_BULK_DESC_LEN     * USBD_BULK_ENABLE +                                            USBD_MSC_DESC_LEN     * USBD_MSC_ENABLE)
N
N/*------------------------------------------------------------------------------
N  Default HID Report Descriptor
N *----------------------------------------------------------------------------*/
N
N/*   Bit    Input       Output
N      0     IN0          OUT0
N      1     IN1          OUT1
N      2     IN2          OUT2
N      3     IN3          OUT3
N      4     IN4          OUT4
N      5     IN5          OUT5
N      6     IN6          OUT6
N      7     IN7          OUT7
N*/
N
N__weak \
Nconst U8 USBD_HID_ReportDescriptor[] = {
X__weak const U8 USBD_HID_ReportDescriptor[] = {
N    HID_UsagePageVendor(0x00),
X    0x06,0x00,0xFF,
N    HID_Usage(0x01),
X    0x09,0x01,
N    HID_Collection(HID_Application),
X    0xA1,0x01,
N    HID_LogicalMin(0),                              /* value range: 0 - 0xFF */
X    0x15,0,                               
N    HID_LogicalMaxS(0xFF),
X    0x26,(0xFF&0xFF),((0xFF>>8)&0xFF),
N    HID_ReportSize(8),                              /* 8 bits */
X    0x75,8,                               
N#if (USBD_HID_INREPORT_MAX_SZ > 255)
X#if (64 > 255)
S    HID_ReportCountS(USBD_HID_INREPORT_MAX_SZ),
N#else
N    HID_ReportCount(USBD_HID_INREPORT_MAX_SZ),
X    0x95,64,
N#endif
N    HID_Usage(0x01),
X    0x09,0x01,
N    HID_Input(HID_Data | HID_Variable | HID_Absolute),
X    0x81,0<<0 | 1<<1 | 0<<2,
N#if (USBD_HID_OUTREPORT_MAX_SZ > 255)
X#if (64 > 255)
S    HID_ReportCountS(USBD_HID_OUTREPORT_MAX_SZ),
N#else
N    HID_ReportCount(USBD_HID_OUTREPORT_MAX_SZ),
X    0x95,64,
N#endif
N    HID_Usage(0x01),
X    0x09,0x01,
N    HID_Output(HID_Data | HID_Variable | HID_Absolute),
X    0x91,0<<0 | 1<<1 | 0<<2,
N#if (USBD_HID_FEATREPORT_MAX_SZ > 255)
X#if (1 > 255)
S    HID_ReportCountS(USBD_HID_FEATREPORT_MAX_SZ),
N#else
N    HID_ReportCount(USBD_HID_FEATREPORT_MAX_SZ),
X    0x95,1,
N#endif
N    HID_Usage(0x01),
X    0x09,0x01,
N    HID_Feature(HID_Data | HID_Variable | HID_Absolute),
X    0xB1,0<<0 | 1<<1 | 0<<2,
N    HID_EndCollection,
X    0xC0,
N};
N
N__weak \
Nconst U16 USBD_HID_ReportDescriptorSize = sizeof(USBD_HID_ReportDescriptor);
X__weak const U16 USBD_HID_ReportDescriptorSize = sizeof(USBD_HID_ReportDescriptor);
N
N__weak \
NU16 USBD_HID_DescriptorOffset     = USBD_HID_DESC_OFS;
X__weak U16 USBD_HID_DescriptorOffset     = ((sizeof(USB_CONFIGURATION_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + 1 * ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR))) + 1 * ((1*(1|1|0|0|1|1)) * (sizeof(USB_INTERFACE_ASSOCIATION_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + 5 + 5 + 4 + 5 + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR))));
N
N/* USB Device Standard Descriptor */
N__weak \
Nconst U8 USBD_DeviceDescriptor[] = {
X__weak const U8 USBD_DeviceDescriptor[] = {
N    USB_DEVICE_DESC_SIZE,                 /* bLength */
X    (sizeof(USB_DEVICE_DESCRIPTOR)),                  
N    USB_DEVICE_DESCRIPTOR_TYPE,           /* bDescriptorType */
X    1,            
N#if (USBD_BOS_ENABLE)
X#if (1)
N    WBVAL(0x0210), /* 2.10 */             /* bcdUSB */
X    (0x0210 & 0xFF),((0x0210 >> 8) & 0xFF),                
N#elif ((USBD_HS_ENABLE) || (USBD_MULTI_IF))
X#elif ((0) || ((1*(1|1|0|0|1|1))))
S    WBVAL(0x0200), /* 2.00 */             /* bcdUSB */
S#else
S    WBVAL(0x0110), /* 1.10 */             /* bcdUSB */
N#endif
N#if (USBD_MULTI_IF)
X#if ((1*(1|1|0|0|1|1)))
N    USB_DEVICE_CLASS_MISCELLANEOUS,       /* bDeviceClass */
X    0xEF,        
N    0x02,                                 /* bDeviceSubClass */
N    0x01,                                 /* bDeviceProtocol */
N#elif (USBD_CDC_ACM_ENABLE)
X#elif (1)
S    USB_DEVICE_CLASS_COMMUNICATIONS,      /* bDeviceClass CDC*/
S    0x00,                                 /* bDeviceSubClass */
S    0x00,                                 /* bDeviceProtocol */
S#else
S    0x00,                                 /* bDeviceClass */
S    0x00,                                 /* bDeviceSubClass */
S    0x00,                                 /* bDeviceProtocol */
N#endif
N    USBD_MAX_PACKET0,                     /* bMaxPacketSize0 */
X    64,                      
N    WBVAL(USBD_DEVDESC_IDVENDOR),         /* idVendor */
X    (0x0D28 & 0xFF),((0x0D28 >> 8) & 0xFF),          
N    WBVAL(USBD_DEVDESC_IDPRODUCT),        /* idProduct */
X    (0x0204 & 0xFF),((0x0204 >> 8) & 0xFF),         
N    WBVAL(USBD_DEVDESC_BCDDEVICE),        /* bcdDevice */
X    (0x0100 & 0xFF),((0x0100 >> 8) & 0xFF),         
N    0x01,                                 /* iManufacturer */
N    0x02,                                 /* iProduct */
N    0x03 * USBD_STRDESC_SER_ENABLE,       /* iSerialNumber */
X    0x03 * 1,        
N    0x01                                  /* bNumConfigurations: one possible configuration*/
N};
N
N#if (USBD_HS_ENABLE)
X#if (0)
S/* USB Device Qualifier Descriptor (for Full Speed) */
S__weak \
Sconst U8 USBD_DeviceQualifier[] = {
X__weak const U8 USBD_DeviceQualifier[] = {
S    USB_DEVICE_QUALI_SIZE,                /* bLength */
S    USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE, /* bDescriptorType */
S#if (USBD_BOS_ENABLE)
S    WBVAL(0x0210), /* 2.10 */             /* bcdUSB */
S#else
S    WBVAL(0x0200), /* 2.00 */             /* bcdUSB */
S#endif
S    0x00,                                 /* bDeviceClass */
S    0x00,                                 /* bDeviceSubClass */
S    0x00,                                 /* bDeviceProtocol */
S    USBD_MAX_PACKET0,                     /* bMaxPacketSize0 */
S    0x01,                                 /* bNumConfigurations */
S    0x00                                  /* bReserved */
S};
S
S/* USB Device Qualifier Descriptor for High Speed */
S__weak \
Sconst U8 USBD_DeviceQualifier_HS[] = {
X__weak const U8 USBD_DeviceQualifier_HS[] = {
S    USB_DEVICE_QUALI_SIZE,                /* bLength */
S    USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE, /* bDescriptorType */
S#if (USBD_BOS_ENABLE)
S    WBVAL(0x0210), /* 2.10 */             /* bcdUSB */
S#else
S    WBVAL(0x0200), /* 2.00 */             /* bcdUSB */
S#endif
S    0x00,                                 /* bDeviceClass */
S    0x00,                                 /* bDeviceSubClass */
S    0x00,                                 /* bDeviceProtocol */
S    USBD_MAX_PACKET0,                     /* bMaxPacketSize0 */
S    0x01,                                 /* bNumConfigurations */
S    0x00                                  /* bReserved */
S};
N#else
N/* USB Device Qualifier Descriptor (for Full Speed) */
N__weak \
Nconst U8 USBD_DeviceQualifier[]    = { 0 };
X__weak const U8 USBD_DeviceQualifier[]    = { 0 };
N
N/* USB Device Qualifier Descriptor for High Speed */
N__weak \
Nconst U8 USBD_DeviceQualifier_HS[] = { 0 };
X__weak const U8 USBD_DeviceQualifier_HS[] = { 0 };
N#endif
N
N#if (USBD_WINUSB_ENABLE)
X#if (1)
N
N#define FUNCTION_SUBSET_LEN                 160
N#define DEVICE_INTERFACE_GUIDS_FEATURE_LEN  132
N
N#define USBD_WINUSB_DESC_SET_LEN            (WINUSB_DESCRIPTOR_SET_HEADER_SIZE + USBD_WEBUSB_ENABLE * FUNCTION_SUBSET_LEN + USBD_BULK_ENABLE * FUNCTION_SUBSET_LEN)
N
NU8 USBD_WinUSBDescriptorSetDescriptor[] = {
N    WBVAL(WINUSB_DESCRIPTOR_SET_HEADER_SIZE), /* wLength */
X    (10 & 0xFF),((10 >> 8) & 0xFF),  
N    WBVAL(WINUSB_SET_HEADER_DESCRIPTOR_TYPE), /* wDescriptorType */
X    (0x00 & 0xFF),((0x00 >> 8) & 0xFF),  
N    0x00, 0x00, 0x03, 0x06, /* >= Win 8.1 */  /* dwWindowsVersion*/
N    WBVAL(USBD_WINUSB_DESC_SET_LEN),          /* wDescriptorSetTotalLength */
X    ((10 + 1 * 160 + 1 * 160) & 0xFF),(((10 + 1 * 160 + 1 * 160) >> 8) & 0xFF),           
N#if (USBD_WEBUSB_ENABLE)    
X#if (1)    
N    WBVAL(WINUSB_FUNCTION_SUBSET_HEADER_SIZE),// wLength 
X    (8 & 0xFF),((8 >> 8) & 0xFF),
N    WBVAL(WINUSB_SUBSET_HEADER_FUNCTION_TYPE),// wDescriptorType 
X    (0x02 & 0xFF),((0x02 >> 8) & 0xFF),
N    0,                                        // bFirstInterface USBD_WINUSB_IF_NUM
N    0,                                        // bReserved 
N    WBVAL(FUNCTION_SUBSET_LEN),               // wSubsetLength 
X    (160 & 0xFF),((160 >> 8) & 0xFF),               
N    WBVAL(WINUSB_FEATURE_COMPATIBLE_ID_SIZE), // wLength 
X    (20 & 0xFF),((20 >> 8) & 0xFF), 
N    WBVAL(WINUSB_FEATURE_COMPATIBLE_ID_TYPE), // wDescriptorType 
X    (0x03 & 0xFF),((0x03 >> 8) & 0xFF), 
N    'W', 'I', 'N', 'U', 'S', 'B', 0, 0,       // CompatibleId
N    0, 0, 0, 0, 0, 0, 0, 0,                   // SubCompatibleId
N    WBVAL(DEVICE_INTERFACE_GUIDS_FEATURE_LEN),// wLength 
X    (132 & 0xFF),((132 >> 8) & 0xFF),
N    WBVAL(WINUSB_FEATURE_REG_PROPERTY_TYPE),  // wDescriptorType 
X    (0x04 & 0xFF),((0x04 >> 8) & 0xFF),  
N    WBVAL(WINUSB_PROP_DATA_TYPE_REG_MULTI_SZ), // wPropertyDataType 
X    (0x07 & 0xFF),((0x07 >> 8) & 0xFF), 
N    WBVAL(42), // wPropertyNameLength 
X    (42 & 0xFF),((42 >> 8) & 0xFF), 
N    'D',0,'e',0,'v',0,'i',0,'c',0,'e',0,
N    'I',0,'n',0,'t',0,'e',0,'r',0,'f',0,'a',0,'c',0,'e',0,
N    'G',0,'U',0,'I',0,'D',0,'s',0,0,0,
N    WBVAL(80), // wPropertyDataLength 
X    (80 & 0xFF),((80 >> 8) & 0xFF), 
N    '{',0,
N    '9',0,'2',0,'C',0,'E',0,'6',0,'4',0,'6',0,'2',0,'-',0,
N    '9',0,'C',0,'7',0,'7',0,'-',0,
N    '4',0,'6',0,'F',0,'E',0,'-',0,
N    '9',0,'3',0,'3',0,'B',0,'-',
N    0,'3',0,'1',0,'C',0,'B',0,'9',0,'C',0,'5',0,'A',0,'A',0,'3',0,'B',0,'9',0,
N    '}',0,0,0,0,0,
N#endif 
N#if (USBD_BULK_ENABLE)    
X#if (1)    
N    WBVAL(WINUSB_FUNCTION_SUBSET_HEADER_SIZE),/* wLength */
X    (8 & 0xFF),((8 >> 8) & 0xFF), 
N    WBVAL(WINUSB_SUBSET_HEADER_FUNCTION_TYPE),/* wDescriptorType */
X    (0x02 & 0xFF),((0x02 >> 8) & 0xFF), 
N    0,                                        /* bFirstInterface USBD_BULK_IF_NUM*/
N    0,                                        /* bReserved */
N    WBVAL(FUNCTION_SUBSET_LEN),               /* wSubsetLength */
X    (160 & 0xFF),((160 >> 8) & 0xFF),                
N    WBVAL(WINUSB_FEATURE_COMPATIBLE_ID_SIZE), /* wLength */
X    (20 & 0xFF),((20 >> 8) & 0xFF),  
N    WBVAL(WINUSB_FEATURE_COMPATIBLE_ID_TYPE), /* wDescriptorType */
X    (0x03 & 0xFF),((0x03 >> 8) & 0xFF),  
N    'W', 'I', 'N', 'U', 'S', 'B', 0, 0,       /* CompatibleId*/
N    0, 0, 0, 0, 0, 0, 0, 0,                   /* SubCompatibleId*/
N    WBVAL(DEVICE_INTERFACE_GUIDS_FEATURE_LEN),/* wLength */
X    (132 & 0xFF),((132 >> 8) & 0xFF), 
N    WBVAL(WINUSB_FEATURE_REG_PROPERTY_TYPE),  /* wDescriptorType */
X    (0x04 & 0xFF),((0x04 >> 8) & 0xFF),   
N    WBVAL(WINUSB_PROP_DATA_TYPE_REG_MULTI_SZ), /* wPropertyDataType */
X    (0x07 & 0xFF),((0x07 >> 8) & 0xFF),  
N    WBVAL(42), /* wPropertyNameLength */
X    (42 & 0xFF),((42 >> 8) & 0xFF),  
N    'D',0,'e',0,'v',0,'i',0,'c',0,'e',0,
N    'I',0,'n',0,'t',0,'e',0,'r',0,'f',0,'a',0,'c',0,'e',0,
N    'G',0,'U',0,'I',0,'D',0,'s',0,0,0,
N    WBVAL(80), /* wPropertyDataLength */
X    (80 & 0xFF),((80 >> 8) & 0xFF),  
N    '{',0,
N    'C',0,'D',0,'B',0,'3',0,'B',0,'5',0,'A',0,'D',0,'-',0,
N    '2',0,'9',0,'3',0,'B',0,'-',0,
N    '4',0,'6',0,'6',0,'3',0,'-',0,
N    'A',0,'A',0,'3',0,'6',0,'-',
N    0,'1',0,'A',0,'A',0,'E',0,'4',0,'6',0,'4',0,'6',0,'3',0,'7',0,'7',0,'6',0,
N    '}',0,0,0,0,0,
N#endif    
N};
N
N#else
S
Sconst U8 USBD_WinUSBDescriptorSetDescriptor[] = { 0 };
S
SBOOL USBD_EndPoint0_Setup_WinUSB_ReqToDevice(void)
S{
S    return (__FALSE);
S}
S
N#endif
N
N#if (USBD_BOS_ENABLE)
X#if (1)
N
N#define USBD_NUM_DEV_CAPABILITIES         (USBD_WEBUSB_ENABLE + USBD_WINUSB_ENABLE)
N
N#define USBD_WEBUSB_DESC_LEN              (sizeof(WEBUSB_PLATFORM_CAPABILITY_DESCRIPTOR))
N
N#define USBD_WINUSB_DESC_LEN              (sizeof(WINUSB_PLATFORM_CAPABILITY_DESCRIPTOR))
N
N#define USBD_BOS_WTOTALLENGTH             (USB_BOS_DESC_SIZE +                         \
N                                           USBD_WEBUSB_DESC_LEN * USBD_WEBUSB_ENABLE + \
N                                           USBD_WINUSB_DESC_LEN * USBD_WINUSB_ENABLE)
X#define USBD_BOS_WTOTALLENGTH             (USB_BOS_DESC_SIZE +                                                                    USBD_WEBUSB_DESC_LEN * USBD_WEBUSB_ENABLE +                                            USBD_WINUSB_DESC_LEN * USBD_WINUSB_ENABLE)
N
N__weak \
Nconst U8 USBD_BinaryObjectStoreDescriptor[] = {
X__weak const U8 USBD_BinaryObjectStoreDescriptor[] = {
N	USB_BOS_DESC_SIZE,                      /* bLength */
X	(sizeof(USB_BINARY_OBJECT_STORE_DESCRIPTOR)),                       
N	USB_BINARY_OBJECT_STORE_DESCRIPTOR_TYPE,/* bDescriptorType */
X	15, 
N	WBVAL(USBD_BOS_WTOTALLENGTH),           /* wTotalLength */
X	(((sizeof(USB_BINARY_OBJECT_STORE_DESCRIPTOR)) + (sizeof(WEBUSB_PLATFORM_CAPABILITY_DESCRIPTOR)) * 1 + (sizeof(WINUSB_PLATFORM_CAPABILITY_DESCRIPTOR)) * 1) & 0xFF),((((sizeof(USB_BINARY_OBJECT_STORE_DESCRIPTOR)) + (sizeof(WEBUSB_PLATFORM_CAPABILITY_DESCRIPTOR)) * 1 + (sizeof(WINUSB_PLATFORM_CAPABILITY_DESCRIPTOR)) * 1) >> 8) & 0xFF),            
N	USBD_NUM_DEV_CAPABILITIES,              /* bNumDeviceCaps */
X	(1 + 1),               
N#if (USBD_WEBUSB_ENABLE)
X#if (1)
N	USBD_WEBUSB_DESC_LEN,                   /* bLength */
X	(sizeof(WEBUSB_PLATFORM_CAPABILITY_DESCRIPTOR)),                    
N	USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE,  /* bDescriptorType */
X	16,   
N	USB_DEVICE_CAPABILITY_PLATFORM,         /* bDevCapabilityType */
X	5,          
N	0x00,                                   /* bReserved */
N	0x38, 0xB6, 0x08, 0x34,                 /* PlatformCapabilityUUID */
N	0xA9, 0x09, 0xA0, 0x47,
N	0x8B, 0xFD, 0xA0, 0x76,
N	0x88, 0x15, 0xB6, 0x65,
N	WBVAL(0x0100), /* 1.00 */               /* bcdVersion */
X	(0x0100 & 0xFF),((0x0100 >> 8) & 0xFF),                  
N	USBD_WEBUSB_VENDOR_CODE,                /* bVendorCode */
X	0x21,                 
N	0,                                      /* iLandingPage */
N#endif
N#if (USBD_WINUSB_ENABLE)
X#if (1)
N	USBD_WINUSB_DESC_LEN,                   /* bLength */
X	(sizeof(WINUSB_PLATFORM_CAPABILITY_DESCRIPTOR)),                    
N	USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE,  /* bDescriptorType */
X	16,   
N	USB_DEVICE_CAPABILITY_PLATFORM,         /* bDevCapabilityType */
X	5,          
N	0x00,                                   /* bReserved */
N	0xDF, 0x60, 0xDD, 0xD8,                 /* PlatformCapabilityUUID */
N	0x89, 0x45, 0xC7, 0x4C,
N	0x9C, 0xD2, 0x65, 0x9D,
N	0x9E, 0x64, 0x8A, 0x9F,
N	0x00, 0x00, 0x03, 0x06, /* >= Win 8.1 *//* dwWindowsVersion*/
N	WBVAL(USBD_WINUSB_DESC_SET_LEN),        /* wDescriptorSetTotalLength */
X	((10 + 1 * 160 + 1 * 160) & 0xFF),(((10 + 1 * 160 + 1 * 160) >> 8) & 0xFF),         
N	USBD_WINUSB_VENDOR_CODE,                /* bVendorCode */
X	0x20,                 
N	0,                                      /* bAltEnumCode */
N#endif
N};
N
N#else
S__weak \
Sconst U8 USBD_BinaryObjectStoreDescriptor[] = { 0 };
X__weak const U8 USBD_BinaryObjectStoreDescriptor[] = { 0 };
S
N#endif
N
N#define HID_DESC                                                                                            \
N  /* Interface, Alternate Setting 0, HID Class */                                                           \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  0x00,                                 /* bInterfaceNumber USBD_HID_IF_NUM*/                               \
N  0x00,                                 /* bAlternateSetting */                                             \
N  0x00+(USBD_HID_EP_INTIN != 0)+(USBD_HID_EP_INTOUT != 0), /*0x01+(USBD_HID_EP_INTOUT != 0),*/       /* bNumEndpoints */                                                 \
N  USB_DEVICE_CLASS_HUMAN_INTERFACE,     /* bInterfaceClass */                                               \
N  HID_SUBCLASS_NONE,                    /* bInterfaceSubClass */                                            \
N  HID_PROTOCOL_NONE,                    /* bInterfaceProtocol */                                            \
N  USBD_HID_IF_STR_NUM,                  /* iInterface */                                                    \
N                                                                                                            \
N/* HID Class Descriptor */                                                                                  \
N  USB_HID_DESC_SIZE,                    /* bLength */                                                       \
N  HID_HID_DESCRIPTOR_TYPE,              /* bDescriptorType */                                               \
N  WBVAL(0x0100), /* 1.00 */             /* bcdHID */                                                        \
N  0x00,                                 /* bCountryCode */                                                  \
N  0x01,                                 /* bNumDescriptors */                                               \
N  HID_REPORT_DESCRIPTOR_TYPE,           /* bDescriptorType */                                               \
N  WBVAL(USB_HID_REPORT_DESC_SIZE),      /* wDescriptorLength */
X#define HID_DESC                                                                                                                                                            USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          0x00,                                                                   0x00,                                                                                 0x00+(USBD_HID_EP_INTIN != 0)+(USBD_HID_EP_INTOUT != 0),                                                             USB_DEVICE_CLASS_HUMAN_INTERFACE,                                                       HID_SUBCLASS_NONE,                                                                   HID_PROTOCOL_NONE,                                                                   USBD_HID_IF_STR_NUM,                                                                                                                                                                                                                                                                        USB_HID_DESC_SIZE,                                                                              HID_HID_DESCRIPTOR_TYPE,                                                                WBVAL(0x0100),                                                                          0x00,                                                                                      0x01,                                                                                   HID_REPORT_DESCRIPTOR_TYPE,                                                             WBVAL(USB_HID_REPORT_DESC_SIZE),       
N
N#define VENDOR_DESC_IAD(first,num_of_ifs)  /* Vendor: Interface Association Descriptor */                     \
N  USB_INTERFACE_ASSOC_DESC_SIZE,        /* bLength */                                                       \
N  USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE,  /* bDescriptorType */                                         \
N (first),                               /* bFirstInterface */                                               \
N (num_of_ifs),                          /* bInterfaceCount */                                               \
N  USB_DEVICE_CLASS_VENDOR_SPECIFIC,    /* bFunctionClass     */                       \
N  0x00,           /* bFunctionSubclass */                    \
N  0x00,                                 /* bFunctionProtocol */               \
N  0x00,             /* iFunction */
X#define VENDOR_DESC_IAD(first,num_of_ifs)                          USB_INTERFACE_ASSOC_DESC_SIZE,                                                                  USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE,                                             (first),                                                                                (num_of_ifs),                                                                            USB_DEVICE_CLASS_VENDOR_SPECIFIC,                              0x00,                                  0x00,                                                   0x00,              
N
N#define WEBUSB_DESC                                                                                            \
N/* Interface, Alternate Setting 0, VENDOR_SPECIFIC Class */                                                           \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  0x00,                                 /* bInterfaceNumber USBD_WEBUSB_IF_NUM */                           \
N  0x00,                                 /* bAlternateSetting */                                             \
N  0x00,                                 /* bNumEndpoints */                                                 \
N  USB_DEVICE_CLASS_VENDOR_SPECIFIC,     /* bInterfaceClass */                                               \
N  USB_DEVICE_CLASS_HUMAN_INTERFACE,     /* bInterfaceSubClass */                                            \
N  HID_PROTOCOL_NONE,                    /* bInterfaceProtocol */                                            \
N  USBD_WEBUSB_IF_STR_NUM,               /* iInterface */                                                    \
N
X#define WEBUSB_DESC                                                                                                                                                          USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          0x00,                                                               0x00,                                                                                 0x00,                                                                                     USB_DEVICE_CLASS_VENDOR_SPECIFIC,                                                       USB_DEVICE_CLASS_HUMAN_INTERFACE,                                                    HID_PROTOCOL_NONE,                                                                   USBD_WEBUSB_IF_STR_NUM,                                                                    
N#define HID_EP_IN                       /* HID Endpoint for Low-speed/Full-speed */                         \
N/* Endpoint, HID Interrupt In */                                                                            \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_HID_EP_INTIN),   /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  USBD_HID_BINTERVAL,                   /* bInterval */
X#define HID_EP_IN                                                                                                                                USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_HID_EP_INTIN),                                                    USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_WMAXPACKETSIZE),                                                          USBD_HID_BINTERVAL,                    
N
N#define HID_EP_OUT                          /* HID Endpoint for Low-speed/Full-speed */                         \
N/* Endpoint, HID Interrupt Out */                                                                           \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT), /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  USBD_HID_BINTERVAL,                   /* bInterval */
X#define HID_EP_OUT                                                                                                                                  USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT),                                                  USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_WMAXPACKETSIZE),                                                          USBD_HID_BINTERVAL,                    
N
N#define HID_EP_INOUT                    /* HID Endpoint for Low-speed/Full-speed */                         \
N/* Endpoint, HID Interrupt In */                                                                            \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_HID_EP_INTIN),   /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  USBD_HID_BINTERVAL,                   /* bInterval */                                                     \
N                                                                                                            \
N/* Endpoint, HID Interrupt Out */                                                                           \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT), /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  USBD_HID_BINTERVAL,                   /* bInterval */
X#define HID_EP_INOUT                                                                                                                             USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_HID_EP_INTIN),                                                    USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_WMAXPACKETSIZE),                                                          USBD_HID_BINTERVAL,                                                                                                                                                                                                                                                                   USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT),                                                  USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_WMAXPACKETSIZE),                                                          USBD_HID_BINTERVAL,                    
N
N#define HID_EP_IN_HS                       /* HID Endpoint for High-speed */                                   \
N/* Endpoint, HID Interrupt In */                                                                            \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_HID_EP_INTIN),   /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_HS_WMAXPACKETSIZE),    /* wMaxPacketSize */                                                \
N  USBD_HID_HS_BINTERVAL,                /* bInterval */
X#define HID_EP_IN_HS                                                                                                                                          USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_HID_EP_INTIN),                                                    USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_HS_WMAXPACKETSIZE),                                                       USBD_HID_HS_BINTERVAL,                 
N
N#define HID_EP_OUT_HS                       /* HID Endpoint for High-speed */                                   \
N/* Endpoint, HID Interrupt Out */                                                                           \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT), /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_HS_WMAXPACKETSIZE),    /* wMaxPacketSize */                                                \
N  USBD_HID_HS_BINTERVAL,                /* bInterval */
X#define HID_EP_OUT_HS                                                                                                                                         USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT),                                                  USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_HS_WMAXPACKETSIZE),                                                       USBD_HID_HS_BINTERVAL,                 
N
N#define HID_EP_INOUT_HS                 /* HID Endpoint for High-speed */                                   \
N/* Endpoint, HID Interrupt In */                                                                            \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_HID_EP_INTIN),   /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_HS_WMAXPACKETSIZE),    /* wMaxPacketSize */                                                \
N  USBD_HID_HS_BINTERVAL,                /* bInterval */                                                     \
N                                                                                                            \
N/* Endpoint, HID Interrupt Out */                                                                           \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT), /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_HID_HS_WMAXPACKETSIZE),    /* wMaxPacketSize */                                                \
N  USBD_HID_HS_BINTERVAL,                /* bInterval */
X#define HID_EP_INOUT_HS                                                                                                                                    USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_HID_EP_INTIN),                                                    USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_HS_WMAXPACKETSIZE),                                                       USBD_HID_HS_BINTERVAL,                                                                                                                                                                                                                                                                USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_HID_EP_INTOUT),                                                  USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_HID_HS_WMAXPACKETSIZE),                                                       USBD_HID_HS_BINTERVAL,                 
N
N#define MSC_DESC                                                                                            \
N/* Interface, Alternate Setting 0, MSC Class */                                                             \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  0x00,                                 /* bInterfaceNumber USBD_MSC_IF_NUM*/                               \
N  0x00,                                 /* bAlternateSetting */                                             \
N  0x02,                                 /* bNumEndpoints */                                                 \
N  USB_DEVICE_CLASS_STORAGE,             /* bInterfaceClass */                                               \
N  MSC_SUBCLASS_SCSI,                    /* bInterfaceSubClass */                                            \
N  MSC_PROTOCOL_BULK_ONLY,               /* bInterfaceProtocol */                                            \
N  USBD_MSC_IF_STR_NUM,                  /* iInterface */
X#define MSC_DESC                                                                                                                                                            USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          0x00,                                                                   0x00,                                                                                 0x02,                                                                                     USB_DEVICE_CLASS_STORAGE,                                                               MSC_SUBCLASS_SCSI,                                                                   MSC_PROTOCOL_BULK_ONLY,                                                              USBD_MSC_IF_STR_NUM,                   
N
N#define MSC_EP                          /* MSC Endpoints for Low-speed/Full-speed */                        \
N/* Endpoint, EP Bulk IN */                                                                                  \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_MSC_EP_BULKIN),  /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_MSC_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */                           \
N                                                                                                            \
N/* Endpoint, EP Bulk OUT */                                                                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_MSC_EP_BULKOUT),/* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_MSC_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */
X#define MSC_EP                                                                                                                                        USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_MSC_EP_BULKIN),                                                   USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_MSC_WMAXPACKETSIZE),                                                          0x00,                                                                                                                                                                                                                                                             USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_MSC_EP_BULKOUT),                                                 USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_MSC_WMAXPACKETSIZE),                                                          0x00,                                  
N
N#define MSC_EP_HS                       /* MSC Endpoints for High-speed */                                  \
N/* Endpoint, EP Bulk IN */                                                                                  \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_MSC_EP_BULKIN),  /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_MSC_HS_WMAXPACKETSIZE),    /* wMaxPacketSize */                                                \
N  USBD_MSC_HS_BINTERVAL,                /* bInterval */                                                     \
N                                                                                                            \
N/* Endpoint, EP Bulk OUT */                                                                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_MSC_EP_BULKOUT),/* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_MSC_HS_WMAXPACKETSIZE),    /* wMaxPacketSize */                                                \
N  USBD_MSC_HS_BINTERVAL,                /* bInterval */
X#define MSC_EP_HS                                                                                                                                               USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_MSC_EP_BULKIN),                                                   USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_MSC_HS_WMAXPACKETSIZE),                                                       USBD_MSC_HS_BINTERVAL,                                                                                                                                                                                                                                                                      USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_MSC_EP_BULKOUT),                                                 USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_MSC_HS_WMAXPACKETSIZE),                                                       USBD_MSC_HS_BINTERVAL,                 
N  
N#define BULK_DESC                                                                                            \
N/* Interface, Alternate Setting 0, MSC Class */                                                             \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  0x00,                                 /* bInterfaceNumber USBD_BULK_IF_NUM*/                             \
N  0x00,                                 /* bAlternateSetting */                                             \
N  0x02,                                 /* bNumEndpoints */                                                 \
N  USB_DEVICE_CLASS_VENDOR_SPECIFIC,     /* bInterfaceClass */                                               \
N  0x00,                                 /* bInterfaceSubClass */                                            \
N  0x00,                                 /* bInterfaceProtocol */                                            \
N  USBD_BULK_IF_STR_NUM,                  /* iInterface */
X#define BULK_DESC                                                                                                                                                            USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          0x00,                                                                 0x00,                                                                                 0x02,                                                                                     USB_DEVICE_CLASS_VENDOR_SPECIFIC,                                                       0x00,                                                                                0x00,                                                                                USBD_BULK_IF_STR_NUM,                   
N
N#define BULK_EP                          /* MSC Endpoints for Low-speed/Full-speed */                        \
N/* Endpoint, EP Bulk OUT */                                                                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_BULK_EP_BULKOUT),/* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_BULK_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */                           \
N                                                                                                            \
N/* Endpoint, EP Bulk IN */                                                                                  \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_BULK_EP_BULKIN),  /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_BULK_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */                           
X#define BULK_EP                                                                                                                                       USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_BULK_EP_BULKOUT),                                                 USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_BULK_WMAXPACKETSIZE),                                                          0x00,                                                                                                                                                                                                                                                              USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_BULK_EP_BULKIN),                                                   USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_BULK_WMAXPACKETSIZE),                                                          0x00,                                                             
N
N#define BULK_EP_HS                          /* MSC Endpoints for Low-speed/Full-speed */                        \
N/* Endpoint, EP Bulk OUT */                                                                                  \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_BULK_EP_BULKOUT),  /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_BULK_HS_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */                           \
N                                                                                                            \
N/* Endpoint, EP Bulk IN */                                                                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_BULK_EP_BULKIN),/* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_BULK_HS_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */                           
X#define BULK_EP_HS                                                                                                                                        USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_BULK_EP_BULKOUT),                                                   USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_BULK_HS_WMAXPACKETSIZE),                                                          0x00,                                                                                                                                                                                                                                                             USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_BULK_EP_BULKIN),                                                 USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_BULK_HS_WMAXPACKETSIZE),                                                          0x00,                                                             
N
N#define ADC_DESC_IAD(first,num_of_ifs)  /* ADC: Interface Association Descriptor */                         \
N  USB_INTERFACE_ASSOC_DESC_SIZE,        /* bLength */                                                       \
N  USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE,  /* bDescriptorType */                                         \
N (first),                               /* bFirstInterface */                                               \
N (num_of_ifs),                          /* bInterfaceCount */                                               \
N  USB_DEVICE_CLASS_AUDIO,               /* bFunctionClass */                                                \
N  AUDIO_SUBCLASS_AUDIOCONTROL,          /* bFunctionSubclass */                                             \
N  AUDIO_PROTOCOL_UNDEFINED,             /* bFunctionProtocol */                                             \
N  USBD_ADC_CIF_STR_NUM,                 /* iFunction */                                                     \
N
X#define ADC_DESC_IAD(first,num_of_ifs)                              USB_INTERFACE_ASSOC_DESC_SIZE,                                                                  USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE,                                             (first),                                                                                (num_of_ifs),                                                                            USB_DEVICE_CLASS_AUDIO,                                                                  AUDIO_SUBCLASS_AUDIOCONTROL,                                                          AUDIO_PROTOCOL_UNDEFINED,                                                             USBD_ADC_CIF_STR_NUM,                                                                       
N#define ADC_DESC                                                                                            \
N/* Interface, Alternate Setting 0, Audio Control */                                                         \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  USBD_ADC_CIF_NUM,                     /* bInterfaceNumber */                                              \
N  0x00,                                 /* bAlternateSetting */                                             \
N  0x00,                                 /* bNumEndpoints */                                                 \
N  USB_DEVICE_CLASS_AUDIO,               /* bInterfaceClass */                                               \
N  AUDIO_SUBCLASS_AUDIOCONTROL,          /* bInterfaceSubClass */                                            \
N  AUDIO_PROTOCOL_UNDEFINED,             /* bInterfaceProtocol */                                            \
N  USBD_ADC_CIF_STR_NUM,                 /* iInterface */                                                    \
N/* Audio Control Interface */                                                                               \
N  AUDIO_CONTROL_INTERFACE_DESC_SZ(1),   /* bLength */                                                       \
N  AUDIO_INTERFACE_DESCRIPTOR_TYPE,      /* bDescriptorType */                                               \
N  AUDIO_CONTROL_HEADER,                 /* bDescriptorSubtype */                                            \
N  WBVAL(0x0100), /* 1.00 */             /* bcdADC */                                                        \
N  WBVAL(                                /* wTotalLength */                                                  \
N    AUDIO_CONTROL_INTERFACE_DESC_SZ(1) +                                                                    \
N    AUDIO_INPUT_TERMINAL_DESC_SIZE     +                                                                    \
N    AUDIO_FEATURE_UNIT_DESC_SZ(1,1)    +                                                                    \
N    AUDIO_OUTPUT_TERMINAL_DESC_SIZE                                                                         \
N  ),                                                                                                        \
N  0x01,                                 /* bInCollection */                                                 \
N  0x01,                                 /* baInterfaceNr */                                                 \
N                                                                                                            \
N/* Audio Input Terminal */                                                                                  \
N  AUDIO_INPUT_TERMINAL_DESC_SIZE,       /* bLength */                                                       \
N  AUDIO_INTERFACE_DESCRIPTOR_TYPE,      /* bDescriptorType */                                               \
N  AUDIO_CONTROL_INPUT_TERMINAL,         /* bDescriptorSubtype */                                            \
N  0x01,                                 /* bTerminalID */                                                   \
N  WBVAL(AUDIO_TERMINAL_USB_STREAMING),  /* wTerminalType */                                                 \
N  0x00,                                 /* bAssocTerminal */                                                \
N  0x01,                                 /* bNrChannels */                                                   \
N  WBVAL(AUDIO_CHANNEL_M),               /* wChannelConfig */                                                \
N  0x00,                                 /* iChannelNames */                                                 \
N  0x00,                                 /* iTerminal */                                                     \
N                                                                                                            \
N/* Audio Feature Unit */                                                                                    \
N  AUDIO_FEATURE_UNIT_DESC_SZ(1,1),      /* bLength */                                                       \
N  AUDIO_INTERFACE_DESCRIPTOR_TYPE,      /* bDescriptorType */                                               \
N  AUDIO_CONTROL_FEATURE_UNIT,           /* bDescriptorSubtype */                                            \
N  0x02,                                 /* bUnitID */                                                       \
N  0x01,                                 /* bSourceID */                                                     \
N  0x01,                                 /* bControlSize */                                                  \
N  AUDIO_CONTROL_MUTE |                                                                                      \
N  AUDIO_CONTROL_VOLUME,                 /* bmaControls(0) */                                                \
N  0x00,                                 /* bmaControls(1) */                                                \
N  0x00,                                 /* iTerminal */                                                     \
N                                                                                                            \
N/* Audio Output Terminal */                                                                                 \
N  AUDIO_OUTPUT_TERMINAL_DESC_SIZE,      /* bLength */                                                       \
N  AUDIO_INTERFACE_DESCRIPTOR_TYPE,      /* bDescriptorType */                                               \
N  AUDIO_CONTROL_OUTPUT_TERMINAL,        /* bDescriptorSubtype */                                            \
N  0x03,                                 /* bTerminalID */                                                   \
N  WBVAL(AUDIO_TERMINAL_SPEAKER),        /* wTerminalType */                                                 \
N  0x00,                                 /* bAssocTerminal */                                                \
N  0x02,                                 /* bSourceID */                                                     \
N  0x00,                                 /* iTerminal */                                                     \
N                                                                                                            \
N/* Interface, Alternate Setting 0, Audio Streaming - Zero Bandwith */                                       \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  USBD_ADC_SIF1_NUM,                    /* bInterfaceNumber */                                              \
N  0x00,                                 /* bAlternateSetting */                                             \
N  0x00,                                 /* bNumEndpoints */                                                 \
N  USB_DEVICE_CLASS_AUDIO,               /* bInterfaceClass */                                               \
N  AUDIO_SUBCLASS_AUDIOSTREAMING,        /* bInterfaceSubClass */                                            \
N  AUDIO_PROTOCOL_UNDEFINED,             /* bInterfaceProtocol */                                            \
N  USBD_ADC_SIF1_STR_NUM,                /* iInterface */                                                    \
N                                                                                                            \
N/* Interface, Alternate Setting 1, Audio Streaming - Operational */                                         \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  USBD_ADC_SIF1_NUM,                    /* bInterfaceNumber */                                              \
N  0x01,                                 /* bAlternateSetting */                                             \
N  0x01,                                 /* bNumEndpoints */                                                 \
N  USB_DEVICE_CLASS_AUDIO,               /* bInterfaceClass */                                               \
N  AUDIO_SUBCLASS_AUDIOSTREAMING,        /* bInterfaceSubClass */                                            \
N  AUDIO_PROTOCOL_UNDEFINED,             /* bInterfaceProtocol */                                            \
N  USBD_ADC_SIF2_STR_NUM,                /* iInterface */                                                    \
N                                                                                                            \
N/* Audio Streaming Interface */                                                                             \
N  AUDIO_STREAMING_INTERFACE_DESC_SIZE,  /* bLength */                                                       \
N  AUDIO_INTERFACE_DESCRIPTOR_TYPE,      /* bDescriptorType */                                               \
N  AUDIO_STREAMING_GENERAL,              /* bDescriptorSubtype */                                            \
N  0x01,                                 /* bTerminalLink */                                                 \
N  0x01,                                 /* bDelay */                                                        \
N  WBVAL(AUDIO_FORMAT_PCM),              /* wFormatTag */                                                    \
N                                                                                                            \
N/* Audio Type I Format */                                                                                   \
N  AUDIO_FORMAT_TYPE_I_DESC_SZ(1),       /* bLength */                                                       \
N  AUDIO_INTERFACE_DESCRIPTOR_TYPE,      /* bDescriptorType */                                               \
N  AUDIO_STREAMING_FORMAT_TYPE,          /* bDescriptorSubtype */                                            \
N  AUDIO_FORMAT_TYPE_I,                  /* bFormatType */                                                   \
N  0x01,                                 /* bNrChannels */                                                   \
N  USBD_ADC_BSUBFRAMESIZE,               /* bSubFrameSize */                                                 \
N  USBD_ADC_BBITRESOLUTION,              /* bBitResolution */                                                \
N  0x01,                                 /* bSamFreqType */                                                  \
N  B3VAL(USBD_ADC_TSAMFREQ),             /* tSamFreq */
X#define ADC_DESC                                                                                                                                                        USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          USBD_ADC_CIF_NUM,                                                                      0x00,                                                                                 0x00,                                                                                     USB_DEVICE_CLASS_AUDIO,                                                                 AUDIO_SUBCLASS_AUDIOCONTROL,                                                         AUDIO_PROTOCOL_UNDEFINED,                                                            USBD_ADC_CIF_STR_NUM,                                                                                                                                                        AUDIO_CONTROL_INTERFACE_DESC_SZ(1),                                                             AUDIO_INTERFACE_DESCRIPTOR_TYPE,                                                        AUDIO_CONTROL_HEADER,                                                                WBVAL(0x0100),                                                                          WBVAL(                                                                                       AUDIO_CONTROL_INTERFACE_DESC_SZ(1) +                                                                        AUDIO_INPUT_TERMINAL_DESC_SIZE     +                                                                        AUDIO_FEATURE_UNIT_DESC_SZ(1,1)    +                                                                        AUDIO_OUTPUT_TERMINAL_DESC_SIZE                                                                           ),                                                                                                          0x01,                                                                                     0x01,                                                                                                                                                                                                                                                                                    AUDIO_INPUT_TERMINAL_DESC_SIZE,                                                                 AUDIO_INTERFACE_DESCRIPTOR_TYPE,                                                        AUDIO_CONTROL_INPUT_TERMINAL,                                                        0x01,                                                                                       WBVAL(AUDIO_TERMINAL_USB_STREAMING),                                                      0x00,                                                                                    0x01,                                                                                       WBVAL(AUDIO_CHANNEL_M),                                                                  0x00,                                                                                     0x00,                                                                                                                                                                                                                                                                                          AUDIO_FEATURE_UNIT_DESC_SZ(1,1),                                                                AUDIO_INTERFACE_DESCRIPTOR_TYPE,                                                        AUDIO_CONTROL_FEATURE_UNIT,                                                          0x02,                                                                                           0x01,                                                                                         0x01,                                                                                      AUDIO_CONTROL_MUTE |                                                                                        AUDIO_CONTROL_VOLUME,                                                                    0x00,                                                                                    0x00,                                                                                                                                                                                                                                                                                       AUDIO_OUTPUT_TERMINAL_DESC_SIZE,                                                                AUDIO_INTERFACE_DESCRIPTOR_TYPE,                                                        AUDIO_CONTROL_OUTPUT_TERMINAL,                                                       0x03,                                                                                       WBVAL(AUDIO_TERMINAL_SPEAKER),                                                            0x00,                                                                                    0x02,                                                                                         0x00,                                                                                                                                                                                                                                             USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          USBD_ADC_SIF1_NUM,                                                                     0x00,                                                                                 0x00,                                                                                     USB_DEVICE_CLASS_AUDIO,                                                                 AUDIO_SUBCLASS_AUDIOSTREAMING,                                                       AUDIO_PROTOCOL_UNDEFINED,                                                            USBD_ADC_SIF1_STR_NUM,                                                                                                                                                                                                                             USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          USBD_ADC_SIF1_NUM,                                                                     0x01,                                                                                 0x01,                                                                                     USB_DEVICE_CLASS_AUDIO,                                                                 AUDIO_SUBCLASS_AUDIOSTREAMING,                                                       AUDIO_PROTOCOL_UNDEFINED,                                                            USBD_ADC_SIF2_STR_NUM,                                                                                                                                                                                                                                                                 AUDIO_STREAMING_INTERFACE_DESC_SIZE,                                                            AUDIO_INTERFACE_DESCRIPTOR_TYPE,                                                        AUDIO_STREAMING_GENERAL,                                                             0x01,                                                                                     0x01,                                                                                            WBVAL(AUDIO_FORMAT_PCM),                                                                                                                                                                                                                                                                     AUDIO_FORMAT_TYPE_I_DESC_SZ(1),                                                                 AUDIO_INTERFACE_DESCRIPTOR_TYPE,                                                        AUDIO_STREAMING_FORMAT_TYPE,                                                         AUDIO_FORMAT_TYPE_I,                                                                        0x01,                                                                                       USBD_ADC_BSUBFRAMESIZE,                                                                   USBD_ADC_BBITRESOLUTION,                                                                 0x01,                                                                                      B3VAL(USBD_ADC_TSAMFREQ),              
N
N#define ADC_EP                          /* ADC Endpoints for Low-speed/Full-speed */                        \
N/* Endpoint, EP ISO OUT - Standard Descriptor */                                                            \
N  AUDIO_STANDARD_ENDPOINT_DESC_SIZE,    /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_ADC_EP_ISOOUT), /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_ISOCHRONOUS,        /* bmAttributes */                                                  \
N  WBVAL(USBD_ADC_WMAXPACKETSIZE),       /* wMaxPacketSize */                                                \
N  USBD_ADC_BINTERVAL,                   /* bInterval */                                                     \
N  0x00,                                 /* bRefresh */                                                      \
N  0x00,                                 /* bSynchAddress */                                                 \
N                                                                                                            \
N/* Endpoint - Audio Streaming */                                                                            \
N  AUDIO_STREAMING_ENDPOINT_DESC_SIZE,   /* bLength */                                                       \
N  AUDIO_ENDPOINT_DESCRIPTOR_TYPE,       /* bDescriptorType */                                               \
N  AUDIO_ENDPOINT_GENERAL,               /* bDescriptor */                                                   \
N  0x00,                                 /* bmAttributes */                                                  \
N  0x00,                                 /* bLockDelayUnits */                                               \
N  WBVAL(0x0000),                        /* wLockDelay */
X#define ADC_EP                                                                                                                  AUDIO_STANDARD_ENDPOINT_DESC_SIZE,                                                              USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_ADC_EP_ISOOUT),                                                  USB_ENDPOINT_TYPE_ISOCHRONOUS,                                                             WBVAL(USBD_ADC_WMAXPACKETSIZE),                                                          USBD_ADC_BINTERVAL,                                                                           0x00,                                                                                          0x00,                                                                                                                                                                                                                                                                              AUDIO_STREAMING_ENDPOINT_DESC_SIZE,                                                             AUDIO_ENDPOINT_DESCRIPTOR_TYPE,                                                         AUDIO_ENDPOINT_GENERAL,                                                                     0x00,                                                                                      0x00,                                                                                   WBVAL(0x0000),                         
N
N#define ADC_EP_HS                       /* ADC Endpoints for High-speed */                                  \
N/* Endpoint, EP ISO OUT - Standard Descriptor */                                                            \
N  AUDIO_STANDARD_ENDPOINT_DESC_SIZE,    /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_ADC_EP_ISOOUT), /* bEndpointAddress */                                              \
N  USB_ENDPOINT_TYPE_ISOCHRONOUS,        /* bmAttributes */                                                  \
N  WBVAL(USBD_ADC_HS_WMAXPACKETSIZE),    /* wMaxPacketSize */                                                \
N  USBD_ADC_BINTERVAL,                   /* bInterval */                                                     \
N  0x00,                                 /* bRefresh */                                                      \
N  0x00,                                 /* bSynchAddress */                                                 \
N                                                                                                            \
N/* Endpoint - Audio Streaming */                                                                            \
N  AUDIO_STREAMING_ENDPOINT_DESC_SIZE,   /* bLength */                                                       \
N  AUDIO_ENDPOINT_DESCRIPTOR_TYPE,       /* bDescriptorType */                                               \
N  AUDIO_ENDPOINT_GENERAL,               /* bDescriptor */                                                   \
N  0x00,                                 /* bmAttributes */                                                  \
N  0x00,                                 /* bLockDelayUnits */                                               \
N  WBVAL(0x0000),                        /* wLockDelay */
X#define ADC_EP_HS                                                                                                                         AUDIO_STANDARD_ENDPOINT_DESC_SIZE,                                                              USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_ADC_EP_ISOOUT),                                                  USB_ENDPOINT_TYPE_ISOCHRONOUS,                                                             WBVAL(USBD_ADC_HS_WMAXPACKETSIZE),                                                       USBD_ADC_BINTERVAL,                                                                           0x00,                                                                                          0x00,                                                                                                                                                                                                                                                                              AUDIO_STREAMING_ENDPOINT_DESC_SIZE,                                                             AUDIO_ENDPOINT_DESCRIPTOR_TYPE,                                                         AUDIO_ENDPOINT_GENERAL,                                                                     0x00,                                                                                      0x00,                                                                                   WBVAL(0x0000),                         
N
N#define CDC_ACM_DESC_IAD(first,num_of_ifs)  /* CDC: Interface Association Descriptor */                     \
N  USB_INTERFACE_ASSOC_DESC_SIZE,        /* bLength */                                                       \
N  USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE,  /* bDescriptorType */                                         \
N (first),                               /* bFirstInterface */                                               \
N (num_of_ifs),                          /* bInterfaceCount */                                               \
N  CDC_COMMUNICATION_INTERFACE_CLASS,    /* bFunctionClass    (Communication Class) */                       \
N  CDC_ABSTRACT_CONTROL_MODEL,           /* bFunctionSubclass (Abstract Control Model) */                    \
N  0x01,                                 /* bFunctionProtocol (V.25ter, Common AT commands) */               \
N  USBD_CDC_ACM_CIF_STR_NUM,             /* iFunction */                                                     \
N
X#define CDC_ACM_DESC_IAD(first,num_of_ifs)                          USB_INTERFACE_ASSOC_DESC_SIZE,                                                                  USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE,                                             (first),                                                                                (num_of_ifs),                                                                            CDC_COMMUNICATION_INTERFACE_CLASS,                              CDC_ABSTRACT_CONTROL_MODEL,                                  0x01,                                                   USBD_CDC_ACM_CIF_STR_NUM,                                                                   
N#define CDC_ACM_DESC_IF0                                                                                        \
N/* Interface, Alternate Setting 0, CDC Class */                                                             \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  0x00,                                 /* bInterfaceNumber: Number of Interface USBD_CDC_ACM_CIF_NUM*/    \
N  0x00,                                 /* bAlternateSetting: Alternate setting */                          \
N  0x01,                                 /* bNumEndpoints: One endpoint used */                              \
N  CDC_COMMUNICATION_INTERFACE_CLASS,    /* bInterfaceClass: Communication Interface Class */                \
N  CDC_ABSTRACT_CONTROL_MODEL,           /* bInterfaceSubClass: Abstract Control Model */                    \
N  0x01,                                 /* bInterfaceProtocol: no protocol used */                          \
N  USBD_CDC_ACM_CIF_STR_NUM,             /* iInterface: */                                                   \
N                                                                                                            \
N/* Header Functional Descriptor */                                                                          \
N  CDC_HEADER_SIZE,                      /* bLength: Endpoint Descriptor size */                             \
N  CDC_CS_INTERFACE,                     /* bDescriptorType: CS_INTERFACE */                                 \
N  CDC_HEADER,                           /* bDescriptorSubtype: Header Func Desc */                          \
N  WBVAL(CDC_V1_10), /* 1.10 */          /* bcdCDC */                                                        \
N/* Call Management Functional Descriptor */                                                                 \
N  CDC_CALL_MANAGEMENT_SIZE,             /* bFunctionLength */                                               \
N  CDC_CS_INTERFACE,                     /* bDescriptorType: CS_INTERFACE */                                 \
N  CDC_CALL_MANAGEMENT,                  /* bDescriptorSubtype: Call Management Func Desc */                 \
N  0x03,                                 /* bmCapabilities: device handles call management */                \
N  0x02,                                 /* bDataInterface: CDC data IF ID */                                \
N/* Abstract Control Management Functional Descriptor */                                                     \
N  CDC_ABSTRACT_CONTROL_MANAGEMENT_SIZE, /* bFunctionLength */                                               \
N  CDC_CS_INTERFACE,                     /* bDescriptorType: CS_INTERFACE */                                 \
N  CDC_ABSTRACT_CONTROL_MANAGEMENT,      /* bDescriptorSubtype: Abstract Control Management desc */          \
N  0x06,                                 /* bmCapabilities: SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_LINE_STATE supported */ \
N/* Union Functional Descriptor */                                                                           \
N  CDC_UNION_SIZE,                       /* bFunctionLength */                                               \
N  CDC_CS_INTERFACE,                     /* bDescriptorType: CS_INTERFACE */                                 \
N  CDC_UNION,                            /* bDescriptorSubtype: Union func desc */                           \
N  0x00,                                 /* bMasterInterface: Communication class interface is master USBD_CDC_ACM_CIF_NUM*/ \
N  0x00,                                 /* bSlaveInterface0: Data class interface is slave 0 USBD_CDC_ACM_DIF_NUM*/
X#define CDC_ACM_DESC_IF0                                                                                                                                                        USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          0x00,                                        0x00,                                                              0x01,                                                                  CDC_COMMUNICATION_INTERFACE_CLASS,                       CDC_ABSTRACT_CONTROL_MODEL,                                  0x01,                                                              USBD_CDC_ACM_CIF_STR_NUM,                                                                                                                                                                                                                                                          CDC_HEADER_SIZE,                                                      CDC_CS_INTERFACE,                                                         CDC_HEADER,                                                        WBVAL(CDC_V1_10),                                                                                                                                         CDC_CALL_MANAGEMENT_SIZE,                                                               CDC_CS_INTERFACE,                                                         CDC_CALL_MANAGEMENT,                                      0x03,                                                    0x02,                                                                                                                          CDC_ABSTRACT_CONTROL_MANAGEMENT_SIZE,                                                   CDC_CS_INTERFACE,                                                         CDC_ABSTRACT_CONTROL_MANAGEMENT,                   0x06,                                                                                                                 CDC_UNION_SIZE,                                                                         CDC_CS_INTERFACE,                                                         CDC_UNION,                                                          0x00,                                     0x00,                                  
N
N#define CDC_ACM_EP_IF0                  /* CDC Endpoints for Interface 0 for Low-speed/Full-speed */        \
N/* Endpoint, EP Interrupt IN */         /* event notification (optional) */                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_CDC_ACM_EP_INTIN),/* bEndpointAddress */                                             \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_CDC_ACM_WMAXPACKETSIZE),   /* wMaxPacketSize */                                                \
N  USBD_CDC_ACM_BINTERVAL,               /* bInterval */
X#define CDC_ACM_EP_IF0                                                                         USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_CDC_ACM_EP_INTIN),                                                USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_CDC_ACM_WMAXPACKETSIZE),                                                      USBD_CDC_ACM_BINTERVAL,                
N
N#define CDC_ACM_EP_IF0_HS               /* CDC Endpoints for Interface 0 for High-speed */                  \
N/* Endpoint, EP Interrupt IN */         /* event notification (optional) */                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_CDC_ACM_EP_INTIN),/* bEndpointAddress */                                             \
N  USB_ENDPOINT_TYPE_INTERRUPT,          /* bmAttributes */                                                  \
N  WBVAL(USBD_CDC_ACM_HS_WMAXPACKETSIZE),/* wMaxPacketSize */                                                \
N  USBD_CDC_ACM_HS_BINTERVAL,            /* bInterval */
X#define CDC_ACM_EP_IF0_HS                                                                                USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_CDC_ACM_EP_INTIN),                                                USB_ENDPOINT_TYPE_INTERRUPT,                                                               WBVAL(USBD_CDC_ACM_HS_WMAXPACKETSIZE),                                                   USBD_CDC_ACM_HS_BINTERVAL,             
N
N#define CDC_ACM_DESC_IF1                                                                                        \
N/* Interface, Alternate Setting 0, Data class interface descriptor*/                                        \
N  USB_INTERFACE_DESC_SIZE,              /* bLength */                                                       \
N  USB_INTERFACE_DESCRIPTOR_TYPE,        /* bDescriptorType */                                               \
N  0x00,                                 /* bInterfaceNumber: Number of Interface USBD_CDC_ACM_DIF_NUM*/      \
N  0x00,                                 /* bAlternateSetting: no alternate setting */                       \
N  0x02,                                 /* bNumEndpoints: two endpoints used */                             \
N  CDC_DATA_INTERFACE_CLASS,             /* bInterfaceClass: Data Interface Class */                         \
N  0x00,                                 /* bInterfaceSubClass: no subclass available */                     \
N  0x00,                                 /* bInterfaceProtocol: no protocol used */                          \
N  USBD_CDC_ACM_DIF_STR_NUM,             /* iInterface */
X#define CDC_ACM_DESC_IF1                                                                                                                                   USB_INTERFACE_DESC_SIZE,                                                                        USB_INTERFACE_DESCRIPTOR_TYPE,                                                          0x00,                                          0x00,                                                           0x02,                                                                 CDC_DATA_INTERFACE_CLASS,                                         0x00,                                                         0x00,                                                              USBD_CDC_ACM_DIF_STR_NUM,              
N
N#define CDC_ACM_EP_IF1                  /* CDC Endpoints for Interface 1 for Low-speed/Full-speed */        \
N/* Endpoint, EP Bulk OUT */                                                                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_CDC_ACM_EP_BULKOUT),/* bEndpointAddress */                                          \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_CDC_ACM_WMAXPACKETSIZE1),  /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */                           \
N                                                                                                            \
N/* Endpoint, EP Bulk IN */                                                                                  \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_CDC_ACM_EP_BULKIN),/* bEndpointAddress */                                            \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_CDC_ACM_WMAXPACKETSIZE1),  /* wMaxPacketSize */                                                \
N  0x00,                                 /* bInterval: ignore for Bulk transfer */
X#define CDC_ACM_EP_IF1                                                                                                               USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_CDC_ACM_EP_BULKOUT),                                             USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_CDC_ACM_WMAXPACKETSIZE1),                                                     0x00,                                                                                                                                                                                                                                                              USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_CDC_ACM_EP_BULKIN),                                               USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_CDC_ACM_WMAXPACKETSIZE1),                                                     0x00,                                  
N
N#define CDC_ACM_EP_IF1_HS               /* CDC Endpoints for Interface 1 for High-speed */                  \
N/* Endpoint, EP Bulk OUT */                                                                                 \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_OUT(USBD_CDC_ACM_EP_BULKOUT),/* bEndpointAddress */                                          \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_CDC_ACM_HS_WMAXPACKETSIZE1),/* wMaxPacketSize */                                               \
N  USBD_CDC_ACM_HS_BINTERVAL1,           /* bInterval */                                                     \
N                                                                                                            \
N/* Endpoint, EP Bulk IN */                                                                                  \
N  USB_ENDPOINT_DESC_SIZE,               /* bLength */                                                       \
N  USB_ENDPOINT_DESCRIPTOR_TYPE,         /* bDescriptorType */                                               \
N  USB_ENDPOINT_IN(USBD_CDC_ACM_EP_BULKIN),/* bEndpointAddress */                                            \
N  USB_ENDPOINT_TYPE_BULK,               /* bmAttributes */                                                  \
N  WBVAL(USBD_CDC_ACM_HS_WMAXPACKETSIZE1),/* wMaxPacketSize */                                               \
N  USBD_CDC_ACM_HS_BINTERVAL1,           /* bInterval */
X#define CDC_ACM_EP_IF1_HS                                                                                                                      USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_OUT(USBD_CDC_ACM_EP_BULKOUT),                                             USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_CDC_ACM_HS_WMAXPACKETSIZE1),                                                  USBD_CDC_ACM_HS_BINTERVAL1,                                                                                                                                                                                                                                                                  USB_ENDPOINT_DESC_SIZE,                                                                         USB_ENDPOINT_DESCRIPTOR_TYPE,                                                           USB_ENDPOINT_IN(USBD_CDC_ACM_EP_BULKIN),                                               USB_ENDPOINT_TYPE_BULK,                                                                    WBVAL(USBD_CDC_ACM_HS_WMAXPACKETSIZE1),                                                  USBD_CDC_ACM_HS_BINTERVAL1,            
N
N/* USB Device Configuration Descriptor (for Full Speed) */
N/*   All Descriptors (Configuration, Interface, Endpoint, Class, Vendor) */
N__weak \
NU8 USBD_ConfigDescriptor[200] = { 0 };
X__weak U8 USBD_ConfigDescriptor[200] = { 0 };
N
N#if (USBD_HS_ENABLE == 0)               /* If High-speed not enabled, declare dummy descriptors for High-speed */
X#if (0 == 0)                
N__weak \
NU8 USBD_ConfigDescriptor_HS[] = { 0 };
X__weak U8 USBD_ConfigDescriptor_HS[] = { 0 };
N#else
S/* USB Device Configuration Descriptor (for High Speed) */
S/*   All Descriptors (Configuration, Interface, Endpoint, Class, Vendor) */
S__weak \
SU8 USBD_ConfigDescriptor_HS[200] = { 0 };
X__weak U8 USBD_ConfigDescriptor_HS[200] = { 0 };
S
N#endif
N
N/* USB Device Create String Descriptor */
N#define USBD_STR_DEF(n)                 \
N  struct {                              \
N    U8  len;                            \
N    U8  type;                           \
N    U16 str[sizeof(USBD_##n)/2-1];      \
N  } desc##n
X#define USBD_STR_DEF(n)                   struct {                                  U8  len;                                U8  type;                               U16 str[sizeof(USBD_##n)/2-1];        } desc##n
N
N#define USBD_STR_VAL(n)                  \
N { sizeof(USBD_##n), USB_STRING_DESCRIPTOR_TYPE, USBD_##n }
X#define USBD_STR_VAL(n)                   { sizeof(USBD_##n), USB_STRING_DESCRIPTOR_TYPE, USBD_##n }
N
N__weak \
Nconst struct {
X__weak const struct {
N    struct {
N        U8  len;
N        U8  type;
N        U16 langid;
N    } desc_langid;
N    USBD_STR_DEF(STRDESC_MAN);
X    struct { U8 len; U8 type; U16 str[sizeof(L"ARM")/2-1]; } descSTRDESC_MAN;
N    USBD_STR_DEF(STRDESC_PROD);
X    struct { U8 len; U8 type; U16 str[sizeof(L"DAPLink CMSIS-DAP")/2-1]; } descSTRDESC_PROD;
N#if  (USBD_STRDESC_SER_ENABLE)
X#if  (1)
N    USBD_STR_DEF(STRDESC_SER);
X    struct { U8 len; U8 type; U16 str[sizeof(L"0001A0000000")/2-1]; } descSTRDESC_SER;
N#endif
N#if (USBD_ADC_ENABLE)
X#if (0)
S    USBD_STR_DEF(ADC_CIF_STRDESC);
S    USBD_STR_DEF(ADC_SIF1_STRDESC);
S    USBD_STR_DEF(ADC_SIF2_STRDESC);
N#endif
N#if (USBD_CDC_ACM_ENABLE)
X#if (1)
N    USBD_STR_DEF(CDC_ACM_CIF_STRDESC);
X    struct { U8 len; U8 type; U16 str[sizeof(L"mbed Serial Port")/2-1]; } descCDC_ACM_CIF_STRDESC;
N    USBD_STR_DEF(CDC_ACM_DIF_STRDESC);
X    struct { U8 len; U8 type; U16 str[sizeof(L"mbed Serial Port")/2-1]; } descCDC_ACM_DIF_STRDESC;
N#endif
N#if (USBD_HID_ENABLE)
X#if (1)
N    USBD_STR_DEF(HID_STRDESC);
X    struct { U8 len; U8 type; U16 str[sizeof(L"CMSIS-DAP v1")/2-1]; } descHID_STRDESC;
N#endif
N#if (USBD_WEBUSB_ENABLE)
X#if (1)
N    USBD_STR_DEF(WEBUSB_STRDESC);
X    struct { U8 len; U8 type; U16 str[sizeof(L"WebUSB: CMSIS-DAP")/2-1]; } descWEBUSB_STRDESC;
N#endif
N#if (USBD_MSC_ENABLE)
X#if (1)
N    USBD_STR_DEF(MSC_STRDESC);
X    struct { U8 len; U8 type; U16 str[sizeof(L"USB_MSC")/2-1]; } descMSC_STRDESC;
N#endif
N#if (USBD_BULK_ENABLE)
X#if (1)
N    USBD_STR_DEF(BULK_STRDESC);
X    struct { U8 len; U8 type; U16 str[sizeof(L"CMSIS-DAP v2")/2-1]; } descBULK_STRDESC;
N#endif
N} USBD_StringDescriptor
N= {
N    { 4, USB_STRING_DESCRIPTOR_TYPE, USBD_STRDESC_LANGID },
X    { 4, 3, 0x0409 },
N    USBD_STR_VAL(STRDESC_MAN),
X    { sizeof(L"ARM"), 3, L"ARM" },
N    USBD_STR_VAL(STRDESC_PROD),
X    { sizeof(L"DAPLink CMSIS-DAP"), 3, L"DAPLink CMSIS-DAP" },
N#if (USBD_STRDESC_SER_ENABLE)
X#if (1)
N    USBD_STR_VAL(STRDESC_SER),
X    { sizeof(L"0001A0000000"), 3, L"0001A0000000" },
N#endif
N#if (USBD_ADC_ENABLE)
X#if (0)
S    USBD_STR_VAL(ADC_CIF_STRDESC),
S    USBD_STR_VAL(ADC_SIF1_STRDESC),
S    USBD_STR_VAL(ADC_SIF2_STRDESC),
N#endif
N#if (USBD_CDC_ACM_ENABLE)
X#if (1)
N    USBD_STR_VAL(CDC_ACM_CIF_STRDESC),
X    { sizeof(L"mbed Serial Port"), 3, L"mbed Serial Port" },
N    USBD_STR_VAL(CDC_ACM_DIF_STRDESC),
X    { sizeof(L"mbed Serial Port"), 3, L"mbed Serial Port" },
N#endif
N#if (USBD_HID_ENABLE)
X#if (1)
N    USBD_STR_VAL(HID_STRDESC),
X    { sizeof(L"CMSIS-DAP v1"), 3, L"CMSIS-DAP v1" },
N#endif
N#if (USBD_WEBUSB_ENABLE)
X#if (1)
N    USBD_STR_VAL(WEBUSB_STRDESC),
X    { sizeof(L"WebUSB: CMSIS-DAP"), 3, L"WebUSB: CMSIS-DAP" },
N#endif
N#if (USBD_MSC_ENABLE)
X#if (1)
N    USBD_STR_VAL(MSC_STRDESC),
X    { sizeof(L"USB_MSC"), 3, L"USB_MSC" },
N#endif
N#if (USBD_BULK_ENABLE)
X#if (1)
N    USBD_STR_VAL(BULK_STRDESC),
X    { sizeof(L"CMSIS-DAP v2"), 3, L"CMSIS-DAP v2" },
N#endif
N};
N
N#if (USBD_WEBUSB_ENABLE)
X#if (1)
N
N#define WEBUSB_NUM_FUNCTIONS              (1)
N
N#define WEBUSB_WTOTALLENGTH               (WEBUSB_DESCRIPTOR_SET_HEADER_SIZE +      \
N                                           WEBUSB_CONFIGURATION_SUBSET_HEADER_SIZE +\
N                                           (WEBUSB_NUM_FUNCTIONS * (WEBUSB_FUNCTION_SUBSET_HEADER_SIZE + 1)))
X#define WEBUSB_WTOTALLENGTH               (WEBUSB_DESCRIPTOR_SET_HEADER_SIZE +                                                 WEBUSB_CONFIGURATION_SUBSET_HEADER_SIZE +                                           (WEBUSB_NUM_FUNCTIONS * (WEBUSB_FUNCTION_SUBSET_HEADER_SIZE + 1)))
N
N/* WebUSB Create URL Descriptor */
N#define WEBUSB_URL_DEF(n)       \
N  struct {                      \
N    U8  bLength;                \
N    U8  bDescriptorType;        \
N    U8  bScheme;                \
N    U8  URL[sizeof(USBD_##n)+3];\
N  } url##n
X#define WEBUSB_URL_DEF(n)         struct {                          U8  bLength;                    U8  bDescriptorType;            U8  bScheme;                    U8  URL[sizeof(USBD_##n)+3];  } url##n
N
N#define WEBUSB_HTTP_URL_VAL(n)  \
N{                               \
N    (sizeof(USBD_##n) + 3) + 3, \
N    WEBUSB_URL_TYPE,            \
N    WEBUSB_URL_SCHEME_HTTP,     \
N    USBD_##n                    \
N}
X#define WEBUSB_HTTP_URL_VAL(n)  {                                   (sizeof(USBD_##n) + 3) + 3,     WEBUSB_URL_TYPE,                WEBUSB_URL_SCHEME_HTTP,         USBD_##n                    }
N
N#define WEBUSB_HTTPS_URL_VAL(n) \
N{                               \
N    (sizeof(USBD_##n) + 3) + 3, \
N    WEBUSB_URL_TYPE,            \
N    WEBUSB_URL_SCHEME_HTTPS,    \
N    USBD_##n                    \
N}
X#define WEBUSB_HTTPS_URL_VAL(n) {                                   (sizeof(USBD_##n) + 3) + 3,     WEBUSB_URL_TYPE,                WEBUSB_URL_SCHEME_HTTPS,        USBD_##n                    }
N
N__weak \
Nstruct {
X__weak struct {
N    WEBUSB_URL_DEF(WEBUSB_LANDING_URL);
X    struct { U8 bLength; U8 bDescriptorType; U8 bScheme; U8 URL[sizeof("os.mbed.com/webusb/landing-page/?bid=")+3]; } urlWEBUSB_LANDING_URL;
N    WEBUSB_URL_DEF(WEBUSB_ORIGIN_URL);
X    struct { U8 bLength; U8 bDescriptorType; U8 bScheme; U8 URL[sizeof("os.mbed.com/")+3]; } urlWEBUSB_ORIGIN_URL;
N} USBD_WebUSBURLDescriptor
N= {
N    WEBUSB_HTTPS_URL_VAL(WEBUSB_LANDING_URL),
X    { (sizeof("os.mbed.com/webusb/landing-page/?bid=") + 3) + 3, 0x03, 0x01, "os.mbed.com/webusb/landing-page/?bid=" },
N    WEBUSB_HTTPS_URL_VAL(WEBUSB_ORIGIN_URL),
X    { (sizeof("os.mbed.com/") + 3) + 3, 0x03, 0x01, "os.mbed.com/" },
N};
N
N#else
S
SU8 USBD_WebUSBURLDescriptor[] = { 0 };
S
SBOOL USBD_EndPoint0_Setup_WebUSB_ReqToDevice(void)
S{
S    return (__FALSE);
S}
S
N#endif  //USBD_WEBUSB_ENABLE
N
N
Nextern uint8_t flash_algo_valid(void);
N
Nstatic U16 start_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
N    U8 * pD = 0;
N    const U8 start_desc[] = { 
N        /* Configuration 1 */
N        USB_CONFIGUARTION_DESC_SIZE,                // bLength 
X        (sizeof(USB_CONFIGURATION_DESCRIPTOR)),                
N        USB_CONFIGURATION_DESCRIPTOR_TYPE,          // bDescriptorType 
X        2,          
N        WBVAL(USBD_WTOTALLENGTH_MAX),               // wTotalLength 
X        (((sizeof(USB_CONFIGURATION_DESCRIPTOR)) + ((1*(1|1|0|0|1|1)) * (sizeof(USB_INTERFACE_ASSOCIATION_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + 5 + 5 + 4 + 5 + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + (sizeof(HID_DESCRIPTOR)) + ((sizeof(USB_ENDPOINT_DESCRIPTOR))*((0 != 0)+(0 != 0)))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1) & 0xFF),((((sizeof(USB_CONFIGURATION_DESCRIPTOR)) + ((1*(1|1|0|0|1|1)) * (sizeof(USB_INTERFACE_ASSOCIATION_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + 5 + 5 + 4 + 5 + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + (sizeof(HID_DESCRIPTOR)) + ((sizeof(USB_ENDPOINT_DESCRIPTOR))*((0 != 0)+(0 != 0)))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1) >> 8) & 0xFF),               
N        USBD_IF_NUM_MAX,                            // bNumInterfaces 
X        (1+1+1+1+(0*2)+(1*2)+0),                            
N        0x01,                                       // bConfigurationValue: 0x01 is used to select this configuration 
N        0x00,                                       // iConfiguration: no string to describe this configuration 
N        USBD_CFGDESC_BMATTRIBUTES |                 // bmAttributes 
X        0x80 |                 
N        (USBD_POWER << 6),
X        (0 << 6),
N        USBD_CFGDESC_BMAXPOWER                      // bMaxPower, device power consumption 
X        0xFA                      
N    };
N    pD = config_desc;
N    memcpy(pD, start_desc, sizeof(start_desc));
N    
N#if (USBD_HS_ENABLE == 1)
X#if (0 == 1)
S    pD = config_desc_hs;
S    memcpy(pD, start_desc, sizeof(start_desc));
N#endif
N    
N    return sizeof(start_desc);
N}
N
Nstatic U16 hid_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
N    U8 * pD = 0;
N    const U8 hid_desc[] = {
N        HID_DESC
X        (sizeof(USB_INTERFACE_DESCRIPTOR)), 4, 0x00, 0x00, 0x00+(0 != 0)+(0 != 0), 0x03, 0x00, 0x00, (3+1+0*3+1*2), (sizeof(HID_DESCRIPTOR)), 0x21, (0x0100 & 0xFF),((0x0100 >> 8) & 0xFF), 0x00, 0x01, 0x22, ((sizeof(USBD_HID_ReportDescriptor)) & 0xFF),(((sizeof(USBD_HID_ReportDescriptor)) >> 8) & 0xFF),
N    #if ((USBD_HID_EP_INTOUT != 0) && (USBD_HID_EP_INTIN != 0))
X    #if ((0 != 0) && (0 != 0))
S        HID_EP_INOUT
S    #elif (USBD_HID_EP_INTIN != 0)
X    #elif (0 != 0)
S        HID_EP_IN
S    #elif (USBD_HID_EP_INTOUT != 0)
X    #elif (0 != 0)
S        HID_EP_OUT
N    #endif
N    };
N    pD = config_desc;
N    memcpy(pD, hid_desc, sizeof(hid_desc));
N    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N#if (USBD_HS_ENABLE == 1)  
X#if (0 == 1)  
S    const U8 hid_desc_hs[] = {
S        HID_DESC
S    #if ((USBD_HID_EP_INTOUT != 0) && (USBD_HID_EP_INTIN != 0))
S        HID_EP_INOUT_HS
S    #elif (USBD_HID_EP_INTIN != 0) //#else
S        HID_EP_IN_HS
S    #elif (USBD_HID_EP_INTOUT != 0)
S        HID_EP_OUT_HS
S    #endif
S    };
S    pD = config_desc_hs;
S    memcpy(pD, hid_desc_hs, sizeof(hid_desc_hs));
S    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N#endif    
N    return sizeof(hid_desc);
N}
N
Nstatic U16 acm_cdc_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
N    U8 * pD = 0;
N    const U8 cdc_desc[] = {
N    #if (USBD_MULTI_IF)
X    #if ((1*(1|1|0|0|1|1)))
N        CDC_ACM_DESC_IAD(0, 2)
X        (sizeof(USB_INTERFACE_ASSOCIATION_DESCRIPTOR)), 11, (0), (2), 0x02, 0x02, 0x01, (3+1+0*3+0),
N    #endif
N        CDC_ACM_DESC_IF0
X        (sizeof(USB_INTERFACE_DESCRIPTOR)), 4, 0x00, 0x00, 0x01, 0x02, 0x02, 0x01, (3+1+0*3+0), 5, 0x24, 0x00, (0x0110 & 0xFF),((0x0110 >> 8) & 0xFF), 5, 0x24, 0x01, 0x03, 0x02, 4, 0x24, 0x02, 0x06, 5, 0x24, 0x06, 0x00, 0x00,
N        CDC_ACM_EP_IF0
X        (sizeof(USB_ENDPOINT_DESCRIPTOR)), 5, ((3) | 0x80), 0x03, (16 & 0xFF),((16 >> 8) & 0xFF), 32,
N        CDC_ACM_DESC_IF1
X        (sizeof(USB_INTERFACE_DESCRIPTOR)), 4, 0x00, 0x00, 0x02, 0x0A, 0x00, 0x00, (3+1+0*3+1),
N        CDC_ACM_EP_IF1
X        (sizeof(USB_ENDPOINT_DESCRIPTOR)), 5, ((4) | 0x00), 0x02, (16 & 0xFF),((16 >> 8) & 0xFF), 0x00, (sizeof(USB_ENDPOINT_DESCRIPTOR)), 5, ((4) | 0x80), 0x02, (16 & 0xFF),((16 >> 8) & 0xFF), 0x00,
N    };
N    pD = config_desc;
N    memcpy(pD, cdc_desc, sizeof(cdc_desc));
N
N#if (USBD_MULTI_IF)
X#if ((1*(1|1|0|0|1|1)))
N    ((USB_INTERFACE_ASSOCIATION_DESCRIPTOR *)pD)->bFirstInterface = if_num;
N    pD += USB_INTERFACE_ASSOC_DESC_SIZE;
X    pD += (sizeof(USB_INTERFACE_ASSOCIATION_DESCRIPTOR));
N#endif    
N    
N    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N    pD += USB_INTERFACE_DESC_SIZE + CDC_HEADER_SIZE + CDC_CALL_MANAGEMENT_SIZE + CDC_ABSTRACT_CONTROL_MANAGEMENT_SIZE;
X    pD += (sizeof(USB_INTERFACE_DESCRIPTOR)) + 5 + 5 + 4;
N    ((UNION_FUNCTIONAL_DESCRIPTOR*)pD)->bMasterInterface = if_num;
N    ((UNION_FUNCTIONAL_DESCRIPTOR*)pD)->bSlaveInterface0 = if_num + 1;
N    pD += CDC_UNION_SIZE + USB_ENDPOINT_DESC_SIZE;
X    pD += 5 + (sizeof(USB_ENDPOINT_DESCRIPTOR));
N    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num + 1;
N
N#if (USBD_HS_ENABLE == 1)    
X#if (0 == 1)    
S    const U8 cdc_desc_hs[] = {
S    #if (USBD_MULTI_IF)
S        CDC_ACM_DESC_IAD(0, 2)
S    #endif
S        CDC_ACM_DESC_IF0
S        CDC_ACM_EP_IF0_HS
S        CDC_ACM_DESC_IF1
S        CDC_ACM_EP_IF1_HS
S    };
S     pD = config_desc_hs;
S    memcpy(pD, cdc_desc_hs, sizeof(cdc_desc_hs));
S    
S#if (USBD_MULTI_IF)
S    ((USB_INTERFACE_ASSOCIATION_DESCRIPTOR *)pD)->bFirstInterface = if_num;
S    pD += USB_INTERFACE_ASSOC_DESC_SIZE;
S#endif    
S    
S    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
S    pD += USB_INTERFACE_DESC_SIZE + CDC_HEADER_SIZE + CDC_CALL_MANAGEMENT_SIZE + CDC_ABSTRACT_CONTROL_MANAGEMENT_SIZE;
S    ((UNION_FUNCTIONAL_DESCRIPTOR*)pD)->bMasterInterface = if_num;
S    ((UNION_FUNCTIONAL_DESCRIPTOR*)pD)->bSlaveInterface0 = if_num + 1;
S    pD += CDC_UNION_SIZE + USB_ENDPOINT_DESC_SIZE;
S    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num +1 ;
N#endif  //(USBD_HS_ENABLE == 1)    
N    return sizeof(cdc_desc);
N}
N
Nstatic U16 msc_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
N    U8 * pD = 0;
N    const U8 msc_desc[] = { 
N        MSC_DESC
X        (sizeof(USB_INTERFACE_DESCRIPTOR)), 4, 0x00, 0x00, 0x02, 0x08, 0x06, 0x50, (3+1+0*3+1*2+1+1),
N        MSC_EP
X        (sizeof(USB_ENDPOINT_DESCRIPTOR)), 5, ((2) | 0x80), 0x02, (64 & 0xFF),((64 >> 8) & 0xFF), 0x00, (sizeof(USB_ENDPOINT_DESCRIPTOR)), 5, ((2) | 0x00), 0x02, (64 & 0xFF),((64 >> 8) & 0xFF), 0x00,
N    };
N    pD = config_desc;
N    memcpy(pD, msc_desc, sizeof(msc_desc));
N    
N    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N
N#if (USBD_HS_ENABLE == 1)     
X#if (0 == 1)     
S    const U8 msc_desc_hs[] = { 
S        MSC_DESC
S        MSC_EP_HS
S    };
S    pD = config_desc_hs;
S    memcpy(pD, msc_desc_hs, sizeof(msc_desc_hs));
S    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N#endif
N    
N    return sizeof(msc_desc);
N}
N
N#if (USBD_WEBUSB_ENABLE)
X#if (1)
Nstatic U16 webusb_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
N    U8 * pD = 0;
N    const U8 webusb_desc[] = {
N        WEBUSB_DESC
X        (sizeof(USB_INTERFACE_DESCRIPTOR)), 4, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, (3+1+0*3+1*2+1),
N    };
N    pD = config_desc;
N    memcpy(pD, webusb_desc, sizeof(webusb_desc));
N    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N    
N#if (USBD_HS_ENABLE == 1)
X#if (0 == 1)
S    pD = config_desc_hs;
S    memcpy(pD, webusb_desc, sizeof(webusb_desc));
S    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N#endif
N    
N#if (USBD_WINUSB_ENABLE)
X#if (1)
N    pD = USBD_WinUSBDescriptorSetDescriptor + WINUSB_DESCRIPTOR_SET_HEADER_SIZE;
X    pD = USBD_WinUSBDescriptorSetDescriptor + 10;
N    ((WINUSB_FUNCTION_SUBSET_HEADER*)pD)->bFirstInterface = if_num;
N#else
S#error "WEBUSB requires WINUSB!"
N#endif
N    
N    return sizeof(webusb_desc); 
N}
N#endif
N
N#if (USBD_BULK_ENABLE)
X#if (1)
Nstatic U16 bulk_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
N    U8 * pD = 0;
N    const U8 bulk_desc[] = { 
N        BULK_DESC
X        (sizeof(USB_INTERFACE_DESCRIPTOR)), 4, 0x00, 0x00, 0x02, 0xFF, 0x00, 0x00, (3+1+0*3+1*2+1+1+1),
N        BULK_EP
X        (sizeof(USB_ENDPOINT_DESCRIPTOR)), 5, ((1) | 0x00), 0x02, (64 & 0xFF),((64 >> 8) & 0xFF), 0x00, (sizeof(USB_ENDPOINT_DESCRIPTOR)), 5, ((1) | 0x80), 0x02, (64 & 0xFF),((64 >> 8) & 0xFF), 0x00,
N    };
N    pD = config_desc;
N    memcpy(pD, bulk_desc, sizeof(bulk_desc));
N    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N#if (USBD_HS_ENABLE == 1)   
X#if (0 == 1)   
S    const U8 bulk_desc_hs[] = { 
S        BULK_DESC
S        BULK_EP_HS
S    };
S     pD = config_desc_hs;
S    memcpy(pD, bulk_desc_hs, sizeof(bulk_desc_hs));
S    ((USB_INTERFACE_DESCRIPTOR *)pD)->bInterfaceNumber = if_num;
N#endif
N
N#if (USBD_WINUSB_ENABLE)
X#if (1)
N    pD = USBD_WinUSBDescriptorSetDescriptor + WINUSB_DESCRIPTOR_SET_HEADER_SIZE;
X    pD = USBD_WinUSBDescriptorSetDescriptor + 10;
N#if (USBD_WEBUSB_ENABLE)
X#if (1)
N    pD += WINUSB_FUNCTION_SUBSET_HEADER_SIZE + WINUSB_FEATURE_COMPATIBLE_ID_SIZE + DEVICE_INTERFACE_GUIDS_FEATURE_LEN;
X    pD += 8 + 20 + 132;
N#endif
N    ((WINUSB_FUNCTION_SUBSET_HEADER*)pD)->bFirstInterface = if_num;
N#else
S#error "BULK interfaces requires WINUSB!"
N#endif
N    
N    return sizeof(bulk_desc);
N}
N#endif
N
Nvoid usbd_class_init(void)
N{   
N    U8  if_num = 0;
N    U16 desc_ptr = 0;
N    
N    desc_ptr += start_desc_fill(&USBD_ConfigDescriptor[desc_ptr], &USBD_ConfigDescriptor_HS[desc_ptr], if_num);    
N    
N#if (USBD_ADC_ENABLE)
X#if (0)
S    usbd_adc_init();
N#endif
N
N
N#if (USBD_MSC_ENABLE)        
X#if (1)        
N    
N#if !(defined(DAPLINK_BL)) &&  defined(DRAG_N_DROP_SUPPORT)
X#if !(0L) &&  1L
N    //change descriptors here
N    if (config_ram_get_disable_msd() == 1 || flash_algo_valid()==0 ){
N        usbd_if_num -= USBD_MSC_ENABLE;
X        usbd_if_num -= 1;
N        USB_CONFIGURATION_DESCRIPTOR * usb_conf_desc = (USB_CONFIGURATION_DESCRIPTOR *)USBD_ConfigDescriptor;
N        usb_conf_desc->bNumInterfaces = usbd_if_num;
N        U16 usb_wtotal_len = USBD_WTOTALLENGTH_MAX - (USBD_MSC_DESC_LEN     * USBD_MSC_ENABLE);
X        U16 usb_wtotal_len = ((sizeof(USB_CONFIGURATION_DESCRIPTOR)) + ((1*(1|1|0|0|1|1)) * (sizeof(USB_INTERFACE_ASSOCIATION_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + 5 + 5 + 4 + 5 + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_INTERFACE_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR)) + (sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + (sizeof(HID_DESCRIPTOR)) + ((sizeof(USB_ENDPOINT_DESCRIPTOR))*((0 != 0)+(0 != 0)))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1 + ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR))) * 1) - (((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR)))     * 1);
N        usb_conf_desc->wTotalLength = usb_wtotal_len;
N        USBD_ConfigDescriptor[usb_wtotal_len] = 0;
N        USBD_HID_DescriptorOffset -= USBD_MSC_ENABLE * USBD_MSC_DESC_LEN;
X        USBD_HID_DescriptorOffset -= 1 * ((sizeof(USB_INTERFACE_DESCRIPTOR)) + 2*(sizeof(USB_ENDPOINT_DESCRIPTOR)));
N#if (USBD_HS_ENABLE == 1)
X#if (0 == 1)
S        usb_conf_desc = (USB_CONFIGURATION_DESCRIPTOR *)USBD_ConfigDescriptor_HS;
S        usb_conf_desc->bNumInterfaces = usbd_if_num;
S        usb_conf_desc->wTotalLength = usb_wtotal_len;
S        USBD_ConfigDescriptor_HS[usb_wtotal_len] = 0;
N#endif         
N    } else
N#endif
N    {
N    usbd_msc_if_num = if_num++;
N    desc_ptr += msc_desc_fill(&USBD_ConfigDescriptor[desc_ptr], &USBD_ConfigDescriptor_HS[desc_ptr], usbd_msc_if_num);
N    usbd_msc_init();
N
N    }
N#endif //#if (USBD_MSC_ENABLE)  
N
N#if (USBD_CDC_ACM_ENABLE)
X#if (1)
N    usbd_cdc_acm_cif_num = if_num++;
N    usbd_cdc_acm_dif_num = if_num++;
N    desc_ptr += acm_cdc_desc_fill(&USBD_ConfigDescriptor[desc_ptr], &USBD_ConfigDescriptor_HS[desc_ptr], usbd_cdc_acm_cif_num);
N    USBD_CDC_ACM_Initialize();
N#endif
N
N#if (USBD_HID_ENABLE) 
X#if (1) 
N    usbd_hid_if_num = if_num++;
N    desc_ptr += hid_desc_fill(&USBD_ConfigDescriptor[desc_ptr], &USBD_ConfigDescriptor_HS[desc_ptr], usbd_hid_if_num);
N    usbd_hid_init();
N#endif
N
N#if (USBD_WEBUSB_ENABLE)
X#if (1)
N    usbd_webusb_if_num = if_num++;   
N    desc_ptr += webusb_desc_fill(&USBD_ConfigDescriptor[desc_ptr], &USBD_ConfigDescriptor_HS[desc_ptr], usbd_webusb_if_num);
N#endif
N
N#if (USBD_BULK_ENABLE)
X#if (1)
N    usbd_bulk_if_num = if_num++;  
N    desc_ptr += bulk_desc_fill(&USBD_ConfigDescriptor[desc_ptr], &USBD_ConfigDescriptor_HS[desc_ptr], usbd_bulk_if_num);
N    usbd_bulk_init();
N#endif
N
N#if (USBD_CLS_ENABLE)
X#if (0)
S    usbd_cls_init();
N#endif
N
N}
N
N#endif  //USBD_ENABLE
N
N#endif  /* __USB_CONFIG__ */
L 552 "..\..\..\source\hic_hal\stm32\stm32f103xb\usb_config.c" 2
N#endif
N
N#endif  /* __USB_CONFIG__ */
