; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\swd_host.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\swd_host.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\swd_host.crf ..\..\..\source\daplink\interface\swd_host.c]
                          THUMB

                          AREA ||i.JTAG2SWD||, CODE, READONLY, ALIGN=1

                  JTAG2SWD PROC
;;;779    
;;;780    uint8_t JTAG2SWD()
000000  b51c              PUSH     {r2-r4,lr}
;;;781    {
;;;782        uint32_t tmp = 0;
;;;783    
;;;784        if (!swd_reset()) {
000002  f7fffffe          BL       swd_reset
000006  2800              CMP      r0,#0
000008  d01b              BEQ      |L1.66|
00000a  209e              MOVS     r0,#0x9e
00000c  f88d0000          STRB     r0,[sp,#0]
000010  20e7              MOVS     r0,#0xe7
000012  f88d0001          STRB     r0,[sp,#1]
000016  4669              MOV      r1,sp
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       SWJ_Sequence
;;;785            return 0;
;;;786        }
;;;787    
;;;788        if (!swd_switch(0xE79E)) {
;;;789            return 0;
;;;790        }
;;;791    
;;;792        if (!swd_reset()) {
00001e  f7fffffe          BL       swd_reset
000022  2800              CMP      r0,#0                 ;788
000024  d00d              BEQ      |L1.66|
000026  2000              MOVS     r0,#0                 ;788
000028  f88d0000          STRB     r0,[sp,#0]            ;788
00002c  4669              MOV      r1,sp                 ;788
00002e  2008              MOVS     r0,#8                 ;788
000030  f7fffffe          BL       SWJ_Sequence
000034  a901              ADD      r1,sp,#4              ;788
000036  2000              MOVS     r0,#0                 ;788
000038  f7fffffe          BL       swd_read_dp
00003c  2801              CMP      r0,#1                 ;788
00003e  d000              BEQ      |L1.66|
;;;793            return 0;
;;;794        }
;;;795    
;;;796        if (!swd_read_idcode(&tmp)) {
;;;797            return 0;
000040  2000              MOVS     r0,#0
                  |L1.66|
;;;798        }
;;;799    
;;;800        return 1;
;;;801    }
000042  bd1c              POP      {r2-r4,pc}
;;;802    
                          ENDP


                          AREA ||i.PORT_SWD_SETUP||, CODE, READONLY, ALIGN=2

                  PORT_SWD_SETUP PROC
;;;234    */
;;;235    __STATIC_INLINE void PORT_SWD_SETUP(void)
000000  b570              PUSH     {r4-r6,lr}
;;;236    {
;;;237        // Set SWCLK HIGH
;;;238        pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);
000002  4c0f              LDR      r4,|L2.64|
000004  210d              MOVS     r1,#0xd
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       pin_out_init
;;;239        SWCLK_TCK_PIN_PORT->BSRR = SWCLK_TCK_PIN;
00000c  4d0c              LDR      r5,|L2.64|
00000e  1460              ASRS     r0,r4,#17
000010  3510              ADDS     r5,r5,#0x10
000012  6028              STR      r0,[r5,#0]
;;;240        // Set SWDIO HIGH
;;;241        pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);
000014  210c              MOVS     r1,#0xc
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pin_out_init
;;;242        SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
00001c  14a0              ASRS     r0,r4,#18
00001e  6028              STR      r0,[r5,#0]
;;;243    
;;;244        pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, 1);
000020  2201              MOVS     r2,#1
000022  210e              MOVS     r1,#0xe
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       pin_in_init
00002a  6820              LDR      r0,[r4,#0]
00002c  f020000f          BIC      r0,r0,#0xf
000030  6020              STR      r0,[r4,#0]
000032  6820              LDR      r0,[r4,#0]
000034  f0400007          ORR      r0,r0,#7
000038  6020              STR      r0,[r4,#0]
;;;245        // Set RESET HIGH
;;;246        pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);//TODO - fix reset logic
;;;247        nRESET_PIN_PORT->BSRR = nRESET_PIN;
00003a  2001              MOVS     r0,#1
00003c  6028              STR      r0,[r5,#0]
;;;248    }
00003e  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

                  |L2.64|
                          DCD      0x40010c00

                          AREA ||i.int2array||, CODE, READONLY, ALIGN=1

                  int2array PROC
;;;84     
;;;85     void int2array(uint8_t *res, uint32_t data, uint8_t len)
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87         uint8_t i = 0;
000002  2300              MOVS     r3,#0
000004  e005              B        |L3.18|
                  |L3.6|
;;;88     
;;;89         for (i = 0; i < len; i++) {
;;;90             res[i] = (data >> 8 * i) & 0xff;
000006  00dc              LSLS     r4,r3,#3
000008  fa21f404          LSR      r4,r1,r4
00000c  54c4              STRB     r4,[r0,r3]
00000e  1c5b              ADDS     r3,r3,#1
000010  b2db              UXTB     r3,r3                 ;89
                  |L3.18|
000012  4293              CMP      r3,r2                 ;89
000014  d3f7              BCC      |L3.6|
;;;91         }
;;;92     }
000016  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.pin_in_init||, CODE, READONLY, ALIGN=1

                  pin_in_init PROC
;;;150    
;;;151    __STATIC_INLINE void pin_in_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit, uint8_t mode)
000000  b570              PUSH     {r4-r6,lr}
;;;152    {
;;;153        uint8_t config;
;;;154        if(mode == 1)
000002  2a01              CMP      r2,#1
000004  d012              BEQ      |L4.44|
;;;155            config = 0x08; //Up
;;;156        else if(mode == 2)
000006  2a02              CMP      r2,#2
000008  d010              BEQ      |L4.44|
;;;157            config = 0x08; //down
;;;158        else
;;;159            config = 0x00; //GPIO_Mode_AIN
00000a  2300              MOVS     r3,#0
                  |L4.12|
00000c  2401              MOVS     r4,#1                 ;152
;;;160    
;;;161        if(pin_bit >= 8)
;;;162        {
;;;163            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
;;;164            GPIOx->CRH |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit-8) << 2) );
;;;165            if(mode == 1)
;;;166                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
00000e  408c              LSLS     r4,r4,r1
000010  260f              MOVS     r6,#0xf               ;163
000012  008d              LSLS     r5,r1,#2              ;163
000014  2908              CMP      r1,#8                 ;161
000016  d311              BCC      |L4.60|
000018  3d20              SUBS     r5,r5,#0x20           ;161
00001a  6841              LDR      r1,[r0,#4]            ;163
00001c  40ae              LSLS     r6,r6,r5              ;163
00001e  43b1              BICS     r1,r1,r6              ;163
000020  6041              STR      r1,[r0,#4]            ;163
000022  6841              LDR      r1,[r0,#4]            ;164
000024  40ab              LSLS     r3,r3,r5              ;164
000026  430b              ORRS     r3,r3,r1              ;164
000028  6043              STR      r3,[r0,#4]            ;164
00002a  e00f              B        |L4.76|
                  |L4.44|
00002c  2308              MOVS     r3,#8                 ;157
00002e  e7ed              B        |L4.12|
                  |L4.48|
000030  6104              STR      r4,[r0,#0x10]
                  |L4.50|
;;;167            else if(mode == 2)
;;;168                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;169        }
;;;170        else
;;;171        {
;;;172            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;173            GPIOx->CRL |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit) << 2) );
;;;174            if(mode == 1)
;;;175                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
;;;176            else if(mode == 2)
;;;177                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;178        }
;;;179    }
000032  bd70              POP      {r4-r6,pc}
                  |L4.52|
000034  2a02              CMP      r2,#2                 ;167
000036  d1fc              BNE      |L4.50|
000038  6144              STR      r4,[r0,#0x14]         ;168
00003a  bd70              POP      {r4-r6,pc}
                  |L4.60|
00003c  6801              LDR      r1,[r0,#0]            ;172
00003e  40ae              LSLS     r6,r6,r5              ;172
000040  43b1              BICS     r1,r1,r6              ;172
000042  6001              STR      r1,[r0,#0]            ;172
000044  6801              LDR      r1,[r0,#0]            ;173
000046  40ab              LSLS     r3,r3,r5              ;173
000048  430b              ORRS     r3,r3,r1              ;173
00004a  6003              STR      r3,[r0,#0]            ;173
                  |L4.76|
00004c  2a01              CMP      r2,#1                 ;174
00004e  d1f1              BNE      |L4.52|
000050  e7ee              B        |L4.48|
;;;180    //**************************************************************************************************
                          ENDP


                          AREA ||i.pin_out_init||, CODE, READONLY, ALIGN=1

                  pin_out_init PROC
;;;122    
;;;123    __STATIC_INLINE void pin_out_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125        if(pin_bit >= 8)
;;;126        {
;;;127            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
000002  230f              MOVS     r3,#0xf
;;;128            GPIOx->CRH |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit-8) << 2) );
000004  2403              MOVS     r4,#3
000006  008a              LSLS     r2,r1,#2              ;127
000008  2908              CMP      r1,#8                 ;125
00000a  d309              BCC      |L5.32|
00000c  3a20              SUBS     r2,r2,#0x20           ;124
00000e  6841              LDR      r1,[r0,#4]            ;127
000010  4093              LSLS     r3,r3,r2              ;127
000012  4399              BICS     r1,r1,r3              ;127
000014  6041              STR      r1,[r0,#4]            ;127
000016  6841              LDR      r1,[r0,#4]
000018  4094              LSLS     r4,r4,r2
00001a  430c              ORRS     r4,r4,r1
00001c  6044              STR      r4,[r0,#4]
;;;129        }
;;;130        else
;;;131        {
;;;132            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;133            GPIOx->CRL |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit) << 2) );
;;;134        }
;;;135    }
00001e  bd10              POP      {r4,pc}
                  |L5.32|
000020  6801              LDR      r1,[r0,#0]            ;132
000022  4093              LSLS     r3,r3,r2              ;132
000024  4399              BICS     r1,r1,r3              ;132
000026  6001              STR      r1,[r0,#0]            ;132
000028  6801              LDR      r1,[r0,#0]            ;133
00002a  4094              LSLS     r4,r4,r2              ;133
00002c  4321              ORRS     r1,r1,r4              ;133
00002e  6001              STR      r1,[r0,#0]            ;133
000030  bd10              POP      {r4,pc}
;;;136    
                          ENDP


                          AREA ||i.swd_clear_errors||, CODE, READONLY, ALIGN=1

                  swd_clear_errors PROC
;;;130    
;;;131    uint8_t swd_clear_errors(void)
000000  b510              PUSH     {r4,lr}
;;;132    {
;;;133        if (!swd_write_dp(DP_ABORT, STKCMPCLR | STKERRCLR | WDERRCLR | ORUNERRCLR)) {
000002  211e              MOVS     r1,#0x1e
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       swd_write_dp
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L6.16|
;;;134            return 0;
;;;135        }
;;;136        return 1;
00000e  2001              MOVS     r0,#1
                  |L6.16|
;;;137    }
000010  bd10              POP      {r4,pc}
;;;138    
                          ENDP


                          AREA ||i.swd_flash_syscall_exec||, CODE, READONLY, ALIGN=2

                  swd_flash_syscall_exec PROC
;;;691    
;;;692    uint8_t swd_flash_syscall_exec(const program_syscall_t *sysCallParam, uint32_t entry, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4, flash_algo_return_t return_type)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;693    {
000004  b092              SUB      sp,sp,#0x48
000006  460d              MOV      r5,r1
000008  e9dd981a          LDRD     r9,r8,[sp,#0x68]
00000c  4604              MOV      r4,r0
00000e  461e              MOV      r6,r3
000010  4617              MOV      r7,r2
;;;694        DEBUG_STATE state = {{0}, 0};
000012  2144              MOVS     r1,#0x44
000014  4668              MOV      r0,sp
000016  f8dda070          LDR      r10,[sp,#0x70]
00001a  f7fffffe          BL       __aeabi_memclr4
;;;695        // Call flash algorithm function on target and wait for result.
;;;696        state.r[0]     = arg1;                   // R0: Argument 1
;;;697        state.r[1]     = arg2;                   // R1: Argument 2
;;;698        state.r[2]     = arg3;                   // R2: Argument 3
;;;699        state.r[3]     = arg4;                   // R3: Argument 4
;;;700        state.r[9]     = sysCallParam->static_base;    // SB: Static Base
00001e  e9cd7600          STRD     r7,r6,[sp,#0]
000022  e9cd9802          STRD     r9,r8,[sp,#8]
000026  1d20              ADDS     r0,r4,#4
000028  f7fffffe          BL       __aeabi_uread4
;;;701        state.r[13]    = sysCallParam->stack_pointer;  // SP: Stack Pointer
00002c  9009              STR      r0,[sp,#0x24]
00002e  f1040008          ADD      r0,r4,#8
000032  f7fffffe          BL       __aeabi_uread4
;;;702        state.r[14]    = sysCallParam->breakpoint;     // LR: Exit Point
000036  900d              STR      r0,[sp,#0x34]
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       __aeabi_uread4
00003e  e9cd050e          STRD     r0,r5,[sp,#0x38]
;;;703        state.r[15]    = entry;                        // PC: Entry Point
;;;704        state.xpsr     = 0x01000000;          // xPSR: T = 1, ISR = 0
000042  f04f7080          MOV      r0,#0x1000000
;;;705    
;;;706        if (!swd_write_debug_state(&state)) {
000046  9010              STR      r0,[sp,#0x40]
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       swd_write_debug_state
00004e  2800              CMP      r0,#0
000050  d01d              BEQ      |L7.142|
000052  4d15              LDR      r5,|L7.168|
000054  f8df8054          LDR      r8,|L7.172|
000058  2400              MOVS     r4,#0
                  |L7.90|
00005a  a911              ADD      r1,sp,#0x44
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       swd_read_word
000062  b198              CBZ      r0,|L7.140|
000064  9811              LDR      r0,[sp,#0x44]
000066  0380              LSLS     r0,r0,#14
000068  d514              BPL      |L7.148|
;;;707            return 0;
;;;708        }
;;;709    
;;;710        if (!swd_wait_until_halted()) {
;;;711            return 0;
;;;712        }
;;;713    
;;;714        if (!swd_read_core_register(0, &state.r[0])) {
00006a  4669              MOV      r1,sp
00006c  2000              MOVS     r0,#0
00006e  f7fffffe          BL       swd_read_core_register
000072  2800              CMP      r0,#0
000074  d00b              BEQ      |L7.142|
;;;715            return 0;
;;;716        }
;;;717    
;;;718        //remove the C_MASKINTS
;;;719        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT)) {
000076  490e              LDR      r1,|L7.176|
000078  4640              MOV      r0,r8
00007a  f7fffffe          BL       swd_write_word
00007e  2800              CMP      r0,#0
000080  d005              BEQ      |L7.142|
;;;720            return 0;
;;;721        }
;;;722    
;;;723        if ( return_type == FLASHALGO_RETURN_POINTER ) {
000082  9800              LDR      r0,[sp,#0]
000084  f1ba0f01          CMP      r10,#1
000088  d008              BEQ      |L7.156|
;;;724            // Flash verify functions return pointer to byte following the buffer if successful.
;;;725            if (state.r[0] != (arg1 + arg2)) {
;;;726                return 0;
;;;727            }
;;;728        }
;;;729        else {
;;;730            // Flash functions return 0 if successful.
;;;731            if (state.r[0] != 0) {
00008a  b150              CBZ      r0,|L7.162|
                  |L7.140|
;;;732                return 0;
00008c  2000              MOVS     r0,#0
                  |L7.142|
;;;733            }
;;;734        }
;;;735    
;;;736        return 1;
;;;737    }
00008e  b012              ADD      sp,sp,#0x48
000090  e8bd87f0          POP      {r4-r10,pc}
                  |L7.148|
000094  1c64              ADDS     r4,r4,#1
000096  42ac              CMP      r4,r5
000098  d3df              BCC      |L7.90|
00009a  e7f7              B        |L7.140|
                  |L7.156|
00009c  19b9              ADDS     r1,r7,r6              ;725
00009e  4288              CMP      r0,r1                 ;725
0000a0  d1f4              BNE      |L7.140|
                  |L7.162|
0000a2  2001              MOVS     r0,#1                 ;736
0000a4  e7f3              B        |L7.142|
;;;738    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L7.168|
                          DCD      0x000f4240
                  |L7.172|
                          DCD      0xe000edf0
                  |L7.176|
                          DCD      0xa05f0003

                          AREA ||i.swd_get_apsel||, CODE, READONLY, ALIGN=1

                  swd_get_apsel PROC
;;;70     
;;;71     static uint32_t swd_get_apsel(uint32_t adr)
000000  b510              PUSH     {r4,lr}
;;;72     {
000002  4604              MOV      r4,r0
;;;73         uint32_t apsel = target_get_apsel();
000004  f7fffffe          BL       target_get_apsel
;;;74         if (!apsel)
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L8.16|
;;;75             return adr & 0xff000000;
00000c  f004407f          AND      r0,r4,#0xff000000
                  |L8.16|
;;;76         else
;;;77             return apsel;
;;;78     }
000010  bd10              POP      {r4,pc}
;;;79     
                          ENDP


                          AREA ||i.swd_init||, CODE, READONLY, ALIGN=1

                  swd_init PROC
;;;114    
;;;115    uint8_t swd_init(void)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117        //TODO - DAP_Setup puts GPIO pins in a hi-z state which can
;;;118        //       cause problems on re-init.  This needs to be investigated
;;;119        //       and fixed.
;;;120        DAP_Setup();
000002  f7fffffe          BL       DAP_Setup
;;;121        PORT_SWD_SETUP();
000006  f7fffffe          BL       PORT_SWD_SETUP
;;;122        return 1;
00000a  2001              MOVS     r0,#1
;;;123    }
00000c  bd10              POP      {r4,pc}
;;;124    
                          ENDP


                          AREA ||i.swd_init_debug||, CODE, READONLY, ALIGN=2

                  swd_init_debug PROC
;;;802    
;;;803    uint8_t swd_init_debug(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;804    {
;;;805        uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;806        int i = 0;
;;;807        int timeout = 100;
;;;808        // init dap state with fake values
;;;809        dap_state.select = 0xffffffff;
000006  1e41              SUBS     r1,r0,#1
000008  9000              STR      r0,[sp,#0]
00000a  4832              LDR      r0,|L10.212|
00000c  2664              MOVS     r6,#0x64              ;807
;;;810        dap_state.csw = 0xffffffff;
;;;811    
;;;812        int8_t retries = 4;
00000e  2704              MOVS     r7,#4
000010  6001              STR      r1,[r0,#0]            ;810  ; dap_state
;;;813        int8_t do_abort = 0;
000012  2400              MOVS     r4,#0
;;;814        do {
;;;815            if (do_abort) {
;;;816                //do an abort on stale target, then reset the device
;;;817                swd_write_dp(DP_ABORT, DAPABORT);
;;;818                swd_set_target_reset(1);
;;;819                osDelay(2);
;;;820                swd_set_target_reset(0);
;;;821                osDelay(2);
;;;822                do_abort = 0;
;;;823            }
;;;824            swd_init();
;;;825            // call a target dependant function
;;;826            // this function can do several stuff before really
;;;827            // initing the debug
;;;828            if (g_target_family && g_target_family->target_before_init_debug) {
000014  f8df80c0          LDR      r8,|L10.216|
000018  6041              STR      r1,[r0,#4]            ;804  ; dap_state
00001a  e011              B        |L10.64|
                  |L10.28|
00001c  b184              CBZ      r4,|L10.64|
00001e  2101              MOVS     r1,#1                 ;817
000020  2000              MOVS     r0,#0                 ;817
000022  f7fffffe          BL       swd_write_dp
000026  2001              MOVS     r0,#1                 ;818
000028  f7fffffe          BL       swd_set_target_reset
00002c  2002              MOVS     r0,#2                 ;819
00002e  f7fffffe          BL       osDelay
000032  2000              MOVS     r0,#0                 ;820
000034  f7fffffe          BL       swd_set_target_reset
000038  2002              MOVS     r0,#2                 ;821
00003a  f7fffffe          BL       osDelay
00003e  2400              MOVS     r4,#0                 ;822
                  |L10.64|
000040  f7fffffe          BL       swd_init
000044  f8d80000          LDR      r0,[r8,#0]  ; g_target_family
000048  b110              CBZ      r0,|L10.80|
00004a  6880              LDR      r0,[r0,#8]
00004c  b100              CBZ      r0,|L10.80|
;;;829                g_target_family->target_before_init_debug();
00004e  4780              BLX      r0
                  |L10.80|
;;;830            }
;;;831    
;;;832            if (!JTAG2SWD()) {
000050  f7fffffe          BL       JTAG2SWD
000054  b3a0              CBZ      r0,|L10.192|
;;;833                do_abort = 1;
;;;834                continue;
;;;835            }
;;;836    
;;;837            if (!swd_clear_errors()) {
000056  f7fffffe          BL       swd_clear_errors
00005a  b388              CBZ      r0,|L10.192|
;;;838                do_abort = 1;
;;;839                continue;
;;;840            }
;;;841    
;;;842            if (!swd_write_dp(DP_SELECT, 0)) {
00005c  2100              MOVS     r1,#0
00005e  2008              MOVS     r0,#8
000060  f7fffffe          BL       swd_write_dp
000064  b360              CBZ      r0,|L10.192|
;;;843                do_abort = 1;
;;;844                continue;
;;;845    
;;;846            }
;;;847    
;;;848            // Power up
;;;849            if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
000066  f04f41a0          MOV      r1,#0x50000000
00006a  2004              MOVS     r0,#4
00006c  f7fffffe          BL       swd_write_dp
000070  b330              CBZ      r0,|L10.192|
;;;850                do_abort = 1;
;;;851                continue;
;;;852            }
;;;853    
;;;854            for (i = 0; i < timeout; i++) {
000072  2500              MOVS     r5,#0
;;;855                if (!swd_read_dp(DP_CTRL_STAT, &tmp)) {
;;;856                    do_abort = 1;
;;;857                    break;
;;;858                }
;;;859                if ((tmp & (CDBGPWRUPACK | CSYSPWRUPACK)) == (CDBGPWRUPACK | CSYSPWRUPACK)) {
000074  f04f4920          MOV      r9,#0xa0000000
000078  e009              B        |L10.142|
                  |L10.122|
00007a  4669              MOV      r1,sp                 ;855
00007c  2004              MOVS     r0,#4                 ;855
00007e  f7fffffe          BL       swd_read_dp
000082  b1f0              CBZ      r0,|L10.194|
000084  9900              LDR      r1,[sp,#0]
000086  ea390001          BICS     r0,r9,r1
00008a  d002              BEQ      |L10.146|
00008c  1c6d              ADDS     r5,r5,#1
                  |L10.142|
00008e  42b5              CMP      r5,r6                 ;854
000090  dbf3              BLT      |L10.122|
                  |L10.146|
;;;860                    // Break from loop if powerup is complete
;;;861                    break;
;;;862                }
;;;863            }
;;;864            if ((i == timeout) || (do_abort == 1)) {
000092  42b5              CMP      r5,r6
000094  d017              BEQ      |L10.198|
000096  2c01              CMP      r4,#1
000098  d015              BEQ      |L10.198|
;;;865                // Unable to powerup DP
;;;866                do_abort = 1;
;;;867                continue;
;;;868            }
;;;869    
;;;870            if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ | TRNNORMAL | MASKLANE)) {
00009a  4910              LDR      r1,|L10.220|
00009c  2004              MOVS     r0,#4
00009e  f7fffffe          BL       swd_write_dp
0000a2  b168              CBZ      r0,|L10.192|
;;;871                do_abort = 1;
;;;872                continue;
;;;873            }
;;;874    
;;;875            // call a target dependant function:
;;;876            // some target can enter in a lock state
;;;877            // this function can unlock these targets
;;;878            if (g_target_family && g_target_family->target_unlock_sequence) {
0000a4  f8d80000          LDR      r0,[r8,#0]  ; g_target_family
0000a8  b110              CBZ      r0,|L10.176|
0000aa  6900              LDR      r0,[r0,#0x10]
0000ac  b100              CBZ      r0,|L10.176|
;;;879                g_target_family->target_unlock_sequence();
0000ae  4780              BLX      r0
                  |L10.176|
;;;880            }
;;;881    
;;;882            if (!swd_write_dp(DP_SELECT, 0)) {
0000b0  2100              MOVS     r1,#0
0000b2  2008              MOVS     r0,#8
0000b4  f7fffffe          BL       swd_write_dp
0000b8  b110              CBZ      r0,|L10.192|
;;;883                do_abort = 1;
;;;884                continue;
;;;885            }
;;;886    
;;;887            return 1;
0000ba  2001              MOVS     r0,#1
                  |L10.188|
;;;888    
;;;889        } while (--retries > 0);
;;;890    
;;;891        return 0;
;;;892    }
0000bc  e8bd83f8          POP      {r3-r9,pc}
                  |L10.192|
0000c0  e001              B        |L10.198|
                  |L10.194|
0000c2  2401              MOVS     r4,#1                 ;856
0000c4  e7e5              B        |L10.146|
                  |L10.198|
0000c6  1e7f              SUBS     r7,r7,#1              ;883
0000c8  2401              MOVS     r4,#1                 ;883
0000ca  b27f              SXTB     r7,r7                 ;889
0000cc  2f00              CMP      r7,#0                 ;889
0000ce  dca5              BGT      |L10.28|
0000d0  2000              MOVS     r0,#0                 ;891
0000d2  e7f3              B        |L10.188|
;;;893    
                          ENDP

                  |L10.212|
                          DCD      ||.data||+0x8
                  |L10.216|
                          DCD      g_target_family
                  |L10.220|
                          DCD      0x50000f00

                          AREA ||i.swd_off||, CODE, READONLY, ALIGN=2

                  swd_off PROC
;;;124    
;;;125    uint8_t swd_off(void)
000000  b510              PUSH     {r4,lr}
000002  4c09              LDR      r4,|L11.40|
000004  2200              MOVS     r2,#0
000006  210d              MOVS     r1,#0xd
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       pin_in_init
00000e  2200              MOVS     r2,#0
000010  210c              MOVS     r1,#0xc
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       pin_in_init
000018  2200              MOVS     r2,#0
00001a  210e              MOVS     r1,#0xe
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       pin_in_init
;;;126    {
;;;127        PORT_OFF();
;;;128        return 1;
000022  2001              MOVS     r0,#1
;;;129    }
000024  bd10              POP      {r4,pc}
;;;130    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      0x40010c00

                          AREA ||i.swd_read_ap||, CODE, READONLY, ALIGN=1

                  swd_read_ap PROC
;;;181    // Read access port register.
;;;182    uint8_t swd_read_ap(uint32_t adr, uint32_t *val)
000000  b538              PUSH     {r3-r5,lr}
;;;183    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;184        uint8_t tmp_in, ack;
;;;185        uint8_t tmp_out[4];
;;;186        uint32_t tmp;
;;;187        uint32_t apsel = swd_get_apsel(adr);
000006  f7fffffe          BL       swd_get_apsel
;;;188        uint32_t bank_sel = adr & APBANKSEL;
00000a  f00502f0          AND      r2,r5,#0xf0
;;;189    
;;;190        if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
00000e  ea400102          ORR      r1,r0,r2
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       swd_write_dp
000018  2800              CMP      r0,#0
00001a  d022              BEQ      |L12.98|
;;;191            return 0;
;;;192        }
;;;193    
;;;194        tmp_in = SWD_REG_AP | SWD_REG_R | SWD_REG_ADR(adr);
00001c  f005050c          AND      r5,r5,#0xc
;;;195        // first dummy read
;;;196        swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
000020  1ced              ADDS     r5,r5,#3
000022  4669              MOV      r1,sp
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       swd_transfer_retry
;;;197        ack = swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
00002a  4669              MOV      r1,sp
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       swd_transfer_retry
;;;198        *val = 0;
000032  2200              MOVS     r2,#0
;;;199        tmp = tmp_out[3];
000034  6022              STR      r2,[r4,#0]
000036  f89d1003          LDRB     r1,[sp,#3]
;;;200        *val |= (tmp << 24);
00003a  ea426101          ORR      r1,r2,r1,LSL #24
;;;201        tmp = tmp_out[2];
00003e  6021              STR      r1,[r4,#0]
000040  f89d2002          LDRB     r2,[sp,#2]
;;;202        *val |= (tmp << 16);
000044  ea414102          ORR      r1,r1,r2,LSL #16
;;;203        tmp = tmp_out[1];
000048  6021              STR      r1,[r4,#0]
00004a  f89d2001          LDRB     r2,[sp,#1]
;;;204        *val |= (tmp << 8);
00004e  ea412102          ORR      r1,r1,r2,LSL #8
;;;205        tmp = tmp_out[0];
000052  6021              STR      r1,[r4,#0]
000054  f89d2000          LDRB     r2,[sp,#0]
;;;206        *val |= (tmp << 0);
000058  4311              ORRS     r1,r1,r2
;;;207        return (ack == 0x01);
00005a  6021              STR      r1,[r4,#0]
00005c  2801              CMP      r0,#1
00005e  d000              BEQ      |L12.98|
000060  2000              MOVS     r0,#0
                  |L12.98|
;;;208    }
000062  bd38              POP      {r3-r5,pc}
;;;209    
                          ENDP


                          AREA ||i.swd_read_block||, CODE, READONLY, ALIGN=2

                  swd_read_block PROC
;;;293    // size is in bytes.
;;;294    static uint8_t swd_read_block(uint32_t address, uint8_t *data, uint32_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;295    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  b362              CBZ      r2,|L13.98|
;;;296        uint8_t tmp_in[4], req, ack;
;;;297        uint32_t size_in_words;
;;;298        uint32_t i;
;;;299    
;;;300        if (size == 0) {
;;;301            return 0;
;;;302        }
;;;303    
;;;304        size_in_words = size / 4;
000008  0896              LSRS     r6,r2,#2
;;;305    
;;;306        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
00000a  4917              LDR      r1,|L13.104|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       swd_write_ap
000012  2800              CMP      r0,#0
000014  d026              BEQ      |L13.100|
;;;307            return 0;
;;;308        }
;;;309    
;;;310        // TAR write
;;;311        req = SWD_REG_AP | SWD_REG_W | AP_TAR;
000016  2705              MOVS     r7,#5
;;;312        int2array(tmp_in, address, 4);
000018  2204              MOVS     r2,#4
00001a  4621              MOV      r1,r4
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       int2array
;;;313    
;;;314        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != DAP_TRANSFER_OK) {
000022  4669              MOV      r1,sp
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       swd_transfer_retry
00002a  2801              CMP      r0,#1
00002c  d119              BNE      |L13.98|
;;;315            return 0;
;;;316        }
;;;317    
;;;318        // read data
;;;319        req = SWD_REG_AP | SWD_REG_R | AP_DRW;
00002e  270f              MOVS     r7,#0xf
;;;320    
;;;321        // initiate first read, data comes back in next read
;;;322        if (swd_transfer_retry(req, NULL) != 0x01) {
000030  2100              MOVS     r1,#0
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       swd_transfer_retry
000038  2801              CMP      r0,#1
00003a  d112              BNE      |L13.98|
;;;323            return 0;
;;;324        }
;;;325    
;;;326        for (i = 0; i < (size_in_words - 1); i++) {
00003c  2400              MOVS     r4,#0
00003e  1e76              SUBS     r6,r6,#1
000040  e007              B        |L13.82|
                  |L13.66|
;;;327            if (swd_transfer_retry(req, (uint32_t *)data) != DAP_TRANSFER_OK) {
000042  4629              MOV      r1,r5
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       swd_transfer_retry
00004a  2801              CMP      r0,#1
00004c  d109              BNE      |L13.98|
00004e  1c64              ADDS     r4,r4,#1
000050  1d2d              ADDS     r5,r5,#4
                  |L13.82|
000052  42b4              CMP      r4,r6                 ;326
000054  d3f5              BCC      |L13.66|
;;;328                return 0;
;;;329            }
;;;330    
;;;331            data += 4;
;;;332        }
;;;333    
;;;334        // read last word
;;;335        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000056  200e              MOVS     r0,#0xe
;;;336        ack = swd_transfer_retry(req, (uint32_t *)data);
000058  4629              MOV      r1,r5
00005a  f7fffffe          BL       swd_transfer_retry
;;;337        return (ack == 0x01);
00005e  2801              CMP      r0,#1
000060  d000              BEQ      |L13.100|
                  |L13.98|
000062  2000              MOVS     r0,#0
                  |L13.100|
;;;338    }
000064  bdf8              POP      {r3-r7,pc}
;;;339    
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
                          DCD      0x23000052

                          AREA ||i.swd_read_byte||, CODE, READONLY, ALIGN=2

                  swd_read_byte PROC
;;;432    // Read 8-bit byte from target memory.
;;;433    uint8_t swd_read_byte(uint32_t addr, uint8_t *val)
000000  b538              PUSH     {r3-r5,lr}
;;;434    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;435        uint32_t tmp;
;;;436    
;;;437        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
000006  4909              LDR      r1,|L14.44|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d00b              BEQ      |L14.42|
;;;438            return 0;
;;;439        }
;;;440    
;;;441        if (!swd_read_data(addr, &tmp)) {
000012  4669              MOV      r1,sp
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       swd_read_data
00001a  2800              CMP      r0,#0
00001c  d005              BEQ      |L14.42|
;;;442            return 0;
;;;443        }
;;;444    
;;;445        *val = (uint8_t)(tmp >> ((addr & 0x03) << 3));
00001e  07a0              LSLS     r0,r4,#30
000020  0ec1              LSRS     r1,r0,#27
000022  9800              LDR      r0,[sp,#0]
000024  40c8              LSRS     r0,r0,r1
000026  7028              STRB     r0,[r5,#0]
;;;446        return 1;
000028  2001              MOVS     r0,#1
                  |L14.42|
;;;447    }
00002a  bd38              POP      {r3-r5,pc}
;;;448    
                          ENDP

                  |L14.44|
                          DCD      0x23000050

                          AREA ||i.swd_read_core_register||, CODE, READONLY, ALIGN=2

                  swd_read_core_register PROC
;;;617    
;;;618    uint8_t swd_read_core_register(uint32_t n, uint32_t *val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;619    {
000004  460e              MOV      r6,r1
;;;620        int i = 0, timeout = 100;
;;;621    
;;;622        if (!swd_write_word(DCRSR, n)) {
000006  4601              MOV      r1,r0
000008  2400              MOVS     r4,#0                 ;620
00000a  2564              MOVS     r5,#0x64              ;620
00000c  4810              LDR      r0,|L15.80|
00000e  f7fffffe          BL       swd_write_word
000012  2800              CMP      r0,#0
000014  d010              BEQ      |L15.56|
;;;623            return 0;
;;;624        }
;;;625    
;;;626        // wait for S_REGRDY
;;;627        for (i = 0; i < timeout; i++) {
;;;628            if (!swd_read_word(DHCSR, val)) {
000016  4f0e              LDR      r7,|L15.80|
000018  1f3f              SUBS     r7,r7,#4
                  |L15.26|
00001a  4631              MOV      r1,r6
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       swd_read_word
000022  2800              CMP      r0,#0
000024  d008              BEQ      |L15.56|
;;;629                return 0;
;;;630            }
;;;631    
;;;632            if (*val & S_REGRDY) {
000026  6830              LDR      r0,[r6,#0]
000028  03c0              LSLS     r0,r0,#15
00002a  d402              BMI      |L15.50|
00002c  1c64              ADDS     r4,r4,#1
00002e  42ac              CMP      r4,r5                 ;627
000030  dbf3              BLT      |L15.26|
                  |L15.50|
;;;633                break;
;;;634            }
;;;635        }
;;;636    
;;;637        if (i == timeout) {
000032  42ac              CMP      r4,r5
000034  d102              BNE      |L15.60|
;;;638            return 0;
000036  2000              MOVS     r0,#0
                  |L15.56|
;;;639        }
;;;640    
;;;641        if (!swd_read_word(DCRDR, val)) {
;;;642            return 0;
;;;643        }
;;;644    
;;;645        return 1;
;;;646    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L15.60|
00003c  4804              LDR      r0,|L15.80|
00003e  4631              MOV      r1,r6                 ;641
000040  1d00              ADDS     r0,r0,#4              ;641
000042  f7fffffe          BL       swd_read_word
000046  2800              CMP      r0,#0                 ;641
000048  d0f6              BEQ      |L15.56|
00004a  2001              MOVS     r0,#1                 ;645
00004c  e7f4              B        |L15.56|
;;;647    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      0xe000edf4

                          AREA ||i.swd_read_data||, CODE, READONLY, ALIGN=1

                  swd_read_data PROC
;;;340    // Read target memory.
;;;341    static uint8_t swd_read_data(uint32_t addr, uint32_t *val)
000000  b51c              PUSH     {r2-r4,lr}
;;;342    {
000002  460c              MOV      r4,r1
;;;343        uint8_t tmp_in[4];
;;;344        uint8_t tmp_out[4];
;;;345        uint8_t req, ack;
;;;346        uint32_t tmp;
;;;347        // put addr in TAR register
;;;348        int2array(tmp_in, addr, 4);
000004  4601              MOV      r1,r0
000006  2204              MOVS     r2,#4
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       int2array
;;;349        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
00000e  2005              MOVS     r0,#5
;;;350    
;;;351        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000010  a901              ADD      r1,sp,#4
000012  f7fffffe          BL       swd_transfer_retry
000016  2801              CMP      r0,#1
000018  d120              BNE      |L16.92|
;;;352            return 0;
;;;353        }
;;;354    
;;;355        // read data
;;;356        req = SWD_REG_AP | SWD_REG_R | (3 << 2);
00001a  200f              MOVS     r0,#0xf
;;;357    
;;;358        if (swd_transfer_retry(req, (uint32_t *)tmp_out) != 0x01) {
00001c  4669              MOV      r1,sp
00001e  f7fffffe          BL       swd_transfer_retry
000022  2801              CMP      r0,#1
000024  d11a              BNE      |L16.92|
;;;359            return 0;
;;;360        }
;;;361    
;;;362        // dummy read
;;;363        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000026  200e              MOVS     r0,#0xe
;;;364        ack = swd_transfer_retry(req, (uint32_t *)tmp_out);
000028  4669              MOV      r1,sp
00002a  f7fffffe          BL       swd_transfer_retry
;;;365        *val = 0;
00002e  2200              MOVS     r2,#0
;;;366        tmp = tmp_out[3];
000030  6022              STR      r2,[r4,#0]
000032  f89d1003          LDRB     r1,[sp,#3]
;;;367        *val |= (tmp << 24);
000036  ea426101          ORR      r1,r2,r1,LSL #24
;;;368        tmp = tmp_out[2];
00003a  6021              STR      r1,[r4,#0]
00003c  f89d2002          LDRB     r2,[sp,#2]
;;;369        *val |= (tmp << 16);
000040  ea414102          ORR      r1,r1,r2,LSL #16
;;;370        tmp = tmp_out[1];
000044  6021              STR      r1,[r4,#0]
000046  f89d2001          LDRB     r2,[sp,#1]
;;;371        *val |= (tmp << 8);
00004a  ea412102          ORR      r1,r1,r2,LSL #8
;;;372        tmp = tmp_out[0];
00004e  6021              STR      r1,[r4,#0]
000050  f89d2000          LDRB     r2,[sp,#0]
;;;373        *val |= (tmp << 0);
000054  4311              ORRS     r1,r1,r2
;;;374        return (ack == 0x01);
000056  6021              STR      r1,[r4,#0]
000058  2801              CMP      r0,#1
00005a  d000              BEQ      |L16.94|
                  |L16.92|
00005c  2000              MOVS     r0,#0
                  |L16.94|
;;;375    }
00005e  bd1c              POP      {r2-r4,pc}
;;;376    
                          ENDP


                          AREA ||i.swd_read_dp||, CODE, READONLY, ALIGN=1

                  swd_read_dp PROC
;;;139    // Read debug port register.
;;;140    uint8_t swd_read_dp(uint8_t adr, uint32_t *val)
000000  b538              PUSH     {r3-r5,lr}
;;;141    {
000002  460c              MOV      r4,r1
;;;142        uint32_t tmp_in;
;;;143        uint8_t tmp_out[4];
;;;144        uint8_t ack;
;;;145        uint32_t tmp;
;;;146        tmp_in = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(adr);
000004  f000000c          AND      r0,r0,#0xc
;;;147        ack = swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
000008  4669              MOV      r1,sp
00000a  1c80              ADDS     r0,r0,#2
00000c  f7fffffe          BL       swd_transfer_retry
;;;148        *val = 0;
000010  2200              MOVS     r2,#0
;;;149        tmp = tmp_out[3];
000012  6022              STR      r2,[r4,#0]
000014  f89d1003          LDRB     r1,[sp,#3]
;;;150        *val |= (tmp << 24);
000018  ea426101          ORR      r1,r2,r1,LSL #24
;;;151        tmp = tmp_out[2];
00001c  6021              STR      r1,[r4,#0]
00001e  f89d2002          LDRB     r2,[sp,#2]
;;;152        *val |= (tmp << 16);
000022  ea414102          ORR      r1,r1,r2,LSL #16
;;;153        tmp = tmp_out[1];
000026  6021              STR      r1,[r4,#0]
000028  f89d2001          LDRB     r2,[sp,#1]
;;;154        *val |= (tmp << 8);
00002c  ea412102          ORR      r1,r1,r2,LSL #8
;;;155        tmp = tmp_out[0];
000030  6021              STR      r1,[r4,#0]
000032  f89d2000          LDRB     r2,[sp,#0]
;;;156        *val |= (tmp << 0);
000036  4311              ORRS     r1,r1,r2
;;;157        return (ack == 0x01);
000038  6021              STR      r1,[r4,#0]
00003a  2801              CMP      r0,#1
00003c  d000              BEQ      |L17.64|
00003e  2000              MOVS     r0,#0
                  |L17.64|
;;;158    }
000040  bd38              POP      {r3-r5,pc}
;;;159    
                          ENDP


                          AREA ||i.swd_read_memory||, CODE, READONLY, ALIGN=1

                  swd_read_memory PROC
;;;468    // size is in bytes.
;;;469    uint8_t swd_read_memory(uint32_t address, uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;470    {
000004  4614              MOV      r4,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;471        uint32_t n;
;;;472    
;;;473        // Read bytes until word aligned
;;;474        while ((size > 0) && (address & 0x3)) {
;;;475            if (!swd_read_byte(address, data)) {
;;;476                return 0;
;;;477            }
;;;478    
;;;479            address++;
;;;480            data++;
;;;481            size--;
00000a  e008              B        |L18.30|
                  |L18.12|
00000c  4639              MOV      r1,r7                 ;475
00000e  4628              MOV      r0,r5                 ;475
000010  f7fffffe          BL       swd_read_byte
000014  2800              CMP      r0,#0                 ;475
000016  d027              BEQ      |L18.104|
000018  1e64              SUBS     r4,r4,#1              ;475
00001a  1c6d              ADDS     r5,r5,#1              ;475
00001c  1c7f              ADDS     r7,r7,#1              ;475
                  |L18.30|
00001e  b314              CBZ      r4,|L18.102|
000020  07a8              LSLS     r0,r5,#30             ;474
000022  d1f3              BNE      |L18.12|
000024  e011              B        |L18.74|
                  |L18.38|
;;;482        }
;;;483    
;;;484        // Read word aligned blocks
;;;485        while (size > 3) {
;;;486            // Limit to auto increment page size
;;;487            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
000026  f3c50009          UBFX     r0,r5,#0,#10
00002a  f5c06680          RSB      r6,r0,#0x400
;;;488    
;;;489            if (size < n) {
00002e  42b4              CMP      r4,r6
000030  d201              BCS      |L18.54|
;;;490                n = size & 0xFFFFFFFC; // Only count complete words remaining
000032  f0240603          BIC      r6,r4,#3
                  |L18.54|
;;;491            }
;;;492    
;;;493            if (!swd_read_block(address, data, n)) {
000036  4632              MOV      r2,r6
000038  4639              MOV      r1,r7
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       swd_read_block
000040  2800              CMP      r0,#0
000042  d011              BEQ      |L18.104|
;;;494                return 0;
;;;495            }
;;;496    
;;;497            address += n;
000044  4435              ADD      r5,r5,r6
;;;498            data += n;
000046  4437              ADD      r7,r7,r6
;;;499            size -= n;
000048  1ba4              SUBS     r4,r4,r6
                  |L18.74|
00004a  2c03              CMP      r4,#3                 ;485
00004c  d8eb              BHI      |L18.38|
00004e  e008              B        |L18.98|
                  |L18.80|
;;;500        }
;;;501    
;;;502        // Read remaining bytes
;;;503        while (size > 0) {
;;;504            if (!swd_read_byte(address, data)) {
000050  4639              MOV      r1,r7
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       swd_read_byte
000058  2800              CMP      r0,#0
00005a  d005              BEQ      |L18.104|
00005c  1e64              SUBS     r4,r4,#1
00005e  1c6d              ADDS     r5,r5,#1
000060  1c7f              ADDS     r7,r7,#1
                  |L18.98|
000062  2c00              CMP      r4,#0                 ;503
000064  d1f4              BNE      |L18.80|
                  |L18.102|
;;;505                return 0;
;;;506            }
;;;507    
;;;508            address++;
;;;509            data++;
;;;510            size--;
;;;511        }
;;;512    
;;;513        return 1;
000066  2001              MOVS     r0,#1
                  |L18.104|
;;;514    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;515    
                          ENDP


                          AREA ||i.swd_read_word||, CODE, READONLY, ALIGN=2

                  swd_read_word PROC
;;;404    // Read 32-bit word from target memory.
;;;405    uint8_t swd_read_word(uint32_t addr, uint32_t *val)
000000  b570              PUSH     {r4-r6,lr}
;;;406    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;407        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
000006  4907              LDR      r1,|L19.36|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d006              BEQ      |L19.32|
;;;408            return 0;
;;;409        }
;;;410    
;;;411        if (!swd_read_data(addr, val)) {
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       swd_read_data
00001a  2800              CMP      r0,#0
00001c  d000              BEQ      |L19.32|
;;;412            return 0;
;;;413        }
;;;414    
;;;415        return 1;
00001e  2001              MOVS     r0,#1
                  |L19.32|
;;;416    }
000020  bd70              POP      {r4-r6,pc}
;;;417    
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      0x23000052

                          AREA ||i.swd_reset||, CODE, READONLY, ALIGN=1

                  swd_reset PROC
;;;739    // SWD Reset
;;;740    static uint8_t swd_reset(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;741    {
;;;742        uint8_t tmp_in[8];
;;;743        uint8_t i = 0;
000002  2000              MOVS     r0,#0
000004  466a              MOV      r2,sp                 ;742
;;;744    
;;;745        for (i = 0; i < 8; i++) {
;;;746            tmp_in[i] = 0xff;
000006  21ff              MOVS     r1,#0xff
                  |L20.8|
000008  5411              STRB     r1,[r2,r0]
00000a  1c40              ADDS     r0,r0,#1
00000c  b2c0              UXTB     r0,r0                 ;745
00000e  2808              CMP      r0,#8                 ;745
000010  d3fa              BCC      |L20.8|
;;;747        }
;;;748    
;;;749        SWJ_Sequence(51, tmp_in);
000012  4611              MOV      r1,r2
000014  2033              MOVS     r0,#0x33
000016  f7fffffe          BL       SWJ_Sequence
;;;750        return 1;
00001a  2001              MOVS     r0,#1
;;;751    }
00001c  bd1c              POP      {r2-r4,pc}
;;;752    
                          ENDP


                          AREA ||i.swd_set_reset_connect||, CODE, READONLY, ALIGN=2

                  swd_set_reset_connect PROC
;;;79     
;;;80     void swd_set_reset_connect(SWD_CONNECT_TYPE type)
000000  4901              LDR      r1,|L21.8|
;;;81     {
;;;82         reset_connect = type;
000002  7008              STRB     r0,[r1,#0]
;;;83     }
000004  4770              BX       lr
;;;84     
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      ||.data||

                          AREA ||i.swd_set_soft_reset||, CODE, READONLY, ALIGN=2

                  swd_set_soft_reset PROC
;;;109    
;;;110    void swd_set_soft_reset(uint32_t soft_reset_type)
000000  4901              LDR      r1,|L22.8|
;;;111    {
;;;112        soft_reset = soft_reset_type;
000002  6048              STR      r0,[r1,#4]  ; soft_reset
;;;113    }
000004  4770              BX       lr
;;;114    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      ||.data||

                          AREA ||i.swd_set_target_state_hw||, CODE, READONLY, ALIGN=2

                  swd_set_target_state_hw PROC
;;;893    
;;;894    uint8_t swd_set_target_state_hw(target_state_t state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;895    {
;;;896        uint32_t val;
;;;897        int8_t ap_retries = 2;
000002  2402              MOVS     r4,#2
000004  4606              MOV      r6,r0                 ;895
;;;898        /* Calling swd_init prior to entering RUN state causes operations to fail. */
;;;899        if (state != RUN) {
000006  2806              CMP      r0,#6
000008  d001              BEQ      |L23.14|
;;;900            swd_init();
00000a  f7fffffe          BL       swd_init
                  |L23.14|
;;;901        }
;;;902    
;;;903        switch (state) {
;;;904            case RESET_HOLD:
;;;905                swd_set_target_reset(1);
;;;906                break;
;;;907    
;;;908            case RESET_RUN:
;;;909                swd_set_target_reset(1);
;;;910                osDelay(2);
;;;911                swd_set_target_reset(0);
;;;912                osDelay(2);
;;;913                swd_off();
;;;914                break;
;;;915    
;;;916            case RESET_PROGRAM:
;;;917                if (!swd_init_debug()) {
;;;918                    return 0;
;;;919                }
;;;920    
;;;921                if (reset_connect == CONNECT_UNDER_RESET) {
;;;922                    // Assert reset
;;;923                    swd_set_target_reset(1);
;;;924                    osDelay(2);
;;;925                }
;;;926    
;;;927                // Enable debug
;;;928                while(swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN) == 0) {
;;;929                    if( --ap_retries <=0 )
;;;930                        return 0;
;;;931                    // Target is in invalid state?
;;;932                    swd_set_target_reset(1);
;;;933                    osDelay(2);
;;;934                    swd_set_target_reset(0);
;;;935                    osDelay(2);
;;;936                }
;;;937    
;;;938                // Enable halt on reset
;;;939                if (!swd_write_word(DBG_EMCR, VC_CORERESET)) {
;;;940                    return 0;
;;;941                }
;;;942    
;;;943                if (reset_connect == CONNECT_NORMAL) {
;;;944                    // Assert reset
;;;945                    swd_set_target_reset(1);
;;;946                    osDelay(2);
;;;947                }
;;;948    
;;;949                // Deassert reset
;;;950                swd_set_target_reset(0);
;;;951                osDelay(2);
;;;952    
;;;953                do {
;;;954                    if (!swd_read_word(DBG_HCSR, &val)) {
;;;955                        return 0;
;;;956                    }
;;;957                } while ((val & S_HALT) == 0);
;;;958    
;;;959                // Disable halt on reset
;;;960                if (!swd_write_word(DBG_EMCR, 0)) {
;;;961                    return 0;
;;;962                }
;;;963    
;;;964                break;
;;;965    
;;;966            case NO_DEBUG:
;;;967                if (!swd_write_word(DBG_HCSR, DBGKEY)) {
00000e  494e              LDR      r1,|L23.328|
000010  4d4e              LDR      r5,|L23.332|
000012  1c4f              ADDS     r7,r1,#1              ;928
000014  2e08              CMP      r6,#8                 ;903
000016  d274              BCS      |L23.258|
000018  e8dff006          TBB      [pc,r6]               ;903
00001c  0415085a          DCB      0x04,0x15,0x08,0x5a
000020  5c748a91          DCB      0x5c,0x74,0x8a,0x91
000024  2001              MOVS     r0,#1                 ;905
000026  f7fffffe          BL       swd_set_target_reset
00002a  e088              B        |L23.318|
00002c  2001              MOVS     r0,#1                 ;909
00002e  f7fffffe          BL       swd_set_target_reset
000032  2002              MOVS     r0,#2                 ;910
000034  f7fffffe          BL       osDelay
000038  2000              MOVS     r0,#0                 ;911
00003a  f7fffffe          BL       swd_set_target_reset
00003e  2002              MOVS     r0,#2                 ;912
000040  f7fffffe          BL       osDelay
000044  e079              B        |L23.314|
000046  f7fffffe          BL       swd_init_debug
00004a  2800              CMP      r0,#0                 ;917
00004c  d078              BEQ      |L23.320|
00004e  4e40              LDR      r6,|L23.336|
000050  7830              LDRB     r0,[r6,#0]            ;921  ; reset_connect
000052  2801              CMP      r0,#1                 ;921
000054  d00b              BEQ      |L23.110|
000056  e00f              B        |L23.120|
                  |L23.88|
000058  1e64              SUBS     r4,r4,#1              ;921
00005a  b264              SXTB     r4,r4                 ;929
00005c  2c00              CMP      r4,#0                 ;929
00005e  dd70              BLE      |L23.322|
000060  2001              MOVS     r0,#1                 ;932
000062  f7fffffe          BL       swd_set_target_reset
000066  2002              MOVS     r0,#2                 ;933
000068  f7fffffe          BL       osDelay
00006c  2000              MOVS     r0,#0                 ;934
                  |L23.110|
00006e  f7fffffe          BL       swd_set_target_reset
000072  2002              MOVS     r0,#2                 ;924
000074  f7fffffe          BL       osDelay
                  |L23.120|
000078  4639              MOV      r1,r7                 ;928
00007a  4628              MOV      r0,r5                 ;928
00007c  f7fffffe          BL       swd_write_word
000080  2800              CMP      r0,#0                 ;928
000082  d0e9              BEQ      |L23.88|
000084  4c31              LDR      r4,|L23.332|
000086  2101              MOVS     r1,#1                 ;939
000088  340c              ADDS     r4,r4,#0xc            ;939
00008a  4620              MOV      r0,r4                 ;939
00008c  f7fffffe          BL       swd_write_word
000090  2800              CMP      r0,#0                 ;939
000092  d055              BEQ      |L23.320|
000094  7830              LDRB     r0,[r6,#0]            ;943  ; reset_connect
000096  b928              CBNZ     r0,|L23.164|
000098  2001              MOVS     r0,#1                 ;945
00009a  f7fffffe          BL       swd_set_target_reset
00009e  2002              MOVS     r0,#2                 ;946
0000a0  f7fffffe          BL       osDelay
                  |L23.164|
0000a4  2000              MOVS     r0,#0                 ;950
0000a6  f7fffffe          BL       swd_set_target_reset
0000aa  2002              MOVS     r0,#2                 ;951
0000ac  f7fffffe          BL       osDelay
                  |L23.176|
0000b0  4669              MOV      r1,sp                 ;954
0000b2  4628              MOV      r0,r5                 ;954
0000b4  f7fffffe          BL       swd_read_word
0000b8  2800              CMP      r0,#0                 ;954
0000ba  d041              BEQ      |L23.320|
0000bc  9800              LDR      r0,[sp,#0]            ;957
0000be  0380              LSLS     r0,r0,#14             ;957
0000c0  d5f6              BPL      |L23.176|
0000c2  2100              MOVS     r1,#0                 ;960
0000c4  4620              MOV      r0,r4                 ;960
                  |L23.198|
0000c6  f7fffffe          BL       swd_write_word
0000ca  2800              CMP      r0,#0
0000cc  d038              BEQ      |L23.320|
0000ce  e036              B        |L23.318|
                  |L23.208|
0000d0  4628              MOV      r0,r5
0000d2  e7f8              B        |L23.198|
;;;968                    return 0;
;;;969                }
;;;970    
;;;971                break;
;;;972    
;;;973            case DEBUG:
;;;974                if (!JTAG2SWD()) {
0000d4  f7fffffe          BL       JTAG2SWD
0000d8  2800              CMP      r0,#0
0000da  d031              BEQ      |L23.320|
;;;975                    return 0;
;;;976                }
;;;977    
;;;978                if (!swd_clear_errors()) {
0000dc  f7fffffe          BL       swd_clear_errors
0000e0  2800              CMP      r0,#0
0000e2  d02d              BEQ      |L23.320|
;;;979                    return 0;
;;;980                }
;;;981    
;;;982                // Ensure CTRL/STAT register selected in DPBANKSEL
;;;983                if (!swd_write_dp(DP_SELECT, 0)) {
0000e4  2100              MOVS     r1,#0
0000e6  2008              MOVS     r0,#8
0000e8  f7fffffe          BL       swd_write_dp
0000ec  2800              CMP      r0,#0
0000ee  d027              BEQ      |L23.320|
;;;984                    return 0;
;;;985                }
;;;986    
;;;987                // Power up
;;;988                if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
0000f0  f04f41a0          MOV      r1,#0x50000000
0000f4  2004              MOVS     r0,#4
0000f6  f7fffffe          BL       swd_write_dp
0000fa  2800              CMP      r0,#0
0000fc  d020              BEQ      |L23.320|
;;;989                    return 0;
;;;990                }
;;;991    
;;;992                // Enable debug
;;;993                if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
0000fe  4639              MOV      r1,r7
000100  e7e6              B        |L23.208|
                  |L23.258|
000102  e01e              B        |L23.322|
;;;994                    return 0;
;;;995                }
;;;996    
;;;997                break;
;;;998    
;;;999            case HALT:
;;;1000               if (!swd_init_debug()) {
000104  f7fffffe          BL       swd_init_debug
000108  2800              CMP      r0,#0
00010a  d019              BEQ      |L23.320|
;;;1001                   return 0;
;;;1002               }
;;;1003   
;;;1004               // Enable debug and halt the core (DHCSR <- 0xA05F0003)
;;;1005               if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT)) {
00010c  490e              LDR      r1,|L23.328|
00010e  4628              MOV      r0,r5
000110  1cc9              ADDS     r1,r1,#3
000112  f7fffffe          BL       swd_write_word
000116  2800              CMP      r0,#0
000118  d012              BEQ      |L23.320|
                  |L23.282|
;;;1006                   return 0;
;;;1007               }
;;;1008   
;;;1009               // Wait until core is halted
;;;1010               do {
;;;1011                   if (!swd_read_word(DBG_HCSR, &val)) {
00011a  4669              MOV      r1,sp
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       swd_read_word
000122  2800              CMP      r0,#0
000124  d00c              BEQ      |L23.320|
;;;1012                       return 0;
;;;1013                   }
;;;1014               } while ((val & S_HALT) == 0);
000126  9800              LDR      r0,[sp,#0]
000128  0380              LSLS     r0,r0,#14
00012a  d5f6              BPL      |L23.282|
00012c  e007              B        |L23.318|
00012e  e007              B        |L23.320|
;;;1015               break;
;;;1016   
;;;1017           case RUN:
;;;1018               if (!swd_write_word(DBG_HCSR, DBGKEY)) {
000130  4628              MOV      r0,r5
000132  f7fffffe          BL       swd_write_word
000136  2800              CMP      r0,#0
000138  d002              BEQ      |L23.320|
                  |L23.314|
;;;1019                   return 0;
;;;1020               }
;;;1021               swd_off();
00013a  f7fffffe          BL       swd_off
                  |L23.318|
;;;1022               break;
;;;1023   
;;;1024           case POST_FLASH_RESET:
;;;1025               // This state should be handled in target_reset.c, nothing needs to be done here.
;;;1026               break;
;;;1027   
;;;1028           default:
;;;1029               return 0;
;;;1030       }
;;;1031   
;;;1032       return 1;
00013e  2001              MOVS     r0,#1
                  |L23.320|
;;;1033   }
000140  bdf8              POP      {r3-r7,pc}
                  |L23.322|
000142  2000              MOVS     r0,#0                 ;1029
000144  bdf8              POP      {r3-r7,pc}
;;;1034   
                          ENDP

000146  0000              DCW      0x0000
                  |L23.328|
                          DCD      0xa05f0000
                  |L23.332|
                          DCD      0xe000edf0
                  |L23.336|
                          DCD      ||.data||

                          AREA ||i.swd_set_target_state_sw||, CODE, READONLY, ALIGN=2

                  swd_set_target_state_sw PROC
;;;1034   
;;;1035   uint8_t swd_set_target_state_sw(target_state_t state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1036   {
;;;1037       uint32_t val;
;;;1038       int8_t ap_retries = 2;
000002  2402              MOVS     r4,#2
000004  4605              MOV      r5,r0                 ;1036
;;;1039       /* Calling swd_init prior to enterring RUN state causes operations to fail. */
;;;1040       if (state != RUN) {
000006  2806              CMP      r0,#6
000008  d001              BEQ      |L24.14|
;;;1041           swd_init();
00000a  f7fffffe          BL       swd_init
                  |L24.14|
;;;1042       }
;;;1043   
;;;1044       switch (state) {
;;;1045           case RESET_HOLD:
;;;1046               swd_set_target_reset(1);
;;;1047               break;
;;;1048   
;;;1049           case RESET_RUN:
;;;1050               swd_set_target_reset(1);
;;;1051               osDelay(2);
;;;1052               swd_set_target_reset(0);
;;;1053               osDelay(2);
;;;1054               swd_off();
;;;1055               break;
;;;1056   
;;;1057           case RESET_PROGRAM:
;;;1058               if (!swd_init_debug()) {
;;;1059                   return 0;
;;;1060               }
;;;1061   
;;;1062               // Enable debug and halt the core (DHCSR <- 0xA05F0003)
;;;1063               while (swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT) == 0) {
;;;1064                   if ( --ap_retries <=0 ) {
;;;1065                       return 0;
;;;1066                   }
;;;1067                   // Target is in invalid state?
;;;1068                   swd_set_target_reset(1);
;;;1069                   osDelay(2);
;;;1070                   swd_set_target_reset(0);
;;;1071                   osDelay(2);
;;;1072               }
;;;1073   
;;;1074               // Wait until core is halted
;;;1075               do {
;;;1076                   if (!swd_read_word(DBG_HCSR, &val)) {
;;;1077                       return 0;
;;;1078                   }
;;;1079               } while ((val & S_HALT) == 0);
;;;1080   
;;;1081               // Enable halt on reset
;;;1082               if (!swd_write_word(DBG_EMCR, VC_CORERESET)) {
;;;1083                   return 0;
;;;1084               }
;;;1085   
;;;1086               // Perform a soft reset
;;;1087               if (!swd_read_word(NVIC_AIRCR, &val)) {
;;;1088                   return 0;
;;;1089               }
;;;1090   
;;;1091               if (!swd_write_word(NVIC_AIRCR, VECTKEY | (val & SCB_AIRCR_PRIGROUP_Msk) | soft_reset)) {
;;;1092                   return 0;
;;;1093               }
;;;1094   
;;;1095               osDelay(2);
;;;1096   
;;;1097               do {
;;;1098                   if (!swd_read_word(DBG_HCSR, &val)) {
;;;1099                       return 0;
;;;1100                   }
;;;1101               } while ((val & S_HALT) == 0);
;;;1102   
;;;1103               // Disable halt on reset
;;;1104               if (!swd_write_word(DBG_EMCR, 0)) {
;;;1105                   return 0;
;;;1106               }
;;;1107   
;;;1108               break;
;;;1109   
;;;1110           case NO_DEBUG:
;;;1111               if (!swd_write_word(DBG_HCSR, DBGKEY)) {
00000e  4957              LDR      r1,|L24.364|
000010  462a              MOV      r2,r5                 ;1044
000012  1cce              ADDS     r6,r1,#3              ;1063
000014  4d56              LDR      r5,|L24.368|
000016  2a08              CMP      r2,#8                 ;1044
000018  d27e              BCS      |L24.280|
00001a  e8dff002          TBB      [pc,r2]               ;1044
00001e  0415              DCB      0x04,0x15
000020  08696b85          DCB      0x08,0x69,0x6b,0x85
000024  9ba2              DCB      0x9b,0xa2
000026  2001              MOVS     r0,#1                 ;1046
000028  f7fffffe          BL       swd_set_target_reset
00002c  e099              B        |L24.354|
00002e  2001              MOVS     r0,#1                 ;1050
000030  f7fffffe          BL       swd_set_target_reset
000034  2002              MOVS     r0,#2                 ;1051
000036  f7fffffe          BL       osDelay
00003a  2000              MOVS     r0,#0                 ;1052
00003c  f7fffffe          BL       swd_set_target_reset
000040  2002              MOVS     r0,#2                 ;1053
000042  f7fffffe          BL       osDelay
000046  e08a              B        |L24.350|
000048  f7fffffe          BL       swd_init_debug
00004c  2800              CMP      r0,#0                 ;1058
00004e  d07d              BEQ      |L24.332|
000050  e00f              B        |L24.114|
                  |L24.82|
000052  1e64              SUBS     r4,r4,#1              ;1058
000054  b264              SXTB     r4,r4                 ;1064
000056  2c00              CMP      r4,#0                 ;1064
000058  dd5e              BLE      |L24.280|
00005a  2001              MOVS     r0,#1                 ;1068
00005c  f7fffffe          BL       swd_set_target_reset
000060  2002              MOVS     r0,#2                 ;1069
000062  f7fffffe          BL       osDelay
000066  2000              MOVS     r0,#0                 ;1070
000068  f7fffffe          BL       swd_set_target_reset
00006c  2002              MOVS     r0,#2                 ;1071
00006e  f7fffffe          BL       osDelay
                  |L24.114|
000072  4631              MOV      r1,r6                 ;1063
000074  4628              MOV      r0,r5                 ;1063
000076  f7fffffe          BL       swd_write_word
00007a  2800              CMP      r0,#0                 ;1063
00007c  d0e9              BEQ      |L24.82|
                  |L24.126|
00007e  4669              MOV      r1,sp                 ;1076
000080  4628              MOV      r0,r5                 ;1076
000082  f7fffffe          BL       swd_read_word
000086  2800              CMP      r0,#0                 ;1076
000088  d06c              BEQ      |L24.356|
00008a  9800              LDR      r0,[sp,#0]            ;1079
00008c  0380              LSLS     r0,r0,#14             ;1079
00008e  d5f6              BPL      |L24.126|
000090  4c37              LDR      r4,|L24.368|
000092  2101              MOVS     r1,#1                 ;1082
000094  340c              ADDS     r4,r4,#0xc            ;1082
000096  4620              MOV      r0,r4                 ;1082
000098  f7fffffe          BL       swd_write_word
00009c  2800              CMP      r0,#0                 ;1082
00009e  d061              BEQ      |L24.356|
0000a0  4e33              LDR      r6,|L24.368|
0000a2  4669              MOV      r1,sp                 ;1087
0000a4  3ee4              SUBS     r6,r6,#0xe4           ;1087
0000a6  4630              MOV      r0,r6                 ;1087
0000a8  f7fffffe          BL       swd_read_word
0000ac  2800              CMP      r0,#0                 ;1087
0000ae  d059              BEQ      |L24.356|
0000b0  9800              LDR      r0,[sp,#0]            ;1091
0000b2  f40061e0          AND      r1,r0,#0x700          ;1091
0000b6  482f              LDR      r0,|L24.372|
0000b8  6840              LDR      r0,[r0,#4]            ;1091  ; soft_reset
0000ba  4301              ORRS     r1,r1,r0              ;1091
0000bc  482e              LDR      r0,|L24.376|
0000be  4301              ORRS     r1,r1,r0              ;1091
0000c0  4630              MOV      r0,r6                 ;1091
0000c2  f7fffffe          BL       swd_write_word
0000c6  2800              CMP      r0,#0                 ;1091
0000c8  d04c              BEQ      |L24.356|
0000ca  2002              MOVS     r0,#2                 ;1095
0000cc  f7fffffe          BL       osDelay
                  |L24.208|
0000d0  4669              MOV      r1,sp                 ;1098
0000d2  4628              MOV      r0,r5                 ;1098
0000d4  f7fffffe          BL       swd_read_word
0000d8  2800              CMP      r0,#0                 ;1098
0000da  d043              BEQ      |L24.356|
0000dc  9800              LDR      r0,[sp,#0]            ;1101
0000de  0380              LSLS     r0,r0,#14             ;1101
0000e0  d5f6              BPL      |L24.208|
0000e2  2100              MOVS     r1,#0                 ;1104
0000e4  4620              MOV      r0,r4                 ;1104
                  |L24.230|
0000e6  f7fffffe          BL       swd_write_word
0000ea  2800              CMP      r0,#0
0000ec  d03a              BEQ      |L24.356|
0000ee  e038              B        |L24.354|
                  |L24.240|
0000f0  4628              MOV      r0,r5
0000f2  e7f8              B        |L24.230|
;;;1112                   return 0;
;;;1113               }
;;;1114   
;;;1115               break;
;;;1116   
;;;1117           case DEBUG:
;;;1118               if (!JTAG2SWD()) {
0000f4  f7fffffe          BL       JTAG2SWD
0000f8  2800              CMP      r0,#0
0000fa  d033              BEQ      |L24.356|
;;;1119                   return 0;
;;;1120               }
;;;1121   
;;;1122               if (!swd_clear_errors()) {
0000fc  f7fffffe          BL       swd_clear_errors
000100  2800              CMP      r0,#0
000102  d02f              BEQ      |L24.356|
;;;1123                   return 0;
;;;1124               }
;;;1125   
;;;1126               // Ensure CTRL/STAT register selected in DPBANKSEL
;;;1127               if (!swd_write_dp(DP_SELECT, 0)) {
000104  2100              MOVS     r1,#0
000106  2008              MOVS     r0,#8
000108  f7fffffe          BL       swd_write_dp
00010c  2800              CMP      r0,#0
00010e  d029              BEQ      |L24.356|
;;;1128                   return 0;
;;;1129               }
;;;1130   
;;;1131               // Power up
;;;1132               if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
000110  f04f41a0          MOV      r1,#0x50000000
000114  2004              MOVS     r0,#4
000116  e000              B        |L24.282|
                  |L24.280|
000118  e025              B        |L24.358|
                  |L24.282|
00011a  f7fffffe          BL       swd_write_dp
00011e  2800              CMP      r0,#0
000120  d020              BEQ      |L24.356|
;;;1133                   return 0;
;;;1134               }
;;;1135   
;;;1136               // Enable debug
;;;1137               if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
000122  4912              LDR      r1,|L24.364|
000124  1c49              ADDS     r1,r1,#1
000126  e7e3              B        |L24.240|
;;;1138                   return 0;
;;;1139               }
;;;1140   
;;;1141               break;
;;;1142   
;;;1143           case HALT:
;;;1144               if (!swd_init_debug()) {
000128  f7fffffe          BL       swd_init_debug
00012c  2800              CMP      r0,#0
00012e  d019              BEQ      |L24.356|
;;;1145                   return 0;
;;;1146               }
;;;1147   
;;;1148               // Enable debug and halt the core (DHCSR <- 0xA05F0003)
;;;1149               if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT)) {
000130  4631              MOV      r1,r6
000132  4628              MOV      r0,r5
000134  f7fffffe          BL       swd_write_word
000138  2800              CMP      r0,#0
00013a  d013              BEQ      |L24.356|
                  |L24.316|
;;;1150                   return 0;
;;;1151               }
;;;1152   
;;;1153               // Wait until core is halted
;;;1154               do {
;;;1155                   if (!swd_read_word(DBG_HCSR, &val)) {
00013c  4669              MOV      r1,sp
00013e  4628              MOV      r0,r5
000140  f7fffffe          BL       swd_read_word
000144  2800              CMP      r0,#0
000146  d00d              BEQ      |L24.356|
;;;1156                       return 0;
;;;1157                   }
;;;1158               } while ((val & S_HALT) == 0);
000148  9800              LDR      r0,[sp,#0]
00014a  e000              B        |L24.334|
                  |L24.332|
00014c  e00a              B        |L24.356|
                  |L24.334|
00014e  0380              LSLS     r0,r0,#14
000150  d5f4              BPL      |L24.316|
000152  e006              B        |L24.354|
;;;1159               break;
;;;1160   
;;;1161           case RUN:
;;;1162               if (!swd_write_word(DBG_HCSR, DBGKEY)) {
000154  4628              MOV      r0,r5
000156  f7fffffe          BL       swd_write_word
00015a  2800              CMP      r0,#0
00015c  d002              BEQ      |L24.356|
                  |L24.350|
;;;1163                   return 0;
;;;1164               }
;;;1165               swd_off();
00015e  f7fffffe          BL       swd_off
                  |L24.354|
;;;1166               break;
;;;1167   
;;;1168           case POST_FLASH_RESET:
;;;1169               // This state should be handled in target_reset.c, nothing needs to be done here.
;;;1170               break;
;;;1171   
;;;1172           default:
;;;1173               return 0;
;;;1174       }
;;;1175   
;;;1176       return 1;
000162  2001              MOVS     r0,#1
                  |L24.356|
;;;1177   }
000164  bdf8              POP      {r3-r7,pc}
                  |L24.358|
000166  2000              MOVS     r0,#0                 ;1173
000168  bdf8              POP      {r3-r7,pc}
;;;1178   #endif
                          ENDP

00016a  0000              DCW      0x0000
                  |L24.364|
                          DCD      0xa05f0000
                  |L24.368|
                          DCD      0xe000edf0
                  |L24.372|
                          DCD      ||.data||
                  |L24.376|
                          DCD      0x05fa0000

                          AREA ||i.swd_transfer_retry||, CODE, READONLY, ALIGN=1

                  swd_transfer_retry PROC
;;;93     
;;;94     uint8_t swd_transfer_retry(uint32_t req, uint32_t *data)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;96         uint8_t i, ack;
;;;97     
;;;98         for (i = 0; i < MAX_SWD_RETRY; i++) {
000006  2400              MOVS     r4,#0
                  |L25.8|
;;;99             ack = SWD_Transfer(req, data);
000008  4629              MOV      r1,r5
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       SWD_Transfer
;;;100    
;;;101            // if ack != WAIT
;;;102            if (ack != DAP_TRANSFER_WAIT) {
000010  2802              CMP      r0,#2
000012  d103              BNE      |L25.28|
000014  1c64              ADDS     r4,r4,#1
000016  b2e4              UXTB     r4,r4                 ;98
000018  2c64              CMP      r4,#0x64              ;98
00001a  d3f5              BCC      |L25.8|
                  |L25.28|
;;;103                return ack;
;;;104            }
;;;105        }
;;;106    
;;;107        return ack;
;;;108    }
00001c  bd70              POP      {r4-r6,pc}
;;;109    
                          ENDP


                          AREA ||i.swd_write_ap||, CODE, READONLY, ALIGN=2

                  swd_write_ap PROC
;;;210    // Write access port register
;;;211    uint8_t swd_write_ap(uint32_t adr, uint32_t val)
000000  b538              PUSH     {r3-r5,lr}
;;;212    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;213        uint8_t data[4];
;;;214        uint8_t req, ack;
;;;215        uint32_t apsel = swd_get_apsel(adr);
000006  f7fffffe          BL       swd_get_apsel
;;;216        uint32_t bank_sel = adr & APBANKSEL;
00000a  f00402f0          AND      r2,r4,#0xf0
;;;217    
;;;218        if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
00000e  ea400102          ORR      r1,r0,r2
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       swd_write_dp
000018  2800              CMP      r0,#0
00001a  d005              BEQ      |L26.40|
;;;219            return 0;
;;;220        }
;;;221    
;;;222        switch (adr) {
00001c  b934              CBNZ     r4,|L26.44|
;;;223            case AP_CSW:
;;;224                if (dap_state.csw == val) {
00001e  480e              LDR      r0,|L26.88|
000020  6841              LDR      r1,[r0,#4]  ; dap_state
000022  42a9              CMP      r1,r5
000024  d101              BNE      |L26.42|
;;;225                    return 1;
000026  2001              MOVS     r0,#1
                  |L26.40|
;;;226                }
;;;227    
;;;228                dap_state.csw = val;
;;;229                break;
;;;230    
;;;231            default:
;;;232                break;
;;;233        }
;;;234    
;;;235        req = SWD_REG_AP | SWD_REG_W | SWD_REG_ADR(adr);
;;;236        int2array(data, val, 4);
;;;237    
;;;238        if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
;;;239            return 0;
;;;240        }
;;;241    
;;;242        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
;;;243        ack = swd_transfer_retry(req, NULL);
;;;244        return (ack == 0x01);
;;;245    }
000028  bd38              POP      {r3-r5,pc}
                  |L26.42|
00002a  6045              STR      r5,[r0,#4]            ;228  ; dap_state
                  |L26.44|
00002c  f004040c          AND      r4,r4,#0xc            ;235
000030  2204              MOVS     r2,#4                 ;236
000032  4629              MOV      r1,r5                 ;236
000034  4668              MOV      r0,sp                 ;236
000036  1c64              ADDS     r4,r4,#1              ;236
000038  f7fffffe          BL       int2array
00003c  4669              MOV      r1,sp                 ;238
00003e  4620              MOV      r0,r4                 ;238
000040  f7fffffe          BL       swd_transfer_retry
000044  2801              CMP      r0,#1                 ;238
000046  d105              BNE      |L26.84|
000048  200e              MOVS     r0,#0xe               ;242
00004a  2100              MOVS     r1,#0                 ;243
00004c  f7fffffe          BL       swd_transfer_retry
000050  2801              CMP      r0,#1                 ;244
000052  d0e9              BEQ      |L26.40|
                  |L26.84|
000054  2000              MOVS     r0,#0                 ;244
000056  bd38              POP      {r3-r5,pc}
;;;246    
                          ENDP

                  |L26.88|
                          DCD      ||.data||+0x8

                          AREA ||i.swd_write_block||, CODE, READONLY, ALIGN=2

                  swd_write_block PROC
;;;249    // size is in bytes.
;;;250    static uint8_t swd_write_block(uint32_t address, uint8_t *data, uint32_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;251    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  b32a              CBZ      r2,|L27.84|
;;;252        uint8_t tmp_in[4], req;
;;;253        uint32_t size_in_words;
;;;254        uint32_t i, ack;
;;;255    
;;;256        if (size == 0) {
;;;257            return 0;
;;;258        }
;;;259    
;;;260        size_in_words = size / 4;
000008  0896              LSRS     r6,r2,#2
;;;261    
;;;262        // CSW register
;;;263        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
00000a  4913              LDR      r1,|L27.88|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       swd_write_ap
000012  2800              CMP      r0,#0
000014  d01f              BEQ      |L27.86|
;;;264            return 0;
;;;265        }
;;;266    
;;;267        // TAR write
;;;268        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
000016  2705              MOVS     r7,#5
;;;269        int2array(tmp_in, address, 4);
000018  2204              MOVS     r2,#4
00001a  4621              MOV      r1,r4
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       int2array
;;;270    
;;;271        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000022  4669              MOV      r1,sp
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       swd_transfer_retry
00002a  2801              CMP      r0,#1
00002c  d112              BNE      |L27.84|
;;;272            return 0;
;;;273        }
;;;274    
;;;275        // DRW write
;;;276        req = SWD_REG_AP | SWD_REG_W | (3 << 2);
00002e  270d              MOVS     r7,#0xd
;;;277    
;;;278        for (i = 0; i < size_in_words; i++) {
000030  2400              MOVS     r4,#0
000032  e007              B        |L27.68|
                  |L27.52|
;;;279            if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
000034  4629              MOV      r1,r5
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       swd_transfer_retry
00003c  2801              CMP      r0,#1
00003e  d109              BNE      |L27.84|
000040  1c64              ADDS     r4,r4,#1
000042  1d2d              ADDS     r5,r5,#4
                  |L27.68|
000044  42b4              CMP      r4,r6                 ;278
000046  d3f5              BCC      |L27.52|
;;;280                return 0;
;;;281            }
;;;282    
;;;283            data += 4;
;;;284        }
;;;285    
;;;286        // dummy read
;;;287        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000048  200e              MOVS     r0,#0xe
;;;288        ack = swd_transfer_retry(req, NULL);
00004a  2100              MOVS     r1,#0
00004c  f7fffffe          BL       swd_transfer_retry
;;;289        return (ack == 0x01);
000050  2801              CMP      r0,#1
000052  d000              BEQ      |L27.86|
                  |L27.84|
000054  2000              MOVS     r0,#0
                  |L27.86|
;;;290    }
000056  bdf8              POP      {r3-r7,pc}
;;;291    
                          ENDP

                  |L27.88|
                          DCD      0x23000052

                          AREA ||i.swd_write_byte||, CODE, READONLY, ALIGN=2

                  swd_write_byte PROC
;;;449    // Write 8-bit byte to target memory.
;;;450    uint8_t swd_write_byte(uint32_t addr, uint8_t val)
000000  b570              PUSH     {r4-r6,lr}
;;;451    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;452        uint32_t tmp;
;;;453    
;;;454        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
000006  4908              LDR      r1,|L28.40|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d009              BEQ      |L28.38|
;;;455            return 0;
;;;456        }
;;;457    
;;;458        tmp = val << ((addr & 0x03) << 3);
000012  07a8              LSLS     r0,r5,#30
000014  0ec0              LSRS     r0,r0,#27
000016  fa04f100          LSL      r1,r4,r0
;;;459    
;;;460        if (!swd_write_data(addr, tmp)) {
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       swd_write_data
000020  2800              CMP      r0,#0
000022  d000              BEQ      |L28.38|
;;;461            return 0;
;;;462        }
;;;463    
;;;464        return 1;
000024  2001              MOVS     r0,#1
                  |L28.38|
;;;465    }
000026  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

                  |L28.40|
                          DCD      0x23000050

                          AREA ||i.swd_write_core_register||, CODE, READONLY, ALIGN=2

                  swd_write_core_register PROC
;;;647    
;;;648    uint8_t swd_write_core_register(uint32_t n, uint32_t val)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;649    {
000002  4606              MOV      r6,r0
;;;650        int i = 0, timeout = 100;
000004  2400              MOVS     r4,#0
000006  2564              MOVS     r5,#0x64
;;;651    
;;;652        if (!swd_write_word(DCRDR, val)) {
000008  480f              LDR      r0,|L29.72|
00000a  9901              LDR      r1,[sp,#4]
00000c  f7fffffe          BL       swd_write_word
000010  2800              CMP      r0,#0
000012  d013              BEQ      |L29.60|
;;;653            return 0;
;;;654        }
;;;655    
;;;656        if (!swd_write_word(DCRSR, n | REGWnR)) {
000014  480c              LDR      r0,|L29.72|
000016  f4463180          ORR      r1,r6,#0x10000
00001a  1f00              SUBS     r0,r0,#4
00001c  f7fffffe          BL       swd_write_word
000020  2800              CMP      r0,#0
000022  d00b              BEQ      |L29.60|
;;;657            return 0;
;;;658        }
;;;659    
;;;660        // wait for S_REGRDY
;;;661        for (i = 0; i < timeout; i++) {
;;;662            if (!swd_read_word(DHCSR, &val)) {
000024  4e08              LDR      r6,|L29.72|
000026  3e08              SUBS     r6,r6,#8
                  |L29.40|
000028  a901              ADD      r1,sp,#4
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       swd_read_word
000030  2800              CMP      r0,#0
000032  d003              BEQ      |L29.60|
;;;663                return 0;
;;;664            }
;;;665    
;;;666            if (val & S_REGRDY) {
000034  9801              LDR      r0,[sp,#4]
000036  03c0              LSLS     r0,r0,#15
000038  d501              BPL      |L29.62|
;;;667                return 1;
00003a  2001              MOVS     r0,#1
                  |L29.60|
;;;668            }
;;;669        }
;;;670    
;;;671        return 0;
;;;672    }
00003c  bd7c              POP      {r2-r6,pc}
                  |L29.62|
00003e  1c64              ADDS     r4,r4,#1
000040  42ac              CMP      r4,r5                 ;661
000042  dbf1              BLT      |L29.40|
000044  2000              MOVS     r0,#0                 ;671
000046  bd7c              POP      {r2-r6,pc}
;;;673    
                          ENDP

                  |L29.72|
                          DCD      0xe000edf8

                          AREA ||i.swd_write_data||, CODE, READONLY, ALIGN=1

                  swd_write_data PROC
;;;377    // Write target memory.
;;;378    static uint8_t swd_write_data(uint32_t address, uint32_t data)
000000  b538              PUSH     {r3-r5,lr}
;;;379    {
000002  460c              MOV      r4,r1
;;;380        uint8_t tmp_in[4];
;;;381        uint8_t req, ack;
;;;382        // put addr in TAR register
;;;383        int2array(tmp_in, address, 4);
000004  4601              MOV      r1,r0
000006  2204              MOVS     r2,#4
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       int2array
;;;384        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
00000e  2005              MOVS     r0,#5
;;;385    
;;;386        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000010  4669              MOV      r1,sp
000012  f7fffffe          BL       swd_transfer_retry
000016  2801              CMP      r0,#1
000018  d110              BNE      |L30.60|
;;;387            return 0;
;;;388        }
;;;389    
;;;390        // write data
;;;391        int2array(tmp_in, data, 4);
00001a  2204              MOVS     r2,#4
00001c  4621              MOV      r1,r4
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       int2array
;;;392        req = SWD_REG_AP | SWD_REG_W | (3 << 2);
000024  200d              MOVS     r0,#0xd
;;;393    
;;;394        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000026  4669              MOV      r1,sp
000028  f7fffffe          BL       swd_transfer_retry
00002c  2801              CMP      r0,#1
00002e  d105              BNE      |L30.60|
;;;395            return 0;
;;;396        }
;;;397    
;;;398        // dummy read
;;;399        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000030  200e              MOVS     r0,#0xe
;;;400        ack = swd_transfer_retry(req, NULL);
000032  2100              MOVS     r1,#0
000034  f7fffffe          BL       swd_transfer_retry
;;;401        return (ack == 0x01) ? 1 : 0;
000038  2801              CMP      r0,#1
00003a  d000              BEQ      |L30.62|
                  |L30.60|
00003c  2000              MOVS     r0,#0
                  |L30.62|
;;;402    }
00003e  bd38              POP      {r3-r5,pc}
;;;403    
                          ENDP


                          AREA ||i.swd_write_debug_state||, CODE, READONLY, ALIGN=2

                  swd_write_debug_state PROC
;;;565    // Execute system call.
;;;566    static uint8_t swd_write_debug_state(DEBUG_STATE *state)
000000  b538              PUSH     {r3-r5,lr}
;;;567    {
000002  4605              MOV      r5,r0
;;;568        uint32_t i, status;
;;;569    
;;;570        if (!swd_write_dp(DP_SELECT, 0)) {
000004  2100              MOVS     r1,#0
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       swd_write_dp
00000c  2800              CMP      r0,#0
00000e  d03a              BEQ      |L31.134|
;;;571            return 0;
;;;572        }
;;;573    
;;;574        // R0, R1, R2, R3
;;;575        for (i = 0; i < 4; i++) {
000010  2400              MOVS     r4,#0
                  |L31.18|
;;;576            if (!swd_write_core_register(i, state->r[i])) {
000012  4620              MOV      r0,r4
000014  f8551024          LDR      r1,[r5,r4,LSL #2]
000018  f7fffffe          BL       swd_write_core_register
00001c  2800              CMP      r0,#0
00001e  d032              BEQ      |L31.134|
000020  1c64              ADDS     r4,r4,#1
000022  2c04              CMP      r4,#4                 ;575
000024  d3f5              BCC      |L31.18|
;;;577                return 0;
;;;578            }
;;;579        }
;;;580    
;;;581        // R9
;;;582        if (!swd_write_core_register(9, state->r[9])) {
000026  2009              MOVS     r0,#9
000028  6a69              LDR      r1,[r5,#0x24]
00002a  f7fffffe          BL       swd_write_core_register
00002e  2800              CMP      r0,#0
000030  d029              BEQ      |L31.134|
;;;583            return 0;
;;;584        }
;;;585    
;;;586        // R13, R14, R15
;;;587        for (i = 13; i < 16; i++) {
000032  240d              MOVS     r4,#0xd
                  |L31.52|
;;;588            if (!swd_write_core_register(i, state->r[i])) {
000034  4620              MOV      r0,r4
000036  f8551024          LDR      r1,[r5,r4,LSL #2]
00003a  f7fffffe          BL       swd_write_core_register
00003e  2800              CMP      r0,#0
000040  d021              BEQ      |L31.134|
000042  1c64              ADDS     r4,r4,#1
000044  2c10              CMP      r4,#0x10              ;587
000046  d3f5              BCC      |L31.52|
;;;589                return 0;
;;;590            }
;;;591        }
;;;592    
;;;593        // xPSR
;;;594        if (!swd_write_core_register(16, state->xpsr)) {
000048  2010              MOVS     r0,#0x10
00004a  6c29              LDR      r1,[r5,#0x40]
00004c  f7fffffe          BL       swd_write_core_register
000050  2800              CMP      r0,#0
000052  d018              BEQ      |L31.134|
;;;595            return 0;
;;;596        }
;;;597    
;;;598        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_MASKINTS | C_HALT)) {
000054  4c0e              LDR      r4,|L31.144|
000056  490d              LDR      r1,|L31.140|
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       swd_write_word
00005e  2800              CMP      r0,#0
000060  d011              BEQ      |L31.134|
;;;599            return 0;
;;;600        }
;;;601    
;;;602        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_MASKINTS)) {
000062  490a              LDR      r1,|L31.140|
000064  4620              MOV      r0,r4
000066  1e89              SUBS     r1,r1,#2
000068  f7fffffe          BL       swd_write_word
00006c  2800              CMP      r0,#0
00006e  d00a              BEQ      |L31.134|
;;;603            return 0;
;;;604        }
;;;605    
;;;606        // check status
;;;607        if (!swd_read_dp(DP_CTRL_STAT, &status)) {
000070  4669              MOV      r1,sp
000072  2004              MOVS     r0,#4
000074  f7fffffe          BL       swd_read_dp
000078  2800              CMP      r0,#0
00007a  d004              BEQ      |L31.134|
;;;608            return 0;
;;;609        }
;;;610    
;;;611        if (status & (STICKYERR | WDATAERR)) {
00007c  9800              LDR      r0,[sp,#0]
00007e  f0100fa0          TST      r0,#0xa0
000082  d001              BEQ      |L31.136|
;;;612            return 0;
000084  2000              MOVS     r0,#0
                  |L31.134|
;;;613        }
;;;614    
;;;615        return 1;
;;;616    }
000086  bd38              POP      {r3-r5,pc}
                  |L31.136|
000088  2001              MOVS     r0,#1                 ;615
00008a  bd38              POP      {r3-r5,pc}
;;;617    
                          ENDP

                  |L31.140|
                          DCD      0xa05f000b
                  |L31.144|
                          DCD      0xe000edf0

                          AREA ||i.swd_write_dp||, CODE, READONLY, ALIGN=2

                  swd_write_dp PROC
;;;160    // Write debug port register
;;;161    uint8_t swd_write_dp(uint8_t adr, uint32_t val)
000000  b5f8              PUSH     {r3-r7,lr}
;;;162    {
;;;163        uint32_t req;
;;;164        uint8_t data[4];
;;;165        uint8_t ack;
;;;166    
;;;167        //check if the right bank is already selected
;;;168        if ((adr == DP_SELECT) && (dap_state.select == val)) {
000002  4e0d              LDR      r6,|L32.56|
000004  4604              MOV      r4,r0                 ;162
000006  460d              MOV      r5,r1                 ;162
000008  2808              CMP      r0,#8
00000a  d102              BNE      |L32.18|
00000c  6830              LDR      r0,[r6,#0]  ; dap_state
00000e  42a8              CMP      r0,r5
000010  d010              BEQ      |L32.52|
                  |L32.18|
;;;169            return 1;
;;;170        }
;;;171    
;;;172        req = SWD_REG_DP | SWD_REG_W | SWD_REG_ADR(adr);
000012  f004070c          AND      r7,r4,#0xc
;;;173        int2array(data, val, 4);
000016  2204              MOVS     r2,#4
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       int2array
;;;174        ack = swd_transfer_retry(req, (uint32_t *)data);
00001e  4669              MOV      r1,sp
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       swd_transfer_retry
;;;175        if ((ack == DAP_TRANSFER_OK) && (adr == DP_SELECT)) {
000026  2801              CMP      r0,#1
000028  d001              BEQ      |L32.46|
;;;176            dap_state.select = val;
;;;177        }
;;;178        return (ack == 0x01);
00002a  2000              MOVS     r0,#0
;;;179    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L32.46|
00002e  2c08              CMP      r4,#8                 ;175
000030  d100              BNE      |L32.52|
000032  6035              STR      r5,[r6,#0]            ;176  ; dap_state
                  |L32.52|
000034  2001              MOVS     r0,#1                 ;178
000036  bdf8              POP      {r3-r7,pc}
;;;180    
                          ENDP

                  |L32.56|
                          DCD      ||.data||+0x8

                          AREA ||i.swd_write_memory||, CODE, READONLY, ALIGN=1

                  swd_write_memory PROC
;;;517    // size is in bytes.
;;;518    uint8_t swd_write_memory(uint32_t address, uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;519    {
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
000008  4606              MOV      r6,r0
;;;520        uint32_t n = 0;
;;;521    
;;;522        // Write bytes until word aligned
;;;523        while ((size > 0) && (address & 0x3)) {
;;;524            if (!swd_write_byte(address, *data)) {
;;;525                return 0;
;;;526            }
;;;527    
;;;528            address++;
;;;529            data++;
;;;530            size--;
00000a  e008              B        |L33.30|
                  |L33.12|
00000c  7829              LDRB     r1,[r5,#0]            ;524
00000e  4630              MOV      r0,r6                 ;524
000010  f7fffffe          BL       swd_write_byte
000014  2800              CMP      r0,#0                 ;524
000016  d027              BEQ      |L33.104|
000018  1e64              SUBS     r4,r4,#1              ;524
00001a  1c6d              ADDS     r5,r5,#1              ;524
00001c  1c76              ADDS     r6,r6,#1              ;524
                  |L33.30|
00001e  b314              CBZ      r4,|L33.102|
000020  07b0              LSLS     r0,r6,#30             ;523
000022  d1f3              BNE      |L33.12|
000024  e011              B        |L33.74|
                  |L33.38|
;;;531        }
;;;532    
;;;533        // Write word aligned blocks
;;;534        while (size > 3) {
;;;535            // Limit to auto increment page size
;;;536            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
000026  f3c60009          UBFX     r0,r6,#0,#10
00002a  f5c06780          RSB      r7,r0,#0x400
;;;537    
;;;538            if (size < n) {
00002e  42bc              CMP      r4,r7
000030  d201              BCS      |L33.54|
;;;539                n = size & 0xFFFFFFFC; // Only count complete words remaining
000032  f0240703          BIC      r7,r4,#3
                  |L33.54|
;;;540            }
;;;541    
;;;542            if (!swd_write_block(address, data, n)) {
000036  463a              MOV      r2,r7
000038  4629              MOV      r1,r5
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       swd_write_block
000040  2800              CMP      r0,#0
000042  d011              BEQ      |L33.104|
;;;543                return 0;
;;;544            }
;;;545    
;;;546            address += n;
000044  443e              ADD      r6,r6,r7
;;;547            data += n;
000046  443d              ADD      r5,r5,r7
;;;548            size -= n;
000048  1be4              SUBS     r4,r4,r7
                  |L33.74|
00004a  2c03              CMP      r4,#3                 ;534
00004c  d8eb              BHI      |L33.38|
00004e  e008              B        |L33.98|
                  |L33.80|
;;;549        }
;;;550    
;;;551        // Write remaining bytes
;;;552        while (size > 0) {
;;;553            if (!swd_write_byte(address, *data)) {
000050  7829              LDRB     r1,[r5,#0]
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       swd_write_byte
000058  2800              CMP      r0,#0
00005a  d005              BEQ      |L33.104|
00005c  1e64              SUBS     r4,r4,#1
00005e  1c6d              ADDS     r5,r5,#1
000060  1c76              ADDS     r6,r6,#1
                  |L33.98|
000062  2c00              CMP      r4,#0                 ;552
000064  d1f4              BNE      |L33.80|
                  |L33.102|
;;;554                return 0;
;;;555            }
;;;556    
;;;557            address++;
;;;558            data++;
;;;559            size--;
;;;560        }
;;;561    
;;;562        return 1;
000066  2001              MOVS     r0,#1
                  |L33.104|
;;;563    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;564    
                          ENDP


                          AREA ||i.swd_write_word||, CODE, READONLY, ALIGN=2

                  swd_write_word PROC
;;;418    // Write 32-bit word to target memory.
;;;419    uint8_t swd_write_word(uint32_t addr, uint32_t val)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;421        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
000006  4907              LDR      r1,|L34.36|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d006              BEQ      |L34.32|
;;;422            return 0;
;;;423        }
;;;424    
;;;425        if (!swd_write_data(addr, val)) {
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       swd_write_data
00001a  2800              CMP      r0,#0
00001c  d000              BEQ      |L34.32|
;;;426            return 0;
;;;427        }
;;;428    
;;;429        return 1;
00001e  2001              MOVS     r0,#1
                  |L34.32|
;;;430    }
000020  bd70              POP      {r4-r6,pc}
;;;431    
                          ENDP

000022  0000              DCW      0x0000
                  |L34.36|
                          DCD      0x23000052

                          AREA ||.data||, DATA, ALIGN=2

                  reset_connect
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  soft_reset
                          DCD      0x00000004
                  dap_state
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\interface\\swd_host.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_swd_host_c_a7d0a6c9____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___10_swd_host_c_a7d0a6c9____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_swd_host_c_a7d0a6c9____REVSH|
#line 495
|__asm___10_swd_host_c_a7d0a6c9____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_swd_host_c_a7d0a6c9____RRX|
#line 682
|__asm___10_swd_host_c_a7d0a6c9____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
