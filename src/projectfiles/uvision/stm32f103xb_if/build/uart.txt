; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\uart.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\uart.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\uart.crf ..\..\..\source\hic_hal\stm32\stm32f103xb\uart.c]
                          THUMB

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;234    
;;;235    void CDC_UART_IRQn_Handler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;236    {
;;;237        const uint32_t sr = CDC_UART->SR;
000002  4815              LDR      r0,|L1.88|
000004  6804              LDR      r4,[r0,#0]
;;;238    
;;;239        if (sr & USART_SR_RXNE) {
;;;240            uint8_t dat = CDC_UART->DR;
000006  4d15              LDR      r5,|L1.92|
000008  06a0              LSLS     r0,r4,#26             ;239
00000a  d512              BPL      |L1.50|
00000c  6828              LDR      r0,[r5,#0]
00000e  b2c6              UXTB     r6,r0
;;;241            uint32_t free = circ_buf_count_free(&read_buffer);
000010  4813              LDR      r0,|L1.96|
000012  f7fffffe          BL       circ_buf_count_free
;;;242            if (free > RX_OVRF_MSG_SIZE) {
000016  2813              CMP      r0,#0x13
000018  d904              BLS      |L1.36|
;;;243                circ_buf_push(&read_buffer, dat);
00001a  4631              MOV      r1,r6
00001c  4810              LDR      r0,|L1.96|
00001e  f7fffffe          BL       circ_buf_push
000022  e006              B        |L1.50|
                  |L1.36|
;;;244            } else if (RX_OVRF_MSG_SIZE == free) {
000024  d105              BNE      |L1.50|
;;;245                circ_buf_write(&read_buffer, (uint8_t*)RX_OVRF_MSG, RX_OVRF_MSG_SIZE);
000026  f04f0213          MOV      r2,#0x13
00002a  a10e              ADR      r1,|L1.100|
00002c  480c              LDR      r0,|L1.96|
00002e  f7fffffe          BL       circ_buf_write
                  |L1.50|
;;;246            } else {
;;;247                // Drop character
;;;248            }
;;;249        }
;;;250    
;;;251        if (sr & USART_SR_TXE) {
000032  0620              LSLS     r0,r4,#24
000034  d507              BPL      |L1.70|
;;;252            if (circ_buf_count_used(&write_buffer) > 0) {
000036  4810              LDR      r0,|L1.120|
000038  f7fffffe          BL       circ_buf_count_used
00003c  b120              CBZ      r0,|L1.72|
;;;253                CDC_UART->DR = circ_buf_pop(&write_buffer);
00003e  480e              LDR      r0,|L1.120|
000040  f7fffffe          BL       circ_buf_pop
000044  6028              STR      r0,[r5,#0]
                  |L1.70|
;;;254            } else {
;;;255                CDC_UART->CR1 &= ~USART_IT_TXE;
;;;256            }
;;;257        }
;;;258    }
000046  bd70              POP      {r4-r6,pc}
                  |L1.72|
000048  4804              LDR      r0,|L1.92|
00004a  3008              ADDS     r0,r0,#8              ;255
00004c  6801              LDR      r1,[r0,#0]            ;255
00004e  4a0b              LDR      r2,|L1.124|
000050  4011              ANDS     r1,r1,r2              ;255
000052  6001              STR      r1,[r0,#0]            ;255
000054  bd70              POP      {r4-r6,pc}
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x40004400
                  |L1.92|
                          DCD      0x40004404
                  |L1.96|
                          DCD      ||.bss||+0x210
                  |L1.100|
000064  3c444150          DCB      "<DAPLink:Overflow>\n",0
000068  4c696e6b
00006c  3a4f7665
000070  72666c6f
000074  773e0a00
                  |L1.120|
                          DCD      ||.bss||
                  |L1.124|
                          DCD      0xefffff7f

                          AREA ||i.clear_buffers||, CODE, READONLY, ALIGN=2

                  clear_buffers PROC
;;;74     
;;;75     static void clear_buffers(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77         circ_buf_init(&write_buffer, write_buffer_data, sizeof(write_buffer_data));
000002  4908              LDR      r1,|L2.36|
000004  f44f7400          MOV      r4,#0x200
000008  4622              MOV      r2,r4
00000a  f1a10010          SUB      r0,r1,#0x10
00000e  f7fffffe          BL       circ_buf_init
;;;78         circ_buf_init(&read_buffer, read_buffer_data, sizeof(read_buffer_data));
000012  4622              MOV      r2,r4
000014  4904              LDR      r1,|L2.40|
000016  e8bd4010          POP      {r4,lr}
00001a  f1a10010          SUB      r0,r1,#0x10
00001e  f7ffbffe          B.W      circ_buf_init
;;;79     }
;;;80     
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      ||.bss||+0x10
                  |L2.40|
                          DCD      ||.bss||+0x220

                          AREA ||i.uart_get_configuration||, CODE, READONLY, ALIGN=2

                  uart_get_configuration PROC
;;;205    
;;;206    int32_t uart_get_configuration(UART_Configuration *config)
000000  4906              LDR      r1,|L3.28|
;;;207    {
;;;208        config->Baudrate = configuration.Baudrate;
000002  680a              LDR      r2,[r1,#0]  ; configuration
;;;209        config->DataBits = configuration.DataBits;
000004  6002              STR      r2,[r0,#0]
000006  790a              LDRB     r2,[r1,#4]  ; configuration
000008  7102              STRB     r2,[r0,#4]
;;;210        config->Parity   = configuration.Parity;
00000a  794a              LDRB     r2,[r1,#5]  ; configuration
00000c  7142              STRB     r2,[r0,#5]
;;;211        config->StopBits = configuration.StopBits;
00000e  7989              LDRB     r1,[r1,#6]  ; configuration
000010  7181              STRB     r1,[r0,#6]
;;;212        config->FlowControl = UART_FLOW_CONTROL_NONE;
000012  2100              MOVS     r1,#0
000014  71c1              STRB     r1,[r0,#7]
;;;213    
;;;214        return 1;
000016  2001              MOVS     r0,#1
;;;215    }
000018  4770              BX       lr
;;;216    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      ||.data||

                          AREA ||i.uart_initialize||, CODE, READONLY, ALIGN=2

                  uart_initialize PROC
;;;80     
;;;81     int32_t uart_initialize(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;82     {
;;;83         GPIO_InitTypeDef GPIO_InitStructure;
;;;84     
;;;85         CDC_UART->CR1 &= ~(USART_IT_TXE | USART_IT_RXNE);
000004  4825              LDR      r0,|L4.156|
000006  b086              SUB      sp,sp,#0x18           ;82
000008  6801              LDR      r1,[r0,#0]
00000a  4a25              LDR      r2,|L4.160|
00000c  4011              ANDS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;86         clear_buffers();
000010  f7fffffe          BL       clear_buffers
;;;87     
;;;88         CDC_UART_ENABLE();
000014  4823              LDR      r0,|L4.164|
000016  69c1              LDR      r1,[r0,#0x1c]
000018  f4413100          ORR      r1,r1,#0x20000
00001c  61c1              STR      r1,[r0,#0x1c]
00001e  69c1              LDR      r1,[r0,#0x1c]
000020  f4013100          AND      r1,r1,#0x20000
;;;89         UART_PINS_PORT_ENABLE();
000024  9104              STR      r1,[sp,#0x10]
000026  6981              LDR      r1,[r0,#0x18]
000028  f0410104          ORR      r1,r1,#4
00002c  6181              STR      r1,[r0,#0x18]
00002e  6980              LDR      r0,[r0,#0x18]
;;;90     
;;;91         //TX pin
;;;92         GPIO_InitStructure.Pin = UART_TX_PIN;
;;;93         GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;94         GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
000030  2602              MOVS     r6,#2
000032  f0000004          AND      r0,r0,#4              ;89
000036  9004              STR      r0,[sp,#0x10]         ;92
000038  2004              MOVS     r0,#4                 ;92
;;;95         HAL_GPIO_Init(UART_TX_PORT, &GPIO_InitStructure);
00003a  e9cd0600          STRD     r0,r6,[sp,#0]
00003e  f8df8068          LDR      r8,|L4.168|
000042  2503              MOVS     r5,#3                 ;93
000044  4669              MOV      r1,sp
000046  9503              STR      r5,[sp,#0xc]
000048  4640              MOV      r0,r8
00004a  f7fffffe          BL       HAL_GPIO_Init
;;;96         //RX pin
;;;97         GPIO_InitStructure.Pin = UART_RX_PIN;
00004e  2008              MOVS     r0,#8
;;;98         GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;99         GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
000050  2700              MOVS     r7,#0
;;;100        GPIO_InitStructure.Pull = GPIO_PULLUP;
;;;101        HAL_GPIO_Init(UART_RX_PORT, &GPIO_InitStructure);
000052  e9cd0700          STRD     r0,r7,[sp,#0]
000056  2401              MOVS     r4,#1                 ;100
000058  4669              MOV      r1,sp
00005a  4640              MOV      r0,r8
00005c  e9cd4502          STRD     r4,r5,[sp,#8]
000060  f7fffffe          BL       HAL_GPIO_Init
000064  e9cd4700          STRD     r4,r7,[sp,#0]
;;;102        //CTS pin, input
;;;103        GPIO_InitStructure.Pin = UART_CTS_PIN;
;;;104        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;105        GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
;;;106        GPIO_InitStructure.Pull = GPIO_PULLUP;
;;;107        HAL_GPIO_Init(UART_CTS_PORT, &GPIO_InitStructure);
000068  4669              MOV      r1,sp
00006a  4640              MOV      r0,r8
00006c  e9cd4502          STRD     r4,r5,[sp,#8]
000070  f7fffffe          BL       HAL_GPIO_Init
;;;108        //RTS pin, output low
;;;109        HAL_GPIO_WritePin(UART_RTS_PORT, UART_RTS_PIN, GPIO_PIN_RESET);
000074  2200              MOVS     r2,#0
000076  2102              MOVS     r1,#2
000078  4640              MOV      r0,r8
00007a  f7fffffe          BL       HAL_GPIO_WritePin
;;;110        GPIO_InitStructure.Pin = UART_RTS_PIN;
;;;111        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;112        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;113        HAL_GPIO_Init(UART_RTS_PORT, &GPIO_InitStructure);
00007e  e9cd6400          STRD     r6,r4,[sp,#0]
000082  4669              MOV      r1,sp
000084  4640              MOV      r0,r8
000086  9503              STR      r5,[sp,#0xc]
000088  f7fffffe          BL       HAL_GPIO_Init
00008c  4907              LDR      r1,|L4.172|
00008e  2040              MOVS     r0,#0x40
000090  f8c10100          STR      r0,[r1,#0x100]
;;;114    
;;;115        NVIC_EnableIRQ(CDC_UART_IRQn);
;;;116    
;;;117        return 1;
;;;118    }
000094  b006              ADD      sp,sp,#0x18
000096  2001              MOVS     r0,#1                 ;117
000098  e8bd81f0          POP      {r4-r8,pc}
;;;119    
                          ENDP

                  |L4.156|
                          DCD      0x4000440c
                  |L4.160|
                          DCD      0xefffff5f
                  |L4.164|
                          DCD      0x40021000
                  |L4.168|
                          DCD      0x40010800
                  |L4.172|
                          DCD      0xe000e004

                          AREA ||i.uart_read_data||, CODE, READONLY, ALIGN=2

                  uart_read_data PROC
;;;229    
;;;230    int32_t uart_read_data(uint8_t *data, uint16_t size)
000000  460a              MOV      r2,r1
;;;231    {
;;;232        return circ_buf_read(&read_buffer, data, size);
000002  4601              MOV      r1,r0
000004  4801              LDR      r0,|L5.12|
000006  f7ffbffe          B.W      circ_buf_read
;;;233    }
;;;234    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      ||.bss||+0x210

                          AREA ||i.uart_reset||, CODE, READONLY, ALIGN=2

                  uart_reset PROC
;;;126    
;;;127    int32_t uart_reset(void)
000000  b570              PUSH     {r4-r6,lr}
;;;128    {
;;;129        const uint32_t cr1 = CDC_UART->CR1;
000002  4d06              LDR      r5,|L6.28|
000004  682c              LDR      r4,[r5,#0]
;;;130        CDC_UART->CR1 = cr1 & ~(USART_IT_TXE | USART_IT_RXNE);
000006  4806              LDR      r0,|L6.32|
000008  4020              ANDS     r0,r0,r4
00000a  6028              STR      r0,[r5,#0]
;;;131        clear_buffers();
00000c  f7fffffe          BL       clear_buffers
;;;132        CDC_UART->CR1 = cr1 & ~USART_IT_TXE;
000010  4803              LDR      r0,|L6.32|
000012  3020              ADDS     r0,r0,#0x20
000014  4004              ANDS     r4,r4,r0
000016  602c              STR      r4,[r5,#0]
;;;133        return 1;
000018  2001              MOVS     r0,#1
;;;134    }
00001a  bd70              POP      {r4-r6,pc}
;;;135    
                          ENDP

                  |L6.28|
                          DCD      0x4000440c
                  |L6.32|
                          DCD      0xefffff5f

                          AREA ||i.uart_set_configuration||, CODE, READONLY, ALIGN=2

                  uart_set_configuration PROC
;;;135    
;;;136    int32_t uart_set_configuration(UART_Configuration *config)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
;;;138        UART_HandleTypeDef uart_handle;
;;;139        HAL_StatusTypeDef status;
;;;140    
;;;141        memset(&uart_handle, 0, sizeof(uart_handle));
000006  2140              MOVS     r1,#0x40
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memclr4
;;;142        uart_handle.Instance = CDC_UART;
00000e  482f              LDR      r0,|L7.204|
;;;143    
;;;144        // parity
;;;145        configuration.Parity = config->Parity;
000010  9000              STR      r0,[sp,#0]
000012  4b2f              LDR      r3,|L7.208|
000014  7961              LDRB     r1,[r4,#5]
;;;146        if(config->Parity == UART_PARITY_ODD) {
;;;147            uart_handle.Init.Parity = HAL_UART_PARITY_ODD;
;;;148        } else if(config->Parity == UART_PARITY_EVEN) {
;;;149            uart_handle.Init.Parity = HAL_UART_PARITY_EVEN;
000016  2200              MOVS     r2,#0
000018  7159              STRB     r1,[r3,#5]            ;145
00001a  f44f60c0          MOV      r0,#0x600             ;147
00001e  f44f6580          MOV      r5,#0x400
000022  2901              CMP      r1,#1                 ;146
000024  d01a              BEQ      |L7.92|
000026  2902              CMP      r1,#2                 ;148
000028  d01a              BEQ      |L7.96|
;;;150        } else if(config->Parity == UART_PARITY_NONE) {
00002a  9204              STR      r2,[sp,#0x10]
00002c  b101              CBZ      r1,|L7.48|
;;;151            uart_handle.Init.Parity = HAL_UART_PARITY_NONE;
;;;152        } else {   //Other not support
;;;153            uart_handle.Init.Parity = HAL_UART_PARITY_NONE;
;;;154            configuration.Parity = UART_PARITY_NONE;
00002e  715a              STRB     r2,[r3,#5]
                  |L7.48|
;;;155        }
;;;156    
;;;157        // stop bits
;;;158        configuration.StopBits = config->StopBits;
000030  79a1              LDRB     r1,[r4,#6]
000032  7199              STRB     r1,[r3,#6]
;;;159        if(config->StopBits == UART_STOP_BITS_2) {
;;;160            uart_handle.Init.StopBits = UART_STOPBITS_2;
000034  f44f5600          MOV      r6,#0x2000
000038  2902              CMP      r1,#2                 ;159
00003a  d013              BEQ      |L7.100|
;;;161        } else if(config->StopBits == UART_STOP_BITS_1_5) {
00003c  2901              CMP      r1,#1
00003e  d013              BEQ      |L7.104|
;;;162            uart_handle.Init.StopBits = UART_STOPBITS_2;
;;;163            configuration.StopBits = UART_STOP_BITS_2;
;;;164        } else if(config->StopBits == UART_STOP_BITS_1) {
000040  9203              STR      r2,[sp,#0xc]
000042  b101              CBZ      r1,|L7.70|
;;;165            uart_handle.Init.StopBits = UART_STOPBITS_1;
;;;166        } else {
;;;167            uart_handle.Init.StopBits = UART_STOPBITS_1;
;;;168            configuration.StopBits = UART_STOP_BITS_1;
000044  719a              STRB     r2,[r3,#6]
                  |L7.70|
;;;169        }
;;;170    
;;;171        //Only 8 bit support
;;;172        configuration.DataBits = UART_DATA_BITS_8;
000046  2108              MOVS     r1,#8
000048  7119              STRB     r1,[r3,#4]
;;;173        if (uart_handle.Init.Parity == HAL_UART_PARITY_ODD || uart_handle.Init.Parity == HAL_UART_PARITY_EVEN) {
00004a  9904              LDR      r1,[sp,#0x10]
00004c  4281              CMP      r1,r0
00004e  d001              BEQ      |L7.84|
000050  42a9              CMP      r1,r5
000052  d10d              BNE      |L7.112|
                  |L7.84|
;;;174            uart_handle.Init.WordLength = UART_WORDLENGTH_9B;
000054  f44f5080          MOV      r0,#0x1000
000058  9002              STR      r0,[sp,#8]
00005a  e00a              B        |L7.114|
                  |L7.92|
00005c  9004              STR      r0,[sp,#0x10]         ;147
00005e  e7e7              B        |L7.48|
                  |L7.96|
000060  9504              STR      r5,[sp,#0x10]         ;149
000062  e7e5              B        |L7.48|
                  |L7.100|
000064  9603              STR      r6,[sp,#0xc]          ;160
000066  e7ee              B        |L7.70|
                  |L7.104|
000068  2102              MOVS     r1,#2                 ;163
00006a  9603              STR      r6,[sp,#0xc]          ;163
00006c  7199              STRB     r1,[r3,#6]            ;163
00006e  e7ea              B        |L7.70|
                  |L7.112|
;;;175        } else {
;;;176            uart_handle.Init.WordLength = UART_WORDLENGTH_8B;
000070  9202              STR      r2,[sp,#8]
                  |L7.114|
;;;177        }
;;;178    
;;;179        // No flow control
;;;180        configuration.FlowControl = UART_FLOW_CONTROL_NONE;
000072  71da              STRB     r2,[r3,#7]
;;;181        uart_handle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
;;;182        
;;;183        // Specified baudrate
;;;184        configuration.Baudrate = config->Baudrate;
000074  9206              STR      r2,[sp,#0x18]
000076  6820              LDR      r0,[r4,#0]
;;;185        uart_handle.Init.BaudRate = config->Baudrate;
000078  6018              STR      r0,[r3,#0]  ; configuration
;;;186    
;;;187        // TX and RX
;;;188        uart_handle.Init.Mode = UART_MODE_TX_RX;
00007a  9001              STR      r0,[sp,#4]
;;;189        
;;;190        // Disable uart and tx/rx interrupt
;;;191        CDC_UART->CR1 &= ~(USART_IT_TXE | USART_IT_RXNE);
00007c  4c13              LDR      r4,|L7.204|
00007e  200c              MOVS     r0,#0xc               ;188
000080  340c              ADDS     r4,r4,#0xc
000082  9005              STR      r0,[sp,#0x14]
000084  6820              LDR      r0,[r4,#0]
000086  4913              LDR      r1,|L7.212|
000088  4008              ANDS     r0,r0,r1
00008a  6020              STR      r0,[r4,#0]
;;;192    
;;;193        clear_buffers();
00008c  f7fffffe          BL       clear_buffers
;;;194    
;;;195        status = HAL_UART_DeInit(&uart_handle);
000090  4668              MOV      r0,sp
000092  f7fffffe          BL       HAL_UART_DeInit
;;;196        util_assert(HAL_OK == status);
000096  b1a0              CBZ      r0,|L7.194|
000098  2000              MOVS     r0,#0
                  |L7.154|
00009a  22c4              MOVS     r2,#0xc4
00009c  a10e              ADR      r1,|L7.216|
00009e  f7fffffe          BL       _util_assert
;;;197        status = HAL_UART_Init(&uart_handle);
0000a2  4668              MOV      r0,sp
0000a4  f7fffffe          BL       HAL_UART_Init
;;;198        util_assert(HAL_OK == status);
0000a8  b168              CBZ      r0,|L7.198|
0000aa  2000              MOVS     r0,#0
                  |L7.172|
0000ac  22c6              MOVS     r2,#0xc6
0000ae  a10a              ADR      r1,|L7.216|
0000b0  f7fffffe          BL       _util_assert
;;;199        (void)status;
;;;200    
;;;201        CDC_UART->CR1 |= USART_IT_RXNE;
0000b4  6820              LDR      r0,[r4,#0]
0000b6  4915              LDR      r1,|L7.268|
0000b8  4308              ORRS     r0,r0,r1
0000ba  6020              STR      r0,[r4,#0]
;;;202    
;;;203        return 1;
;;;204    }
0000bc  b010              ADD      sp,sp,#0x40
0000be  2001              MOVS     r0,#1                 ;203
0000c0  bd70              POP      {r4-r6,pc}
                  |L7.194|
0000c2  2001              MOVS     r0,#1                 ;196
0000c4  e7e9              B        |L7.154|
                  |L7.198|
0000c6  2001              MOVS     r0,#1                 ;198
0000c8  e7f0              B        |L7.172|
;;;205    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L7.204|
                          DCD      0x40004400
                  |L7.208|
                          DCD      ||.data||
                  |L7.212|
                          DCD      0xefffff5f
                  |L7.216|
0000d8  2e2e5c2e          DCB      "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\uart.c"
0000dc  2e5c2e2e
0000e0  5c736f75
0000e4  7263655c
0000e8  6869635f
0000ec  68616c5c
0000f0  73746d33
0000f4  325c7374
0000f8  6d333266
0000fc  31303378
000100  625c7561
000104  72742e63
000108  00                DCB      0
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L7.268|
                          DCD      0x10000020

                          AREA ||i.uart_uninitialize||, CODE, READONLY, ALIGN=2

                  uart_uninitialize PROC
;;;119    
;;;120    int32_t uart_uninitialize(void)
000000  4804              LDR      r0,|L8.20|
;;;121    {
000002  b510              PUSH     {r4,lr}
;;;122        CDC_UART->CR1 &= ~(USART_IT_TXE | USART_IT_RXNE);
000004  6801              LDR      r1,[r0,#0]
000006  4a04              LDR      r2,|L8.24|
000008  4011              ANDS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;123        clear_buffers();
00000c  f7fffffe          BL       clear_buffers
;;;124        return 1;
000010  2001              MOVS     r0,#1
;;;125    }
000012  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  |L8.20|
                          DCD      0x4000440c
                  |L8.24|
                          DCD      0xefffff5f

                          AREA ||i.uart_write_data||, CODE, READONLY, ALIGN=2

                  uart_write_data PROC
;;;221    
;;;222    int32_t uart_write_data(uint8_t *data, uint16_t size)
000000  460a              MOV      r2,r1
;;;223    {
000002  b510              PUSH     {r4,lr}
;;;224        uint32_t cnt = circ_buf_write(&write_buffer, data, size);
000004  4601              MOV      r1,r0
000006  4804              LDR      r0,|L9.24|
000008  f7fffffe          BL       circ_buf_write
;;;225        CDC_UART->CR1 |= USART_IT_TXE;
00000c  4903              LDR      r1,|L9.28|
00000e  680a              LDR      r2,[r1,#0]
000010  4b03              LDR      r3,|L9.32|
000012  431a              ORRS     r2,r2,r3
000014  600a              STR      r2,[r1,#0]
;;;226    
;;;227        return cnt;
;;;228    }
000016  bd10              POP      {r4,pc}
;;;229    
                          ENDP

                  |L9.24|
                          DCD      ||.bss||
                  |L9.28|
                          DCD      0x4000440c
                  |L9.32|
                          DCD      0x10000080

                          AREA ||i.uart_write_free||, CODE, READONLY, ALIGN=2

                  uart_write_free PROC
;;;216    
;;;217    int32_t uart_write_free(void)
000000  4801              LDR      r0,|L10.8|
;;;218    {
;;;219        return circ_buf_count_free(&write_buffer);
000002  f7ffbffe          B.W      circ_buf_count_free
;;;220    }
;;;221    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  write_buffer
                          %        16
                  write_buffer_data
                          %        512
                  read_buffer
                          %        16
                  read_buffer_data
                          %        512

                          AREA ||.data||, DATA, ALIGN=2

                  configuration
                          DCD      0x00002580
000004  08000000          DCB      0x08,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_deffd5cd____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___6_uart_c_deffd5cd____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_deffd5cd____REVSH|
#line 495
|__asm___6_uart_c_deffd5cd____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_deffd5cd____RRX|
#line 682
|__asm___6_uart_c_deffd5cd____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
