; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\usbd_cdc_acm.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usbd_cdc_acm.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\usbd_cdc_acm.crf ..\..\..\source\usb\cdc\usbd_cdc_acm.c]
                          THUMB

                          AREA ||i.USBD_CDC_ACM_ClearCommFeature||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_ClearCommFeature PROC
;;;113    }
;;;114    __weak int32_t USBD_CDC_ACM_ClearCommFeature(uint16_t feat)
000000  2000              MOVS     r0,#0
;;;115    {
;;;116        return (0);
;;;117    }
000002  4770              BX       lr
;;;118    __weak int32_t USBD_CDC_ACM_SendBreak(uint16_t dur)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_DataAvailable||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_DataAvailable PROC
;;;426    
;;;427    int32_t USBD_CDC_ACM_DataAvailable(void)
000000  4802              LDR      r0,|L2.12|
;;;428    {
;;;429        return (ptr_data_received - ptr_data_read);
000002  e9d0100c          LDRD     r1,r0,[r0,#0x30]
000006  1a08              SUBS     r0,r1,r0
;;;430    }
000008  4770              BX       lr
;;;431    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.data||

                          AREA ||i.USBD_CDC_ACM_DataFree||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_DataFree PROC
;;;286    */
;;;287    int32_t USBD_CDC_ACM_DataFree(void)
000000  4803              LDR      r0,|L3.16|
;;;288    {
;;;289        return ((int32_t)usbd_cdc_acm_sendbuf_sz) - (data_to_send_wr - data_to_send_rd);
000002  e9d01004          LDRD     r1,r0,[r0,#0x10]
000006  1a08              SUBS     r0,r1,r0
000008  4902              LDR      r1,|L3.20|
00000a  8809              LDRH     r1,[r1,#0]  ; usbd_cdc_acm_sendbuf_sz
00000c  1a08              SUBS     r0,r1,r0
;;;290    }
00000e  4770              BX       lr
;;;291    
                          ENDP

                  |L3.16|
                          DCD      ||.data||
                  |L3.20|
                          DCD      usbd_cdc_acm_sendbuf_sz

                          AREA ||i.USBD_CDC_ACM_DataRead||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_DataRead PROC
;;;376    
;;;377    int32_t USBD_CDC_ACM_DataRead(uint8_t *buf, int32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;378    {
;;;379        int32_t len_data;
;;;380    
;;;381        if (ptr_data_received > ptr_data_read) { /*If there is already received data   */
000002  4d0b              LDR      r5,|L4.48|
000004  460c              MOV      r4,r1                 ;378
000006  4603              MOV      r3,r0                 ;378
000008  e9d5010c          LDRD     r0,r1,[r5,#0x30]
00000c  4288              CMP      r0,r1
00000e  d90b              BLS      |L4.40|
;;;382            len_data = ptr_data_received - ptr_data_read; /* Available bytes of data  */
000010  1a40              SUBS     r0,r0,r1
;;;383    
;;;384            if (len > len_data) {               /* If more requested then available   */
000012  4284              CMP      r4,r0
000014  dd00              BLE      |L4.24|
;;;385                len = len_data;    /* correct to return maximum available*/
000016  4604              MOV      r4,r0
                  |L4.24|
;;;386            }
;;;387    
;;;388            memcpy(buf, ptr_data_read, len);    /* Copy received data to provided buf */
000018  4622              MOV      r2,r4
00001a  4618              MOV      r0,r3
00001c  f7fffffe          BL       __aeabi_memcpy
;;;389            ptr_data_read      += len;          /* Correct position of read pointer   */
000020  6b68              LDR      r0,[r5,#0x34]  ; ptr_data_read
000022  4420              ADD      r0,r0,r4
000024  6368              STR      r0,[r5,#0x34]  ; ptr_data_read
000026  e000              B        |L4.42|
                  |L4.40|
;;;390        } else {
;;;391            len = 0;                            /* No data received                   */
000028  2400              MOVS     r4,#0
                  |L4.42|
;;;392        }
;;;393    
;;;394        return (len);                         /* Number of bytes actually read      */
00002a  4620              MOV      r0,r4
;;;395    }
00002c  bd70              POP      {r4-r6,pc}
;;;396    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      ||.data||

                          AREA ||i.USBD_CDC_ACM_DataReceived||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_DataReceived PROC
;;;88     int32_t USBD_CDC_ACM_GetChar(void);
;;;89     __weak int32_t USBD_CDC_ACM_DataReceived(int32_t len)
000000  2000              MOVS     r0,#0
;;;90     {
;;;91         return (0);
;;;92     }
000002  4770              BX       lr
;;;93     int32_t USBD_CDC_ACM_DataAvailable(void);
                          ENDP


                          AREA ||i.USBD_CDC_ACM_DataSend||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_DataSend PROC
;;;301    
;;;302    int32_t USBD_CDC_ACM_DataSend(const uint8_t *buf, int32_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;303    {
;;;304        int32_t  len_data, len_available, len_before_wrap;
;;;305        uint8_t *buf_loc;
;;;306        buf_loc       = (uint8_t *)buf;       /* Pointer to buf                     */
;;;307        len_data      = data_to_send_wr - data_to_send_rd;  /* Num of data in buffer*/
000004  4f19              LDR      r7,|L6.108|
000006  460c              MOV      r4,r1                 ;303
000008  4606              MOV      r6,r0                 ;303
00000a  e9d70104          LDRD     r0,r1,[r7,#0x10]
00000e  1a40              SUBS     r0,r0,r1
;;;308        len_available = ((int32_t)usbd_cdc_acm_sendbuf_sz) - len_data;  /* Num of
000010  4917              LDR      r1,|L6.112|
000012  8809              LDRH     r1,[r1,#0]  ; usbd_cdc_acm_sendbuf_sz
000014  1a08              SUBS     r0,r1,r0
;;;309                                               bytes of space available           */
;;;310    
;;;311        if (len_available <= 0) {             /* If no space for data to send       */
000016  2800              CMP      r0,#0
000018  dc02              BGT      |L6.32|
;;;312            return (0);
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;313        }
;;;314    
;;;315        if (len > len_available)              /* If more data requested for sending
;;;316                                               then available space               */
;;;317        {
;;;318            len = len_available;    /* Correct to maximum available       */
;;;319        }
;;;320    
;;;321        len_before_wrap = 0;                  /* Circular buffer size before wrap   */
;;;322    
;;;323        if ((ptr_data_to_send >= ptr_data_sent) && /* If wrap is possible to happen */
;;;324                ((ptr_data_to_send + len) >= (USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz))) {
;;;325            /* If data wraps around end of buffer */
;;;326            len_before_wrap   = USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz - ptr_data_to_send;
;;;327            memcpy(ptr_data_to_send, buf_loc, len_before_wrap); /* Copy data till end */
;;;328            buf_loc          += len_before_wrap;            /* Increment buf pointer  */
;;;329            len              -= len_before_wrap;            /* Decrement bytes to send*/
;;;330            ptr_data_to_send  = USBD_CDC_ACM_SendBuf;       /* Wrap send buffer
;;;331                                                           pointer to beginning of
;;;332                                                           the send buffer        */
;;;333        }
;;;334    
;;;335        if (len) {                            /* If there are bytes to send         */
;;;336            memcpy(ptr_data_to_send, buf_loc, len);   /* Copy data to send buffer     */
;;;337            ptr_data_to_send += len;            /* Correct position of write pointer  */
;;;338        }
;;;339    
;;;340        len += len_before_wrap;               /* Total number of bytes prepared for
;;;341                                               send                               */
;;;342        data_to_send_wr += len;               /* Bytes prepared to send counter     */
;;;343        return (len);                         /* Number of bytes accepted for send  */
;;;344    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L6.32|
000020  4284              CMP      r4,r0                 ;315
000022  dd00              BLE      |L6.38|
000024  4604              MOV      r4,r0                 ;318
                  |L6.38|
000026  e9d70206          LDRD     r0,r2,[r7,#0x18]      ;321
00002a  2500              MOVS     r5,#0                 ;321
00002c  4290              CMP      r0,r2                 ;323
00002e  d30f              BCC      |L6.80|
000030  4b10              LDR      r3,|L6.116|
000032  1902              ADDS     r2,r0,r4              ;324
000034  4419              ADD      r1,r1,r3              ;324
000036  428a              CMP      r2,r1                 ;324
000038  d30a              BCC      |L6.80|
00003a  1a0d              SUBS     r5,r1,r0              ;326
00003c  4698              MOV      r8,r3                 ;326
00003e  462a              MOV      r2,r5                 ;327
000040  4631              MOV      r1,r6                 ;327
000042  f7fffffe          BL       __aeabi_memcpy
000046  442e              ADD      r6,r6,r5              ;328
000048  1b64              SUBS     r4,r4,r5              ;329
00004a  4640              MOV      r0,r8                 ;330
00004c  f8c78018          STR      r8,[r7,#0x18]         ;330  ; ptr_data_to_send
                  |L6.80|
000050  b134              CBZ      r4,|L6.96|
000052  4622              MOV      r2,r4                 ;336
000054  4631              MOV      r1,r6                 ;336
000056  f7fffffe          BL       __aeabi_memcpy
00005a  69b8              LDR      r0,[r7,#0x18]         ;337  ; ptr_data_to_send
00005c  4420              ADD      r0,r0,r4              ;337
00005e  61b8              STR      r0,[r7,#0x18]         ;337  ; ptr_data_to_send
                  |L6.96|
000060  6939              LDR      r1,[r7,#0x10]         ;342  ; data_to_send_wr
000062  1960              ADDS     r0,r4,r5              ;340
000064  4401              ADD      r1,r1,r0              ;342
000066  6139              STR      r1,[r7,#0x10]         ;342  ; data_to_send_wr
000068  e7d8              B        |L6.28|
;;;345    
                          ENDP

00006a  0000              DCW      0x0000
                  |L6.108|
                          DCD      ||.data||
                  |L6.112|
                          DCD      usbd_cdc_acm_sendbuf_sz
                  |L6.116|
                          DCD      USBD_CDC_ACM_SendBuf

                          AREA ||i.USBD_CDC_ACM_EP_BULKIN_Event||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_EP_BULKIN_Event PROC
;;;718    
;;;719    void USBD_CDC_ACM_EP_BULKIN_Event(uint32_t event)
000000  b510              PUSH     {r4,lr}
;;;720    {
;;;721        if (data_send_access                  /* If send data is being accessed     */
000002  4c05              LDR      r4,|L7.24|
000004  6860              LDR      r0,[r4,#4]            ;720  ; data_send_access
000006  2800              CMP      r0,#0                 ;720
000008  d105              BNE      |L7.22|
;;;722    // ||((control_line_state & 3) != 3)    /* or if DTR or RTS is 0              */
;;;723           ) {
;;;724            return;
;;;725        }
;;;726    
;;;727        data_send_access = 1;                 /* Block access to send data          */
00000a  2001              MOVS     r0,#1
;;;728        USBD_CDC_ACM_EP_BULKIN_HandleData();  /* Handle data to send                */
00000c  6060              STR      r0,[r4,#4]  ; data_send_access
00000e  f7fffffe          BL       USBD_CDC_ACM_EP_BULKIN_HandleData
;;;729        data_send_access = 0;                 /* Allow access to send data          */
000012  2000              MOVS     r0,#0
000014  6060              STR      r0,[r4,#4]  ; data_send_access
                  |L7.22|
;;;730    }
000016  bd10              POP      {r4,pc}
;;;731    
                          ENDP

                  |L7.24|
                          DCD      ||.data||

                          AREA ||i.USBD_CDC_ACM_EP_BULKIN_HandleData||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_EP_BULKIN_HandleData PROC
;;;608    
;;;609    static void USBD_CDC_ACM_EP_BULKIN_HandleData(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;610    {
;;;611        int32_t len_to_send, len_sent;
;;;612    
;;;613        if (!data_send_active) {              /* If sending is not active           */
000004  4c24              LDR      r4,|L8.152|
000006  68a0              LDR      r0,[r4,#8]            ;610  ; data_send_active
000008  2800              CMP      r0,#0                 ;610
00000a  d03e              BEQ      |L8.138|
00000c  e9d40104          LDRD     r0,r1,[r4,#0x10]      ;610
;;;614            return;
;;;615        }
;;;616    
;;;617        len_to_send = data_to_send_wr - data_to_send_rd;  /* Num of data to send    */
000010  1a42              SUBS     r2,r0,r1
;;;618    
;;;619        /* Check if sending is finished                                             */
;;;620        if (!len_to_send    &&                /* If all data was sent               */
000012  68e0              LDR      r0,[r4,#0xc]  ; data_send_zlp
000014  f04f0600          MOV      r6,#0
000018  ea520100          ORRS     r1,r2,r0
00001c  d037              BEQ      |L8.142|
00001e  4621              MOV      r1,r4                 ;613
;;;621                !data_send_zlp)  {                /* and ZLP was sent if necessary also */
;;;622            data_send_active = 0;               /* Sending not active any more        */
;;;623            return;
;;;624        }
;;;625    
;;;626        /* Check if data needs to be sent                                           */
;;;627        if (len_to_send) {
;;;628            /* If there is data available do be
;;;629                                                     sent                               */
;;;630            if ((ptr_data_sent >= ptr_data_to_send) && /* If data before end of buf avail*/
;;;631                    ((ptr_data_sent + len_to_send) >= (USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz))) {
000020  4f1e              LDR      r7,|L8.156|
000022  69c9              LDR      r1,[r1,#0x1c]         ;630
;;;632                /* and if available data wraps around
;;;633                   the end of the send buffer         */
;;;634                /* Correct bytes to send to data
;;;635                   available untill end of send buf   */
;;;636                len_to_send = USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz - ptr_data_sent;
;;;637            }
;;;638    
;;;639            if (len_to_send > usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed]) {
000024  f8df8078          LDR      r8,|L8.160|
000028  f8df9078          LDR      r9,|L8.164|
00002c  4d1e              LDR      r5,|L8.168|
00002e  b17a              CBZ      r2,|L8.80|
000030  69a0              LDR      r0,[r4,#0x18]         ;630  ; ptr_data_to_send
000032  4281              CMP      r1,r0                 ;630
000034  d305              BCC      |L8.66|
000036  8838              LDRH     r0,[r7,#0]            ;631  ; usbd_cdc_acm_sendbuf_sz
000038  188b              ADDS     r3,r1,r2              ;631
00003a  4428              ADD      r0,r0,r5              ;631
00003c  4283              CMP      r3,r0                 ;631
00003e  d300              BCC      |L8.66|
000040  1a42              SUBS     r2,r0,r1              ;636
                  |L8.66|
000042  f8993000          LDRB     r3,[r9,#0]  ; USBD_HighSpeed
000046  f8380013          LDRH     r0,[r8,r3,LSL #1]
00004a  4290              CMP      r0,r2
00004c  da00              BGE      |L8.80|
;;;640                /* If
;;;641                                                       there is more data to be sent then
;;;642                                                       can be sent in a single packet     */
;;;643                /* Correct to send maximum pckt size  */
;;;644                len_to_send = usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed];
00004e  4602              MOV      r2,r0
                  |L8.80|
;;;645            }
;;;646        } else if (data_send_zlp) {           /* or if ZLP should be sent           */
;;;647            len_to_send = 0;
;;;648        }
;;;649    
;;;650        data_send_zlp = 0;
;;;651        /* Send data                          */
;;;652        len_sent = USBD_WriteEP(usbd_cdc_acm_ep_bulkin | 0x80, ptr_data_sent, len_to_send);
000050  4816              LDR      r0,|L8.172|
000052  60e6              STR      r6,[r4,#0xc]  ; data_send_zlp
000054  7800              LDRB     r0,[r0,#0]  ; usbd_cdc_acm_ep_bulkin
000056  f0400080          ORR      r0,r0,#0x80
00005a  f7fffffe          BL       USBD_WriteEP
;;;653        ptr_data_sent    += len_sent;         /* Correct position of sent pointer   */
00005e  69e1              LDR      r1,[r4,#0x1c]  ; ptr_data_sent
000060  4401              ADD      r1,r1,r0
;;;654        data_to_send_rd  += len_sent;         /* Correct num of bytes left to send  */
000062  61e1              STR      r1,[r4,#0x1c]  ; ptr_data_sent
000064  6962              LDR      r2,[r4,#0x14]  ; data_to_send_rd
000066  4402              ADD      r2,r2,r0
;;;655    
;;;656        if (ptr_data_sent == USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz)
000068  6162              STR      r2,[r4,#0x14]  ; data_to_send_rd
00006a  883b              LDRH     r3,[r7,#0]  ; usbd_cdc_acm_sendbuf_sz
00006c  442b              ADD      r3,r3,r5
00006e  428b              CMP      r3,r1
000070  d100              BNE      |L8.116|
;;;657            /* If pointer to sent data wraps      */
;;;658        {
;;;659            ptr_data_sent = USBD_CDC_ACM_SendBuf;
000072  61e5              STR      r5,[r4,#0x1c]  ; ptr_data_sent
                  |L8.116|
;;;660        } /* Correct it to beginning of send
;;;661    
;;;662                                               buffer                             */
;;;663    
;;;664        if ((data_to_send_wr == data_to_send_rd) &&   /* If there are no more
000074  6921              LDR      r1,[r4,#0x10]  ; data_to_send_wr
000076  4291              CMP      r1,r2
000078  d10b              BNE      |L8.146|
;;;665                                               bytes available to be sent         */
;;;666                (len_sent == usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed])) {
00007a  f8992000          LDRB     r2,[r9,#0]  ; USBD_HighSpeed
00007e  f8381012          LDRH     r1,[r8,r2,LSL #1]
000082  4281              CMP      r1,r0
000084  d105              BNE      |L8.146|
;;;667            /* If last packet size was same as
;;;668               maximum packet size                */
;;;669            data_send_zlp = 1;                  /* ZLP packet should be sent          */
000086  2001              MOVS     r0,#1
000088  60e0              STR      r0,[r4,#0xc]  ; data_send_zlp
                  |L8.138|
;;;670        } else {
;;;671            data_send_zlp = 0;                  /* No ZLP packet should be sent       */
;;;672        }
;;;673    }
00008a  e8bd87f0          POP      {r4-r10,pc}
                  |L8.142|
00008e  60a6              STR      r6,[r4,#8]            ;623  ; data_send_active
000090  e7fb              B        |L8.138|
                  |L8.146|
000092  60e6              STR      r6,[r4,#0xc]          ;671  ; data_send_zlp
000094  e7f9              B        |L8.138|
;;;674    
                          ENDP

000096  0000              DCW      0x0000
                  |L8.152|
                          DCD      ||.data||
                  |L8.156|
                          DCD      usbd_cdc_acm_sendbuf_sz
                  |L8.160|
                          DCD      usbd_cdc_acm_maxpacketsize1
                  |L8.164|
                          DCD      USBD_HighSpeed
                  |L8.168|
                          DCD      USBD_CDC_ACM_SendBuf
                  |L8.172|
                          DCD      usbd_cdc_acm_ep_bulkin

                          AREA ||i.USBD_CDC_ACM_EP_BULKOUT_Event||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_EP_BULKOUT_Event PROC
;;;685    
;;;686    void USBD_CDC_ACM_EP_BULKOUT_Event(uint32_t event)
000000  b510              PUSH     {r4,lr}
;;;687    {
;;;688        if (data_read_access) {
000002  4c0b              LDR      r4,|L9.48|
000004  6a20              LDR      r0,[r4,#0x20]         ;687  ; data_read_access
000006  b118              CBZ      r0,|L9.16|
;;;689            /* If data is being accessed from
;;;690                                                     read function                      */
;;;691            data_received_pending_pckts++;      /* 1 more packet received and not
000008  6aa0              LDR      r0,[r4,#0x28]  ; data_received_pending_pckts
00000a  1c40              ADDS     r0,r0,#1
;;;692                                               handled                            */
;;;693            return;
00000c  62a0              STR      r0,[r4,#0x28]  ; data_received_pending_pckts
                  |L9.14|
;;;694        }
;;;695    
;;;696        data_read_access = 1;                 /* Block access to read data          */
;;;697        data_receive_int_access = 1;          /* Read access from interrupt function*/
;;;698        USBD_CDC_ACM_EP_BULKOUT_HandleData(); /* Handle received data               */
;;;699        data_receive_int_access = 0;          /* Read access from interrupt func end*/
;;;700        data_read_access = 0;                 /* Allow access to read data          */
;;;701    
;;;702        if (ptr_data_received != ptr_data_read) {
;;;703            USBD_CDC_ACM_DataReceived(ptr_data_received - ptr_data_read);
;;;704        }    /* Call
;;;705    
;;;706                                               received callback                  */
;;;707    }
00000e  bd10              POP      {r4,pc}
                  |L9.16|
000010  2001              MOVS     r0,#1                 ;696
000012  6220              STR      r0,[r4,#0x20]         ;697  ; data_read_access
000014  6260              STR      r0,[r4,#0x24]         ;698  ; data_receive_int_access
000016  f7fffffe          BL       USBD_CDC_ACM_EP_BULKOUT_HandleData
00001a  2000              MOVS     r0,#0                 ;699
00001c  6260              STR      r0,[r4,#0x24]         ;700  ; data_receive_int_access
00001e  6220              STR      r0,[r4,#0x20]         ;700  ; data_read_access
000020  e9d4010c          LDRD     r0,r1,[r4,#0x30]      ;700
000024  4288              CMP      r0,r1                 ;702
000026  d0f2              BEQ      |L9.14|
000028  1a40              SUBS     r0,r0,r1              ;703
00002a  f7fffffe          BL       USBD_CDC_ACM_DataReceived
00002e  bd10              POP      {r4,pc}
;;;708    
                          ENDP

                  |L9.48|
                          DCD      ||.data||

                          AREA ||i.USBD_CDC_ACM_EP_BULKOUT_HandleData||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_EP_BULKOUT_HandleData PROC
;;;571    
;;;572    static void USBD_CDC_ACM_EP_BULKOUT_HandleData()
000000  b510              PUSH     {r4,lr}
;;;573    {
;;;574        uint32_t len_free_to_recv;
;;;575        int32_t len_received;
;;;576    
;;;577        if ((usbd_cdc_acm_receivebuf_sz - (ptr_data_received - USBD_CDC_ACM_ReceiveBuf)) >= usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed]) {
000002  4c13              LDR      r4,|L10.80|
000004  4813              LDR      r0,|L10.84|
000006  4b16              LDR      r3,|L10.96|
000008  6b21              LDR      r1,[r4,#0x30]  ; ptr_data_received
00000a  1a0a              SUBS     r2,r1,r0
00000c  4812              LDR      r0,|L10.88|
00000e  781b              LDRB     r3,[r3,#0]  ; USBD_HighSpeed
000010  8800              LDRH     r0,[r0,#0]  ; usbd_cdc_acm_receivebuf_sz
000012  1a82              SUBS     r2,r0,r2
000014  4811              LDR      r0,|L10.92|
000016  f8300013          LDRH     r0,[r0,r3,LSL #1]
00001a  4282              CMP      r2,r0
00001c  db0e              BLT      |L10.60|
;;;578            /* If there is space for 1 max packet */
;;;579            /* Read received packet to receive buf*/
;;;580            len_free_to_recv = usbd_cdc_acm_receivebuf_sz - (ptr_data_received - USBD_CDC_ACM_ReceiveBuf);
;;;581            len_received       = USBD_ReadEP(usbd_cdc_acm_ep_bulkout, ptr_data_received, len_free_to_recv);
00001e  4811              LDR      r0,|L10.100|
000020  7800              LDRB     r0,[r0,#0]  ; usbd_cdc_acm_ep_bulkout
000022  f7fffffe          BL       USBD_ReadEP
;;;582            ptr_data_received += len_received;  /* Correct pointer to received data   */
000026  6b21              LDR      r1,[r4,#0x30]  ; ptr_data_received
000028  4408              ADD      r0,r0,r1
;;;583    
;;;584            if (data_received_pending_pckts &&  /* If packet was pending              */
00002a  6320              STR      r0,[r4,#0x30]  ; ptr_data_received
00002c  6aa0              LDR      r0,[r4,#0x28]  ; data_received_pending_pckts
00002e  2800              CMP      r0,#0
000030  d00c              BEQ      |L10.76|
;;;585                    !data_receive_int_access) {      /* and not interrupt access           */
000032  6a61              LDR      r1,[r4,#0x24]  ; data_receive_int_access
000034  2900              CMP      r1,#0
000036  d109              BNE      |L10.76|
000038  1e40              SUBS     r0,r0,#1
;;;586                data_received_pending_pckts--;    /* Decrement pending packets number   */
00003a  e006              B        |L10.74|
                  |L10.60|
;;;587            }
;;;588        } else {
;;;589            data_no_space_for_receive = 1;      /* There is no space in receive buffer
00003c  2001              MOVS     r0,#1
;;;590                                               for the newly received data        */
;;;591    
;;;592            if (data_receive_int_access) {
00003e  62e0              STR      r0,[r4,#0x2c]  ; data_no_space_for_receive
000040  6a60              LDR      r0,[r4,#0x24]  ; data_receive_int_access
000042  2800              CMP      r0,#0
000044  d002              BEQ      |L10.76|
;;;593                /* If this access is from interrupt
;;;594                                                       function                           */
;;;595                data_received_pending_pckts++;    /* then this is new unhandled packet  */
000046  6aa0              LDR      r0,[r4,#0x28]  ; data_received_pending_pckts
000048  1c40              ADDS     r0,r0,#1
                  |L10.74|
00004a  62a0              STR      r0,[r4,#0x28]         ;586  ; data_received_pending_pckts
                  |L10.76|
;;;596            }
;;;597        }
;;;598    }
00004c  bd10              POP      {r4,pc}
;;;599    
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      ||.data||
                  |L10.84|
                          DCD      USBD_CDC_ACM_ReceiveBuf
                  |L10.88|
                          DCD      usbd_cdc_acm_receivebuf_sz
                  |L10.92|
                          DCD      usbd_cdc_acm_maxpacketsize1
                  |L10.96|
                          DCD      USBD_HighSpeed
                  |L10.100|
                          DCD      usbd_cdc_acm_ep_bulkout

                          AREA ||i.USBD_CDC_ACM_EP_BULK_Event||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_EP_BULK_Event PROC
;;;743    
;;;744    void USBD_CDC_ACM_EP_BULK_Event(uint32_t event)
000000  b510              PUSH     {r4,lr}
;;;745    {
000002  4604              MOV      r4,r0
;;;746        if (event & USBD_EVT_OUT) {
000004  0740              LSLS     r0,r0,#29
000006  d502              BPL      |L11.14|
;;;747            USBD_CDC_ACM_EP_BULKOUT_Event(event);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USBD_CDC_ACM_EP_BULKOUT_Event
                  |L11.14|
;;;748        }
;;;749    
;;;750        if (event & USBD_EVT_IN) {
00000e  0720              LSLS     r0,r4,#28
000010  d504              BPL      |L11.28|
;;;751            USBD_CDC_ACM_EP_BULKIN_Event(event);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      USBD_CDC_ACM_EP_BULKIN_Event
                  |L11.28|
;;;752        }
;;;753    }
00001c  bd10              POP      {r4,pc}
;;;754    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_EP_INTIN_Event||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_EP_INTIN_Event PROC
;;;557    
;;;558    void USBD_CDC_ACM_EP_INTIN_Event(uint32_t event)
000000  4770              BX       lr
;;;559    {
;;;560        /* Notification will be loadad aynchronously and sent automatically upon
;;;561           Interrupt IN token reception                                             */
;;;562    }
;;;563    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_GetChar||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_GetChar PROC
;;;406    
;;;407    int32_t USBD_CDC_ACM_GetChar(void)
000000  b508              PUSH     {r3,lr}
;;;408    {
;;;409        uint8_t ch;
;;;410    
;;;411        if ((USBD_CDC_ACM_DataRead(&ch, 1)) == 1) {
000002  2101              MOVS     r1,#1
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       USBD_CDC_ACM_DataRead
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L13.20|
;;;412            return ((int32_t) ch);
;;;413        }
;;;414    
;;;415        return (-1);
00000e  f04f30ff          MOV      r0,#0xffffffff
;;;416    }
000012  bd08              POP      {r3,pc}
                  |L13.20|
000014  f89d0000          LDRB     r0,[sp,#0]            ;412
000018  bd08              POP      {r3,pc}
;;;417    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_GetCommFeature||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_GetCommFeature PROC
;;;109    }
;;;110    __weak int32_t USBD_CDC_ACM_GetCommFeature(uint16_t feat)
000000  2000              MOVS     r0,#0
;;;111    {
;;;112        return (0);
;;;113    }
000002  4770              BX       lr
;;;114    __weak int32_t USBD_CDC_ACM_ClearCommFeature(uint16_t feat)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_GetEncapsulatedResponse||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_GetEncapsulatedResponse PROC
;;;101    }
;;;102    __weak int32_t USBD_CDC_ACM_GetEncapsulatedResponse(void)
000000  2000              MOVS     r0,#0
;;;103    {
;;;104        return (0);
;;;105    }
000002  4770              BX       lr
;;;106    __weak int32_t USBD_CDC_ACM_SetCommFeature(uint16_t feat)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_GetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_GetLineCoding PROC
;;;246    
;;;247    __weak int32_t USBD_CDC_ACM_GetLineCoding(void)
000000  b510              PUSH     {r4,lr}
;;;248    {
;;;249        if (USBD_CDC_ACM_PortGetLineCoding(&line_coding)) {
000002  480c              LDR      r0,|L16.52|
000004  f7fffffe          BL       USBD_CDC_ACM_PortGetLineCoding
000008  2800              CMP      r0,#0
00000a  d012              BEQ      |L16.50|
;;;250            USBD_EP0Buf[0] = (line_coding.dwDTERate >>  0) & 0xFF;
00000c  4809              LDR      r0,|L16.52|
00000e  f7fffffe          BL       __aeabi_uread4
000012  4909              LDR      r1,|L16.56|
;;;251            USBD_EP0Buf[1] = (line_coding.dwDTERate >>  8) & 0xFF;
000014  0a02              LSRS     r2,r0,#8
000016  7008              STRB     r0,[r1,#0]            ;250
000018  704a              STRB     r2,[r1,#1]
;;;252            USBD_EP0Buf[2] = (line_coding.dwDTERate >> 16) & 0xFF;
00001a  0c02              LSRS     r2,r0,#16
00001c  708a              STRB     r2,[r1,#2]
;;;253            USBD_EP0Buf[3] = (line_coding.dwDTERate >> 24) & 0xFF;
00001e  0e00              LSRS     r0,r0,#24
000020  70c8              STRB     r0,[r1,#3]
;;;254            USBD_EP0Buf[4] =  line_coding.bCharFormat;
000022  4804              LDR      r0,|L16.52|
000024  7902              LDRB     r2,[r0,#4]  ; line_coding
000026  710a              STRB     r2,[r1,#4]
;;;255            USBD_EP0Buf[5] =  line_coding.bParityType;
000028  7942              LDRB     r2,[r0,#5]  ; line_coding
00002a  714a              STRB     r2,[r1,#5]
;;;256            USBD_EP0Buf[6] =  line_coding.bDataBits;
00002c  7980              LDRB     r0,[r0,#6]  ; line_coding
00002e  7188              STRB     r0,[r1,#6]
;;;257            return (1);
000030  2001              MOVS     r0,#1
                  |L16.50|
;;;258        }
;;;259    
;;;260        return (0);
;;;261    }
000032  bd10              POP      {r4,pc}
;;;262    
                          ENDP

                  |L16.52|
                          DCD      ||.data||+0x38
                  |L16.56|
                          DCD      USBD_EP0Buf

                          AREA ||i.USBD_CDC_ACM_Initialize||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_Initialize PROC
;;;139    
;;;140    __weak int32_t USBD_CDC_ACM_Initialize(void)
000000  b510              PUSH     {r4,lr}
;;;141    {
;;;142        data_send_access            = 0;
000002  4810              LDR      r0,|L17.68|
000004  2400              MOVS     r4,#0
;;;143        data_send_active            = 0;
;;;144        data_send_zlp               = 0;
;;;145        data_to_send_wr             = 0;
;;;146        data_to_send_rd             = 0;
;;;147        ptr_data_to_send            = USBD_CDC_ACM_SendBuf;
000006  4910              LDR      r1,|L17.72|
000008  6044              STR      r4,[r0,#4]            ;143  ; data_send_access
00000a  6084              STR      r4,[r0,#8]            ;144  ; data_send_active
00000c  60c4              STR      r4,[r0,#0xc]          ;145  ; data_send_zlp
00000e  6104              STR      r4,[r0,#0x10]  ; data_to_send_wr
000010  e9c04105          STRD     r4,r1,[r0,#0x14]
000014  e9c01407          STRD     r1,r4,[r0,#0x1c]
;;;148        ptr_data_sent               = USBD_CDC_ACM_SendBuf;
;;;149        data_read_access            = 0;
;;;150        data_receive_int_access     = 0;
;;;151        data_received_pending_pckts = 0;
000018  6244              STR      r4,[r0,#0x24]  ; data_receive_int_access
;;;152        data_no_space_for_receive   = 0;
;;;153        ptr_data_received           = USBD_CDC_ACM_ReceiveBuf;
00001a  490c              LDR      r1,|L17.76|
00001c  6284              STR      r4,[r0,#0x28]  ; data_received_pending_pckts
00001e  e9c0410b          STRD     r4,r1,[r0,#0x2c]
;;;154        ptr_data_read               = USBD_CDC_ACM_ReceiveBuf;
;;;155        control_line_state          = 0;
000022  6341              STR      r1,[r0,#0x34]  ; ptr_data_read
000024  8004              STRH     r4,[r0,#0]
;;;156        line_coding.dwDTERate       = 9600;
000026  f1000138          ADD      r1,r0,#0x38
00002a  f44f5016          MOV      r0,#0x2580
00002e  f7fffffe          BL       __aeabi_uwrite4
;;;157        line_coding.bCharFormat     = 0;
000032  4804              LDR      r0,|L17.68|
;;;158        line_coding.bParityType     = 0;
;;;159        line_coding.bDataBits       = 8;
000034  2108              MOVS     r1,#8
000036  3038              ADDS     r0,r0,#0x38           ;157
000038  7104              STRB     r4,[r0,#4]            ;157
00003a  7144              STRB     r4,[r0,#5]            ;158
00003c  7181              STRB     r1,[r0,#6]
;;;160        return (USBD_CDC_ACM_PortInitialize());
00003e  f7fffffe          BL       USBD_CDC_ACM_PortInitialize
;;;161    }
000042  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L17.68|
                          DCD      ||.data||
                  |L17.72|
                          DCD      USBD_CDC_ACM_SendBuf
                  |L17.76|
                          DCD      USBD_CDC_ACM_ReceiveBuf

                          AREA ||i.USBD_CDC_ACM_Notify||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_Notify PROC
;;;449    
;;;450    int32_t USBD_CDC_ACM_Notify(uint16_t stat)
000000  490f              LDR      r1,|L18.64|
;;;451    {
000002  b510              PUSH     {r4,lr}
;;;452        if (USBD_Configuration) {
000004  7809              LDRB     r1,[r1,#0]  ; USBD_Configuration
000006  b1c1              CBZ      r1,|L18.58|
;;;453            USBD_CDC_ACM_NotifyBuf[0] = 0xA1;   /* bmRequestType                      */
000008  490e              LDR      r1,|L18.68|
00000a  22a1              MOVS     r2,#0xa1
;;;454            USBD_CDC_ACM_NotifyBuf[1] = CDC_NOTIFICATION_SERIAL_STATE;/* bNotification
;;;455                                              (SERIAL_STATE)                      */
;;;456            USBD_CDC_ACM_NotifyBuf[2] = 0x00;   /* wValue                             */
;;;457            USBD_CDC_ACM_NotifyBuf[3] = 0x00;
;;;458            USBD_CDC_ACM_NotifyBuf[4] = 0x00;   /* wIndex (Interface 0)               */
;;;459            USBD_CDC_ACM_NotifyBuf[5] = 0x00;
;;;460            USBD_CDC_ACM_NotifyBuf[6] = 0x02;   /* wLength                            */
00000c  2302              MOVS     r3,#2
00000e  700a              STRB     r2,[r1,#0]            ;453
000010  2220              MOVS     r2,#0x20              ;454
000012  704a              STRB     r2,[r1,#1]            ;454
000014  2200              MOVS     r2,#0                 ;456
000016  708a              STRB     r2,[r1,#2]            ;456
000018  70ca              STRB     r2,[r1,#3]            ;457
00001a  710a              STRB     r2,[r1,#4]            ;458
00001c  714a              STRB     r2,[r1,#5]            ;459
00001e  718b              STRB     r3,[r1,#6]
;;;461            USBD_CDC_ACM_NotifyBuf[7] = 0x00;
000020  71ca              STRB     r2,[r1,#7]
;;;462            USBD_CDC_ACM_NotifyBuf[8] = stat >> 0; /* UART State Bitmap                  */
000022  7208              STRB     r0,[r1,#8]
;;;463            USBD_CDC_ACM_NotifyBuf[9] = stat >> 8;
000024  0a00              LSRS     r0,r0,#8
000026  7248              STRB     r0,[r1,#9]
;;;464            /* Write notification to be sent      */
;;;465            USBD_WriteEP(usbd_cdc_acm_ep_intin | 0x80, USBD_CDC_ACM_NotifyBuf, 10);
000028  4807              LDR      r0,|L18.72|
00002a  220a              MOVS     r2,#0xa
00002c  7800              LDRB     r0,[r0,#0]  ; usbd_cdc_acm_ep_intin
00002e  f0400080          ORR      r0,r0,#0x80
000032  f7fffffe          BL       USBD_WriteEP
;;;466            return (1);
000036  2001              MOVS     r0,#1
;;;467        }
;;;468    
;;;469        return (0);
;;;470    }
000038  bd10              POP      {r4,pc}
                  |L18.58|
00003a  2000              MOVS     r0,#0                 ;469
00003c  bd10              POP      {r4,pc}
;;;471    
                          ENDP

00003e  0000              DCW      0x0000
                  |L18.64|
                          DCD      USBD_Configuration
                  |L18.68|
                          DCD      USBD_CDC_ACM_NotifyBuf
                  |L18.72|
                          DCD      usbd_cdc_acm_ep_intin

                          AREA ||i.USBD_CDC_ACM_PortGetLineCoding||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortGetLineCoding PROC
;;;73     }
;;;74     __weak int32_t USBD_CDC_ACM_PortGetLineCoding(CDC_LINE_CODING *line_coding)
000000  2000              MOVS     r0,#0
;;;75     {
;;;76         return (0);
;;;77     }
000002  4770              BX       lr
;;;78     __weak int32_t USBD_CDC_ACM_PortSetControlLineState(uint16_t ctrl_bmp)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortInitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortInitialize PROC
;;;57        functionality                                                              */
;;;58     __weak int32_t USBD_CDC_ACM_PortInitialize(void)
000000  2000              MOVS     r0,#0
;;;59     {
;;;60         return (0);
;;;61     }
000002  4770              BX       lr
;;;62     __weak int32_t USBD_CDC_ACM_PortUninitialize(void)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortReset||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortReset PROC
;;;65     }
;;;66     __weak int32_t USBD_CDC_ACM_PortReset(void)
000000  2000              MOVS     r0,#0
;;;67     {
;;;68         return (0);
;;;69     }
000002  4770              BX       lr
;;;70     __weak int32_t USBD_CDC_ACM_PortSetLineCoding(CDC_LINE_CODING *line_coding)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortSetControlLineState||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortSetControlLineState PROC
;;;77     }
;;;78     __weak int32_t USBD_CDC_ACM_PortSetControlLineState(uint16_t ctrl_bmp)
000000  2000              MOVS     r0,#0
;;;79     {
;;;80         return (0);
;;;81     }
000002  4770              BX       lr
;;;82     
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortSetLineCoding||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortSetLineCoding PROC
;;;69     }
;;;70     __weak int32_t USBD_CDC_ACM_PortSetLineCoding(CDC_LINE_CODING *line_coding)
000000  2000              MOVS     r0,#0
;;;71     {
;;;72         return (0);
;;;73     }
000002  4770              BX       lr
;;;74     __weak int32_t USBD_CDC_ACM_PortGetLineCoding(CDC_LINE_CODING *line_coding)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortUninitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortUninitialize PROC
;;;61     }
;;;62     __weak int32_t USBD_CDC_ACM_PortUninitialize(void)
000000  2000              MOVS     r0,#0
;;;63     {
;;;64         return (0);
;;;65     }
000002  4770              BX       lr
;;;66     __weak int32_t USBD_CDC_ACM_PortReset(void)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PutChar||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PutChar PROC
;;;356    
;;;357    int32_t USBD_CDC_ACM_PutChar(const uint8_t ch)
000000  b501              PUSH     {r0,lr}
;;;358    {
;;;359        if ((USBD_CDC_ACM_DataSend(&ch, 1)) == 1) {
000002  2101              MOVS     r1,#1
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       USBD_CDC_ACM_DataSend
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L25.20|
;;;360            return ((uint32_t) ch);
;;;361        }
;;;362    
;;;363        return (-1);
00000e  f04f30ff          MOV      r0,#0xffffffff
;;;364    }
000012  bd08              POP      {r3,pc}
                  |L25.20|
000014  f89d0000          LDRB     r0,[sp,#0]            ;360
000018  bd08              POP      {r3,pc}
;;;365    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_Reset||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_Reset PROC
;;;190    
;;;191    __weak int32_t USBD_CDC_ACM_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;192    {
;;;193        data_send_access            = 0;
000002  4811              LDR      r0,|L26.72|
000004  2400              MOVS     r4,#0
;;;194        data_send_active            = 0;
;;;195        data_send_zlp               = 0;
;;;196        data_to_send_wr             = 0;
;;;197        data_to_send_rd             = 0;
;;;198        ptr_data_to_send            = USBD_CDC_ACM_SendBuf;
000006  4911              LDR      r1,|L26.76|
000008  6044              STR      r4,[r0,#4]            ;194  ; data_send_access
00000a  6084              STR      r4,[r0,#8]            ;195  ; data_send_active
00000c  60c4              STR      r4,[r0,#0xc]          ;196  ; data_send_zlp
00000e  6104              STR      r4,[r0,#0x10]  ; data_to_send_wr
000010  e9c04105          STRD     r4,r1,[r0,#0x14]
000014  e9c01407          STRD     r1,r4,[r0,#0x1c]
;;;199        ptr_data_sent               = USBD_CDC_ACM_SendBuf;
;;;200        data_read_access            = 0;
;;;201        data_receive_int_access     = 0;
;;;202        data_received_pending_pckts = 0;
000018  6244              STR      r4,[r0,#0x24]  ; data_receive_int_access
;;;203        data_no_space_for_receive   = 0;
;;;204        ptr_data_received           = USBD_CDC_ACM_ReceiveBuf;
00001a  490d              LDR      r1,|L26.80|
00001c  6284              STR      r4,[r0,#0x28]  ; data_received_pending_pckts
00001e  e9c0410b          STRD     r4,r1,[r0,#0x2c]
;;;205        ptr_data_read               = USBD_CDC_ACM_ReceiveBuf;
;;;206        control_line_state          = 0;
000022  6341              STR      r1,[r0,#0x34]  ; ptr_data_read
000024  8004              STRH     r4,[r0,#0]
;;;207        USBD_CDC_ACM_PortReset();
000026  f7fffffe          BL       USBD_CDC_ACM_PortReset
;;;208        line_coding.dwDTERate       = 9600;
00002a  4907              LDR      r1,|L26.72|
00002c  f44f5016          MOV      r0,#0x2580
000030  3138              ADDS     r1,r1,#0x38
000032  f7fffffe          BL       __aeabi_uwrite4
;;;209        line_coding.bCharFormat     = 0;
000036  4804              LDR      r0,|L26.72|
;;;210        line_coding.bParityType     = 0;
;;;211        line_coding.bDataBits       = 8;
000038  2108              MOVS     r1,#8
00003a  3038              ADDS     r0,r0,#0x38           ;209
00003c  7104              STRB     r4,[r0,#4]            ;209
00003e  7144              STRB     r4,[r0,#5]            ;210
000040  7181              STRB     r1,[r0,#6]
;;;212        return (USBD_CDC_ACM_PortSetLineCoding(&line_coding));
000042  f7fffffe          BL       USBD_CDC_ACM_PortSetLineCoding
;;;213    }
000046  bd10              POP      {r4,pc}
;;;214    
                          ENDP

                  |L26.72|
                          DCD      ||.data||
                  |L26.76|
                          DCD      USBD_CDC_ACM_SendBuf
                  |L26.80|
                          DCD      USBD_CDC_ACM_ReceiveBuf

                          AREA ||i.USBD_CDC_ACM_Reset_Event||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_Reset_Event PROC
;;;479    
;;;480    void USBD_CDC_ACM_Reset_Event(void)
000000  b510              PUSH     {r4,lr}
;;;481    {
;;;482        USBD_CDC_ACM_Reset();
000002  f7fffffe          BL       USBD_CDC_ACM_Reset
;;;483    }
000006  bd10              POP      {r4,pc}
;;;484    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_SOF_Event||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_SOF_Event PROC
;;;495    
;;;496    void USBD_CDC_ACM_SOF_Event(void)
000000  b570              PUSH     {r4-r6,lr}
;;;497    {
;;;498        if (!USBD_Configuration) {
000002  4819              LDR      r0,|L28.104|
000004  7800              LDRB     r0,[r0,#0]  ; USBD_Configuration
000006  2800              CMP      r0,#0                 ;497
000008  d02d              BEQ      |L28.102|
;;;499            // Don't process events until CDC is
;;;500            // configured and the endpoints enabled
;;;501            return;
;;;502        }
;;;503        if ((!data_read_access)         &&    /* If not read active                 */
00000a  4c18              LDR      r4,|L28.108|
00000c  2500              MOVS     r5,#0
;;;504                (ptr_data_received == ptr_data_read) &&     /* If received and read
;;;505                                                         pointers point to same
;;;506                                                         the location             */
;;;507                (ptr_data_received != USBD_CDC_ACM_ReceiveBuf)) {
;;;508            /* and if receive
;;;509                                                           pointer does not already
;;;510                                                           point to the start of
;;;511                                                           the receive buffer       */
;;;512            data_read_access = 1;               /* Block access to read data          */
00000e  2601              MOVS     r6,#1
000010  6a20              LDR      r0,[r4,#0x20]         ;503  ; data_read_access
000012  b950              CBNZ     r0,|L28.42|
000014  e9d4010c          LDRD     r0,r1,[r4,#0x30]      ;503
000018  4288              CMP      r0,r1                 ;504
00001a  d106              BNE      |L28.42|
00001c  4914              LDR      r1,|L28.112|
00001e  4288              CMP      r0,r1                 ;507
000020  d003              BEQ      |L28.42|
;;;513            ptr_data_received = USBD_CDC_ACM_ReceiveBuf;  /* Correct received pointer
;;;514                                                         to point to the start of
;;;515                                                         the receive buffer       */
;;;516            ptr_data_read     = USBD_CDC_ACM_ReceiveBuf;  /* Correct read pointer to
000022  6321              STR      r1,[r4,#0x30]  ; ptr_data_received
;;;517                                                         point to the start of the
;;;518                                                         receive buffer           */
;;;519            data_no_space_for_receive  = 0;               /* There is space for
;;;520                                                         reception available      */
;;;521            data_read_access = 0;               /* Allow access to read data          */
000024  62e5              STR      r5,[r4,#0x2c]  ; data_no_space_for_receive
000026  6225              STR      r5,[r4,#0x20]  ; data_read_access
000028  6361              STR      r1,[r4,#0x34]  ; ptr_data_read
                  |L28.42|
;;;522        }
;;;523    
;;;524        if (data_received_pending_pckts &&    /* If packets are pending             */
00002a  6aa0              LDR      r0,[r4,#0x28]  ; data_received_pending_pckts
00002c  b170              CBZ      r0,|L28.76|
;;;525                (!data_read_access)          &&    /* and if not read active             */
00002e  6a20              LDR      r0,[r4,#0x20]  ; data_read_access
000030  b960              CBNZ     r0,|L28.76|
;;;526                (!data_no_space_for_receive)) {    /* and if there is space to receive   */
000032  6ae0              LDR      r0,[r4,#0x2c]  ; data_no_space_for_receive
000034  b950              CBNZ     r0,|L28.76|
;;;527            data_read_access = 1;               /* Disable access to read data        */
;;;528            USBD_CDC_ACM_EP_BULKOUT_HandleData(); /* Handle received data             */
000036  6226              STR      r6,[r4,#0x20]  ; data_read_access
000038  f7fffffe          BL       USBD_CDC_ACM_EP_BULKOUT_HandleData
;;;529            data_read_access = 0;               /* Enable access to read data         */
00003c  6225              STR      r5,[r4,#0x20]  ; data_read_access
00003e  e9d4010c          LDRD     r0,r1,[r4,#0x30]
;;;530    
;;;531            if (ptr_data_received != ptr_data_read) {
000042  4288              CMP      r0,r1
000044  d002              BEQ      |L28.76|
;;;532                USBD_CDC_ACM_DataReceived(ptr_data_received - ptr_data_read);
000046  1a40              SUBS     r0,r0,r1
000048  f7fffffe          BL       USBD_CDC_ACM_DataReceived
                  |L28.76|
00004c  e9d40101          LDRD     r0,r1,[r4,#4]
;;;533            }  /* Call
;;;534    
;;;535                                               received callback                  */
;;;536        }
;;;537    
;;;538        if ((!data_send_access)         &&    /* If send data is not being accessed */
000050  4308              ORRS     r0,r0,r1
000052  d108              BNE      |L28.102|
000054  e9d40104          LDRD     r0,r1,[r4,#0x10]
;;;539                (!data_send_active)         &&    /* and send is not active             */
;;;540                (data_to_send_wr - data_to_send_rd) /* and if there is data to be sent    */
000058  4288              CMP      r0,r1
00005a  d004              BEQ      |L28.102|
;;;541    //&& ((control_line_state & 3) == 3)    /* and if DTR and RTS is 1            */
;;;542           ) {
;;;543            data_send_access = 1;               /* Block access to send data          */
;;;544            data_send_active = 1;               /* Start data sending                 */
00005c  6066              STR      r6,[r4,#4]  ; data_send_access
;;;545            USBD_CDC_ACM_EP_BULKIN_HandleData();/* Handle data to send                */
00005e  60a6              STR      r6,[r4,#8]  ; data_send_active
000060  f7fffffe          BL       USBD_CDC_ACM_EP_BULKIN_HandleData
;;;546            data_send_access = 0;               /* Allow access to send data          */
000064  6065              STR      r5,[r4,#4]  ; data_send_access
                  |L28.102|
;;;547        }
;;;548    }
000066  bd70              POP      {r4-r6,pc}
;;;549    
                          ENDP

                  |L28.104|
                          DCD      USBD_Configuration
                  |L28.108|
                          DCD      ||.data||
                  |L28.112|
                          DCD      USBD_CDC_ACM_ReceiveBuf

                          AREA ||i.USBD_CDC_ACM_SendBreak||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_SendBreak PROC
;;;117    }
;;;118    __weak int32_t USBD_CDC_ACM_SendBreak(uint16_t dur)
000000  2000              MOVS     r0,#0
;;;119    {
;;;120        return (0);
;;;121    }
000002  4770              BX       lr
;;;122    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_SendEncapsulatedCommand||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_SendEncapsulatedCommand PROC
;;;97        handling of CDC ACM requests)                                              */
;;;98     __weak int32_t USBD_CDC_ACM_SendEncapsulatedCommand(void)
000000  2000              MOVS     r0,#0
;;;99     {
;;;100        return (0);
;;;101    }
000002  4770              BX       lr
;;;102    __weak int32_t USBD_CDC_ACM_GetEncapsulatedResponse(void)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_SetCommFeature||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_SetCommFeature PROC
;;;105    }
;;;106    __weak int32_t USBD_CDC_ACM_SetCommFeature(uint16_t feat)
000000  2000              MOVS     r0,#0
;;;107    {
;;;108        return (0);
;;;109    }
000002  4770              BX       lr
;;;110    __weak int32_t USBD_CDC_ACM_GetCommFeature(uint16_t feat)
                          ENDP


                          AREA ||i.USBD_CDC_ACM_SetControlLineState||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_SetControlLineState PROC
;;;275    
;;;276    __weak int32_t USBD_CDC_ACM_SetControlLineState(uint16_t ctrl_bmp)
000000  4902              LDR      r1,|L32.12|
;;;277    {
000002  b510              PUSH     {r4,lr}
;;;278        control_line_state = ctrl_bmp;
000004  8008              STRH     r0,[r1,#0]
;;;279        return (USBD_CDC_ACM_PortSetControlLineState(ctrl_bmp));
000006  f7fffffe          BL       USBD_CDC_ACM_PortSetControlLineState
;;;280    }
00000a  bd10              POP      {r4,pc}
;;;281    
                          ENDP

                  |L32.12|
                          DCD      ||.data||

                          AREA ||i.USBD_CDC_ACM_SetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_SetLineCoding PROC
;;;224    
;;;225    __weak int32_t USBD_CDC_ACM_SetLineCoding(void)
000000  b510              PUSH     {r4,lr}
;;;226    {
;;;227        line_coding.dwDTERate   = (USBD_EP0Buf[0] <<  0) |
000002  4c0c              LDR      r4,|L33.52|
000004  7860              LDRB     r0,[r4,#1]  ; USBD_EP0Buf
000006  7822              LDRB     r2,[r4,#0]  ; USBD_EP0Buf
000008  78a1              LDRB     r1,[r4,#2]  ; USBD_EP0Buf
00000a  ea422000          ORR      r0,r2,r0,LSL #8
00000e  f361401f          BFI      r0,r1,#16,#16
000012  78e1              LDRB     r1,[r4,#3]  ; USBD_EP0Buf
000014  ea406001          ORR      r0,r0,r1,LSL #24
000018  4907              LDR      r1,|L33.56|
00001a  f7fffffe          BL       __aeabi_uwrite4
;;;228                                  (USBD_EP0Buf[1] <<  8) |
;;;229                                  (USBD_EP0Buf[2] << 16) |
;;;230                                  (USBD_EP0Buf[3] << 24) ;
;;;231        line_coding.bCharFormat =  USBD_EP0Buf[4];
00001e  4806              LDR      r0,|L33.56|
000020  7921              LDRB     r1,[r4,#4]  ; USBD_EP0Buf
000022  7101              STRB     r1,[r0,#4]
;;;232        line_coding.bParityType =  USBD_EP0Buf[5];
000024  7961              LDRB     r1,[r4,#5]  ; USBD_EP0Buf
000026  7141              STRB     r1,[r0,#5]
;;;233        line_coding.bDataBits   =  USBD_EP0Buf[6];
000028  79a1              LDRB     r1,[r4,#6]  ; USBD_EP0Buf
00002a  7181              STRB     r1,[r0,#6]
;;;234        return (USBD_CDC_ACM_PortSetLineCoding(&line_coding));
00002c  f7fffffe          BL       USBD_CDC_ACM_PortSetLineCoding
;;;235    }
000030  bd10              POP      {r4,pc}
;;;236    
                          ENDP

000032  0000              DCW      0x0000
                  |L33.52|
                          DCD      USBD_EP0Buf
                  |L33.56|
                          DCD      ||.data||+0x38

                          AREA ||i.USBD_CDC_ACM_Uninitialization||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_Uninitialization PROC
;;;172    
;;;173    __weak int32_t USBD_CDC_ACM_Uninitialization(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175        return (USBD_CDC_ACM_PortUninitialize());
000002  f7fffffe          BL       USBD_CDC_ACM_PortUninitialize
;;;176    }
000006  bd10              POP      {r4,pc}
;;;177    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  control_line_state
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  data_send_access
                          DCD      0x00000000
                  data_send_active
                          DCD      0x00000000
                  data_send_zlp
                          DCD      0x00000000
                  data_to_send_wr
                          DCD      0x00000000
                  data_to_send_rd
                          DCD      0x00000000
                  ptr_data_to_send
                          DCD      0x00000000
                  ptr_data_sent
                          DCD      0x00000000
                  data_read_access
                          DCD      0x00000000
                  data_receive_int_access
                          DCD      0x00000000
                  data_received_pending_pckts
                          DCD      0x00000000
                  data_no_space_for_receive
                          DCD      0x00000000
                  ptr_data_received
                          DCD      0x00000000
                  ptr_data_read
                          DCD      0x00000000
                  line_coding
                          DCD      0x00000000
00003c  000000            DCB      0x00,0x00,0x00
