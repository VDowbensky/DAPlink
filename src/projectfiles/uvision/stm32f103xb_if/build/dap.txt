; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\dap.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\dap.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\dap.crf ..\..\..\source\daplink\cmsis-dap\DAP.c]
                          THUMB

                          AREA ||i.DAP_ExecuteCommand||, CODE, READONLY, ALIGN=1

                  DAP_ExecuteCommand PROC
;;;1751   //             number of bytes in request (upper 16 bits)
;;;1752   uint32_t DAP_ExecuteCommand(const uint8_t *request, uint8_t *response) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1753     uint32_t cnt, num, n;
;;;1754   
;;;1755     if (*request == ID_DAP_ExecuteCommands) {
000004  7802              LDRB     r2,[r0,#0]
000006  2a7f              CMP      r2,#0x7f
000008  d003              BEQ      |L1.18|
;;;1756       *response++ = *request++;
;;;1757       cnt = *request++;
;;;1758       *response++ = (uint8_t)cnt;
;;;1759       num = (2U << 16) | 2U;
;;;1760       while (cnt--) {
;;;1761         n = DAP_ProcessCommand(request, response);
;;;1762         num += n;
;;;1763         request  += (uint16_t)(n >> 16);
;;;1764         response += (uint16_t) n;
;;;1765       }
;;;1766       return (num);
;;;1767     }
;;;1768   
;;;1769     return DAP_ProcessCommand(request, response);
00000a  e8bd41f0          POP      {r4-r8,lr}
00000e  f7ffbffe          B.W      DAP_ProcessCommand
                  |L1.18|
000012  f8012b01          STRB     r2,[r1],#1            ;1756
000016  7844              LDRB     r4,[r0,#1]            ;1757
000018  f8014b01          STRB     r4,[r1],#1            ;1758
00001c  1c86              ADDS     r6,r0,#2              ;1757
00001e  460d              MOV      r5,r1                 ;1758
000020  f04f1702          MOV      r7,#0x20002           ;1759
000024  e008              B        |L1.56|
                  |L1.38|
000026  4629              MOV      r1,r5                 ;1761
000028  4630              MOV      r0,r6                 ;1761
00002a  f7fffffe          BL       DAP_ProcessCommand
00002e  4407              ADD      r7,r7,r0              ;1762
000030  eb064610          ADD      r6,r6,r0,LSR #16      ;1763
000034  b280              UXTH     r0,r0                 ;1764
000036  4405              ADD      r5,r5,r0              ;1764
                  |L1.56|
000038  1e64              SUBS     r4,r4,#1              ;1764
00003a  d2f4              BCS      |L1.38|
00003c  4638              MOV      r0,r7                 ;1766
;;;1770   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1771   
                          ENDP


                          AREA ||i.DAP_Info||, CODE, READONLY, ALIGN=2

                  DAP_Info PROC
;;;78     //   return:  number of bytes in info data
;;;79     static uint8_t DAP_Info(uint8_t id, uint8_t *info) {
000000  b570              PUSH     {r4-r6,lr}
;;;80       uint8_t length = 0U;
000002  2400              MOVS     r4,#0
000004  460b              MOV      r3,r1                 ;79
000006  4622              MOV      r2,r4
;;;81     
;;;82       switch (id) {
000008  2807              CMP      r0,#7
00000a  d01e              BEQ      |L2.74|
00000c  dc06              BGT      |L2.28|
00000e  2805              CMP      r0,#5
000010  d23a              BCS      |L2.136|
000012  e8dff000          TBB      [pc,r0]
000016  3939              DCB      0x39,0x39
000018  39111500          DCB      0x39,0x11,0x15,0x00
                  |L2.28|
;;;83         case DAP_ID_VENDOR:
;;;84           length = DAP_GetVendorString((char *)info);
;;;85           break;
;;;86         case DAP_ID_PRODUCT:
;;;87           length = DAP_GetProductString((char *)info);
;;;88           break;
;;;89         case DAP_ID_SER_NUM:
;;;90           length = DAP_GetSerNumString((char *)info);
;;;91           break;
;;;92         case DAP_ID_CMSIS_DAP_VER:
;;;93           length = (uint8_t)sizeof(DAP_FW_Ver);
;;;94           memcpy(info, DAP_FW_Ver, length);
;;;95           break;
;;;96         case DAP_ID_DEVICE_VENDOR:
;;;97     #if TARGET_DEVICE_FIXED
;;;98           length = (uint8_t)sizeof(TargetDeviceVendor);
;;;99           memcpy(info, TargetDeviceVendor, length);
;;;100    #endif
;;;101          break;
;;;102        case DAP_ID_DEVICE_NAME:
;;;103    #if TARGET_DEVICE_FIXED
;;;104          length = (uint8_t)sizeof(TargetDeviceName);
;;;105          memcpy(info, TargetDeviceName, length);
;;;106    #endif
;;;107          break;
;;;108        case DAP_ID_PRODUCT_FW_VER:
;;;109          length = DAP_ProductFirmwareVerString((char *)info);
;;;110          break;
;;;111        case DAP_ID_CAPABILITIES:
;;;112          info[0] = ((DAP_SWD  != 0)         ? (1U << 0) : 0U) |
;;;113                    ((DAP_JTAG != 0)         ? (1U << 1) : 0U) |
;;;114                    ((SWO_UART != 0)         ? (1U << 2) : 0U) |
;;;115                    ((SWO_MANCHESTER != 0)   ? (1U << 3) : 0U) |
;;;116                    /* Atomic Commands  */     (1U << 4)       |
;;;117                    ((TIMESTAMP_CLOCK != 0U) ? (1U << 5) : 0U) |
;;;118                    ((SWO_STREAM != 0U)      ? (1U << 6) : 0U);
;;;119          length = 1U;
;;;120          break;
;;;121        case DAP_ID_TIMESTAMP_CLOCK:
;;;122    #if (TIMESTAMP_CLOCK != 0U)
;;;123          info[0] = (uint8_t)(TIMESTAMP_CLOCK >>  0);
00001c  2140              MOVS     r1,#0x40
00001e  28fd              CMP      r0,#0xfd              ;82
000020  d032              BEQ      |L2.136|
000022  dc04              BGT      |L2.46|
000024  28f0              CMP      r0,#0xf0              ;82
000026  d01e              BEQ      |L2.102|
000028  28f1              CMP      r0,#0xf1              ;82
00002a  d12d              BNE      |L2.136|
00002c  e01d              B        |L2.106|
                  |L2.46|
00002e  28fe              CMP      r0,#0xfe              ;82
000030  d027              BEQ      |L2.130|
000032  28ff              CMP      r0,#0xff              ;82
000034  d128              BNE      |L2.136|
000036  e020              B        |L2.122|
000038  461d              MOV      r5,r3                 ;90
00003a  f7fffffe          BL       info_get_unique_id
00003e  e007              B        |L2.80|
000040  2406              MOVS     r4,#6                 ;93
000042  4622              MOV      r2,r4                 ;94
000044  4911              LDR      r1,|L2.140|
000046  4618              MOV      r0,r3                 ;94
000048  e00a              B        |L2.96|
                  |L2.74|
00004a  460d              MOV      r5,r1                 ;109
00004c  f7fffffe          BL       info_get_version
                  |L2.80|
000050  4606              MOV      r6,r0                 ;109
000052  f7fffffe          BL       strlen
000056  1c40              ADDS     r0,r0,#1              ;109
000058  b2c4              UXTB     r4,r0                 ;109
00005a  4622              MOV      r2,r4                 ;109
00005c  4631              MOV      r1,r6                 ;109
00005e  4628              MOV      r0,r5                 ;109
                  |L2.96|
000060  f7fffffe          BL       __aeabi_memcpy
000064  e010              B        |L2.136|
                  |L2.102|
000066  2031              MOVS     r0,#0x31              ;112
000068  e00c              B        |L2.132|
                  |L2.106|
00006a  7019              STRB     r1,[r3,#0]
;;;124          info[1] = (uint8_t)(TIMESTAMP_CLOCK >>  8);
00006c  2042              MOVS     r0,#0x42
00006e  7058              STRB     r0,[r3,#1]
;;;125          info[2] = (uint8_t)(TIMESTAMP_CLOCK >> 16);
000070  200f              MOVS     r0,#0xf
000072  7098              STRB     r0,[r3,#2]
;;;126          info[3] = (uint8_t)(TIMESTAMP_CLOCK >> 24);
000074  70da              STRB     r2,[r3,#3]
;;;127          length = 4U;
000076  2404              MOVS     r4,#4
;;;128    #endif
;;;129          break;
000078  e006              B        |L2.136|
                  |L2.122|
;;;130        case DAP_ID_SWO_BUFFER_SIZE:
;;;131    #if ((SWO_UART != 0) || (SWO_MANCHESTER != 0))
;;;132          info[0] = (uint8_t)(SWO_BUFFER_SIZE >>  0);
;;;133          info[1] = (uint8_t)(SWO_BUFFER_SIZE >>  8);
;;;134          info[2] = (uint8_t)(SWO_BUFFER_SIZE >> 16);
;;;135          info[3] = (uint8_t)(SWO_BUFFER_SIZE >> 24);
;;;136          length = 4U;
;;;137    #endif
;;;138          break;
;;;139        case DAP_ID_PACKET_SIZE:
;;;140          info[0] = (uint8_t)(DAP_PACKET_SIZE >> 0);
00007a  7019              STRB     r1,[r3,#0]
;;;141          info[1] = (uint8_t)(DAP_PACKET_SIZE >> 8);
00007c  705a              STRB     r2,[r3,#1]
;;;142          length = 2U;
00007e  2402              MOVS     r4,#2
;;;143          break;
000080  e002              B        |L2.136|
                  |L2.130|
;;;144        case DAP_ID_PACKET_COUNT:
;;;145          info[0] = DAP_PACKET_COUNT;
000082  2004              MOVS     r0,#4
                  |L2.132|
000084  7018              STRB     r0,[r3,#0]
;;;146          length = 1U;
000086  2401              MOVS     r4,#1
                  |L2.136|
;;;147          break;
;;;148        default:
;;;149          break;
;;;150      }
;;;151    
;;;152      return (length);
000088  4620              MOV      r0,r4
;;;153    }
00008a  bd70              POP      {r4-r6,pc}
;;;154    
                          ENDP

                  |L2.140|
                          DCD      ||.constdata||

                          AREA ||i.DAP_ProcessCommand||, CODE, READONLY, ALIGN=2

                  DAP_ProcessCommand PROC
;;;1634   //             number of bytes in request (upper 16 bits)
;;;1635   uint32_t DAP_ProcessCommand(const uint8_t *request, uint8_t *response) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1636     uint32_t num;
;;;1637   
;;;1638     if ((*request >= ID_DAP_Vendor0) && (*request <= ID_DAP_Vendor31)) {
000004  7802              LDRB     r2,[r0,#0]
000006  f1a20380          SUB      r3,r2,#0x80
00000a  2b1f              CMP      r3,#0x1f
00000c  d803              BHI      |L3.22|
;;;1639       return DAP_ProcessVendorCommand(request, response);
00000e  f7fffffe          BL       DAP_ProcessVendorCommand
                  |L3.18|
;;;1640     }
;;;1641   
;;;1642     if ((*request >= ID_DAP_VendorExFirst) && (*request <= ID_DAP_VendorExLast)) {
;;;1643       return DAP_ProcessVendorCommandEx(request, response);
;;;1644     }
;;;1645   
;;;1646     *response++ = *request;
;;;1647   
;;;1648     switch (*request++) {
;;;1649       case ID_DAP_Info:
;;;1650         num = DAP_Info(*request, response+1);
;;;1651         *response = (uint8_t)num;
;;;1652         return ((2U << 16) + 2U + num);
;;;1653   
;;;1654       case ID_DAP_HostStatus:
;;;1655         num = DAP_HostStatus(request, response);
;;;1656         break;
;;;1657   
;;;1658       case ID_DAP_Connect:
;;;1659         num = DAP_Connect(request, response);
;;;1660         break;
;;;1661       case ID_DAP_Disconnect:
;;;1662         num = DAP_Disconnect(response);
;;;1663         break;
;;;1664   
;;;1665       case ID_DAP_Delay:
;;;1666         num = DAP_Delay(request, response);
;;;1667         break;
;;;1668   
;;;1669       case ID_DAP_ResetTarget:
;;;1670         num = DAP_ResetTarget(response);
;;;1671         break;
;;;1672   
;;;1673       case ID_DAP_SWJ_Pins:
;;;1674         num = DAP_SWJ_Pins(request, response);
;;;1675         break;
;;;1676       case ID_DAP_SWJ_Clock:
;;;1677         num = DAP_SWJ_Clock(request, response);
;;;1678         break;
;;;1679       case ID_DAP_SWJ_Sequence:
;;;1680         num = DAP_SWJ_Sequence(request, response);
;;;1681         break;
;;;1682   
;;;1683       case ID_DAP_SWD_Configure:
;;;1684         num = DAP_SWD_Configure(request, response);
;;;1685         break;
;;;1686       case ID_DAP_SWD_Sequence:
;;;1687         num = DAP_SWD_Sequence(request, response);
;;;1688         break;
;;;1689   
;;;1690       case ID_DAP_JTAG_Sequence:
;;;1691         num = DAP_JTAG_Sequence(request, response);
;;;1692         break;
;;;1693       case ID_DAP_JTAG_Configure:
;;;1694         num = DAP_JTAG_Configure(request, response);
;;;1695         break;
;;;1696       case ID_DAP_JTAG_IDCODE:
;;;1697         num = DAP_JTAG_IDCode(request, response);
;;;1698         break;
;;;1699   
;;;1700       case ID_DAP_TransferConfigure:
;;;1701         num = DAP_TransferConfigure(request, response);
;;;1702         break;
;;;1703       case ID_DAP_Transfer:
;;;1704         num = DAP_Transfer(request, response);
;;;1705         break;
;;;1706       case ID_DAP_TransferBlock:
;;;1707         num = DAP_TransferBlock(request, response);
;;;1708         break;
;;;1709   
;;;1710       case ID_DAP_WriteABORT:
;;;1711         num = DAP_WriteAbort(request, response);
;;;1712         break;
;;;1713   
;;;1714   #if ((SWO_UART != 0) || (SWO_MANCHESTER != 0))
;;;1715       case ID_DAP_SWO_Transport:
;;;1716         num = SWO_Transport(request, response);
;;;1717         break;
;;;1718       case ID_DAP_SWO_Mode:
;;;1719         num = SWO_Mode(request, response);
;;;1720         break;
;;;1721       case ID_DAP_SWO_Baudrate:
;;;1722         num = SWO_Baudrate(request, response);
;;;1723         break;
;;;1724       case ID_DAP_SWO_Control:
;;;1725         num = SWO_Control(request, response);
;;;1726         break;
;;;1727       case ID_DAP_SWO_Status:
;;;1728         num = SWO_Status(response);
;;;1729         break;
;;;1730       case ID_DAP_SWO_ExtendedStatus:
;;;1731         num = SWO_ExtendedStatus(request, response);
;;;1732         break;
;;;1733       case ID_DAP_SWO_Data:
;;;1734         num = SWO_Data(request, response);
;;;1735         break;
;;;1736   #endif
;;;1737   
;;;1738       default:
;;;1739         *(response-1) = ID_DAP_Invalid;
;;;1740         return ((1U << 16) | 1U);
;;;1741     }
;;;1742   
;;;1743     return ((1U << 16) + 1U + num);
;;;1744   }
000012  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.22|
000016  f1a203a0          SUB      r3,r2,#0xa0           ;1642
00001a  2b5e              CMP      r3,#0x5e              ;1642
00001c  d802              BHI      |L3.36|
00001e  f7fffffe          BL       DAP_ProcessVendorCommandEx
000022  e7f6              B        |L3.18|
                  |L3.36|
000024  f8012b01          STRB     r2,[r1],#1            ;1646
000028  460f              MOV      r7,r1                 ;1646
00002a  f810cb01          LDRB     r12,[r0],#1           ;1648
00002e  2400              MOVS     r4,#0                 ;1648
000030  23ff              MOVS     r3,#0xff              ;1648
000032  4998              LDR      r1,|L3.660|
000034  4a98              LDR      r2,|L3.664|
000036  f8dfb264          LDR      r11,|L3.668|
00003a  f8dfa264          LDR      r10,|L3.672|
00003e  f04f0901          MOV      r9,#1                 ;1638
000042  f44f5600          MOV      r6,#0x2000            ;1638
000046  f04f1501          MOV      r5,#0x10001           ;1638
00004a  f1bc0f1e          CMP      r12,#0x1e             ;1648
00004e  d277              BCS      |L3.320|
000050  e8dff00c          TBB      [pc,r12]              ;1648
000054  0f172650          DCB      0x0f,0x17,0x26,0x50
000058  bbc8e376          DCB      0xbb,0xc8,0xe3,0x76
00005c  f2647776          DCB      0xf2,0x64,0x77,0x76
000060  76767676          DCB      0x76,0x76,0x76,0x76
000064  7b7f8393          DCB      0x7b,0x7f,0x83,0x93
000068  a0b6b976          DCB      0xa0,0xb6,0xb9,0x76
00006c  76767676          DCB      0x76,0x76,0x76,0x76
000070  769c              DCB      0x76,0x9c
000072  7800              LDRB     r0,[r0,#0]            ;1650
000074  1c79              ADDS     r1,r7,#1              ;1650
000076  f7fffffe          BL       DAP_Info
00007a  7038              STRB     r0,[r7,#0]            ;1651
00007c  f1001002          ADD      r0,r0,#0x20002        ;1651
000080  e7c7              B        |L3.18|
000082  7802              LDRB     r2,[r0,#0]
000084  b122              CBZ      r2,|L3.144|
000086  2a01              CMP      r2,#1
000088  d058              BEQ      |L3.316|
00008a  703b              STRB     r3,[r7,#0]
                  |L3.140|
00008c  4608              MOV      r0,r1
00008e  e0e8              B        |L3.610|
                  |L3.144|
000090  7840              LDRB     r0,[r0,#1]
000092  07c2              LSLS     r2,r0,#31
000094  4883              LDR      r0,|L3.676|
000096  d001              BEQ      |L3.156|
000098  6146              STR      r6,[r0,#0x14]
00009a  e04f              B        |L3.316|
                  |L3.156|
00009c  6106              STR      r6,[r0,#0x10]
00009e  e04d              B        |L3.316|
0000a0  7804              LDRB     r4,[r0,#0]
0000a2  b12c              CBZ      r4,|L3.176|
0000a4  2c01              CMP      r4,#1
0000a6  d004              BEQ      |L3.178|
0000a8  2400              MOVS     r4,#0
                  |L3.170|
0000aa  703c              STRB     r4,[r7,#0]
                  |L3.172|
0000ac  4628              MOV      r0,r5
0000ae  e0d8              B        |L3.610|
                  |L3.176|
0000b0  2401              MOVS     r4,#1
                  |L3.178|
0000b2  f8829000          STRB     r9,[r2,#0]
0000b6  210d              MOVS     r1,#0xd
0000b8  4658              MOV      r0,r11
0000ba  f7fffffe          BL       pin_out_init
0000be  f8df81dc          LDR      r8,|L3.668|
0000c2  f1080810          ADD      r8,r8,#0x10
0000c6  f8c86000          STR      r6,[r8,#0]
0000ca  210c              MOVS     r1,#0xc
0000cc  4658              MOV      r0,r11
0000ce  f7fffffe          BL       pin_out_init
0000d2  f44f5080          MOV      r0,#0x1000
0000d6  f8c80000          STR      r0,[r8,#0]
0000da  2201              MOVS     r2,#1
0000dc  210e              MOVS     r1,#0xe
0000de  4658              MOV      r0,r11
0000e0  f7fffffe          BL       pin_in_init
0000e4  2106              MOVS     r1,#6
0000e6  4658              MOV      r0,r11
0000e8  f7fffffe          BL       pin_out_od_init
0000ec  2040              MOVS     r0,#0x40
0000ee  f8c80000          STR      r0,[r8,#0]
0000f2  e7da              B        |L3.170|
0000f4  7014              STRB     r4,[r2,#0]
0000f6  2200              MOVS     r2,#0
0000f8  210d              MOVS     r1,#0xd
0000fa  465d              MOV      r5,r11
0000fc  4658              MOV      r0,r11
0000fe  f7fffffe          BL       pin_in_init
000102  2200              MOVS     r2,#0
000104  210c              MOVS     r1,#0xc
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       pin_in_init
00010c  2200              MOVS     r2,#0
00010e  210e              MOVS     r1,#0xe
000110  4628              MOV      r0,r5
000112  f7fffffe          BL       pin_in_init
000116  703c              STRB     r4,[r7,#0]
000118  4648              MOV      r0,r9
00011a  e0a2              B        |L3.610|
00011c  7842              LDRB     r2,[r0,#1]            ;1663
00011e  7800              LDRB     r0,[r0,#0]            ;1663
000120  4b62              LDR      r3,|L3.684|
000122  ea402202          ORR      r2,r0,r2,LSL #8       ;1663
000126  4860              LDR      r0,|L3.680|
000128  6800              LDR      r0,[r0,#0]            ;1663  ; SystemCoreClock
00012a  fbb0f0f3          UDIV     r0,r0,r3              ;1663
00012e  2303              MOVS     r3,#3                 ;1663
000130  1c80              ADDS     r0,r0,#2              ;1663
000132  fbb0f0f3          UDIV     r0,r0,r3              ;1663
000136  4350              MULS     r0,r2,r0              ;1663
                  |L3.312|
000138  1e40              SUBS     r0,r0,#1              ;1663
00013a  d1fd              BNE      |L3.312|
                  |L3.316|
00013c  703c              STRB     r4,[r7,#0]            ;1663
00013e  e7a5              B        |L3.140|
                  |L3.320|
000140  e0a3              B        |L3.650|
000142  707c              STRB     r4,[r7,#1]            ;1667
000144  703c              STRB     r4,[r7,#0]            ;1667
000146  2002              MOVS     r0,#2                 ;1667
000148  e08b              B        |L3.610|
00014a  4639              MOV      r1,r7                 ;1674
00014c  f7fffffe          BL       DAP_SWJ_Pins
000150  e087              B        |L3.610|
000152  4639              MOV      r1,r7                 ;1677
000154  f7fffffe          BL       DAP_SWJ_Clock
000158  e083              B        |L3.610|
00015a  f8105b01          LDRB     r5,[r0],#1            ;1678
00015e  b90d              CBNZ     r5,|L3.356|
000160  f44f7580          MOV      r5,#0x100             ;1678
                  |L3.356|
000164  4601              MOV      r1,r0                 ;1678
000166  4628              MOV      r0,r5                 ;1678
000168  f7fffffe          BL       SWJ_Sequence
00016c  1ded              ADDS     r5,r5,#7              ;1678
00016e  703c              STRB     r4,[r7,#0]            ;1678
000170  08e8              LSRS     r0,r5,#3              ;1678
                  |L3.370|
000172  0400              LSLS     r0,r0,#16             ;1678
000174  f1001001          ADD      r0,r0,#0x10001        ;1678
000178  e073              B        |L3.610|
00017a  7800              LDRB     r0,[r0,#0]            ;1678
00017c  f0000103          AND      r1,r0,#3              ;1678
000180  1c49              ADDS     r1,r1,#1              ;1678
000182  7611              STRB     r1,[r2,#0x18]         ;1678
000184  f3c00080          UBFX     r0,r0,#2,#1           ;1678
000188  7650              STRB     r0,[r2,#0x19]         ;1678
00018a  e78e              B        |L3.170|
00018c  4639              MOV      r1,r7                 ;1687
00018e  f7fffffe          BL       DAP_SWD_Sequence
000192  e066              B        |L3.610|
000194  703b              STRB     r3,[r7,#0]            ;1688
000196  2201              MOVS     r2,#1                 ;1688
000198  4614              MOV      r4,r2                 ;1688
00019a  f8103b01          LDRB     r3,[r0],#1            ;1688
00019e  e00a              B        |L3.438|
                  |L3.416|
0001a0  f8101b01          LDRB     r1,[r0],#1            ;1691
0001a4  f011013f          ANDS     r1,r1,#0x3f           ;1691
0001a8  d100              BNE      |L3.428|
0001aa  2140              MOVS     r1,#0x40              ;1691
                  |L3.428|
0001ac  1dc9              ADDS     r1,r1,#7              ;1691
0001ae  08c9              LSRS     r1,r1,#3              ;1691
0001b0  440a              ADD      r2,r2,r1              ;1691
0001b2  4408              ADD      r0,r0,r1              ;1691
0001b4  1c52              ADDS     r2,r2,#1              ;1691
                  |L3.438|
0001b6  1e5b              SUBS     r3,r3,#1              ;1691
0001b8  d2f2              BCS      |L3.416|
0001ba  ea444002          ORR      r0,r4,r2,LSL #16      ;1691
0001be  e050              B        |L3.610|
0001c0  7800              LDRB     r0,[r0,#0]            ;1692
0001c2  703b              STRB     r3,[r7,#0]            ;1692
0001c4  e7d5              B        |L3.370|
0001c6  703b              STRB     r3,[r7,#0]            ;1695
0001c8  e770              B        |L3.172|
0001ca  7801              LDRB     r1,[r0,#0]            ;1698
0001cc  7311              STRB     r1,[r2,#0xc]          ;1698
0001ce  7881              LDRB     r1,[r0,#2]            ;1698
0001d0  7843              LDRB     r3,[r0,#1]            ;1698
0001d2  ea432101          ORR      r1,r3,r1,LSL #8       ;1698
0001d6  8211              STRH     r1,[r2,#0x10]         ;1698
0001d8  7901              LDRB     r1,[r0,#4]            ;1698
0001da  78c3              LDRB     r3,[r0,#3]            ;1698
0001dc  ea432001          ORR      r0,r3,r1,LSL #8       ;1698
0001e0  8250              STRH     r0,[r2,#0x12]         ;1698
0001e2  e050              B        |L3.646|
0001e4  7812              LDRB     r2,[r2,#0]            ;1702  ; DAP_Data
0001e6  4639              MOV      r1,r7                 ;1704
0001e8  2a01              CMP      r2,#1                 ;1704
0001ea  d013              BEQ      |L3.532|
0001ec  4605              MOV      r5,r0                 ;1704
0001ee  1c40              ADDS     r0,r0,#1              ;1704
0001f0  f8102b01          LDRB     r2,[r0],#1            ;1704
0001f4  b142              CBZ      r2,|L3.520|
                  |L3.502|
0001f6  f8103b01          LDRB     r3,[r0],#1            ;1704
0001fa  079e              LSLS     r6,r3,#30             ;1704
0001fc  d501              BPL      |L3.514|
0001fe  06db              LSLS     r3,r3,#27             ;1704
000200  d500              BPL      |L3.516|
                  |L3.514|
000202  1d00              ADDS     r0,r0,#4              ;1704
                  |L3.516|
000204  1e52              SUBS     r2,r2,#1              ;1704
000206  d1f6              BNE      |L3.502|
                  |L3.520|
000208  1b40              SUBS     r0,r0,r5              ;1704
00020a  700c              STRB     r4,[r1,#0]            ;1704
00020c  0400              LSLS     r0,r0,#16             ;1704
00020e  707c              STRB     r4,[r7,#1]            ;1704
000210  1c80              ADDS     r0,r0,#2              ;1704
000212  e026              B        |L3.610|
                  |L3.532|
000214  f7fffffe          BL       DAP_SWD_Transfer
000218  e023              B        |L3.610|
00021a  4605              MOV      r5,r0                 ;1707
00021c  7810              LDRB     r0,[r2,#0]            ;1707  ; DAP_Data
00021e  4639              MOV      r1,r7                 ;1707
000220  2801              CMP      r0,#1                 ;1707
000222  d00a              BEQ      |L3.570|
000224  700c              STRB     r4,[r1,#0]            ;1707
000226  704c              STRB     r4,[r1,#1]            ;1707
000228  70bc              STRB     r4,[r7,#2]            ;1707
00022a  2103              MOVS     r1,#3                 ;1707
                  |L3.556|
00022c  78e8              LDRB     r0,[r5,#3]            ;1707
00022e  0780              LSLS     r0,r0,#30             ;1707
000230  d508              BPL      |L3.580|
000232  f4412080          ORR      r0,r1,#0x40000        ;1707
000236  e014              B        |L3.610|
000238  e00e              B        |L3.600|
                  |L3.570|
00023a  4628              MOV      r0,r5                 ;1707
00023c  f7fffffe          BL       DAP_SWD_TransferBlock
000240  4601              MOV      r1,r0                 ;1707
000242  e7f3              B        |L3.556|
                  |L3.580|
000244  78a8              LDRB     r0,[r5,#2]            ;1707
000246  786a              LDRB     r2,[r5,#1]            ;1707
000248  ea422000          ORR      r0,r2,r0,LSL #8       ;1707
00024c  f44f2280          MOV      r2,#0x40000           ;1707
000250  eb024080          ADD      r0,r2,r0,LSL #18      ;1707
000254  4308              ORRS     r0,r0,r1              ;1707
000256  e004              B        |L3.610|
                  |L3.600|
000258  7811              LDRB     r1,[r2,#0]            ;1707  ; DAP_Data
00025a  2901              CMP      r1,#1                 ;1707
00025c  d004              BEQ      |L3.616|
00025e  703b              STRB     r3,[r7,#0]            ;1711
                  |L3.608|
000260  4650              MOV      r0,r10                ;1711
                  |L3.610|
000262  f1001001          ADD      r0,r0,#0x10001        ;1711
000266  e6d4              B        |L3.18|
                  |L3.616|
000268  7881              LDRB     r1,[r0,#2]
00026a  7843              LDRB     r3,[r0,#1]
00026c  78c2              LDRB     r2,[r0,#3]
00026e  ea432101          ORR      r1,r3,r1,LSL #8
000272  7900              LDRB     r0,[r0,#4]
000274  f362411f          BFI      r1,r2,#16,#16
000278  ea416000          ORR      r0,r1,r0,LSL #24
00027c  9000              STR      r0,[sp,#0]
00027e  4669              MOV      r1,sp
000280  2000              MOVS     r0,#0
000282  f7fffffe          BL       SWD_Transfer
                  |L3.646|
000286  703c              STRB     r4,[r7,#0]
000288  e7ea              B        |L3.608|
                  |L3.650|
00028a  f8073c01          STRB     r3,[r7,#-1]           ;1739
00028e  4628              MOV      r0,r5                 ;1740
000290  e6bf              B        |L3.18|
;;;1745   
                          ENDP

000292  0000              DCW      0x0000
                  |L3.660|
                          DCD      0x00020001
                  |L3.664|
                          DCD      ||.bss||
                  |L3.668|
                          DCD      0x40010c00
                  |L3.672|
                          DCD      0x00050001
                  |L3.676|
                          DCD      0x40011000
                  |L3.680|
                          DCD      SystemCoreClock
                  |L3.684|
                          DCD      0x000f4240

                          AREA ||i.DAP_ProcessVendorCommand||, CODE, READONLY, ALIGN=1

                  DAP_ProcessVendorCommand PROC
;;;1612   //             number of bytes in request (upper 16 bits)
;;;1613   __WEAK uint32_t DAP_ProcessVendorCommand(const uint8_t *request, uint8_t *response) {
000000  20ff              MOVS     r0,#0xff
;;;1614     (void)request;
;;;1615     *response = ID_DAP_Invalid;
000002  7008              STRB     r0,[r1,#0]
;;;1616     return ((1U << 16) | 1U);
000004  f04f1001          MOV      r0,#0x10001
;;;1617   }
000008  4770              BX       lr
;;;1618   
                          ENDP


                          AREA ||i.DAP_ProcessVendorCommandEx||, CODE, READONLY, ALIGN=1

                  DAP_ProcessVendorCommandEx PROC
;;;1624   //             number of bytes in request (upper 16 bits)
;;;1625   __weak uint32_t DAP_ProcessVendorCommandEx(const uint8_t *request, uint8_t *response) {
000000  20ff              MOVS     r0,#0xff
;;;1626     *response = ID_DAP_Invalid;
000002  7008              STRB     r0,[r1,#0]
;;;1627     return ((1U << 16) | 1U);
000004  f04f1001          MOV      r0,#0x10001
;;;1628   }
000008  4770              BX       lr
;;;1629   
                          ENDP


                          AREA ||i.DAP_SETUP||, CODE, READONLY, ALIGN=2

                  DAP_SETUP PROC
;;;505    */
;;;506    __STATIC_INLINE void DAP_SETUP(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;507    {
;;;508        /* Enable port clock */
;;;509        __HAL_RCC_GPIOA_CLK_ENABLE();
000002  4821              LDR      r0,|L6.136|
000004  6981              LDR      r1,[r0,#0x18]
000006  f0410104          ORR      r1,r1,#4
00000a  6181              STR      r1,[r0,#0x18]
00000c  6981              LDR      r1,[r0,#0x18]
00000e  f0010104          AND      r1,r1,#4
;;;510        __HAL_RCC_GPIOB_CLK_ENABLE();
000012  9100              STR      r1,[sp,#0]
000014  6981              LDR      r1,[r0,#0x18]
000016  f0410108          ORR      r1,r1,#8
00001a  6181              STR      r1,[r0,#0x18]
00001c  6981              LDR      r1,[r0,#0x18]
00001e  f0010108          AND      r1,r1,#8
;;;511        __HAL_RCC_GPIOC_CLK_ENABLE();
000022  9100              STR      r1,[sp,#0]
000024  6981              LDR      r1,[r0,#0x18]
000026  f0410110          ORR      r1,r1,#0x10
00002a  6181              STR      r1,[r0,#0x18]
00002c  6981              LDR      r1,[r0,#0x18]
00002e  f0010110          AND      r1,r1,#0x10
;;;512        __HAL_RCC_GPIOD_CLK_ENABLE();
000032  9100              STR      r1,[sp,#0]
000034  6981              LDR      r1,[r0,#0x18]
000036  f0410120          ORR      r1,r1,#0x20
00003a  6181              STR      r1,[r0,#0x18]
00003c  6980              LDR      r0,[r0,#0x18]
;;;513        /* Configure I/O pin SWCLK */
;;;514        pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);
00003e  4e13              LDR      r6,|L6.140|
000040  f0000020          AND      r0,r0,#0x20           ;512
000044  9000              STR      r0,[sp,#0]
000046  210d              MOVS     r1,#0xd
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       pin_out_init
;;;515        SWCLK_TCK_PIN_PORT->BSRR = SWCLK_TCK_PIN;
00004e  4c0f              LDR      r4,|L6.140|
000050  1475              ASRS     r5,r6,#17
000052  3410              ADDS     r4,r4,#0x10
000054  6025              STR      r5,[r4,#0]
;;;516    
;;;517        pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);
000056  210c              MOVS     r1,#0xc
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       pin_out_init
;;;518        SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
00005e  14a0              ASRS     r0,r4,#18
000060  6020              STR      r0,[r4,#0]
;;;519    
;;;520        pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, 1);
000062  2201              MOVS     r2,#1
000064  210e              MOVS     r1,#0xe
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       pin_in_init
;;;521    
;;;522        pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);
00006c  2106              MOVS     r1,#6
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       pin_out_od_init
;;;523        nRESET_PIN_PORT->BSRR = nRESET_PIN;
000074  2040              MOVS     r0,#0x40
000076  6020              STR      r0,[r4,#0]
;;;524    
;;;525        pin_out_init(CONNECTED_LED_PORT, CONNECTED_LED_PIN_Bit);
000078  4c05              LDR      r4,|L6.144|
00007a  210d              MOVS     r1,#0xd
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       pin_out_init
;;;526        CONNECTED_LED_PORT->BSRR = CONNECTED_LED_PIN;
000082  6125              STR      r5,[r4,#0x10]
;;;527    }
000084  bdf8              POP      {r3-r7,pc}
;;;528    
                          ENDP

000086  0000              DCW      0x0000
                  |L6.136|
                          DCD      0x40021000
                  |L6.140|
                          DCD      0x40010c00
                  |L6.144|
                          DCD      0x40011000

                          AREA ||i.DAP_SWD_Sequence||, CODE, READONLY, ALIGN=2

                  DAP_SWD_Sequence PROC
;;;469    //             number of bytes in request (upper 16 bits)
;;;470    static uint32_t DAP_SWD_Sequence(const uint8_t *request, uint8_t *response) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;471      uint32_t sequence_info;
;;;472      uint32_t sequence_count;
;;;473      uint32_t request_count;
;;;474      uint32_t response_count;
;;;475      uint32_t count;
;;;476    
;;;477    #if (DAP_SWD != 0)
;;;478      *response++ = DAP_OK;
000004  2200              MOVS     r2,#0
000006  f8012b01          STRB     r2,[r1],#1
;;;479    #else
;;;480      *response++ = DAP_ERROR;
;;;481    #endif
;;;482      request_count  = 1U;
00000a  2501              MOVS     r5,#1
;;;483      response_count = 1U;
;;;484    
;;;485      sequence_count = *request++;
00000c  f8108b01          LDRB     r8,[r0],#1
000010  468a              MOV      r10,r1                ;478
000012  46a9              MOV      r9,r5                 ;483
000014  4604              MOV      r4,r0
000016  f44f5b80          MOV      r11,#0x1000
00001a  e032              B        |L7.130|
                  |L7.28|
;;;486      while (sequence_count--) {
;;;487        sequence_info = *request++;
00001c  f8147b01          LDRB     r7,[r4],#1
;;;488        count = sequence_info & SWD_SEQUENCE_CLK;
000020  f017003f          ANDS     r0,r7,#0x3f
;;;489        if (count == 0U) {
000024  d100              BNE      |L7.40|
;;;490          count = 64U;
000026  2040              MOVS     r0,#0x40
                  |L7.40|
000028  1dc0              ADDS     r0,r0,#7
;;;491        }
;;;492        count = (count + 7U) / 8U;
00002a  08c6              LSRS     r6,r0,#3
;;;493    #if (DAP_SWD != 0)
;;;494        if ((sequence_info & SWD_SEQUENCE_DIN) != 0U) {
00002c  0638              LSLS     r0,r7,#24
00002e  d508              BPL      |L7.66|
000030  2200              MOVS     r2,#0
000032  210c              MOVS     r1,#0xc
000034  4816              LDR      r0,|L7.144|
000036  f7fffffe          BL       pin_in_init
00003a  4915              LDR      r1,|L7.144|
00003c  4658              MOV      r0,r11
00003e  3110              ADDS     r1,r1,#0x10
;;;495          PIN_SWDIO_OUT_DISABLE();
000040  e006              B        |L7.80|
                  |L7.66|
000042  210c              MOVS     r1,#0xc
000044  4812              LDR      r0,|L7.144|
000046  f7fffffe          BL       pin_out_init
00004a  4911              LDR      r1,|L7.144|
00004c  4658              MOV      r0,r11
00004e  3114              ADDS     r1,r1,#0x14
                  |L7.80|
000050  6008              STR      r0,[r1,#0]
;;;496        } else {
;;;497          PIN_SWDIO_OUT_ENABLE();
;;;498        }
;;;499        SWD_Sequence(sequence_info, request, response);
000052  4652              MOV      r2,r10
000054  4621              MOV      r1,r4
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       SWD_Sequence
;;;500        if (sequence_count == 0U) {
00005c  f1b80f00          CMP      r8,#0
000060  d107              BNE      |L7.114|
000062  210c              MOVS     r1,#0xc
000064  480a              LDR      r0,|L7.144|
000066  f7fffffe          BL       pin_out_init
00006a  4909              LDR      r1,|L7.144|
00006c  3114              ADDS     r1,r1,#0x14
00006e  f8c1b000          STR      r11,[r1,#0]
                  |L7.114|
;;;501          PIN_SWDIO_OUT_ENABLE();
;;;502        }
;;;503    #endif
;;;504        if ((sequence_info & SWD_SEQUENCE_DIN) != 0U) {
000072  0638              LSLS     r0,r7,#24
000074  d502              BPL      |L7.124|
;;;505          request_count++;
;;;506    #if (DAP_SWD != 0)
;;;507          response += count;
000076  44b2              ADD      r10,r10,r6
;;;508          response_count += count;
000078  44b1              ADD      r9,r9,r6
00007a  e001              B        |L7.128|
                  |L7.124|
;;;509    #endif
;;;510        } else {
;;;511          request += count;
00007c  4434              ADD      r4,r4,r6
;;;512          request_count += count + 1U;
00007e  4435              ADD      r5,r5,r6
                  |L7.128|
000080  1c6d              ADDS     r5,r5,#1
                  |L7.130|
000082  f1b80801          SUBS     r8,r8,#1              ;486
000086  d2c9              BCS      |L7.28|
;;;513        }
;;;514      }
;;;515    
;;;516      return ((request_count << 16) | response_count);
000088  ea494005          ORR      r0,r9,r5,LSL #16
;;;517    }
00008c  e8bd9ff0          POP      {r4-r12,pc}
;;;518    
                          ENDP

                  |L7.144|
                          DCD      0x40010c00

                          AREA ||i.DAP_SWD_Transfer||, CODE, READONLY, ALIGN=2

                  DAP_SWD_Transfer PROC
;;;666    #if (DAP_SWD != 0)
;;;667    static uint32_t DAP_SWD_Transfer(const uint8_t *request, uint8_t *response) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
;;;668      const
;;;669      uint8_t  *request_head;
;;;670      uint32_t  request_count;
;;;671      uint32_t  request_value;
;;;672      uint8_t  *response_head;
;;;673      uint32_t  response_count;
;;;674      uint32_t  response_value;
;;;675      uint32_t  post_read;
;;;676      uint32_t  check_write;
;;;677      uint32_t  match_value;
;;;678      uint32_t  match_retry;
;;;679      uint32_t  retry;
;;;680      uint32_t  data;
;;;681    #if (TIMESTAMP_CLOCK != 0U)
;;;682      uint32_t  timestamp;
;;;683    #endif
;;;684    
;;;685      request_head   = request;
;;;686    
;;;687      response_count = 0U;
000008  9005              STR      r0,[sp,#0x14]
00000a  2000              MOVS     r0,#0
;;;688      response_value = 0U;
;;;689      response_head  = response;
;;;690      response      += 2;
;;;691    
;;;692      DAP_TransferAbort = 0U;
00000c  f8dfa38c          LDR      r10,|L8.924|
000010  e9cd0101          STRD     r0,r1,[sp,#4]
000014  1c8c              ADDS     r4,r1,#2              ;689
000016  f88a0000          STRB     r0,[r10,#0]
;;;693    
;;;694      post_read   = 0U;
;;;695      check_write = 0U;
;;;696    
;;;697      request++;            // Ignore DAP index
;;;698    
;;;699      request_count = *request++;
00001a  9003              STR      r0,[sp,#0xc]
00001c  7869              LDRB     r1,[r5,#1]
00001e  1cad              ADDS     r5,r5,#2
000020  4607              MOV      r7,r0                 ;694
000022  ea5f0801          MOVS     r8,r1
000026  d074              BEQ      |L8.274|
                  |L8.40|
;;;700    
;;;701      for (; request_count != 0U; request_count--) {
;;;702        request_value = *request++;
000028  f8156b01          LDRB     r6,[r5],#1
;;;703        if ((request_value & DAP_TRANSFER_RnW) != 0U) {
00002c  07b1              LSLS     r1,r6,#30
00002e  d571              BPL      |L8.276|
;;;704          // Read register
;;;705          if (post_read) {
000030  b3f7              CBZ      r7,|L8.176|
;;;706            // Read was posted before
;;;707            retry = DAP_Data.transfer.retry_count;
000032  f8dfb36c          LDR      r11,|L8.928|
;;;708            if ((request_value & (DAP_TRANSFER_APnDP | DAP_TRANSFER_MATCH_VALUE)) == DAP_TRANSFER_APnDP) {
000036  f0060011          AND      r0,r6,#0x11
00003a  2801              CMP      r0,#1
00003c  f8bb9010          LDRH     r9,[r11,#0x10]        ;707  ; DAP_Data
000040  d007              BEQ      |L8.82|
000042  4657              MOV      r7,r10                ;692
                  |L8.68|
;;;709              // Read previous AP data and post next AP read
;;;710              do {
;;;711                response_value = SWD_Transfer(request_value, &data);
;;;712              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
;;;713            } else {
;;;714              // Read previous AP data
;;;715              do {
;;;716                response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
000044  4669              MOV      r1,sp
000046  200e              MOVS     r0,#0xe
000048  f7fffffe          BL       SWD_Transfer
;;;717              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00004c  2802              CMP      r0,#2
00004e  d00e              BEQ      |L8.110|
000050  e013              B        |L8.122|
                  |L8.82|
000052  4669              MOV      r1,sp                 ;711
000054  4630              MOV      r0,r6                 ;711
000056  f7fffffe          BL       SWD_Transfer
00005a  2802              CMP      r0,#2                 ;712
00005c  d10e              BNE      |L8.124|
00005e  f1b90901          SUBS     r9,r9,#1              ;712
000062  d303              BCC      |L8.108|
000064  f89a1000          LDRB     r1,[r10,#0]           ;712  ; DAP_TransferAbort
000068  2900              CMP      r1,#0                 ;712
00006a  d0f2              BEQ      |L8.82|
                  |L8.108|
00006c  e146              B        |L8.764|
                  |L8.110|
00006e  f1b90901          SUBS     r9,r9,#1
000072  d302              BCC      |L8.122|
000074  7839              LDRB     r1,[r7,#0]  ; DAP_TransferAbort
000076  2900              CMP      r1,#0
000078  d0e4              BEQ      |L8.68|
                  |L8.122|
;;;718              post_read = 0U;
00007a  2700              MOVS     r7,#0
                  |L8.124|
;;;719            }
;;;720            if (response_value != DAP_TRANSFER_OK) {
00007c  2801              CMP      r0,#1
00007e  d1f5              BNE      |L8.108|
;;;721              break;
;;;722            }
;;;723            // Store previous AP data
;;;724            *response++ = (uint8_t) data;
000080  9900              LDR      r1,[sp,#0]
000082  f8041b01          STRB     r1,[r4],#1
;;;725            *response++ = (uint8_t)(data >>  8);
000086  9900              LDR      r1,[sp,#0]
000088  0a09              LSRS     r1,r1,#8
00008a  f8041b01          STRB     r1,[r4],#1
;;;726            *response++ = (uint8_t)(data >> 16);
00008e  9900              LDR      r1,[sp,#0]
000090  0c09              LSRS     r1,r1,#16
000092  f8041b02          STRB     r1,[r4],#2
;;;727            *response++ = (uint8_t)(data >> 24);
000096  9900              LDR      r1,[sp,#0]
000098  0e09              LSRS     r1,r1,#24
00009a  f8041c01          STRB     r1,[r4,#-1]
;;;728    #if (TIMESTAMP_CLOCK != 0U)
;;;729            if (post_read) {
00009e  b13f              CBZ      r7,|L8.176|
;;;730              // Store Timestamp of next AP read
;;;731              if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
0000a0  0631              LSLS     r1,r6,#24
0000a2  d50e              BPL      |L8.194|
;;;732                timestamp = DAP_Data.timestamp;
;;;733                *response++ = (uint8_t) timestamp;
0000a4  f8db1008          LDR      r1,[r11,#8]  ; DAP_Data
0000a8  f8041b01          STRB     r1,[r4],#1
;;;734                *response++ = (uint8_t)(timestamp >>  8);
0000ac  0a0a              LSRS     r2,r1,#8
0000ae  e000              B        |L8.178|
                  |L8.176|
0000b0  e007              B        |L8.194|
                  |L8.178|
0000b2  f8042b01          STRB     r2,[r4],#1
;;;735                *response++ = (uint8_t)(timestamp >> 16);
0000b6  0c0a              LSRS     r2,r1,#16
0000b8  f8042b02          STRB     r2,[r4],#2
;;;736                *response++ = (uint8_t)(timestamp >> 24);
0000bc  0e09              LSRS     r1,r1,#24
0000be  f8041c01          STRB     r1,[r4,#-1]
                  |L8.194|
;;;737              }
;;;738            }
;;;739    #endif
;;;740          }
;;;741          if ((request_value & DAP_TRANSFER_MATCH_VALUE) != 0U) {
0000c2  06f1              LSLS     r1,r6,#27
0000c4  d555              BPL      |L8.370|
;;;742            // Read with value match
;;;743            match_value = (uint32_t)(*(request+0) <<  0) |
0000c6  78a9              LDRB     r1,[r5,#2]
0000c8  7868              LDRB     r0,[r5,#1]
0000ca  f8152b03          LDRB     r2,[r5],#3
0000ce  ea422000          ORR      r0,r2,r0,LSL #8
0000d2  f361401f          BFI      r0,r1,#16,#16
0000d6  f8151b01          LDRB     r1,[r5],#1
0000da  ea406001          ORR      r0,r0,r1,LSL #24
;;;744                          (uint32_t)(*(request+1) <<  8) |
;;;745                          (uint32_t)(*(request+2) << 16) |
;;;746                          (uint32_t)(*(request+3) << 24);
;;;747            request += 4;
;;;748            match_retry = DAP_Data.transfer.match_retry;
0000de  9004              STR      r0,[sp,#0x10]
0000e0  48af              LDR      r0,|L8.928|
0000e2  f8b0b012          LDRH     r11,[r0,#0x12]  ; DAP_Data
;;;749            if ((request_value & DAP_TRANSFER_APnDP) != 0U) {
0000e6  07f0              LSLS     r0,r6,#31
0000e8  d015              BEQ      |L8.278|
;;;750              // Post AP read
;;;751              retry = DAP_Data.transfer.retry_count;
0000ea  48ad              LDR      r0,|L8.928|
0000ec  f8b09010          LDRH     r9,[r0,#0x10]  ; DAP_Data
                  |L8.240|
;;;752              do {
;;;753                response_value = SWD_Transfer(request_value, NULL);
0000f0  2100              MOVS     r1,#0
0000f2  4630              MOV      r0,r6
0000f4  f7fffffe          BL       SWD_Transfer
;;;754              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000f8  2802              CMP      r0,#2
0000fa  d002              BEQ      |L8.258|
;;;755              if (response_value != DAP_TRANSFER_OK) {
0000fc  2801              CMP      r0,#1
0000fe  d1b5              BNE      |L8.108|
000100  e009              B        |L8.278|
                  |L8.258|
000102  f1b90901          SUBS     r9,r9,#1              ;754
000106  d3b1              BCC      |L8.108|
000108  f89a1000          LDRB     r1,[r10,#0]           ;754  ; DAP_TransferAbort
00010c  2900              CMP      r1,#0                 ;754
00010e  d0ef              BEQ      |L8.240|
000110  e0f4              B        |L8.764|
                  |L8.274|
000112  e114              B        |L8.830|
                  |L8.276|
000114  e087              B        |L8.550|
                  |L8.278|
;;;756                break;
;;;757              }
;;;758            }
;;;759            do {
;;;760              // Read register until its value matches or retry counter expires
;;;761              retry = DAP_Data.transfer.retry_count;
000116  48a2              LDR      r0,|L8.928|
000118  f8b09010          LDRH     r9,[r0,#0x10]  ; DAP_Data
                  |L8.284|
;;;762              do {
;;;763                response_value = SWD_Transfer(request_value, &data);
00011c  4669              MOV      r1,sp
00011e  4630              MOV      r0,r6
000120  f7fffffe          BL       SWD_Transfer
;;;764              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000124  2802              CMP      r0,#2
000126  d002              BEQ      |L8.302|
;;;765              if (response_value != DAP_TRANSFER_OK) {
000128  2801              CMP      r0,#1
00012a  d116              BNE      |L8.346|
00012c  e007              B        |L8.318|
                  |L8.302|
00012e  f1b90901          SUBS     r9,r9,#1              ;764
000132  d312              BCC      |L8.346|
000134  f89a1000          LDRB     r1,[r10,#0]           ;764  ; DAP_TransferAbort
000138  2900              CMP      r1,#0                 ;764
00013a  d0ef              BEQ      |L8.284|
00013c  e00d              B        |L8.346|
                  |L8.318|
;;;766                break;
;;;767              }
;;;768            } while (((data & DAP_Data.transfer.match_mask) != match_value) && match_retry-- && !DAP_TransferAbort);
00013e  4998              LDR      r1,|L8.928|
000140  9a00              LDR      r2,[sp,#0]
000142  6949              LDR      r1,[r1,#0x14]  ; DAP_Data
000144  4011              ANDS     r1,r1,r2
000146  9a04              LDR      r2,[sp,#0x10]
000148  4291              CMP      r1,r2
00014a  d006              BEQ      |L8.346|
00014c  f1bb0b01          SUBS     r11,r11,#1
000150  d303              BCC      |L8.346|
000152  f89a1000          LDRB     r1,[r10,#0]  ; DAP_TransferAbort
000156  2900              CMP      r1,#0
000158  d0dd              BEQ      |L8.278|
                  |L8.346|
;;;769            if ((data & DAP_Data.transfer.match_mask) != match_value) {
00015a  4991              LDR      r1,|L8.928|
00015c  9a00              LDR      r2,[sp,#0]
00015e  6949              LDR      r1,[r1,#0x14]  ; DAP_Data
000160  4011              ANDS     r1,r1,r2
000162  9a04              LDR      r2,[sp,#0x10]
000164  4291              CMP      r1,r2
000166  d001              BEQ      |L8.364|
;;;770              response_value |= DAP_TRANSFER_MISMATCH;
000168  f0400010          ORR      r0,r0,#0x10
                  |L8.364|
;;;771            }
;;;772            if (response_value != DAP_TRANSFER_OK) {
00016c  2801              CMP      r0,#1
00016e  d117              BNE      |L8.416|
000170  e057              B        |L8.546|
                  |L8.370|
;;;773              break;
;;;774            }
;;;775          } else {
;;;776            // Normal read
;;;777            retry = DAP_Data.transfer.retry_count;
000172  f8dfb22c          LDR      r11,|L8.928|
;;;778            if ((request_value & DAP_TRANSFER_APnDP) != 0U) {
000176  07f1              LSLS     r1,r6,#31
000178  f8bb9010          LDRH     r9,[r11,#0x10]        ;777  ; DAP_Data
00017c  d022              BEQ      |L8.452|
;;;779              // Read AP register
;;;780              if (post_read == 0U) {
00017e  bb07              CBNZ     r7,|L8.450|
                  |L8.384|
;;;781                // Post AP read
;;;782                do {
;;;783                  response_value = SWD_Transfer(request_value, NULL);
000180  2100              MOVS     r1,#0
000182  4630              MOV      r0,r6
000184  f7fffffe          BL       SWD_Transfer
;;;784                } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000188  2802              CMP      r0,#2
00018a  d002              BEQ      |L8.402|
;;;785                if (response_value != DAP_TRANSFER_OK) {
00018c  2801              CMP      r0,#1
00018e  d107              BNE      |L8.416|
000190  e007              B        |L8.418|
                  |L8.402|
000192  f1b90901          SUBS     r9,r9,#1              ;784
000196  d303              BCC      |L8.416|
000198  f89a1000          LDRB     r1,[r10,#0]           ;784  ; DAP_TransferAbort
00019c  2900              CMP      r1,#0                 ;784
00019e  d0ef              BEQ      |L8.384|
                  |L8.416|
0001a0  e0ac              B        |L8.764|
                  |L8.418|
;;;786                  break;
;;;787                }
;;;788    #if (TIMESTAMP_CLOCK != 0U)
;;;789                // Store Timestamp
;;;790                if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
0001a2  0631              LSLS     r1,r6,#24
0001a4  d50c              BPL      |L8.448|
;;;791                  timestamp = DAP_Data.timestamp;
;;;792                  *response++ = (uint8_t) timestamp;
0001a6  f8db1008          LDR      r1,[r11,#8]  ; DAP_Data
0001aa  f8041b01          STRB     r1,[r4],#1
;;;793                  *response++ = (uint8_t)(timestamp >>  8);
0001ae  0a0a              LSRS     r2,r1,#8
0001b0  f8042b01          STRB     r2,[r4],#1
;;;794                  *response++ = (uint8_t)(timestamp >> 16);
0001b4  0c0a              LSRS     r2,r1,#16
0001b6  f8042b02          STRB     r2,[r4],#2
;;;795                  *response++ = (uint8_t)(timestamp >> 24);
0001ba  0e09              LSRS     r1,r1,#24
0001bc  f8041c01          STRB     r1,[r4,#-1]
                  |L8.448|
;;;796                }
;;;797    #endif
;;;798                post_read = 1U;
0001c0  2701              MOVS     r7,#1
                  |L8.450|
0001c2  e02e              B        |L8.546|
                  |L8.452|
;;;799              }
;;;800            } else {
;;;801              // Read DP register
;;;802              do {
;;;803                response_value = SWD_Transfer(request_value, &data);
0001c4  4669              MOV      r1,sp
0001c6  4630              MOV      r0,r6
0001c8  f7fffffe          BL       SWD_Transfer
;;;804              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0001cc  2802              CMP      r0,#2
0001ce  d002              BEQ      |L8.470|
;;;805              if (response_value != DAP_TRANSFER_OK) {
0001d0  2801              CMP      r0,#1
0001d2  d107              BNE      |L8.484|
0001d4  e007              B        |L8.486|
                  |L8.470|
0001d6  f1b90901          SUBS     r9,r9,#1              ;804
0001da  d303              BCC      |L8.484|
0001dc  f89a1000          LDRB     r1,[r10,#0]           ;804  ; DAP_TransferAbort
0001e0  2900              CMP      r1,#0                 ;804
0001e2  d0ef              BEQ      |L8.452|
                  |L8.484|
0001e4  e08a              B        |L8.764|
                  |L8.486|
;;;806                break;
;;;807              }
;;;808    #if (TIMESTAMP_CLOCK != 0U)
;;;809              // Store Timestamp
;;;810              if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
0001e6  0631              LSLS     r1,r6,#24
0001e8  d50c              BPL      |L8.516|
;;;811                timestamp = DAP_Data.timestamp;
;;;812                *response++ = (uint8_t) timestamp;
0001ea  f8db1008          LDR      r1,[r11,#8]  ; DAP_Data
0001ee  f8041b01          STRB     r1,[r4],#1
;;;813                *response++ = (uint8_t)(timestamp >>  8);
0001f2  0a0a              LSRS     r2,r1,#8
0001f4  f8042b01          STRB     r2,[r4],#1
;;;814                *response++ = (uint8_t)(timestamp >> 16);
0001f8  0c0a              LSRS     r2,r1,#16
0001fa  f8042b02          STRB     r2,[r4],#2
;;;815                *response++ = (uint8_t)(timestamp >> 24);
0001fe  0e09              LSRS     r1,r1,#24
000200  f8041c01          STRB     r1,[r4,#-1]
                  |L8.516|
;;;816              }
;;;817    #endif
;;;818              // Store data
;;;819              *response++ = (uint8_t) data;
000204  9900              LDR      r1,[sp,#0]
000206  f8041b01          STRB     r1,[r4],#1
;;;820              *response++ = (uint8_t)(data >>  8);
00020a  9900              LDR      r1,[sp,#0]
00020c  0a09              LSRS     r1,r1,#8
00020e  f8041b01          STRB     r1,[r4],#1
;;;821              *response++ = (uint8_t)(data >> 16);
000212  9900              LDR      r1,[sp,#0]
000214  0c09              LSRS     r1,r1,#16
000216  f8041b02          STRB     r1,[r4],#2
;;;822              *response++ = (uint8_t)(data >> 24);
00021a  9900              LDR      r1,[sp,#0]
00021c  0e09              LSRS     r1,r1,#24
00021e  f8041c01          STRB     r1,[r4,#-1]
                  |L8.546|
;;;823            }
;;;824          }
;;;825          check_write = 0U;
000222  2100              MOVS     r1,#0
000224  e05c              B        |L8.736|
                  |L8.550|
;;;826        } else {
;;;827          // Write register
;;;828          if (post_read) {
000226  b31f              CBZ      r7,|L8.624|
;;;829            // Read previous data
;;;830            retry = DAP_Data.transfer.retry_count;
000228  485d              LDR      r0,|L8.928|
00022a  f8b09010          LDRH     r9,[r0,#0x10]  ; DAP_Data
                  |L8.558|
;;;831            do {
;;;832              response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
00022e  4669              MOV      r1,sp
000230  200e              MOVS     r0,#0xe
000232  f7fffffe          BL       SWD_Transfer
;;;833            } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000236  2802              CMP      r0,#2
000238  d002              BEQ      |L8.576|
;;;834            if (response_value != DAP_TRANSFER_OK) {
00023a  2801              CMP      r0,#1
00023c  d15e              BNE      |L8.764|
00023e  e007              B        |L8.592|
                  |L8.576|
000240  f1b90901          SUBS     r9,r9,#1              ;833
000244  d35a              BCC      |L8.764|
000246  f89a1000          LDRB     r1,[r10,#0]           ;833  ; DAP_TransferAbort
00024a  2900              CMP      r1,#0                 ;833
00024c  d0ef              BEQ      |L8.558|
00024e  e055              B        |L8.764|
                  |L8.592|
;;;835              break;
;;;836            }
;;;837            // Store previous data
;;;838            *response++ = (uint8_t) data;
000250  9800              LDR      r0,[sp,#0]
000252  f8040b01          STRB     r0,[r4],#1
;;;839            *response++ = (uint8_t)(data >>  8);
000256  9800              LDR      r0,[sp,#0]
000258  0a00              LSRS     r0,r0,#8
00025a  f8040b01          STRB     r0,[r4],#1
;;;840            *response++ = (uint8_t)(data >> 16);
00025e  9800              LDR      r0,[sp,#0]
000260  0c00              LSRS     r0,r0,#16
000262  f8040b02          STRB     r0,[r4],#2
;;;841            *response++ = (uint8_t)(data >> 24);
000266  9800              LDR      r0,[sp,#0]
000268  0e00              LSRS     r0,r0,#24
00026a  f8040c01          STRB     r0,[r4,#-1]
;;;842            post_read = 0U;
00026e  2700              MOVS     r7,#0
                  |L8.624|
;;;843          }
;;;844          // Load data
;;;845          data = (uint32_t)(*(request+0) <<  0) |
000270  78a9              LDRB     r1,[r5,#2]
000272  7868              LDRB     r0,[r5,#1]
000274  f8152b03          LDRB     r2,[r5],#3
000278  ea422000          ORR      r0,r2,r0,LSL #8
00027c  f361401f          BFI      r0,r1,#16,#16
000280  f8151b01          LDRB     r1,[r5],#1
000284  ea406001          ORR      r0,r0,r1,LSL #24
;;;846                 (uint32_t)(*(request+1) <<  8) |
;;;847                 (uint32_t)(*(request+2) << 16) |
;;;848                 (uint32_t)(*(request+3) << 24);
;;;849          request += 4;
;;;850          if ((request_value & DAP_TRANSFER_MATCH_MASK) != 0U) {
000288  9000              STR      r0,[sp,#0]
00028a  06b1              LSLS     r1,r6,#26
00028c  d503              BPL      |L8.662|
;;;851            // Write match mask
;;;852            DAP_Data.transfer.match_mask = data;
00028e  4944              LDR      r1,|L8.928|
;;;853            response_value = DAP_TRANSFER_OK;
000290  6148              STR      r0,[r1,#0x14]  ; DAP_Data
000292  2001              MOVS     r0,#1
000294  e025              B        |L8.738|
                  |L8.662|
;;;854          } else {
;;;855            // Write DP/AP register
;;;856            retry = DAP_Data.transfer.retry_count;
000296  f8dfb108          LDR      r11,|L8.928|
00029a  f8bb9010          LDRH     r9,[r11,#0x10]  ; DAP_Data
                  |L8.670|
;;;857            do {
;;;858              response_value = SWD_Transfer(request_value, &data);
00029e  4669              MOV      r1,sp
0002a0  4630              MOV      r0,r6
0002a2  f7fffffe          BL       SWD_Transfer
;;;859            } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0002a6  2802              CMP      r0,#2
0002a8  d002              BEQ      |L8.688|
;;;860            if (response_value != DAP_TRANSFER_OK) {
0002aa  2801              CMP      r0,#1
0002ac  d126              BNE      |L8.764|
0002ae  e007              B        |L8.704|
                  |L8.688|
0002b0  f1b90901          SUBS     r9,r9,#1              ;859
0002b4  d322              BCC      |L8.764|
0002b6  f89a1000          LDRB     r1,[r10,#0]           ;859  ; DAP_TransferAbort
0002ba  2900              CMP      r1,#0                 ;859
0002bc  d0ef              BEQ      |L8.670|
0002be  e01d              B        |L8.764|
                  |L8.704|
;;;861              break;
;;;862            }
;;;863    #if (TIMESTAMP_CLOCK != 0U)
;;;864            // Store Timestamp
;;;865            if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
0002c0  0631              LSLS     r1,r6,#24
0002c2  d50c              BPL      |L8.734|
;;;866              timestamp = DAP_Data.timestamp;
;;;867              *response++ = (uint8_t) timestamp;
0002c4  f8db1008          LDR      r1,[r11,#8]  ; DAP_Data
0002c8  f8041b01          STRB     r1,[r4],#1
;;;868              *response++ = (uint8_t)(timestamp >>  8);
0002cc  0a0a              LSRS     r2,r1,#8
0002ce  f8042b01          STRB     r2,[r4],#1
;;;869              *response++ = (uint8_t)(timestamp >> 16);
0002d2  0c0a              LSRS     r2,r1,#16
0002d4  f8042b02          STRB     r2,[r4],#2
;;;870              *response++ = (uint8_t)(timestamp >> 24);
0002d8  0e09              LSRS     r1,r1,#24
0002da  f8041c01          STRB     r1,[r4,#-1]
                  |L8.734|
;;;871            }
;;;872    #endif
;;;873            check_write = 1U;
0002de  2101              MOVS     r1,#1
                  |L8.736|
0002e0  9103              STR      r1,[sp,#0xc]
                  |L8.738|
;;;874          }
;;;875        }
;;;876        response_count++;
0002e2  9901              LDR      r1,[sp,#4]
0002e4  1c49              ADDS     r1,r1,#1
;;;877        if (DAP_TransferAbort) {
0002e6  9101              STR      r1,[sp,#4]
0002e8  f89a1000          LDRB     r1,[r10,#0]  ; DAP_TransferAbort
0002ec  b931              CBNZ     r1,|L8.764|
0002ee  f1a80101          SUB      r1,r8,#1              ;701
0002f2  ea5f0801          MOVS     r8,r1                 ;701
0002f6  f47fae97          BNE      |L8.40|
0002fa  e00c              B        |L8.790|
                  |L8.764|
;;;878          break;
;;;879        }
;;;880      }
;;;881    
;;;882      for (; request_count != 0U; request_count--) {
0002fc  f1b80f00          CMP      r8,#0
000300  d009              BEQ      |L8.790|
;;;883        // Process canceled requests
;;;884        request_value = *request++;
000302  f8151b01          LDRB     r1,[r5],#1
;;;885        if ((request_value & DAP_TRANSFER_RnW) != 0U) {
000306  078a              LSLS     r2,r1,#30
000308  d501              BPL      |L8.782|
;;;886          // Read register
;;;887          if ((request_value & DAP_TRANSFER_MATCH_VALUE) != 0U) {
00030a  06c9              LSLS     r1,r1,#27
00030c  d500              BPL      |L8.784|
                  |L8.782|
00030e  1d2d              ADDS     r5,r5,#4
                  |L8.784|
000310  f1a80801          SUB      r8,r8,#1              ;882
000314  e7f2              B        |L8.764|
                  |L8.790|
;;;888            // Read with value match
;;;889            request += 4;
;;;890          }
;;;891        } else {
;;;892          // Write register
;;;893          request += 4;
;;;894        }
;;;895      }
;;;896    
;;;897      if (response_value == DAP_TRANSFER_OK) {
000316  2801              CMP      r0,#1
000318  d132              BNE      |L8.896|
;;;898        if (post_read) {
00031a  b30f              CBZ      r7,|L8.864|
;;;899          // Read previous data
;;;900          retry = DAP_Data.transfer.retry_count;
00031c  4820              LDR      r0,|L8.928|
00031e  4657              MOV      r7,r10                ;692
000320  8a06              LDRH     r6,[r0,#0x10]  ; DAP_Data
                  |L8.802|
;;;901          do {
;;;902            response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
000322  4669              MOV      r1,sp
000324  200e              MOVS     r0,#0xe
000326  f7fffffe          BL       SWD_Transfer
;;;903          } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00032a  2802              CMP      r0,#2
00032c  d002              BEQ      |L8.820|
;;;904          if (response_value != DAP_TRANSFER_OK) {
00032e  2801              CMP      r0,#1
000330  d126              BNE      |L8.896|
000332  e005              B        |L8.832|
                  |L8.820|
000334  1e76              SUBS     r6,r6,#1
000336  d323              BCC      |L8.896|
000338  7839              LDRB     r1,[r7,#0]            ;903  ; DAP_TransferAbort
00033a  2900              CMP      r1,#0                 ;903
00033c  d0f1              BEQ      |L8.802|
                  |L8.830|
00033e  e01f              B        |L8.896|
                  |L8.832|
;;;905            goto end;
;;;906          }
;;;907          // Store previous data
;;;908          *response++ = (uint8_t) data;
000340  9900              LDR      r1,[sp,#0]
000342  f8041b01          STRB     r1,[r4],#1
;;;909          *response++ = (uint8_t)(data >>  8);
000346  9900              LDR      r1,[sp,#0]
000348  0a09              LSRS     r1,r1,#8
00034a  f8041b01          STRB     r1,[r4],#1
;;;910          *response++ = (uint8_t)(data >> 16);
00034e  9900              LDR      r1,[sp,#0]
000350  0c09              LSRS     r1,r1,#16
000352  f8041b02          STRB     r1,[r4],#2
;;;911          *response++ = (uint8_t)(data >> 24);
000356  9900              LDR      r1,[sp,#0]
000358  0e09              LSRS     r1,r1,#24
00035a  f8041c01          STRB     r1,[r4,#-1]
00035e  e00f              B        |L8.896|
                  |L8.864|
;;;912        } else if (check_write) {
000360  9903              LDR      r1,[sp,#0xc]
000362  b169              CBZ      r1,|L8.896|
;;;913          // Check last write
;;;914          retry = DAP_Data.transfer.retry_count;
000364  480e              LDR      r0,|L8.928|
000366  4657              MOV      r7,r10                ;692
000368  8a06              LDRH     r6,[r0,#0x10]  ; DAP_Data
                  |L8.874|
;;;915          do {
;;;916            response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
00036a  2100              MOVS     r1,#0
00036c  200e              MOVS     r0,#0xe
00036e  f7fffffe          BL       SWD_Transfer
;;;917          } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000372  2802              CMP      r0,#2
000374  d104              BNE      |L8.896|
000376  1e76              SUBS     r6,r6,#1
000378  d302              BCC      |L8.896|
00037a  7839              LDRB     r1,[r7,#0]  ; DAP_TransferAbort
00037c  2900              CMP      r1,#0
00037e  d0f4              BEQ      |L8.874|
                  |L8.896|
000380  e9dd1201          LDRD     r1,r2,[sp,#4]
;;;918        }
;;;919      }
;;;920    
;;;921    end:
;;;922      *(response_head+0) = (uint8_t)response_count;
000384  7011              STRB     r1,[r2,#0]
;;;923      *(response_head+1) = (uint8_t)response_value;
000386  9902              LDR      r1,[sp,#8]
000388  7048              STRB     r0,[r1,#1]
;;;924    
;;;925      return (((uint32_t)(request - request_head) << 16) | (uint32_t)(response - response_head));
00038a  9802              LDR      r0,[sp,#8]
00038c  1a21              SUBS     r1,r4,r0
00038e  9805              LDR      r0,[sp,#0x14]
;;;926    }
000390  b007              ADD      sp,sp,#0x1c
000392  1a28              SUBS     r0,r5,r0              ;925
000394  ea414000          ORR      r0,r1,r0,LSL #16      ;925
000398  e8bd8ff0          POP      {r4-r11,pc}
;;;927    #endif
                          ENDP

                  |L8.924|
                          DCD      ||.data||
                  |L8.928|
                          DCD      ||.bss||

                          AREA ||i.DAP_SWD_TransferBlock||, CODE, READONLY, ALIGN=2

                  DAP_SWD_TransferBlock PROC
;;;1276   #if (DAP_SWD != 0)
;;;1277   static uint32_t DAP_SWD_TransferBlock(const uint8_t *request, uint8_t *response) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1278     uint32_t  request_count;
;;;1279     uint32_t  request_value;
;;;1280     uint32_t  response_count;
;;;1281     uint32_t  response_value;
;;;1282     uint8_t  *response_head;
;;;1283     uint32_t  retry;
;;;1284     uint32_t  data;
;;;1285   
;;;1286     response_count = 0U;
000004  2600              MOVS     r6,#0
;;;1287     response_value = 0U;
;;;1288     response_head  = response;
;;;1289     response      += 3;
;;;1290   
;;;1291     DAP_TransferAbort = 0U;
000006  f8df8128          LDR      r8,|L9.304|
00000a  4605              MOV      r5,r0                 ;1277
00000c  4630              MOV      r0,r6                 ;1287
00000e  468a              MOV      r10,r1                ;1288
000010  1ccf              ADDS     r7,r1,#3              ;1289
000012  f8886000          STRB     r6,[r8,#0]
;;;1292   
;;;1293     request++;            // Ignore DAP index
;;;1294   
;;;1295     request_count = (uint32_t)(*(request+0) << 0) |
000016  78a9              LDRB     r1,[r5,#2]
000018  786a              LDRB     r2,[r5,#1]
00001a  1ced              ADDS     r5,r5,#3
00001c  ea522401          ORRS     r4,r2,r1,LSL #8
000020  d07a              BEQ      |L9.280|
;;;1296                     (uint32_t)(*(request+1) << 8);
;;;1297     request += 2;
;;;1298     if (request_count == 0U) {
;;;1299       goto end;
;;;1300     }
;;;1301   
;;;1302     request_value = *request++;
000022  f8159b01          LDRB     r9,[r5],#1
;;;1303     if ((request_value & DAP_TRANSFER_RnW) != 0U) {
;;;1304       // Read register block
;;;1305       if ((request_value & DAP_TRANSFER_APnDP) != 0U) {
;;;1306         // Post AP read
;;;1307         retry = DAP_Data.transfer.retry_count;
000026  f8dfb10c          LDR      r11,|L9.308|
00002a  ea5f7189          LSLS     r1,r9,#30             ;1303
00002e  d562              BPL      |L9.246|
000030  ea5f71c9          LSLS     r1,r9,#31             ;1305
000034  d039              BEQ      |L9.170|
000036  f8bb5010          LDRH     r5,[r11,#0x10]  ; DAP_Data
                  |L9.58|
;;;1308         do {
;;;1309           response_value = SWD_Transfer(request_value, NULL);
00003a  2100              MOVS     r1,#0
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       SWD_Transfer
;;;1310         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000042  2802              CMP      r0,#2
000044  d002              BEQ      |L9.76|
;;;1311         if (response_value != DAP_TRANSFER_OK) {
000046  2801              CMP      r0,#1
000048  d166              BNE      |L9.280|
00004a  e02e              B        |L9.170|
                  |L9.76|
00004c  1e6d              SUBS     r5,r5,#1
00004e  d363              BCC      |L9.280|
000050  f8981000          LDRB     r1,[r8,#0]            ;1310  ; DAP_TransferAbort
000054  2900              CMP      r1,#0                 ;1310
000056  d0f0              BEQ      |L9.58|
000058  e05e              B        |L9.280|
                  |L9.90|
;;;1312           goto end;
;;;1313         }
;;;1314       }
;;;1315       while (request_count--) {
;;;1316         // Read DP/AP register
;;;1317         if ((request_count == 0U) && ((request_value & DAP_TRANSFER_APnDP) != 0U)) {
00005a  b924              CBNZ     r4,|L9.102|
00005c  ea5f70c9          LSLS     r0,r9,#31
000060  d001              BEQ      |L9.102|
;;;1318           // Last AP read
;;;1319           request_value = DP_RDBUFF | DAP_TRANSFER_RnW;
000062  f04f090e          MOV      r9,#0xe
                  |L9.102|
;;;1320         }
;;;1321         retry = DAP_Data.transfer.retry_count;
000066  f8bb5010          LDRH     r5,[r11,#0x10]  ; DAP_Data
                  |L9.106|
;;;1322         do {
;;;1323           response_value = SWD_Transfer(request_value, &data);
00006a  4669              MOV      r1,sp
00006c  4648              MOV      r0,r9
00006e  f7fffffe          BL       SWD_Transfer
;;;1324         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000072  2802              CMP      r0,#2
000074  d002              BEQ      |L9.124|
;;;1325         if (response_value != DAP_TRANSFER_OK) {
000076  2801              CMP      r0,#1
000078  d14e              BNE      |L9.280|
00007a  e006              B        |L9.138|
                  |L9.124|
00007c  1e6d              SUBS     r5,r5,#1
00007e  d34b              BCC      |L9.280|
000080  f8981000          LDRB     r1,[r8,#0]            ;1324  ; DAP_TransferAbort
000084  2900              CMP      r1,#0                 ;1324
000086  d0f0              BEQ      |L9.106|
000088  e046              B        |L9.280|
                  |L9.138|
;;;1326           goto end;
;;;1327         }
;;;1328         // Store data
;;;1329         *response++ = (uint8_t) data;
00008a  9900              LDR      r1,[sp,#0]
00008c  f8071b01          STRB     r1,[r7],#1
;;;1330         *response++ = (uint8_t)(data >>  8);
000090  9900              LDR      r1,[sp,#0]
000092  0a09              LSRS     r1,r1,#8
000094  f8071b01          STRB     r1,[r7],#1
;;;1331         *response++ = (uint8_t)(data >> 16);
000098  9900              LDR      r1,[sp,#0]
00009a  0c09              LSRS     r1,r1,#16
00009c  f8071b02          STRB     r1,[r7],#2
;;;1332         *response++ = (uint8_t)(data >> 24);
0000a0  9900              LDR      r1,[sp,#0]
0000a2  0e09              LSRS     r1,r1,#24
0000a4  f8071c01          STRB     r1,[r7,#-1]
0000a8  1c76              ADDS     r6,r6,#1
                  |L9.170|
0000aa  1e64              SUBS     r4,r4,#1
0000ac  d2d5              BCS      |L9.90|
0000ae  e033              B        |L9.280|
                  |L9.176|
;;;1333         response_count++;
;;;1334       }
;;;1335     } else {
;;;1336       // Write register block
;;;1337       while (request_count--) {
;;;1338         // Load data
;;;1339         data = (uint32_t)(*(request+0) <<  0) |
0000b0  78a9              LDRB     r1,[r5,#2]
0000b2  7868              LDRB     r0,[r5,#1]
0000b4  f8152b03          LDRB     r2,[r5],#3
0000b8  ea422000          ORR      r0,r2,r0,LSL #8
0000bc  f361401f          BFI      r0,r1,#16,#16
0000c0  f8151b01          LDRB     r1,[r5],#1
0000c4  ea406001          ORR      r0,r0,r1,LSL #24
;;;1340                (uint32_t)(*(request+1) <<  8) |
;;;1341                (uint32_t)(*(request+2) << 16) |
;;;1342                (uint32_t)(*(request+3) << 24);
;;;1343         request += 4;
;;;1344         // Write DP/AP register
;;;1345         retry = DAP_Data.transfer.retry_count;
0000c8  9000              STR      r0,[sp,#0]
0000ca  481a              LDR      r0,|L9.308|
0000cc  f8b08010          LDRH     r8,[r0,#0x10]  ; DAP_Data
                  |L9.208|
;;;1346         do {
;;;1347           response_value = SWD_Transfer(request_value, &data);
0000d0  4669              MOV      r1,sp
0000d2  4648              MOV      r0,r9
0000d4  f7fffffe          BL       SWD_Transfer
;;;1348         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000d8  2802              CMP      r0,#2
0000da  d002              BEQ      |L9.226|
;;;1349         if (response_value != DAP_TRANSFER_OK) {
0000dc  2801              CMP      r0,#1
0000de  d11b              BNE      |L9.280|
0000e0  e007              B        |L9.242|
                  |L9.226|
0000e2  f1b80801          SUBS     r8,r8,#1              ;1348
0000e6  d317              BCC      |L9.280|
0000e8  f89b1000          LDRB     r1,[r11,#0]           ;1348  ; DAP_TransferAbort
0000ec  2900              CMP      r1,#0                 ;1348
0000ee  d0ef              BEQ      |L9.208|
0000f0  e012              B        |L9.280|
                  |L9.242|
0000f2  1c76              ADDS     r6,r6,#1              ;1348
;;;1350           goto end;
;;;1351         }
;;;1352         response_count++;
0000f4  e000              B        |L9.248|
                  |L9.246|
0000f6  46c3              MOV      r11,r8                ;1291
                  |L9.248|
0000f8  1e64              SUBS     r4,r4,#1              ;1291
0000fa  d2d9              BCS      |L9.176|
;;;1353       }
;;;1354       // Check last write
;;;1355       retry = DAP_Data.transfer.retry_count;
0000fc  480d              LDR      r0,|L9.308|
0000fe  465d              MOV      r5,r11                ;1291
000100  8a04              LDRH     r4,[r0,#0x10]  ; DAP_Data
                  |L9.258|
;;;1356       do {
;;;1357         response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
000102  2100              MOVS     r1,#0
000104  200e              MOVS     r0,#0xe
000106  f7fffffe          BL       SWD_Transfer
;;;1358       } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00010a  2802              CMP      r0,#2
00010c  d104              BNE      |L9.280|
00010e  1e64              SUBS     r4,r4,#1
000110  d302              BCC      |L9.280|
000112  7829              LDRB     r1,[r5,#0]  ; DAP_TransferAbort
000114  2900              CMP      r1,#0
000116  d0f4              BEQ      |L9.258|
                  |L9.280|
;;;1359     }
;;;1360   
;;;1361   end:
;;;1362     *(response_head+0) = (uint8_t)(response_count >> 0);
000118  f88a6000          STRB     r6,[r10,#0]
;;;1363     *(response_head+1) = (uint8_t)(response_count >> 8);
00011c  0a32              LSRS     r2,r6,#8
00011e  f88a2001          STRB     r2,[r10,#1]
;;;1364     *(response_head+2) = (uint8_t) response_value;
000122  f88a0002          STRB     r0,[r10,#2]
;;;1365   
;;;1366     return ((uint32_t)(response - response_head));
000126  eba7000a          SUB      r0,r7,r10
;;;1367   }
00012a  e8bd8ff8          POP      {r3-r11,pc}
;;;1368   #endif
                          ENDP

00012e  0000              DCW      0x0000
                  |L9.304|
                          DCD      ||.data||
                  |L9.308|
                          DCD      ||.bss||

                          AREA ||i.DAP_SWJ_Clock||, CODE, READONLY, ALIGN=2

                  DAP_SWJ_Clock PROC
;;;375    //             number of bytes in request (upper 16 bits)
;;;376    static uint32_t DAP_SWJ_Clock(const uint8_t *request, uint8_t *response) {
000000  b530              PUSH     {r4,r5,lr}
;;;377    #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
;;;378      uint32_t clock;
;;;379      uint32_t delay;
;;;380    
;;;381      clock = (uint32_t)(*(request+0) <<  0) |
000002  7842              LDRB     r2,[r0,#1]
000004  7804              LDRB     r4,[r0,#0]
000006  7883              LDRB     r3,[r0,#2]
000008  ea442202          ORR      r2,r4,r2,LSL #8
00000c  78c0              LDRB     r0,[r0,#3]
00000e  f363421f          BFI      r2,r3,#16,#16
000012  ea526200          ORRS     r2,r2,r0,LSL #24
;;;382              (uint32_t)(*(request+1) <<  8) |
;;;383              (uint32_t)(*(request+2) << 16) |
;;;384              (uint32_t)(*(request+3) << 24);
;;;385    
;;;386      if (clock == 0U) {
;;;387        *response = DAP_ERROR;
;;;388        return ((4U << 16) | 1U);
000016  480f              LDR      r0,|L10.84|
000018  d009              BEQ      |L10.46|
;;;389      }
;;;390    
;;;391      if (clock >= MAX_SWJ_CLOCK(DELAY_FAST_CYCLES)) {
00001a  4b0f              LDR      r3,|L10.88|
00001c  2500              MOVS     r5,#0
;;;392        DAP_Data.fast_clock  = 1U;
00001e  4c0f              LDR      r4,|L10.92|
000020  681b              LDR      r3,[r3,#0]            ;391  ; SystemCoreClock
000022  ebb20f93          CMP      r2,r3,LSR #2          ;391
000026  d305              BCC      |L10.52|
000028  2201              MOVS     r2,#1
00002a  7062              STRB     r2,[r4,#1]
;;;393        DAP_Data.clock_delay = 1U;
00002c  e00f              B        |L10.78|
                  |L10.46|
00002e  22ff              MOVS     r2,#0xff              ;387
000030  700a              STRB     r2,[r1,#0]            ;387
;;;394      } else {
;;;395        DAP_Data.fast_clock  = 0U;
;;;396    
;;;397        delay = ((CPU_CLOCK/2U) + (clock - 1U)) / clock;
;;;398        if (delay > IO_PORT_WRITE_CYCLES) {
;;;399          delay -= IO_PORT_WRITE_CYCLES;
;;;400          delay  = (delay + (DELAY_SLOW_CYCLES - 1U)) / DELAY_SLOW_CYCLES;
;;;401        } else {
;;;402          delay  = 1U;
;;;403        }
;;;404    
;;;405        DAP_Data.clock_delay = delay;
;;;406      }
;;;407    
;;;408      *response = DAP_OK;
;;;409    #else
;;;410      *response = DAP_ERROR;
;;;411    #endif
;;;412    
;;;413      return ((4U << 16) | 1U);
;;;414    }
000032  bd30              POP      {r4,r5,pc}
                  |L10.52|
000034  eb020353          ADD      r3,r2,r3,LSR #1       ;397
000038  1e5b              SUBS     r3,r3,#1              ;397
00003a  fbb3f2f2          UDIV     r2,r3,r2              ;397
00003e  7065              STRB     r5,[r4,#1]            ;395
000040  2a02              CMP      r2,#2                 ;398
000042  d903              BLS      |L10.76|
000044  2303              MOVS     r3,#3                 ;400
000046  fbb2f2f3          UDIV     r2,r2,r3              ;400
00004a  e000              B        |L10.78|
                  |L10.76|
00004c  2201              MOVS     r2,#1                 ;402
                  |L10.78|
00004e  6062              STR      r2,[r4,#4]            ;408  ; DAP_Data
000050  700d              STRB     r5,[r1,#0]            ;408
000052  bd30              POP      {r4,r5,pc}
;;;415    
                          ENDP

                  |L10.84|
                          DCD      0x00040001
                  |L10.88|
                          DCD      SystemCoreClock
                  |L10.92|
                          DCD      ||.bss||

                          AREA ||i.DAP_SWJ_Pins||, CODE, READONLY, ALIGN=2

                  DAP_SWJ_Pins PROC
;;;272    //             number of bytes in request (upper 16 bits)
;;;273    static uint32_t DAP_SWJ_Pins(const uint8_t *request, uint8_t *response) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  468b              MOV      r11,r1
;;;274    #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
;;;275      uint32_t value;
;;;276      uint32_t select;
;;;277      uint32_t wait;
;;;278      uint32_t timestamp;
;;;279    
;;;280      value  = (uint32_t) *(request+0);
;;;281      select = (uint32_t) *(request+1);
;;;282      wait   = (uint32_t)(*(request+2) <<  0) |
000006  78c1              LDRB     r1,[r0,#3]
000008  7883              LDRB     r3,[r0,#2]
00000a  7805              LDRB     r5,[r0,#0]            ;280
00000c  7844              LDRB     r4,[r0,#1]            ;281
00000e  7902              LDRB     r2,[r0,#4]
000010  ea432101          ORR      r1,r3,r1,LSL #8
000014  7940              LDRB     r0,[r0,#5]
000016  f362411f          BFI      r1,r2,#16,#16
00001a  ea416600          ORR      r6,r1,r0,LSL #24
00001e  4836              LDR      r0,|L11.248|
;;;283               (uint32_t)(*(request+3) <<  8) |
;;;284               (uint32_t)(*(request+4) << 16) |
;;;285               (uint32_t)(*(request+5) << 24);
;;;286    
;;;287      if ((select & (1U << DAP_SWJ_SWCLK_TCK)) != 0U) {
000020  07e2              LSLS     r2,r4,#31
000022  f1000104          ADD      r1,r0,#4
000026  d006              BEQ      |L11.54|
;;;288        if ((value & (1U << DAP_SWJ_SWCLK_TCK)) != 0U) {
000028  07eb              LSLS     r3,r5,#31
00002a  f44f5200          MOV      r2,#0x2000
00002e  d001              BEQ      |L11.52|
000030  6002              STR      r2,[r0,#0]
;;;289          PIN_SWCLK_TCK_SET();
000032  e000              B        |L11.54|
                  |L11.52|
000034  600a              STR      r2,[r1,#0]
                  |L11.54|
;;;290        } else {
;;;291          PIN_SWCLK_TCK_CLR();
;;;292        }
;;;293      }
;;;294      if ((select & (1U << DAP_SWJ_SWDIO_TMS)) != 0U) {
000036  07a2              LSLS     r2,r4,#30
000038  d506              BPL      |L11.72|
;;;295        if ((value & (1U << DAP_SWJ_SWDIO_TMS)) != 0U) {
00003a  07ab              LSLS     r3,r5,#30
00003c  f44f5280          MOV      r2,#0x1000
000040  d501              BPL      |L11.70|
000042  6002              STR      r2,[r0,#0]
;;;296          PIN_SWDIO_TMS_SET();
000044  e000              B        |L11.72|
                  |L11.70|
000046  600a              STR      r2,[r1,#0]
                  |L11.72|
;;;297        } else {
;;;298          PIN_SWDIO_TMS_CLR();
;;;299        }
;;;300      }
;;;301      if ((select & (1U << DAP_SWJ_TDI)) != 0U) {
;;;302        PIN_TDI_OUT(value >> DAP_SWJ_TDI);
;;;303      }
;;;304      if ((select & (1U << DAP_SWJ_nTRST)) != 0U) {
;;;305        PIN_nTRST_OUT(value >> DAP_SWJ_nTRST);
;;;306      }
;;;307      if ((select & (1U << DAP_SWJ_nRESET)) != 0U){
000048  0622              LSLS     r2,r4,#24
00004a  d507              BPL      |L11.92|
;;;308        PIN_nRESET_OUT(value >> DAP_SWJ_nRESET);
00004c  09ea              LSRS     r2,r5,#7
00004e  07d3              LSLS     r3,r2,#31
000050  f04f0240          MOV      r2,#0x40
000054  d001              BEQ      |L11.90|
000056  6002              STR      r2,[r0,#0]
000058  e000              B        |L11.92|
                  |L11.90|
00005a  600a              STR      r2,[r1,#0]
                  |L11.92|
00005c  f8dfa098          LDR      r10,|L11.248|
000060  f04f0900          MOV      r9,#0
000064  f1aa0a04          SUB      r10,r10,#4
000068  f1aa0804          SUB      r8,r10,#4
;;;309      }
;;;310    
;;;311      if (wait != 0U) {
00006c  b37e              CBZ      r6,|L11.206|
;;;312    #if (TIMESTAMP_CLOCK != 0U)
;;;313        if (wait > 3000000U) {
00006e  4823              LDR      r0,|L11.252|
000070  4286              CMP      r6,r0
000072  d900              BLS      |L11.118|
;;;314          wait = 3000000U;
000074  4606              MOV      r6,r0
                  |L11.118|
;;;315        }
;;;316    #if (TIMESTAMP_CLOCK >= 1000000U)
;;;317        wait *= TIMESTAMP_CLOCK / 1000000U;
;;;318    #else
;;;319        wait /= 1000000U / TIMESTAMP_CLOCK;
;;;320    #endif
;;;321    #else
;;;322        wait  = 1U;
;;;323    #endif
;;;324        timestamp = TIMESTAMP_GET();
000076  f7fffffe          BL       TIMESTAMP_GET
00007a  4607              MOV      r7,r0
                  |L11.124|
;;;325        do {
;;;326          if ((select & (1U << DAP_SWJ_SWCLK_TCK)) != 0U) {
00007c  07e0              LSLS     r0,r4,#31
00007e  d005              BEQ      |L11.140|
000080  f8da0000          LDR      r0,[r10,#0]
000084  f3c03040          UBFX     r0,r0,#13,#1
;;;327            if ((value >> DAP_SWJ_SWCLK_TCK) ^ PIN_SWCLK_TCK_IN()) {
000088  42a8              CMP      r0,r5
00008a  d11b              BNE      |L11.196|
                  |L11.140|
;;;328              continue;
;;;329            }
;;;330          }
;;;331          if ((select & (1U << DAP_SWJ_SWDIO_TMS)) != 0U) {
00008c  07a0              LSLS     r0,r4,#30
00008e  d506              BPL      |L11.158|
000090  f8d80000          LDR      r0,[r8,#0]
000094  f3c03080          UBFX     r0,r0,#14,#1
;;;332            if ((value >> DAP_SWJ_SWDIO_TMS) ^ PIN_SWDIO_TMS_IN()) {
000098  ebb00f55          CMP      r0,r5,LSR #1
00009c  d112              BNE      |L11.196|
                  |L11.158|
;;;333              continue;
;;;334            }
;;;335          }
;;;336          if ((select & (1U << DAP_SWJ_TDI)) != 0U) {
00009e  0760              LSLS     r0,r4,#29
0000a0  d502              BPL      |L11.168|
;;;337            if ((value >> DAP_SWJ_TDI) ^ PIN_TDI_IN()) {
0000a2  ebb90f95          CMP      r9,r5,LSR #2
0000a6  d10d              BNE      |L11.196|
                  |L11.168|
;;;338              continue;
;;;339            }
;;;340          }
;;;341          if ((select & (1U << DAP_SWJ_nTRST)) != 0U) {
0000a8  06a0              LSLS     r0,r4,#26
0000aa  d502              BPL      |L11.178|
;;;342            if ((value >> DAP_SWJ_nTRST) ^ PIN_nTRST_IN()) {
0000ac  ebb91f55          CMP      r9,r5,LSR #5
0000b0  d108              BNE      |L11.196|
                  |L11.178|
;;;343              continue;
;;;344            }
;;;345          }
;;;346          if ((select & (1U << DAP_SWJ_nRESET)) != 0U) {
0000b2  0620              LSLS     r0,r4,#24
0000b4  d50b              BPL      |L11.206|
0000b6  f8d80000          LDR      r0,[r8,#0]
0000ba  f3c01080          UBFX     r0,r0,#6,#1
;;;347            if ((value >> DAP_SWJ_nRESET) ^ PIN_nRESET_IN()) {
0000be  ebb01fd5          CMP      r0,r5,LSR #7
0000c2  d004              BEQ      |L11.206|
                  |L11.196|
;;;348              continue;
;;;349            }
;;;350          }
;;;351          break;
;;;352        } while ((TIMESTAMP_GET() - timestamp) < wait);
0000c4  f7fffffe          BL       TIMESTAMP_GET
0000c8  1bc0              SUBS     r0,r0,r7
0000ca  42b0              CMP      r0,r6
0000cc  d3d6              BCC      |L11.124|
                  |L11.206|
0000ce  f8da0000          LDR      r0,[r10,#0]
0000d2  f8d82000          LDR      r2,[r8,#0]
0000d6  f3c03140          UBFX     r1,r0,#13,#1
0000da  f3c23280          UBFX     r2,r2,#14,#1
0000de  f8d80000          LDR      r0,[r8,#0]
;;;353      }
;;;354    
;;;355      value = (PIN_SWCLK_TCK_IN() << DAP_SWJ_SWCLK_TCK) |
0000e2  ea410142          ORR      r1,r1,r2,LSL #1
0000e6  0980              LSRS     r0,r0,#6
0000e8  ea4110c0          ORR      r0,r1,r0,LSL #7
;;;356              (PIN_SWDIO_TMS_IN() << DAP_SWJ_SWDIO_TMS) |
;;;357              (PIN_TDI_IN()       << DAP_SWJ_TDI)       |
;;;358              (PIN_TDO_IN()       << DAP_SWJ_TDO)       |
;;;359              (PIN_nTRST_IN()     << DAP_SWJ_nTRST)     |
;;;360              (PIN_nRESET_IN()    << DAP_SWJ_nRESET);
;;;361    
;;;362      *response = (uint8_t)value;
0000ec  f88b0000          STRB     r0,[r11,#0]
;;;363    #else
;;;364      *response = 0U;
;;;365    #endif
;;;366    
;;;367      return ((6U << 16) | 1U);
0000f0  4803              LDR      r0,|L11.256|
;;;368    }
0000f2  e8bd9ff0          POP      {r4-r12,pc}
;;;369    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L11.248|
                          DCD      0x40010c10
                  |L11.252|
                          DCD      0x002dc6c0
                  |L11.256|
                          DCD      0x00060001

                          AREA ||i.DAP_Setup||, CODE, READONLY, ALIGN=2

                  DAP_Setup PROC
;;;1773   // Setup DAP
;;;1774   void DAP_Setup(void) {
000000  480a              LDR      r0,|L12.44|
;;;1775   
;;;1776     // Default settings
;;;1777     DAP_Data.debug_port  = 0U;
000002  2100              MOVS     r1,#0
;;;1778     DAP_Data.fast_clock  = 0U;
;;;1779     DAP_Data.clock_delay = CLOCK_DELAY(DAP_DEFAULT_SWJ_CLOCK);
000004  4a0a              LDR      r2,|L12.48|
000006  7001              STRB     r1,[r0,#0]            ;1777
000008  7041              STRB     r1,[r0,#1]            ;1778
00000a  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00000c  4b09              LDR      r3,|L12.52|
00000e  fbb2f2f3          UDIV     r2,r2,r3
000012  1e92              SUBS     r2,r2,#2
;;;1780     DAP_Data.transfer.idle_cycles = 0U;
000014  6042              STR      r2,[r0,#4]  ; DAP_Data
000016  7301              STRB     r1,[r0,#0xc]
;;;1781     DAP_Data.transfer.retry_count = 100U;
000018  2264              MOVS     r2,#0x64
00001a  8202              STRH     r2,[r0,#0x10]
;;;1782     DAP_Data.transfer.match_retry = 0U;
00001c  8241              STRH     r1,[r0,#0x12]
;;;1783     DAP_Data.transfer.match_mask  = 0x00000000U;
;;;1784   #if (DAP_SWD != 0)
;;;1785     DAP_Data.swd_conf.turnaround  = 1U;
00001e  2201              MOVS     r2,#1
000020  6141              STR      r1,[r0,#0x14]  ; DAP_Data
000022  7602              STRB     r2,[r0,#0x18]
;;;1786     DAP_Data.swd_conf.data_phase  = 0U;
000024  7641              STRB     r1,[r0,#0x19]
;;;1787   #endif
;;;1788   #if (DAP_JTAG != 0)
;;;1789     DAP_Data.jtag_dev.count = 0U;
;;;1790   #endif
;;;1791   
;;;1792     DAP_SETUP();  // Device specific setup
000026  f7ffbffe          B.W      DAP_SETUP
;;;1793   }
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      ||.bss||
                  |L12.48|
                          DCD      SystemCoreClock
                  |L12.52|
                          DCD      0x00989680

                          AREA ||i.Delayms||, CODE, READONLY, ALIGN=2

                  Delayms PROC
;;;157    //    delay:  delay time in ms
;;;158    void Delayms(uint32_t delay) {
000000  4906              LDR      r1,|L13.28|
;;;159      delay *= ((CPU_CLOCK/1000U) + (DELAY_SLOW_CYCLES-1U)) / DELAY_SLOW_CYCLES;
000002  f44f727a          MOV      r2,#0x3e8
000006  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000008  fbb1f1f2          UDIV     r1,r1,r2
00000c  2203              MOVS     r2,#3
00000e  1c89              ADDS     r1,r1,#2
000010  fbb1f1f2          UDIV     r1,r1,r2
000014  4341              MULS     r1,r0,r1
                  |L13.22|
000016  1e49              SUBS     r1,r1,#1
000018  d1fd              BNE      |L13.22|
;;;160      PIN_DELAY_SLOW(delay);
;;;161    }
00001a  4770              BX       lr
;;;162    
                          ENDP

                  |L13.28|
                          DCD      SystemCoreClock

                          AREA ||i.TIMESTAMP_GET||, CODE, READONLY, ALIGN=2

                  TIMESTAMP_GET PROC
;;;481    */
;;;482    __STATIC_INLINE uint32_t TIMESTAMP_GET (void) {
000000  4804              LDR      r0,|L14.20|
;;;483      return (DWT->CYCCNT) / (CPU_CLOCK / TIMESTAMP_CLOCK);
000002  4905              LDR      r1,|L14.24|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  fbb0f0f1          UDIV     r0,r0,r1
00000a  4904              LDR      r1,|L14.28|
00000c  6849              LDR      r1,[r1,#4]
00000e  fbb1f0f0          UDIV     r0,r1,r0
;;;484    }
000012  4770              BX       lr
;;;485    
                          ENDP

                  |L14.20|
                          DCD      SystemCoreClock
                  |L14.24|
                          DCD      0x000f4240
                  |L14.28|
                          DCD      0xe0001000

                          AREA ||i.pin_in_init||, CODE, READONLY, ALIGN=1

                  pin_in_init PROC
;;;150    
;;;151    __STATIC_INLINE void pin_in_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit, uint8_t mode)
000000  b570              PUSH     {r4-r6,lr}
;;;152    {
;;;153        uint8_t config;
;;;154        if(mode == 1)
000002  2a01              CMP      r2,#1
000004  d012              BEQ      |L15.44|
;;;155            config = 0x08; //Up
;;;156        else if(mode == 2)
000006  2a02              CMP      r2,#2
000008  d010              BEQ      |L15.44|
;;;157            config = 0x08; //down
;;;158        else
;;;159            config = 0x00; //GPIO_Mode_AIN
00000a  2300              MOVS     r3,#0
                  |L15.12|
00000c  2401              MOVS     r4,#1                 ;152
;;;160    
;;;161        if(pin_bit >= 8)
;;;162        {
;;;163            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
;;;164            GPIOx->CRH |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit-8) << 2) );
;;;165            if(mode == 1)
;;;166                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
00000e  408c              LSLS     r4,r4,r1
000010  260f              MOVS     r6,#0xf               ;163
000012  008d              LSLS     r5,r1,#2              ;163
000014  2908              CMP      r1,#8                 ;161
000016  d311              BCC      |L15.60|
000018  3d20              SUBS     r5,r5,#0x20           ;161
00001a  6841              LDR      r1,[r0,#4]            ;163
00001c  40ae              LSLS     r6,r6,r5              ;163
00001e  43b1              BICS     r1,r1,r6              ;163
000020  6041              STR      r1,[r0,#4]            ;163
000022  6841              LDR      r1,[r0,#4]            ;164
000024  40ab              LSLS     r3,r3,r5              ;164
000026  430b              ORRS     r3,r3,r1              ;164
000028  6043              STR      r3,[r0,#4]            ;164
00002a  e00f              B        |L15.76|
                  |L15.44|
00002c  2308              MOVS     r3,#8                 ;157
00002e  e7ed              B        |L15.12|
                  |L15.48|
000030  6104              STR      r4,[r0,#0x10]
                  |L15.50|
;;;167            else if(mode == 2)
;;;168                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;169        }
;;;170        else
;;;171        {
;;;172            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;173            GPIOx->CRL |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit) << 2) );
;;;174            if(mode == 1)
;;;175                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
;;;176            else if(mode == 2)
;;;177                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;178        }
;;;179    }
000032  bd70              POP      {r4-r6,pc}
                  |L15.52|
000034  2a02              CMP      r2,#2                 ;167
000036  d1fc              BNE      |L15.50|
000038  6144              STR      r4,[r0,#0x14]         ;168
00003a  bd70              POP      {r4-r6,pc}
                  |L15.60|
00003c  6801              LDR      r1,[r0,#0]            ;172
00003e  40ae              LSLS     r6,r6,r5              ;172
000040  43b1              BICS     r1,r1,r6              ;172
000042  6001              STR      r1,[r0,#0]            ;172
000044  6801              LDR      r1,[r0,#0]            ;173
000046  40ab              LSLS     r3,r3,r5              ;173
000048  430b              ORRS     r3,r3,r1              ;173
00004a  6003              STR      r3,[r0,#0]            ;173
                  |L15.76|
00004c  2a01              CMP      r2,#1                 ;174
00004e  d1f1              BNE      |L15.52|
000050  e7ee              B        |L15.48|
;;;180    //**************************************************************************************************
                          ENDP


                          AREA ||i.pin_out_init||, CODE, READONLY, ALIGN=1

                  pin_out_init PROC
;;;122    
;;;123    __STATIC_INLINE void pin_out_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125        if(pin_bit >= 8)
;;;126        {
;;;127            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
000002  230f              MOVS     r3,#0xf
;;;128            GPIOx->CRH |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit-8) << 2) );
000004  2403              MOVS     r4,#3
000006  008a              LSLS     r2,r1,#2              ;127
000008  2908              CMP      r1,#8                 ;125
00000a  d309              BCC      |L16.32|
00000c  3a20              SUBS     r2,r2,#0x20           ;124
00000e  6841              LDR      r1,[r0,#4]            ;127
000010  4093              LSLS     r3,r3,r2              ;127
000012  4399              BICS     r1,r1,r3              ;127
000014  6041              STR      r1,[r0,#4]            ;127
000016  6841              LDR      r1,[r0,#4]
000018  4094              LSLS     r4,r4,r2
00001a  430c              ORRS     r4,r4,r1
00001c  6044              STR      r4,[r0,#4]
;;;129        }
;;;130        else
;;;131        {
;;;132            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;133            GPIOx->CRL |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit) << 2) );
;;;134        }
;;;135    }
00001e  bd10              POP      {r4,pc}
                  |L16.32|
000020  6801              LDR      r1,[r0,#0]            ;132
000022  4093              LSLS     r3,r3,r2              ;132
000024  4399              BICS     r1,r1,r3              ;132
000026  6001              STR      r1,[r0,#0]            ;132
000028  6801              LDR      r1,[r0,#0]            ;133
00002a  4094              LSLS     r4,r4,r2              ;133
00002c  4321              ORRS     r1,r1,r4              ;133
00002e  6001              STR      r1,[r0,#0]            ;133
000030  bd10              POP      {r4,pc}
;;;136    
                          ENDP


                          AREA ||i.pin_out_od_init||, CODE, READONLY, ALIGN=1

                  pin_out_od_init PROC
;;;136    
;;;137    __STATIC_INLINE void pin_out_od_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139        if(pin_bit >= 8)
;;;140        {
;;;141            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
000002  230f              MOVS     r3,#0xf
;;;142            GPIOx->CRH |= ( ((uint32_t)(0x04|0x03) & 0x0F) << ((pin_bit-8) << 2) );
000004  2407              MOVS     r4,#7
000006  008a              LSLS     r2,r1,#2              ;141
000008  2908              CMP      r1,#8                 ;139
00000a  d309              BCC      |L17.32|
00000c  3a20              SUBS     r2,r2,#0x20           ;138
00000e  6841              LDR      r1,[r0,#4]            ;141
000010  4093              LSLS     r3,r3,r2              ;141
000012  4399              BICS     r1,r1,r3              ;141
000014  6041              STR      r1,[r0,#4]            ;141
000016  6841              LDR      r1,[r0,#4]
000018  4094              LSLS     r4,r4,r2
00001a  430c              ORRS     r4,r4,r1
00001c  6044              STR      r4,[r0,#4]
;;;143        }
;;;144        else
;;;145        {
;;;146            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;147            GPIOx->CRL |= ( ((uint32_t)(0x04|0x03) & 0x0F) << ((pin_bit) << 2) );
;;;148        }
;;;149    }
00001e  bd10              POP      {r4,pc}
                  |L17.32|
000020  6801              LDR      r1,[r0,#0]            ;146
000022  4093              LSLS     r3,r3,r2              ;146
000024  4399              BICS     r1,r1,r3              ;146
000026  6001              STR      r1,[r0,#0]            ;146
000028  6801              LDR      r1,[r0,#0]            ;147
00002a  4094              LSLS     r4,r4,r2              ;147
00002c  4321              ORRS     r1,r1,r4              ;147
00002e  6001              STR      r1,[r0,#0]            ;147
000030  bd10              POP      {r4,pc}
;;;150    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DAP_Data
                          %        28

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  DAP_FW_Ver
000000  322e302e          DCB      0x32,0x2e,0x30,0x2e
000004  3000              DCB      0x30,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  DAP_TransferAbort
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\cmsis-dap\\DAP.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_Delayms____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___5_DAP_c_Delayms____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_Delayms____REVSH|
#line 495
|__asm___5_DAP_c_Delayms____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_Delayms____RRX|
#line 682
|__asm___5_DAP_c_Delayms____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
