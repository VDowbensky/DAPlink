; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\rt_event.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\rt_event.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\rt_event.crf ..\..\..\source\rtos\rt_Event.c]
                          THUMB

                          AREA ||i.isr_evt_set||, CODE, READONLY, ALIGN=2

                  isr_evt_set PROC
;;;119    
;;;120    void isr_evt_set (U16 event_flags, OS_TID task_id) {
000000  4602              MOV      r2,r0
;;;121      /* Same function as "os_evt_set", but to be called by ISRs. */
;;;122      P_TCB p_tcb = os_active_TCB[task_id-1];
000002  4808              LDR      r0,|L1.36|
000004  b510              PUSH     {r4,lr}               ;120
000006  eb000081          ADD      r0,r0,r1,LSL #2
00000a  f8500c04          LDR      r0,[r0,#-4]
00000e  2800              CMP      r0,#0                 ;120
000010  d006              BEQ      |L1.32|
;;;123    
;;;124      if (p_tcb == NULL) {
;;;125        return;
;;;126      }
;;;127      rt_psq_enq (p_tcb, event_flags);
000012  4611              MOV      r1,r2
000014  f7fffffe          BL       rt_psq_enq
;;;128      rt_psh_req ();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      rt_psh_req
                  |L1.32|
;;;129    }
000020  bd10              POP      {r4,pc}
;;;130    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      os_active_TCB

                          AREA ||i.rt_evt_clr||, CODE, READONLY, ALIGN=2

                  rt_evt_clr PROC
;;;105    
;;;106    void rt_evt_clr (U16 clear_flags, OS_TID task_id) {
000000  4a05              LDR      r2,|L2.24|
;;;107      /* Clear one or more event flags (identified by "clear_flags") of a */
;;;108      /* selectable task (identified by "task"). */
;;;109      P_TCB task = os_active_TCB[task_id-1];
000002  eb020181          ADD      r1,r2,r1,LSL #2
000006  f8511c04          LDR      r1,[r1,#-4]
00000a  2900              CMP      r1,#0                 ;106
00000c  d002              BEQ      |L2.20|
;;;110    
;;;111      if (task == NULL) {
;;;112        return;
;;;113      }
;;;114      task->events &= ~clear_flags;
00000e  8b0a              LDRH     r2,[r1,#0x18]
000010  4382              BICS     r2,r2,r0
000012  830a              STRH     r2,[r1,#0x18]
                  |L2.20|
;;;115    }
000014  4770              BX       lr
;;;116    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      os_active_TCB

                          AREA ||i.rt_evt_get||, CODE, READONLY, ALIGN=2

                  rt_evt_get PROC
;;;133    
;;;134    U16 rt_evt_get (void) {
000000  4801              LDR      r0,|L3.8|
;;;135      /* Get events of a running task after waiting for OR connected events. */
;;;136      return (os_tsk.run->waits);
000002  6800              LDR      r0,[r0,#0]  ; os_tsk
000004  8b40              LDRH     r0,[r0,#0x1a]
;;;137    }
000006  4770              BX       lr
;;;138    
                          ENDP

                  |L3.8|
                          DCD      os_tsk

                          AREA ||i.rt_evt_psh||, CODE, READONLY, ALIGN=2

                  rt_evt_psh PROC
;;;141    
;;;142    void rt_evt_psh (P_TCB p_CB, U16 set_flags) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;143      /* Check if task has to be waken up */
;;;144      U16 event_flags;
;;;145    
;;;146      p_CB->events |= set_flags;
000004  8b00              LDRH     r0,[r0,#0x18]
000006  4308              ORRS     r0,r0,r1
000008  8320              STRH     r0,[r4,#0x18]
;;;147      event_flags = p_CB->waits;
;;;148      if (p_CB->state == WAIT_AND) {
00000a  7862              LDRB     r2,[r4,#1]
00000c  8b61              LDRH     r1,[r4,#0x1a]         ;147
00000e  2a06              CMP      r2,#6
000010  d016              BEQ      |L4.64|
;;;149        /* Check for AND-connected events */
;;;150        if ((p_CB->events & event_flags) == event_flags) {
;;;151          goto rdy;
;;;152        }
;;;153      }
;;;154      if (p_CB->state == WAIT_OR) {
000012  2a05              CMP      r2,#5
000014  d117              BNE      |L4.70|
;;;155        /* Check for OR-connected events */
;;;156        if (p_CB->events & event_flags) {
000016  4208              TST      r0,r1
000018  d015              BEQ      |L4.70|
;;;157          p_CB->waits  &= p_CB->events;
00001a  ea010200          AND      r2,r1,r0
00001e  8362              STRH     r2,[r4,#0x1a]
                  |L4.32|
;;;158    rdy:  p_CB->events &= ~event_flags;
000020  4388              BICS     r0,r0,r1
000022  8320              STRH     r0,[r4,#0x18]
;;;159          rt_rmv_dly (p_CB);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       rt_rmv_dly
;;;160          p_CB->state   = READY;
00002a  2001              MOVS     r0,#1
00002c  7060              STRB     r0,[r4,#1]
;;;161          p_CB->ret_val = OS_R_EVT;
00002e  2002              MOVS     r0,#2
000030  f8840020          STRB     r0,[r4,#0x20]
;;;162          rt_put_prio (&os_rdy, p_CB);
000034  4621              MOV      r1,r4
000036  e8bd4010          POP      {r4,lr}
00003a  4803              LDR      r0,|L4.72|
00003c  f7ffbffe          B.W      rt_put_prio
                  |L4.64|
000040  ea310200          BICS     r2,r1,r0              ;150
000044  d0ec              BEQ      |L4.32|
                  |L4.70|
;;;163        }
;;;164      }
;;;165    }
000046  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  |L4.72|
                          DCD      os_rdy

                          AREA ||i.rt_evt_set||, CODE, READONLY, ALIGN=2

                  rt_evt_set PROC
;;;70     
;;;71     void rt_evt_set (U16 event_flags, OS_TID task_id) {
000000  4602              MOV      r2,r0
000002  b570              PUSH     {r4-r6,lr}
;;;72       /* Set one or more event flags of a selectable task. */
;;;73       P_TCB p_tcb;
;;;74     
;;;75       p_tcb = os_active_TCB[task_id-1];
000004  4815              LDR      r0,|L5.92|
000006  eb000081          ADD      r0,r0,r1,LSL #2
00000a  f8504c04          LDR      r4,[r0,#-4]
00000e  2c00              CMP      r4,#0                 ;71
000010  d022              BEQ      |L5.88|
;;;76       if (p_tcb == NULL) {
;;;77         return;
;;;78       }
;;;79       p_tcb->events |= event_flags;
000012  8b20              LDRH     r0,[r4,#0x18]
000014  4310              ORRS     r0,r0,r2
000016  8320              STRH     r0,[r4,#0x18]
;;;80       event_flags    = p_tcb->waits;
;;;81       /* If the task is not waiting for an event, it should not be put */
;;;82       /* to ready state. */
;;;83       if (p_tcb->state == WAIT_AND) {
000018  7861              LDRB     r1,[r4,#1]
00001a  8b65              LDRH     r5,[r4,#0x1a]         ;80
00001c  2906              CMP      r1,#6
00001e  d018              BEQ      |L5.82|
;;;84         /* Check for AND-connected events */
;;;85         if ((p_tcb->events & event_flags) == event_flags) {
;;;86           goto wkup;
;;;87         }
;;;88       }
;;;89       if (p_tcb->state == WAIT_OR) {
000020  2905              CMP      r1,#5
000022  d119              BNE      |L5.88|
;;;90         /* Check for OR-connected events */
;;;91         if (p_tcb->events & event_flags) {
000024  4228              TST      r0,r5
000026  d017              BEQ      |L5.88|
;;;92           p_tcb->waits  &= p_tcb->events;
000028  ea050100          AND      r1,r5,r0
00002c  8361              STRH     r1,[r4,#0x1a]
                  |L5.46|
;;;93     wkup: p_tcb->events &= ~event_flags;
00002e  43a8              BICS     r0,r0,r5
000030  8320              STRH     r0,[r4,#0x18]
;;;94           rt_rmv_dly (p_tcb);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       rt_rmv_dly
;;;95           p_tcb->events &= ~event_flags;
000038  8b20              LDRH     r0,[r4,#0x18]
00003a  43a8              BICS     r0,r0,r5
00003c  8320              STRH     r0,[r4,#0x18]
;;;96           p_tcb->state   = READY;
00003e  2001              MOVS     r0,#1
000040  7060              STRB     r0,[r4,#1]
;;;97           p_tcb->ret_val = OS_R_EVT;
000042  2002              MOVS     r0,#2
000044  f8840020          STRB     r0,[r4,#0x20]
;;;98           rt_dispatch (p_tcb);
000048  4620              MOV      r0,r4
00004a  e8bd4070          POP      {r4-r6,lr}
00004e  f7ffbffe          B.W      rt_dispatch
                  |L5.82|
000052  ea350100          BICS     r1,r5,r0              ;85
000056  d0ea              BEQ      |L5.46|
                  |L5.88|
;;;99         }
;;;100      }
;;;101    }
000058  bd70              POP      {r4-r6,pc}
;;;102    
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      os_active_TCB

                          AREA ||i.rt_evt_wait||, CODE, READONLY, ALIGN=2

                  rt_evt_wait PROC
;;;36     
;;;37     OS_RESULT rt_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
;;;38       /* Wait for one or more event flags with optional time-out.                */
;;;39       /* "wait_flags" identifies the flags to wait for.                          */
;;;40       /* "timeout" is the time-out limit in system ticks (0xffff if no time-out) */
;;;41       /* "and_wait" specifies the AND-ing of "wait_flags" as condition to be met */
;;;42       /* to complete the wait. (OR-ing if set to 0).                             */
;;;43       U32 block_state;
;;;44     
;;;45       if (and_wait) {
;;;46         /* Check for AND-connected events */
;;;47         if ((os_tsk.run->events & wait_flags) == wait_flags) {
000004  480c              LDR      r0,|L6.56|
000006  460d              MOV      r5,r1                 ;37
000008  6804              LDR      r4,[r0,#0]
00000a  8b20              LDRH     r0,[r4,#0x18]
00000c  b142              CBZ      r2,|L6.32|
00000e  ea330100          BICS     r1,r3,r0
000012  d001              BEQ      |L6.24|
;;;48           os_tsk.run->events &= ~wait_flags;
;;;49           return (OS_R_EVT);
;;;50         }
;;;51         block_state = WAIT_AND;
000014  2106              MOVS     r1,#6
000016  e009              B        |L6.44|
                  |L6.24|
000018  4398              BICS     r0,r0,r3              ;48
00001a  8320              STRH     r0,[r4,#0x18]         ;48
00001c  2002              MOVS     r0,#2                 ;49
;;;52       }
;;;53       else {
;;;54         /* Check for OR-connected events */
;;;55         if (os_tsk.run->events & wait_flags) {
;;;56           os_tsk.run->waits = os_tsk.run->events & wait_flags;
;;;57           os_tsk.run->events &= ~wait_flags;
;;;58           return (OS_R_EVT);
;;;59         }
;;;60         block_state = WAIT_OR;
;;;61       }
;;;62       /* Task has to wait */
;;;63       os_tsk.run->waits = wait_flags;
;;;64       rt_block (timeout, (U8)block_state);
;;;65       return (OS_R_TMO);
;;;66     }
00001e  bd70              POP      {r4-r6,pc}
                  |L6.32|
000020  ea100103          ANDS     r1,r0,r3              ;55
000024  d001              BEQ      |L6.42|
000026  8361              STRH     r1,[r4,#0x1a]         ;56
000028  e7f6              B        |L6.24|
                  |L6.42|
00002a  2105              MOVS     r1,#5                 ;60
                  |L6.44|
00002c  8363              STRH     r3,[r4,#0x1a]         ;63
00002e  4628              MOV      r0,r5                 ;64
000030  f7fffffe          BL       rt_block
000034  2001              MOVS     r0,#1                 ;65
000036  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP

                  |L6.56|
                          DCD      os_tsk
