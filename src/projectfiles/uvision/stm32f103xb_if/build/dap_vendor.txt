; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\dap_vendor.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\dap_vendor.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\dap_vendor.crf ..\..\..\source\daplink\cmsis-dap\DAP_vendor.c]
                          THUMB

                          AREA ||i.DAP_ProcessVendorCommand||, CODE, READONLY, ALIGN=2

                  DAP_ProcessVendorCommand PROC
;;;62     */
;;;63     uint32_t DAP_ProcessVendorCommand(const uint8_t *request, uint8_t *response) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;64       uint32_t num = (1U << 16) | 1U;
;;;65     
;;;66       *response++ = *request;        // copy Command ID
000004  7802              LDRB     r2,[r0,#0]
000006  f8012b01          STRB     r2,[r1],#1
00000a  460d              MOV      r5,r1
00000c  f04f1401          MOV      r4,#0x10001           ;64
;;;67     
;;;68       switch (*request++) {          // first byte in request is Command ID
000010  f8101b01          LDRB     r1,[r0],#1
;;;69         case ID_DAP_Vendor0: {
;;;70             const char *id_str = info_get_unique_id();
;;;71             uint8_t len = strlen(id_str);
;;;72             *response++ = len;
;;;73             memcpy(response, id_str, len);
;;;74             num += (len + 1); // increment response count by ID length + length byte
;;;75             break;
;;;76         }
;;;77         case ID_DAP_Vendor1: {
;;;78             // get line coding
;;;79             int32_t read_len = sizeof(CDC_LINE_CODING);
;;;80             CDC_LINE_CODING cdc_line_coding;
;;;81             USBD_CDC_ACM_PortGetLineCoding(&cdc_line_coding);
;;;82             memcpy(response, &cdc_line_coding, read_len);
;;;83             num += (read_len + 1);
;;;84             break;
;;;85         }
;;;86         case ID_DAP_Vendor2: {
;;;87             // set uart configuration
;;;88             CDC_LINE_CODING cdc_line_coding;
;;;89             USBD_CDC_ACM_PortGetLineCoding(&cdc_line_coding);
;;;90             //set BaudRate
;;;91             uint32_t baud_rate = 0;
;;;92             memcpy(&baud_rate, request, sizeof(uint32_t));
;;;93             cdc_line_coding.dwDTERate = baud_rate;
;;;94             USBD_CDC_ACM_PortSetLineCoding(&cdc_line_coding);
;;;95             USBD_CDC_ACM_SendBreak(0);
;;;96             *response = 1;
;;;97             num += (sizeof(uint32_t) << 16) | 1;
;;;98             break;
;;;99         }
;;;100        case ID_DAP_Vendor3:  {
;;;101            // uart read
;;;102            int32_t read_len = 62;
;;;103            read_len = uart_read_data(response + 1, read_len);
;;;104            response[0] = read_len;
;;;105            // increment request and response count
;;;106            num += (read_len + 1);
;;;107            break;
;;;108        }
;;;109        case ID_DAP_Vendor4:  {
;;;110            // uart write
;;;111            int32_t write_len = *request;
;;;112            request++;
;;;113            uart_write_data((uint8_t *)request, write_len);
;;;114            *response = 1;
;;;115            num += ((write_len + 1) << 16) | 1;
;;;116            break;
;;;117        }
;;;118        case ID_DAP_Vendor5:  break;
;;;119        case ID_DAP_Vendor6:  break;
;;;120        case ID_DAP_Vendor7:  break;
;;;121        case ID_DAP_Vendor8: {
;;;122            *response = 1;
;;;123            if (0 == *request) {
;;;124                main_usb_set_test_mode(false);
;;;125            } else if (1 == *request) {
;;;126                main_usb_set_test_mode(true);
;;;127            } else {
;;;128                *response = 0;
;;;129            }
;;;130            num += (1U << 16) | 1U; // increment request and response count each by 1
000014  0067              LSLS     r7,r4,#1
;;;131            break;
;;;132        }
;;;133        case ID_DAP_Vendor9: {
;;;134            // reset target
;;;135            *response = 1;
;;;136            if (!config_get_auto_rst()) {
;;;137                target_set_state(RESET_RUN);
;;;138            }
;;;139            num += 1;
000016  3980              SUBS     r1,r1,#0x80
000018  4606              MOV      r6,r0                 ;68
00001a  f04f0900          MOV      r9,#0                 ;68
00001e  f04f0801          MOV      r8,#1                 ;96
000022  f1040a01          ADD      r10,r4,#1
000026  290e              CMP      r1,#0xe               ;68
000028  d274              BCS      |L1.276|
00002a  e8dff001          TBB      [pc,r1]               ;68
00002e  0717              DCB      0x07,0x17
000030  22384173          DCB      0x22,0x38,0x41,0x73
000034  73734956          DCB      0x73,0x73,0x49,0x56
000038  60656976          DCB      0x60,0x65,0x69,0x76
00003c  f7fffffe          BL       info_get_unique_id
000040  4606              MOV      r6,r0                 ;70
000042  f7fffffe          BL       strlen
000046  b2c4              UXTB     r4,r0                 ;71
000048  702c              STRB     r4,[r5,#0]            ;72
00004a  1c68              ADDS     r0,r5,#1              ;72
00004c  4622              MOV      r2,r4                 ;73
00004e  4631              MOV      r1,r6                 ;73
000050  f7fffffe          BL       __aeabi_memcpy
000054  f5043480          ADD      r4,r4,#0x10000        ;73
000058  1ca4              ADDS     r4,r4,#2              ;73
00005a  e05b              B        |L1.276|
00005c  2407              MOVS     r4,#7                 ;79
00005e  4668              MOV      r0,sp                 ;81
000060  f7fffffe          BL       USBD_CDC_ACM_PortGetLineCoding
000064  4622              MOV      r2,r4                 ;82
000066  4669              MOV      r1,sp                 ;82
000068  4628              MOV      r0,r5                 ;82
00006a  f7fffffe          BL       __aeabi_memcpy
00006e  4c2f              LDR      r4,|L1.300|
000070  e050              B        |L1.276|
000072  4668              MOV      r0,sp                 ;89
000074  f7fffffe          BL       USBD_CDC_ACM_PortGetLineCoding
000078  2204              MOVS     r2,#4                 ;92
00007a  4631              MOV      r1,r6                 ;92
00007c  a802              ADD      r0,sp,#8              ;92
00007e  f8cd9008          STR      r9,[sp,#8]            ;92
000082  f7fffffe          BL       __aeabi_memcpy
000086  9802              LDR      r0,[sp,#8]            ;93
000088  9000              STR      r0,[sp,#0]            ;94
00008a  4668              MOV      r0,sp                 ;94
00008c  f7fffffe          BL       USBD_CDC_ACM_PortSetLineCoding
000090  2000              MOVS     r0,#0                 ;95
000092  f7fffffe          BL       USBD_CDC_ACM_SendBreak
000096  f8858000          STRB     r8,[r5,#0]            ;96
00009a  4c25              LDR      r4,|L1.304|
00009c  e03a              B        |L1.276|
00009e  213e              MOVS     r1,#0x3e              ;103
0000a0  1c68              ADDS     r0,r5,#1              ;103
0000a2  f7fffffe          BL       uart_read_data
0000a6  f5003480          ADD      r4,r0,#0x10000        ;104
0000aa  7028              STRB     r0,[r5,#0]            ;104
0000ac  1ca4              ADDS     r4,r4,#2              ;104
0000ae  e031              B        |L1.276|
0000b0  7837              LDRB     r7,[r6,#0]            ;111
0000b2  1c70              ADDS     r0,r6,#1              ;112
0000b4  4639              MOV      r1,r7                 ;113
0000b6  f7fffffe          BL       uart_write_data
0000ba  f8858000          STRB     r8,[r5,#0]            ;114
0000be  e025              B        |L1.268|
0000c0  f8858000          STRB     r8,[r5,#0]            ;122
0000c4  7830              LDRB     r0,[r6,#0]            ;123
0000c6  b128              CBZ      r0,|L1.212|
0000c8  2801              CMP      r0,#1                 ;125
0000ca  d003              BEQ      |L1.212|
0000cc  f8859000          STRB     r9,[r5,#0]            ;128
                  |L1.208|
0000d0  463c              MOV      r4,r7                 ;130
0000d2  e01f              B        |L1.276|
                  |L1.212|
0000d4  f7fffffe          BL       main_usb_set_test_mode
0000d8  e7fa              B        |L1.208|
0000da  f8858000          STRB     r8,[r5,#0]            ;135
0000de  f7fffffe          BL       config_get_auto_rst
0000e2  b910              CBNZ     r0,|L1.234|
0000e4  2002              MOVS     r0,#2                 ;137
0000e6  f7fffffe          BL       target_set_state
                  |L1.234|
0000ea  4654              MOV      r4,r10
;;;140            break;
0000ec  e012              B        |L1.276|
;;;141        }
;;;142    #ifdef DRAG_N_DROP_SUPPORT
;;;143        case ID_DAP_Vendor10: {
;;;144            // open mass storage device stream
;;;145            *response = stream_open((stream_type_t)(*request));
0000ee  7830              LDRB     r0,[r6,#0]
0000f0  f7fffffe          BL       stream_open
0000f4  7028              STRB     r0,[r5,#0]
;;;146            num += (1 << 16) | 1;
;;;147            break;
0000f6  e7eb              B        |L1.208|
;;;148        }
;;;149        case ID_DAP_Vendor11: {
;;;150            // close mass storage device stream
;;;151            *response = stream_close();
0000f8  f7fffffe          BL       stream_close
0000fc  7028              STRB     r0,[r5,#0]
;;;152            num += 1;
;;;153            break;
0000fe  e7f4              B        |L1.234|
;;;154        }
;;;155        case ID_DAP_Vendor12: {
;;;156            // write to mass storage device
;;;157            uint32_t write_len = *request;
000100  7837              LDRB     r7,[r6,#0]
;;;158            request++;
000102  1c70              ADDS     r0,r6,#1
;;;159            *response = stream_write((uint8_t *)request, write_len);
000104  4639              MOV      r1,r7
000106  f7fffffe          BL       stream_write
00010a  7028              STRB     r0,[r5,#0]
                  |L1.268|
00010c  eb044407          ADD      r4,r4,r7,LSL #16      ;115
000110  f1041401          ADD      r4,r4,#0x10001        ;115
                  |L1.276|
;;;160            num += ((write_len + 1) << 16) | 1;
;;;161            break;
;;;162        }
;;;163    #endif
;;;164        case ID_DAP_Vendor13: {
;;;165            // switching between chip erase and page erase
;;;166            //              COMMAND(OUT Packet)
;;;167            //              BYTE 0 1000 1110 0x8D
;;;168            //              BYTE 1 Desired Mode:
;;;169            //                                              0x00 - Chip Erase
;;;170            //                                              nonzero - Page Erase
;;;171            //              RESPONSE(IN Packet)
;;;172            //              BYTE 0 
;;;173            //                                              0x00 - OK
;;;174            *response = DAP_OK;
;;;175            if (0x00U == *request) {
;;;176                flash_manager_set_page_erase(false);
;;;177            } else {
;;;178                flash_manager_set_page_erase(true);
;;;179            }
;;;180            num += (1U << 16) | 1U; // increment request and response count each by 1
;;;181            break;
;;;182        }
;;;183        case ID_DAP_Vendor14: break;
;;;184        case ID_DAP_Vendor15: break;
;;;185        case ID_DAP_Vendor16: break;
;;;186        case ID_DAP_Vendor17: break;
;;;187        case ID_DAP_Vendor18: break;
;;;188        case ID_DAP_Vendor19: break;
;;;189        case ID_DAP_Vendor20: break;
;;;190        case ID_DAP_Vendor21: break;
;;;191        case ID_DAP_Vendor22: break;
;;;192        case ID_DAP_Vendor23: break;
;;;193        case ID_DAP_Vendor24: break;
;;;194        case ID_DAP_Vendor25: break;
;;;195        case ID_DAP_Vendor26: break;
;;;196        case ID_DAP_Vendor27: break;
;;;197        case ID_DAP_Vendor28: break;
;;;198        case ID_DAP_Vendor29: break;
;;;199        case ID_DAP_Vendor30: break;
;;;200        case ID_DAP_Vendor31: break;
;;;201        default: break;
;;;202      }
;;;203    
;;;204      return (num);
000114  4620              MOV      r0,r4
;;;205    }
000116  e8bd8ffe          POP      {r1-r11,pc}
00011a  f8859000          STRB     r9,[r5,#0]            ;174
00011e  7830              LDRB     r0,[r6,#0]            ;175
000120  b100              CBZ      r0,|L1.292|
000122  2001              MOVS     r0,#1                 ;178
                  |L1.292|
000124  f7fffffe          BL       flash_manager_set_page_erase
000128  e7d2              B        |L1.208|
;;;206    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
                          DCD      0x00010009
                  |L1.304|
                          DCD      0x00050002

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\cmsis-dap\\DAP_vendor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_DAP_vendor_c_ba376029____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___12_DAP_vendor_c_ba376029____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_DAP_vendor_c_ba376029____REVSH|
#line 495
|__asm___12_DAP_vendor_c_ba376029____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_DAP_vendor_c_ba376029____RRX|
#line 682
|__asm___12_DAP_vendor_c_ba376029____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
