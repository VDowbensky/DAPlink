; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\main.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\main.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\main.crf ..\..\..\source\daplink\interface\main.c]
                          THUMB

                          AREA ||i.USBD_SignalHandler||, CODE, READONLY, ALIGN=2

                  USBD_SignalHandler PROC
;;;174    
;;;175    void USBD_SignalHandler()
000000  4802              LDR      r0,|L1.12|
;;;176    {
;;;177        osThreadFlagsSet(main_task_id, FLAGS_MAIN_PROC_USB);
000002  f44f7100          MOV      r1,#0x200
000006  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000008  f7ffbffe          B.W      osThreadFlagsSet
;;;178    }
;;;179    
                          ENDP

                  |L1.12|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;460    
;;;461    int main(void)
000000  4908              LDR      r1,|L2.36|
;;;462    {
;;;463        // Explicitly set the vector table since the bootloader might not set
;;;464        // it to what we expect.
;;;465    #if DAPLINK_ROM_BL_SIZE > 0
;;;466        SCB->VTOR = SCB_VTOR_TBLOFF_Msk & DAPLINK_ROM_IF_START;
000002  4807              LDR      r0,|L2.32|
000004  6008              STR      r0,[r1,#0]
;;;467    #endif
;;;468        // initialize vendor sdk
;;;469        sdk_init();
000006  f7fffffe          BL       sdk_init
;;;470    
;;;471        osKernelInitialize();                 // Initialize CMSIS-RTOS
00000a  f7fffffe          BL       osKernelInitialize
;;;472        osThreadNew(main_task, NULL, NULL);    // Create application main thread
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4805              LDR      r0,|L2.40|
000014  f7fffffe          BL       osThreadNew
;;;473        osKernelStart();                      // Start thread execution
000018  f7fffffe          BL       osKernelStart
                  |L2.28|
;;;474        for (;;) {}
00001c  e7fe              B        |L2.28|
;;;475    }
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x0800c000
                  |L2.36|
                          DCD      0xe000ed08
                  |L2.40|
                          DCD      main_task

                          AREA ||i.main_blink_cdc_led||, CODE, READONLY, ALIGN=2

                  main_blink_cdc_led PROC
;;;133    // Flash CDC LED using 30mS tick
;;;134    void main_blink_cdc_led(main_led_state_t state)
000000  4902              LDR      r1,|L3.12|
;;;135    {
;;;136        cdc_led_usb_activity = 1;
000002  2201              MOVS     r2,#1
000004  704a              STRB     r2,[r1,#1]
;;;137        cdc_led_state = state;
000006  7108              STRB     r0,[r1,#4]
;;;138        return;
;;;139    }
000008  4770              BX       lr
;;;140    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      ||.data||

                          AREA ||i.main_blink_hid_led||, CODE, READONLY, ALIGN=2

                  main_blink_hid_led PROC
;;;125    // Flash HID LED using 30mS tick
;;;126    void main_blink_hid_led(main_led_state_t state)
000000  4902              LDR      r1,|L4.12|
;;;127    {
;;;128        hid_led_usb_activity = 1;
000002  2201              MOVS     r2,#1
000004  700a              STRB     r2,[r1,#0]
;;;129        hid_led_state = state;
000006  70c8              STRB     r0,[r1,#3]
;;;130        return;
;;;131    }
000008  4770              BX       lr
;;;132    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      ||.data||

                          AREA ||i.main_blink_msc_led||, CODE, READONLY, ALIGN=2

                  main_blink_msc_led PROC
;;;141    // Flash MSC LED using 30mS tick
;;;142    void main_blink_msc_led(main_led_state_t state)
000000  4902              LDR      r1,|L5.12|
;;;143    {
;;;144        msc_led_usb_activity = 1;
000002  2201              MOVS     r2,#1
000004  708a              STRB     r2,[r1,#2]
;;;145        msc_led_state = state;
000006  7148              STRB     r0,[r1,#5]
;;;146        return;
;;;147    }
000008  4770              BX       lr
;;;148    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      ||.data||

                          AREA ||i.main_cdc_send_event||, CODE, READONLY, ALIGN=2

                  main_cdc_send_event PROC
;;;163    // Start CDC processing
;;;164    void main_cdc_send_event(void)
000000  4802              LDR      r0,|L6.12|
;;;165    {
;;;166        osThreadFlagsSet(main_task_id, FLAGS_MAIN_CDC_EVENT);
000002  f44f6100          MOV      r1,#0x800
000006  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000008  f7ffbffe          B.W      osThreadFlagsSet
;;;167        return;
;;;168    }
;;;169    
                          ENDP

                  |L6.12|
                          DCD      ||.data||

                          AREA ||i.main_disable_debug_event||, CODE, READONLY, ALIGN=2

                  main_disable_debug_event PROC
;;;156    // Disable debug on target
;;;157    void main_disable_debug_event(void)
000000  4802              LDR      r0,|L7.12|
;;;158    {
;;;159        osThreadFlagsSet(main_task_id, FLAGS_MAIN_DISABLEDEBUG);
000002  2120              MOVS     r1,#0x20
000004  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000006  f7ffbffe          B.W      osThreadFlagsSet
;;;160        return;
;;;161    }
;;;162    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.main_powerdown_event||, CODE, READONLY, ALIGN=2

                  main_powerdown_event PROC
;;;149    // Power down the interface
;;;150    void main_powerdown_event(void)
000000  4802              LDR      r0,|L8.12|
;;;151    {
;;;152        osThreadFlagsSet(main_task_id, FLAGS_MAIN_POWERDOWN);
000002  2110              MOVS     r1,#0x10
000004  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000006  f7ffbffe          B.W      osThreadFlagsSet
;;;153        return;
;;;154    }
;;;155    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      ||.data||

                          AREA ||i.main_reset_target||, CODE, READONLY, ALIGN=2

                  main_reset_target PROC
;;;118    // parameter should be reset type??
;;;119    void main_reset_target(uint8_t send_unique_id)
000000  4802              LDR      r0,|L9.12|
;;;120    {
;;;121        osThreadFlagsSet(main_task_id, FLAGS_MAIN_RESET);
000002  2104              MOVS     r1,#4
000004  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000006  f7ffbffe          B.W      osThreadFlagsSet
;;;122        return;
;;;123    }
;;;124    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      ||.data||

                          AREA ||i.main_task||, CODE, READONLY, ALIGN=2

                  main_task PROC
;;;181    
;;;182    void main_task(void * arg)
000000  2700              MOVS     r7,#0
;;;183    {
;;;184        // State processing
;;;185        uint16_t flags = 0;
;;;186        // LED
;;;187        gpio_led_state_t hid_led_value = HID_LED_DEF;
;;;188        gpio_led_state_t cdc_led_value = CDC_LED_DEF;
000002  463e              MOV      r6,r7
;;;189        gpio_led_state_t msc_led_value = MSC_LED_DEF;
000004  463d              MOV      r5,r7
;;;190        // USB
;;;191        uint32_t usb_state_count = USB_BUSY_TIME;
;;;192        uint32_t usb_no_config_count = USB_CONFIGURE_TIMEOUT;
000006  f04f0816          MOV      r8,#0x16
;;;193        // button state
;;;194        uint8_t reset_pressed = 0;
00000a  46ba              MOV      r10,r7
;;;195    #ifdef PBON_BUTTON
;;;196        uint8_t power_on = 1;
;;;197    #endif
;;;198    
;;;199        // Initialize settings - required for asserts to work
;;;200        config_init();
00000c  f7fffffe          BL       config_init
;;;201        // Update bootloader if it is out of date
;;;202        bootloader_check_and_update();
000010  f7fffffe          BL       bootloader_check_and_update
;;;203        // Get a reference to this task
;;;204        main_task_id = osThreadGetId();
000014  f7fffffe          BL       osThreadGetId
000018  4c9e              LDR      r4,|L10.660|
;;;205        // leds
;;;206        gpio_init();
00001a  60e0              STR      r0,[r4,#0xc]  ; main_task_id
00001c  f7fffffe          BL       gpio_init
;;;207        // Turn to LED default settings
;;;208        gpio_set_hid_led(hid_led_value);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       gpio_set_hid_led
;;;209        gpio_set_cdc_led(cdc_led_value);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       gpio_set_cdc_led
;;;210        gpio_set_msc_led(msc_led_value);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       gpio_set_msc_led
;;;211        // Initialize the DAP
;;;212        DAP_Setup();
000032  f7fffffe          BL       DAP_Setup
;;;213    
;;;214        // make sure we have a valid board info structure.
;;;215        util_assert(g_board_info.info_version == kBoardInfoVersion);
000036  4898              LDR      r0,|L10.664|
000038  7841              LDRB     r1,[r0,#1]  ; g_board_info
00003a  7802              LDRB     r2,[r0,#0]  ; g_board_info
00003c  ea422001          ORR      r0,r2,r1,LSL #8
000040  2801              CMP      r0,#1
000042  d000              BEQ      |L10.70|
000044  2000              MOVS     r0,#0
                  |L10.70|
000046  22d7              MOVS     r2,#0xd7
000048  a194              ADR      r1,|L10.668|
00004a  f7fffffe          BL       _util_assert
;;;216    
;;;217        // do some init with the target before USB and files are configured
;;;218        if (g_board_info.prerun_board_config) {
00004e  4892              LDR      r0,|L10.664|
000050  306a              ADDS     r0,r0,#0x6a
000052  f7fffffe          BL       __aeabi_uread4
000056  b100              CBZ      r0,|L10.90|
;;;219            g_board_info.prerun_board_config();
000058  4780              BLX      r0
                  |L10.90|
;;;220        }
;;;221    
;;;222        //initialize the family
;;;223        init_family();
00005a  f7fffffe          BL       init_family
;;;224    
;;;225        if (g_target_family && g_target_family->prerun_target_config) {
00005e  489a              LDR      r0,|L10.712|
000060  6800              LDR      r0,[r0,#0]  ; g_target_family
000062  b110              CBZ      r0,|L10.106|
000064  68c0              LDR      r0,[r0,#0xc]
000066  b100              CBZ      r0,|L10.106|
;;;226            g_target_family->prerun_target_config();
000068  4780              BLX      r0
                  |L10.106|
;;;227        }
;;;228    
;;;229        //setup some flags
;;;230        if (g_board_info.flags & kEnableUnderResetConnect) {
00006a  488b              LDR      r0,|L10.664|
00006c  300c              ADDS     r0,r0,#0xc
00006e  4681              MOV      r9,r0
000070  f7fffffe          BL       __aeabi_uread4
000074  0780              LSLS     r0,r0,#30
000076  d502              BPL      |L10.126|
;;;231            swd_set_reset_connect(CONNECT_UNDER_RESET);
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       swd_set_reset_connect
                  |L10.126|
00007e  4648              MOV      r0,r9
;;;232        }
;;;233        if (g_board_info.flags & kEnablePageErase) {
000080  f7fffffe          BL       __aeabi_uread4
000084  07c0              LSLS     r0,r0,#31
000086  d002              BEQ      |L10.142|
;;;234    #ifdef DRAG_N_DROP_SUPPORT
;;;235            flash_manager_set_page_erase(true);
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       flash_manager_set_page_erase
                  |L10.142|
;;;236    #endif
;;;237        }
;;;238    
;;;239        // Update versions and IDs
;;;240        info_init();
00008e  f7fffffe          BL       info_init
;;;241        // USB
;;;242        usbd_init();
000092  f7fffffe          BL       usbd_init
;;;243    #ifdef DRAG_N_DROP_SUPPORT
;;;244        vfs_mngr_fs_enable((config_ram_get_disable_msd()==0));
000096  f7fffffe          BL       config_ram_get_disable_msd
00009a  b3e8              CBZ      r0,|L10.280|
00009c  2000              MOVS     r0,#0
                  |L10.158|
00009e  f7fffffe          BL       vfs_mngr_fs_enable
;;;245    #endif
;;;246        usbd_connect(0);
0000a2  2000              MOVS     r0,#0
0000a4  f7fffffe          BL       usbd_connect
;;;247        usb_state = USB_CONNECTING;
0000a8  487a              LDR      r0,|L10.660|
0000aa  2101              MOVS     r1,#1
;;;248        usb_state_count = USB_CONNECT_DELAY;
;;;249    
;;;250        // Start timer tasks
;;;251        osTimerId_t tmr_id = osTimerNew(timer_task_30mS, osTimerPeriodic, NULL, NULL);
0000ac  2300              MOVS     r3,#0
0000ae  71c1              STRB     r1,[r0,#7]            ;247
0000b0  f04f0b0b          MOV      r11,#0xb              ;248
0000b4  461a              MOV      r2,r3
0000b6  4885              LDR      r0,|L10.716|
0000b8  f7fffffe          BL       osTimerNew
;;;252        osTimerStart(tmr_id, 3);
0000bc  2103              MOVS     r1,#3
0000be  f7fffffe          BL       osTimerStart
0000c2  f04f0900          MOV      r9,#0
                  |L10.198|
;;;253        while (1) {
;;;254            flags = osThreadFlagsWait(FLAGS_MAIN_RESET             // Put target in reset state
0000c6  f04f32ff          MOV      r2,#0xffffffff
0000ca  2100              MOVS     r1,#0
0000cc  f6402037          MOV      r0,#0xa37
0000d0  f7fffffe          BL       osThreadFlagsWait
0000d4  b284              UXTH     r4,r0
;;;255                           | FLAGS_MAIN_90MS            // 90mS tick
;;;256                           | FLAGS_MAIN_30MS            // 30mS tick
;;;257                           | FLAGS_MAIN_POWERDOWN       // Power down interface
;;;258                           | FLAGS_MAIN_DISABLEDEBUG    // Disable target debug
;;;259                           | FLAGS_MAIN_PROC_USB        // process usb events
;;;260                           | FLAGS_MAIN_CDC_EVENT       // cdc event
;;;261                           , osFlagsWaitAny
;;;262                           , osWaitForever);
;;;263    
;;;264            if (flags & FLAGS_MAIN_PROC_USB) {
0000d6  05a0              LSLS     r0,r4,#22
0000d8  d507              BPL      |L10.234|
;;;265                if (usb_test_mode) {
0000da  486e              LDR      r0,|L10.660|
0000dc  7980              LDRB     r0,[r0,#6]  ; usb_test_mode
0000de  b110              CBZ      r0,|L10.230|
;;;266                    // When in USB test mode Insert a delay to
;;;267                    // simulate worst-case behavior.
;;;268                    osDelay(1);
0000e0  2001              MOVS     r0,#1
0000e2  f7fffffe          BL       osDelay
                  |L10.230|
;;;269                }
;;;270                USBD_Handler();
0000e6  f7fffffe          BL       USBD_Handler
                  |L10.234|
;;;271            }
;;;272    
;;;273            if (flags & FLAGS_MAIN_RESET) {
0000ea  0760              LSLS     r0,r4,#29
0000ec  d502              BPL      |L10.244|
;;;274                target_set_state(RESET_RUN);
0000ee  2002              MOVS     r0,#2
0000f0  f7fffffe          BL       target_set_state
                  |L10.244|
;;;275            }
;;;276    
;;;277            if (flags & FLAGS_MAIN_POWERDOWN) {
0000f4  06e0              LSLS     r0,r4,#27
0000f6  d516              BPL      |L10.294|
;;;278                // Disable debug
;;;279                target_set_state(NO_DEBUG);
0000f8  2003              MOVS     r0,#3
0000fa  f7fffffe          BL       target_set_state
;;;280                // Disable board power before USB is disconnected.
;;;281                gpio_set_board_power(false);
0000fe  2000              MOVS     r0,#0
000100  f7fffffe          BL       gpio_set_board_power
;;;282                // Disconnect USB
;;;283                usbd_connect(0);
000104  2000              MOVS     r0,#0
000106  f7fffffe          BL       usbd_connect
;;;284                // Turn off LED
;;;285                gpio_set_hid_led(GPIO_LED_OFF);
00010a  2000              MOVS     r0,#0
00010c  f7fffffe          BL       gpio_set_hid_led
;;;286                gpio_set_cdc_led(GPIO_LED_OFF);
000110  2000              MOVS     r0,#0
000112  f7fffffe          BL       gpio_set_cdc_led
;;;287                gpio_set_msc_led(GPIO_LED_OFF);
000116  e000              B        |L10.282|
                  |L10.280|
000118  e003              B        |L10.290|
                  |L10.282|
00011a  2000              MOVS     r0,#0
00011c  f7fffffe          BL       gpio_set_msc_led
                  |L10.288|
;;;288    
;;;289                // TODO: put the interface chip in sleep mode
;;;290                while (1);
000120  e7fe              B        |L10.288|
                  |L10.290|
000122  2001              MOVS     r0,#1                 ;244
000124  e7bb              B        |L10.158|
                  |L10.294|
;;;291            }
;;;292    
;;;293            if (flags & FLAGS_MAIN_DISABLEDEBUG) {
000126  06a0              LSLS     r0,r4,#26
000128  d502              BPL      |L10.304|
;;;294                // Disable debug
;;;295                target_set_state(NO_DEBUG);
00012a  2003              MOVS     r0,#3
00012c  f7fffffe          BL       target_set_state
                  |L10.304|
;;;296            }
;;;297    
;;;298            if (flags & FLAGS_MAIN_CDC_EVENT) {
000130  0520              LSLS     r0,r4,#20
000132  d501              BPL      |L10.312|
;;;299                cdc_process_event();
000134  f7fffffe          BL       cdc_process_event
                  |L10.312|
;;;300            }
;;;301    
;;;302            if (flags & FLAGS_MAIN_90MS) {
000138  07e0              LSLS     r0,r4,#31
00013a  d03b              BEQ      |L10.436|
;;;303                // Update USB busy status
;;;304    #ifdef DRAG_N_DROP_SUPPORT
;;;305                vfs_mngr_periodic(90); // FLAGS_MAIN_90MS
00013c  205a              MOVS     r0,#0x5a
00013e  f7fffffe          BL       vfs_mngr_periodic
;;;306    #endif
;;;307                // Update USB connect status
;;;308                switch (usb_state) {
000142  4854              LDR      r0,|L10.660|
000144  79c0              LDRB     r0,[r0,#7]  ; usb_state
000146  b1f8              CBZ      r0,|L10.392|
000148  2801              CMP      r0,#1
00014a  d00d              BEQ      |L10.360|
00014c  2803              CMP      r0,#3
00014e  d01c              BEQ      |L10.394|
000150  2805              CMP      r0,#5
000152  d12f              BNE      |L10.436|
;;;309                    case USB_DISCONNECTING:
;;;310                        usb_state = USB_DISCONNECTED;
000154  494f              LDR      r1,|L10.660|
;;;311                        // Disable board power before USB is disconnected.
;;;312                        gpio_set_board_power(false);
000156  2000              MOVS     r0,#0
000158  f8819007          STRB     r9,[r1,#7]            ;310
00015c  f7fffffe          BL       gpio_set_board_power
;;;313                        usbd_connect(0);
000160  2000              MOVS     r0,#0
000162  f7fffffe          BL       usbd_connect
;;;314                        break;
000166  e025              B        |L10.436|
                  |L10.360|
;;;315    
;;;316                    case USB_CONNECTING:
;;;317                        // Wait before connecting
;;;318                        if (DECZERO(usb_state_count) == 0) {
000168  f1bb0f00          CMP      r11,#0
00016c  d004              BEQ      |L10.376|
00016e  f1ab0001          SUB      r0,r11,#1
000172  ea5f0b00          MOVS     r11,r0
000176  d11d              BNE      |L10.436|
                  |L10.376|
;;;319                            usbd_connect(1);
000178  2001              MOVS     r0,#1
00017a  f7fffffe          BL       usbd_connect
;;;320                            usb_state = USB_CHECK_CONNECTED;
00017e  4845              LDR      r0,|L10.660|
000180  2103              MOVS     r1,#3
;;;321                            // Reset connect timeout
;;;322                            usb_no_config_count = USB_CONFIGURE_TIMEOUT;
000182  f04f0816          MOV      r8,#0x16
000186  71c1              STRB     r1,[r0,#7]            ;320
                  |L10.392|
000188  e014              B        |L10.436|
                  |L10.394|
;;;323                        }
;;;324    
;;;325                        break;
;;;326    
;;;327                    case USB_CHECK_CONNECTED:
;;;328                        if (usbd_configured()) {
00018a  f7fffffe          BL       usbd_configured
00018e  b130              CBZ      r0,|L10.414|
;;;329                            // Let the HIC enable power to the target now that high power has been negotiated.
;;;330                            gpio_set_board_power(true);
000190  2001              MOVS     r0,#1
000192  f7fffffe          BL       gpio_set_board_power
;;;331    
;;;332                            usb_state = USB_CONNECTED;
000196  483f              LDR      r0,|L10.660|
000198  2102              MOVS     r1,#2
00019a  71c1              STRB     r1,[r0,#7]
00019c  e00a              B        |L10.436|
                  |L10.414|
;;;333                        }
;;;334                        else if (DECZERO(usb_no_config_count) == 0) {
00019e  f1b80f00          CMP      r8,#0
0001a2  d004              BEQ      |L10.430|
0001a4  f1a80001          SUB      r0,r8,#1
0001a8  ea5f0800          MOVS     r8,r0
0001ac  d102              BNE      |L10.436|
                  |L10.430|
;;;335                            // USB configuration timed out, which most likely indicates that the HIC is
;;;336                            // powered by a USB wall wart or similar power source. Go ahead and enable
;;;337                            // board power.
;;;338                            gpio_set_board_power(true);
0001ae  2001              MOVS     r0,#1
0001b0  f7fffffe          BL       gpio_set_board_power
                  |L10.436|
;;;339                        }
;;;340    
;;;341                        break;
;;;342    
;;;343                    case USB_CONNECTED:
;;;344                    case USB_DISCONNECTED:
;;;345                    default:
;;;346                        break;
;;;347                }
;;;348            }
;;;349    
;;;350            // 30mS tick used for flashing LED when USB is busy
;;;351            if (flags & FLAGS_MAIN_30MS) {
0001b4  07a0              LSLS     r0,r4,#30
0001b6  d586              BPL      |L10.198|
;;;352    
;;;353                // handle reset button without eventing
;;;354                if (!reset_pressed && gpio_get_reset_btn_fwrd()) {
0001b8  f1ba0f00          CMP      r10,#0
0001bc  d003              BEQ      |L10.454|
;;;355    #ifdef DRAG_N_DROP_SUPPORT
;;;356                   if (!flash_intf_target->flash_busy()) //added checking if flashing on target is in progress
;;;357    #endif
;;;358                    {
;;;359                        // Reset button pressed
;;;360                        target_set_state(RESET_HOLD);
;;;361                        reset_pressed = 1;
;;;362                    }
;;;363                } else if (reset_pressed && !gpio_get_reset_btn_fwrd()) {
0001be  f7fffffe          BL       gpio_get_reset_btn_fwrd
0001c2  b168              CBZ      r0,|L10.480|
0001c4  e011              B        |L10.490|
                  |L10.454|
0001c6  f7fffffe          BL       gpio_get_reset_btn_fwrd
0001ca  b170              CBZ      r0,|L10.490|
0001cc  4840              LDR      r0,|L10.720|
0001ce  6800              LDR      r0,[r0,#0]            ;356  ; flash_intf_target
0001d0  69c0              LDR      r0,[r0,#0x1c]         ;356
0001d2  4780              BLX      r0                    ;356
0001d4  b948              CBNZ     r0,|L10.490|
0001d6  2000              MOVS     r0,#0                 ;360
0001d8  f7fffffe          BL       target_set_state
0001dc  2001              MOVS     r0,#1                 ;361
0001de  e003              B        |L10.488|
                  |L10.480|
;;;364                    // Reset button released
;;;365                    target_set_state(RESET_RUN);
0001e0  2002              MOVS     r0,#2
0001e2  f7fffffe          BL       target_set_state
;;;366                    reset_pressed = 0;
0001e6  2000              MOVS     r0,#0
                  |L10.488|
0001e8  4682              MOV      r10,r0
                  |L10.490|
;;;367                }
;;;368    
;;;369    #ifdef PBON_BUTTON
;;;370                // handle PBON pressed
;;;371                if(gpio_get_pbon_btn())
;;;372                {
;;;373                    if(power_on)
;;;374                    {
;;;375                        // Loop till PBON is pressed
;;;376                        while (gpio_get_pbon_btn()) {;}
;;;377                        // Power button released when target was running
;;;378                        target_set_state(SHUTDOWN);
;;;379                        power_on = 0;
;;;380                    }
;;;381                    else
;;;382                    {
;;;383                        // Loop till PBON is pressed
;;;384                        while (gpio_get_pbon_btn()) {;}
;;;385                        // Power button released when target was already powered off
;;;386                        target_set_state(POWER_ON);
;;;387                        power_on = 1;
;;;388                    }
;;;389                }
;;;390    #endif
;;;391    
;;;392                // DAP LED
;;;393                if (hid_led_usb_activity) {
0001ea  4c2a              LDR      r4,|L10.660|
0001ec  7820              LDRB     r0,[r4,#0]  ; hid_led_usb_activity
0001ee  b150              CBZ      r0,|L10.518|
;;;394    
;;;395                    if ((hid_led_state == MAIN_LED_FLASH) || (hid_led_state == MAIN_LED_FLASH_PERMANENT)) {
0001f0  78e0              LDRB     r0,[r4,#3]  ; hid_led_state
0001f2  2801              CMP      r0,#1
0001f4  d024              BEQ      |L10.576|
0001f6  2802              CMP      r0,#2
0001f8  d022              BEQ      |L10.576|
;;;396                        // Toggle LED value
;;;397                        hid_led_value = GPIO_LED_ON == hid_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
;;;398    
;;;399                        // If in flash mode stop after one cycle
;;;400                        if ((HID_LED_DEF == hid_led_value) && (MAIN_LED_FLASH == hid_led_state)) {
;;;401                            hid_led_usb_activity = 0;
;;;402                            hid_led_state = MAIN_LED_DEF;
;;;403                        }
;;;404                    } else {
;;;405                        //LED next state is MAIN_LED_DEF
;;;406                        hid_led_value = HID_LED_DEF;
0001fa  2700              MOVS     r7,#0
;;;407                        hid_led_usb_activity = 0;
0001fc  f8849000          STRB     r9,[r4,#0]
                  |L10.512|
;;;408                    }
;;;409    
;;;410                    // Update hardware
;;;411                    gpio_set_hid_led(hid_led_value);
000200  4638              MOV      r0,r7
000202  f7fffffe          BL       gpio_set_hid_led
                  |L10.518|
;;;412                }
;;;413    
;;;414                // MSD LED
;;;415                if (msc_led_usb_activity) {
000206  78a0              LDRB     r0,[r4,#2]  ; msc_led_usb_activity
000208  b150              CBZ      r0,|L10.544|
;;;416    
;;;417                    if ((msc_led_state == MAIN_LED_FLASH) || (msc_led_state == MAIN_LED_FLASH_PERMANENT)) {
00020a  7960              LDRB     r0,[r4,#5]  ; msc_led_state
00020c  2801              CMP      r0,#1
00020e  d025              BEQ      |L10.604|
000210  2802              CMP      r0,#2
000212  d023              BEQ      |L10.604|
;;;418                        // Toggle LED value
;;;419                        msc_led_value = GPIO_LED_ON == msc_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
;;;420    
;;;421                        // If in flash mode stop after one cycle
;;;422                        if ((MSC_LED_DEF == msc_led_value) && (MAIN_LED_FLASH == msc_led_state)) {
;;;423                            msc_led_usb_activity = 0;
;;;424                            msc_led_state = MAIN_LED_DEF;
;;;425                        }
;;;426                    } else {
;;;427                        //LED next state is MAIN_LED_DEF
;;;428                        msc_led_value = MSC_LED_DEF;
000214  2500              MOVS     r5,#0
;;;429                        msc_led_usb_activity = 0;
000216  f8849002          STRB     r9,[r4,#2]
                  |L10.538|
;;;430                    }
;;;431    
;;;432                    // Update hardware
;;;433                    gpio_set_msc_led(msc_led_value);
00021a  4628              MOV      r0,r5
00021c  f7fffffe          BL       gpio_set_msc_led
                  |L10.544|
;;;434                }
;;;435    
;;;436                // CDC LED
;;;437                if (cdc_led_usb_activity) {
000220  7860              LDRB     r0,[r4,#1]  ; cdc_led_usb_activity
000222  2800              CMP      r0,#0
000224  f43faf4f          BEQ      |L10.198|
;;;438    
;;;439                    if ((cdc_led_state == MAIN_LED_FLASH) || (cdc_led_state == MAIN_LED_FLASH_PERMANENT)){
000228  7920              LDRB     r0,[r4,#4]  ; cdc_led_state
00022a  2801              CMP      r0,#1
00022c  d024              BEQ      |L10.632|
00022e  2802              CMP      r0,#2
000230  d022              BEQ      |L10.632|
;;;440                        // Toggle LED value
;;;441                        cdc_led_value = GPIO_LED_ON == cdc_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
;;;442    
;;;443                        // If in flash mode stop after one cycle
;;;444                        if ((CDC_LED_DEF == cdc_led_value) && (MAIN_LED_FLASH == cdc_led_state)) {
;;;445                            cdc_led_usb_activity = 0;
;;;446                            cdc_led_state = MAIN_LED_DEF;
;;;447                        }
;;;448                    }else{
;;;449                        //LED next state is MAIN_LED_DEF
;;;450                        cdc_led_value = CDC_LED_DEF;
000232  2600              MOVS     r6,#0
;;;451                        cdc_led_usb_activity = 0;
000234  f8849001          STRB     r9,[r4,#1]
                  |L10.568|
;;;452                    }
;;;453    
;;;454                    // Update hardware
;;;455                    gpio_set_cdc_led(cdc_led_value);
000238  4630              MOV      r0,r6
00023a  f7fffffe          BL       gpio_set_cdc_led
00023e  e742              B        |L10.198|
                  |L10.576|
000240  2f01              CMP      r7,#1                 ;397
000242  d001              BEQ      |L10.584|
000244  2701              MOVS     r7,#1                 ;397
000246  e000              B        |L10.586|
                  |L10.584|
000248  2700              MOVS     r7,#0                 ;397
                  |L10.586|
00024a  2f00              CMP      r7,#0                 ;400
00024c  d1d8              BNE      |L10.512|
00024e  2801              CMP      r0,#1                 ;400
000250  d1d6              BNE      |L10.512|
000252  f8849000          STRB     r9,[r4,#0]            ;401
000256  f8849003          STRB     r9,[r4,#3]            ;402
00025a  e7d1              B        |L10.512|
                  |L10.604|
00025c  2d01              CMP      r5,#1                 ;419
00025e  d001              BEQ      |L10.612|
000260  2501              MOVS     r5,#1                 ;419
000262  e000              B        |L10.614|
                  |L10.612|
000264  2500              MOVS     r5,#0                 ;419
                  |L10.614|
000266  2d00              CMP      r5,#0                 ;422
000268  d1d7              BNE      |L10.538|
00026a  2801              CMP      r0,#1                 ;422
00026c  d1d5              BNE      |L10.538|
00026e  f8849002          STRB     r9,[r4,#2]            ;423
000272  f8849005          STRB     r9,[r4,#5]            ;424
000276  e7d0              B        |L10.538|
                  |L10.632|
000278  2e01              CMP      r6,#1                 ;441
00027a  d001              BEQ      |L10.640|
00027c  2601              MOVS     r6,#1                 ;441
00027e  e000              B        |L10.642|
                  |L10.640|
000280  2600              MOVS     r6,#0                 ;441
                  |L10.642|
000282  2e00              CMP      r6,#0                 ;444
000284  d1d8              BNE      |L10.568|
000286  2801              CMP      r0,#1                 ;444
000288  d1d6              BNE      |L10.568|
00028a  f8849001          STRB     r9,[r4,#1]            ;445
00028e  f8849004          STRB     r9,[r4,#4]            ;446
000292  e7d1              B        |L10.568|
;;;456                }
;;;457            }
;;;458        }
;;;459    }
;;;460    
                          ENDP

                  |L10.660|
                          DCD      ||.data||
                  |L10.664|
                          DCD      g_board_info
                  |L10.668|
00029c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\interface\\main.c",0
0002a0  2e5c2e2e
0002a4  5c736f75
0002a8  7263655c
0002ac  6461706c
0002b0  696e6b5c
0002b4  696e7465
0002b8  72666163
0002bc  655c6d61
0002c0  696e2e63
0002c4  00      
0002c5  00                DCB      0
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L10.712|
                          DCD      g_target_family
                  |L10.716|
                          DCD      timer_task_30mS
                  |L10.720|
                          DCD      flash_intf_target

                          AREA ||i.main_usb_set_test_mode||, CODE, READONLY, ALIGN=2

                  main_usb_set_test_mode PROC
;;;169    
;;;170    void main_usb_set_test_mode(bool enabled)
000000  4901              LDR      r1,|L11.8|
;;;171    {
;;;172        usb_test_mode = enabled;
000002  7188              STRB     r0,[r1,#6]
;;;173    }
000004  4770              BX       lr
;;;174    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||.data||

                          AREA ||i.timer_task_30mS||, CODE, READONLY, ALIGN=2

                  timer_task_30mS PROC
;;;107    // Timer task, set flags every 30mS and 90mS
;;;108    void timer_task_30mS(void * arg)
000000  b510              PUSH     {r4,lr}
;;;109    {
;;;110        static uint32_t i = 0;
;;;111        osThreadFlagsSet(main_task_id, FLAGS_MAIN_30MS);
000002  4c0b              LDR      r4,|L12.48|
000004  2102              MOVS     r1,#2
000006  68e0              LDR      r0,[r4,#0xc]  ; main_task_id
000008  f7fffffe          BL       osThreadFlagsSet
;;;112        if (!(i++ % 3)) {
00000c  68a0              LDR      r0,[r4,#8]  ; i
00000e  2103              MOVS     r1,#3
000010  fbb0f2f1          UDIV     r2,r0,r1
000014  fb010112          MLS      r1,r1,r2,r0
000018  1c40              ADDS     r0,r0,#1
00001a  60a0              STR      r0,[r4,#8]  ; i
00001c  2900              CMP      r1,#0
00001e  d105              BNE      |L12.44|
;;;113            osThreadFlagsSet(main_task_id, FLAGS_MAIN_90MS);
000020  68e0              LDR      r0,[r4,#0xc]  ; main_task_id
000022  e8bd4010          POP      {r4,lr}
000026  2101              MOVS     r1,#1
000028  f7ffbffe          B.W      osThreadFlagsSet
                  |L12.44|
;;;114        }
;;;115    }
00002c  bd10              POP      {r4,pc}
;;;116    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  hid_led_usb_activity
000000  00                DCB      0x00
                  cdc_led_usb_activity
000001  00                DCB      0x00
                  msc_led_usb_activity
000002  00                DCB      0x00
                  hid_led_state
000003  01                DCB      0x01
                  cdc_led_state
000004  01                DCB      0x01
                  msc_led_state
000005  01                DCB      0x01
                  usb_test_mode
000006  00                DCB      0x00
                  usb_state
000007  00                DCB      0x00
                  i
                          DCD      0x00000000
                  main_task_id
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\interface\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_3e3da33c____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___6_main_c_3e3da33c____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_3e3da33c____REVSH|
#line 495
|__asm___6_main_c_3e3da33c____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_3e3da33c____RRX|
#line 682
|__asm___6_main_c_3e3da33c____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
