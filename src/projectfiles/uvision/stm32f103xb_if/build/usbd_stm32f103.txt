; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\usbd_stm32f103.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usbd_stm32f103.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\usbd_stm32f103.crf ..\..\..\source\hic_hal\stm32\stm32f103xb\usbd_STM32F103.c]
                          THUMB

                          AREA ||i.EP_Reset||, CODE, READONLY, ALIGN=2

                  EP_Reset PROC
;;;98     
;;;99     void EP_Reset(U32 EPNum)
000000  0701              LSLS     r1,r0,#28
;;;100    {
;;;101        U32 num, val;
;;;102        num = EPNum & 0x0F;
;;;103        val = EPxREG(num);
000002  0e8a              LSRS     r2,r1,#26
000004  4907              LDR      r1,|L1.36|
000006  440a              ADD      r2,r2,r1
000008  f8d21c00          LDR      r1,[r2,#0xc00]
;;;104    
;;;105        if (EPNum & 0x80) {                   /* IN Endpoint                        */
00000c  0600              LSLS     r0,r0,#24
00000e  d502              BPL      |L1.22|
;;;106            EPxREG(num) = val & (EP_MASK | EP_DTOG_TX);
000010  f64870cf          MOV      r0,#0x8fcf
000014  e001              B        |L1.26|
                  |L1.22|
;;;107        } else {                              /* OUT Endpoint                       */
;;;108            EPxREG(num) = val & (EP_MASK | EP_DTOG_RX);
000016  f64c708f          MOV      r0,#0xcf8f
                  |L1.26|
00001a  4001              ANDS     r1,r1,r0              ;106
00001c  f8c21c00          STR      r1,[r2,#0xc00]        ;106
;;;109        }
;;;110    }
000020  4770              BX       lr
;;;111    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x40005000

                          AREA ||i.EP_Status||, CODE, READONLY, ALIGN=2

                  EP_Status PROC
;;;121    
;;;122    void EP_Status(U32 EPNum, U32 stat)
000000  0702              LSLS     r2,r0,#28
;;;123    {
;;;124        U32 num, val;
;;;125        num = EPNum & 0x0F;
;;;126        val = EPxREG(num);
000002  0e93              LSRS     r3,r2,#26
000004  4a0c              LDR      r2,|L2.56|
000006  b530              PUSH     {r4,r5,lr}            ;123
000008  4413              ADD      r3,r3,r2
00000a  f8d32c00          LDR      r2,[r3,#0xc00]
;;;127    
;;;128        if (EPNum & 0x80) {                   /* IN Endpoint                        */
00000e  0600              LSLS     r0,r0,#24
;;;129            EPxREG(num) = EP_VAL_UNCHANGED(val) | ((val ^ stat) & EP_STAT_TX);
000010  f648748f          MOV      r4,#0x8f8f
;;;130        } else {                              /* OUT Endpoint                       */
;;;131            EPxREG(num) = EP_VAL_UNCHANGED(val) | ((val ^ stat) & EP_STAT_RX);
000014  ea020004          AND      r0,r2,r4
000018  f2480580          MOV      r5,#0x8080            ;129
00001c  ea820201          EOR      r2,r2,r1
000020  d502              BPL      |L2.40|
000022  f0020130          AND      r1,r2,#0x30           ;129
000026  e001              B        |L2.44|
                  |L2.40|
000028  f4025140          AND      r1,r2,#0x3000
                  |L2.44|
00002c  4308              ORRS     r0,r0,r1              ;129
00002e  4328              ORRS     r0,r0,r5              ;129
000030  f8c30c00          STR      r0,[r3,#0xc00]        ;129
;;;132        }
;;;133    }
000034  bd30              POP      {r4,r5,pc}
;;;134    
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40005000

                          AREA ||i.USBD_ClearEPBuf||, CODE, READONLY, ALIGN=1

                  USBD_ClearEPBuf PROC
;;;465    
;;;466    void USBD_ClearEPBuf(U32 EPNum)
000000  4770              BX       lr
;;;467    {
;;;468        ;
;;;469    }
;;;470    
                          ENDP


                          AREA ||i.USBD_ClrStallEP||, CODE, READONLY, ALIGN=1

                  USBD_ClrStallEP PROC
;;;450    
;;;451    void USBD_ClrStallEP(U32 EPNum)
000000  b500              PUSH     {lr}
;;;452    {
000002  4603              MOV      r3,r0
;;;453        EP_Reset(EPNum);                      /* reset DTog Bits                    */
000004  f7fffffe          BL       EP_Reset
;;;454        EP_Status(EPNum, EP_TX_VALID | EP_RX_VALID);
000008  f2430130          MOV      r1,#0x3030
00000c  4618              MOV      r0,r3
00000e  f85deb04          POP      {lr}
000012  f7ffbffe          B.W      EP_Status
;;;455    }
;;;456    
                          ENDP


                          AREA ||i.USBD_ConfigEP||, CODE, READONLY, ALIGN=2

                  USBD_ConfigEP PROC
;;;322    
;;;323    void USBD_ConfigEP(USB_ENDPOINT_DESCRIPTOR *pEPD)
000000  b5f0              PUSH     {r4-r7,lr}
;;;324    {
;;;325        /* Double Buffering is not yet supported                                    */
;;;326        U32 num, val;
;;;327        num = pEPD->bEndpointAddress & 0x0F;
000002  7882              LDRB     r2,[r0,#2]
;;;328        val = pEPD->wMaxPacketSize;
;;;329    
;;;330        if (pEPD->bEndpointAddress & USB_ENDPOINT_DIRECTION_MASK) {
;;;331            (pBUF_DSCR + num)->ADDR_TX = FreeBufAddr;
000004  4d22              LDR      r5,|L5.144|
000006  7941              LDRB     r1,[r0,#5]            ;328
000008  7904              LDRB     r4,[r0,#4]            ;328
00000a  f002030f          AND      r3,r2,#0xf            ;327
00000e  ea442101          ORR      r1,r4,r1,LSL #8       ;328
000012  0616              LSLS     r6,r2,#24             ;330
000014  686f              LDR      r7,[r5,#4]
000016  882c              LDRH     r4,[r5,#0]
000018  f002020f          AND      r2,r2,#0xf            ;327
00001c  eb071202          ADD      r2,r7,r2,LSL #4
000020  d504              BPL      |L5.44|
000022  1c49              ADDS     r1,r1,#1
;;;332            val = (val + 1) & ~1;
000024  f0210101          BIC      r1,r1,#1
000028  6014              STR      r4,[r2,#0]
00002a  e011              B        |L5.80|
                  |L5.44|
;;;333        } else {
;;;334            (pBUF_DSCR + num)->ADDR_RX = FreeBufAddr;
;;;335    
;;;336            if (val > 62) {
00002c  6094              STR      r4,[r2,#8]
00002e  293e              CMP      r1,#0x3e
000030  d909              BLS      |L5.70|
000032  311f              ADDS     r1,r1,#0x1f
;;;337                val = (val + 31) & ~31;
000034  f021011f          BIC      r1,r1,#0x1f
;;;338                (pBUF_DSCR + num)->COUNT_RX = ((val << 5) - 1) | 0x8000;
000038  f04f34ff          MOV      r4,#0xffffffff
00003c  eb041441          ADD      r4,r4,r1,LSL #5
000040  f4444400          ORR      r4,r4,#0x8000
000044  e003              B        |L5.78|
                  |L5.70|
000046  1c49              ADDS     r1,r1,#1
;;;339            } else {
;;;340                val = (val + 1)  & ~1;
000048  f0210101          BIC      r1,r1,#1
;;;341                (pBUF_DSCR + num)->COUNT_RX =   val << 9;
00004c  024c              LSLS     r4,r1,#9
                  |L5.78|
00004e  60d4              STR      r4,[r2,#0xc]          ;338
                  |L5.80|
;;;342            }
;;;343        }
;;;344    
;;;345        FreeBufAddr += val;
000050  882a              LDRH     r2,[r5,#0]  ; FreeBufAddr
000052  440a              ADD      r2,r2,r1
000054  802a              STRH     r2,[r5,#0]
;;;346    
;;;347        switch (pEPD->bmAttributes & USB_ENDPOINT_TYPE_MASK) {
000056  78c0              LDRB     r0,[r0,#3]
000058  f0100003          ANDS     r0,r0,#3
00005c  d006              BEQ      |L5.108|
00005e  2801              CMP      r0,#1
000060  d007              BEQ      |L5.114|
000062  2802              CMP      r0,#2
000064  d008              BEQ      |L5.120|
000066  2803              CMP      r0,#3
000068  d10a              BNE      |L5.128|
00006a  e007              B        |L5.124|
                  |L5.108|
;;;348            case USB_ENDPOINT_TYPE_CONTROL:
;;;349                val = EP_CONTROL;
00006c  f44f7100          MOV      r1,#0x200
;;;350                break;
000070  e006              B        |L5.128|
                  |L5.114|
;;;351    
;;;352            case USB_ENDPOINT_TYPE_ISOCHRONOUS:
;;;353                val = EP_ISOCHRONOUS;
000072  f44f6180          MOV      r1,#0x400
;;;354                break;
000076  e003              B        |L5.128|
                  |L5.120|
;;;355    
;;;356            case USB_ENDPOINT_TYPE_BULK:
;;;357                val = EP_BULK;
000078  2100              MOVS     r1,#0
;;;358    
;;;359                if (USB_DBL_BUF_EP & (1 << num)) {
;;;360                    val |= EP_KIND;
;;;361                }
;;;362    
;;;363                break;
00007a  e001              B        |L5.128|
                  |L5.124|
;;;364    
;;;365            case USB_ENDPOINT_TYPE_INTERRUPT:
;;;366                val = EP_INTERRUPT;
00007c  f44f61c0          MOV      r1,#0x600
                  |L5.128|
;;;367                break;
;;;368        }
;;;369    
;;;370        val |= num;
;;;371        EPxREG(num) = val;
000080  4a04              LDR      r2,|L5.148|
000082  4319              ORRS     r1,r1,r3              ;370
000084  eb020083          ADD      r0,r2,r3,LSL #2
000088  f8c01c00          STR      r1,[r0,#0xc00]
;;;372    }
00008c  bdf0              POP      {r4-r7,pc}
;;;373    
                          ENDP

00008e  0000              DCW      0x0000
                  |L5.144|
                          DCD      ||.data||
                  |L5.148|
                          DCD      0x40005000

                          AREA ||i.USBD_Configure||, CODE, READONLY, ALIGN=2

                  USBD_Configure PROC
;;;307    
;;;308    void USBD_Configure(BOOL cfg)
000000  2800              CMP      r0,#0
;;;309    {
000002  d102              BNE      |L6.10|
;;;310        if (cfg == __FALSE) {
;;;311            FreeBufAddr  = EP_BUF_ADDR;
000004  4901              LDR      r1,|L6.12|
;;;312            FreeBufAddr += 2 * USBD_MAX_PACKET0; /* reset Buffer address               */
000006  20d0              MOVS     r0,#0xd0
000008  8008              STRH     r0,[r1,#0]
                  |L6.10|
;;;313        }
;;;314    }
00000a  4770              BX       lr
;;;315    
                          ENDP

                  |L6.12|
                          DCD      ||.data||

                          AREA ||i.USBD_Connect||, CODE, READONLY, ALIGN=2

                  USBD_Connect PROC
;;;175    
;;;176    void USBD_Connect(BOOL con)
000000  4909              LDR      r1,|L7.40|
;;;177    {
;;;178        if (con) {
;;;179            CNTR = CNTR_FRES;                   /* Force USB Reset                    */
;;;180            CNTR = 0;
;;;181            ISTR = 0;                           /* Clear Interrupt Status             */
;;;182            CNTR = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* USB Interrupt Mask       */
;;;183            USB_CONNECT_ON();
000002  13ca              ASRS     r2,r1,#15
000004  b150              CBZ      r0,|L7.28|
000006  2001              MOVS     r0,#1                 ;179
000008  6008              STR      r0,[r1,#0]            ;179
00000a  2000              MOVS     r0,#0                 ;180
00000c  6008              STR      r0,[r1,#0]            ;180
00000e  1d0b              ADDS     r3,r1,#4              ;181
000010  6018              STR      r0,[r3,#0]            ;181
000012  f44f50e0          MOV      r0,#0x1c00            ;182
000016  6008              STR      r0,[r1,#0]            ;182
000018  4804              LDR      r0,|L7.44|
00001a  e003              B        |L7.36|
                  |L7.28|
;;;184        } else {
;;;185            CNTR = CNTR_FRES | CNTR_PDWN;       /* Switch Off USB Device              */
00001c  2003              MOVS     r0,#3
00001e  6008              STR      r0,[r1,#0]
;;;186            USB_CONNECT_OFF();
000020  4802              LDR      r0,|L7.44|
000022  1d00              ADDS     r0,r0,#4
                  |L7.36|
000024  6002              STR      r2,[r0,#0]            ;183
;;;187        }
;;;188    }
000026  4770              BX       lr
;;;189    
                          ENDP

                  |L7.40|
                          DCD      0x40005c40
                  |L7.44|
                          DCD      0x40010810

                          AREA ||i.USBD_DirCtrlEP||, CODE, READONLY, ALIGN=1

                  USBD_DirCtrlEP PROC
;;;380    
;;;381    void USBD_DirCtrlEP(U32 dir)
000000  4770              BX       lr
;;;382    {
;;;383        /* Not needed                                                               */
;;;384    }
;;;385    
                          ENDP


                          AREA ||i.USBD_DisableEP||, CODE, READONLY, ALIGN=1

                  USBD_DisableEP PROC
;;;408    
;;;409    void USBD_DisableEP(U32 EPNum)
000000  2100              MOVS     r1,#0
;;;410    {
;;;411        EP_Status(EPNum, EP_TX_DIS | EP_RX_DIS);
000002  f7ffbffe          B.W      EP_Status
;;;412    }
;;;413    
                          ENDP


                          AREA ||i.USBD_EnableEP||, CODE, READONLY, ALIGN=1

                  USBD_EnableEP PROC
;;;394    
;;;395    void USBD_EnableEP(U32 EPNum)
000000  f2430120          MOV      r1,#0x3020
;;;396    {
;;;397        EP_Status(EPNum, EP_TX_NAK | EP_RX_VALID);    /* EP is able to receive      */
000004  f7ffbffe          B.W      EP_Status
;;;398    }
;;;399    
                          ENDP


                          AREA ||i.USBD_GetFrame||, CODE, READONLY, ALIGN=2

                  USBD_GetFrame PROC
;;;541    
;;;542    U32 USBD_GetFrame(void)
000000  4802              LDR      r0,|L11.12|
;;;543    {
;;;544        return (FNR & FNR_FN);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000a          UBFX     r0,r0,#0,#11
;;;545    }
000008  4770              BX       lr
;;;546    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40005c48

                          AREA ||i.USBD_Handler||, CODE, READONLY, ALIGN=2

                  USBD_Handler PROC
;;;613    
;;;614    void USBD_Handler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;615    {
000004  f3ef8010          MRS      r0,PRIMASK
000008  f0100f01          TST      r0,#1
00000c  b672              CPSID    i
;;;616        U32 istr, num, val, num_val;
;;;617        cortex_int_state_t state;
;;;618    
;;;619        // Get ISTR
;;;620        state = cortex_int_get_and_disable();
;;;621        istr = LastIstr;
00000e  f8df80e8          LDR      r8,|L12.248|
;;;622        LastIstr = 0;
000012  f04f0200          MOV      r2,#0
000016  f8d84010          LDR      r4,[r8,#0x10]  ; LastIstr
00001a  f8c82010          STR      r2,[r8,#0x10]         ;615  ; LastIstr
00001e  d100              BNE      |L12.34|
000020  b662              CPSIE    i                     ;615
                  |L12.34|
;;;623        cortex_int_restore(state);
;;;624    
;;;625        /* USB Reset Request                                                        */
;;;626        if (istr & ISTR_RESET) {
000022  0560              LSLS     r0,r4,#21
000024  d507              BPL      |L12.54|
;;;627            USBD_Reset();
000026  f7fffffe          BL       USBD_Reset
;;;628            usbd_reset_core();
00002a  f7fffffe          BL       usbd_reset_core
;;;629    #ifdef __RTX
;;;630    
;;;631            if (USBD_RTX_DevTask) {
;;;632                isr_evt_set(USBD_EVT_RESET, USBD_RTX_DevTask);
;;;633            }
;;;634    
;;;635    #else
;;;636    
;;;637            if (USBD_P_Reset_Event) {
00002e  4833              LDR      r0,|L12.252|
000030  6800              LDR      r0,[r0,#0]  ; USBD_P_Reset_Event
000032  b100              CBZ      r0,|L12.54|
;;;638                USBD_P_Reset_Event();
000034  4780              BLX      r0
                  |L12.54|
;;;639            }
;;;640    
;;;641    #endif
;;;642        }
;;;643    
;;;644        /* USB Suspend Request                                                      */
;;;645        if (istr & ISTR_SUSP) {
000036  0520              LSLS     r0,r4,#20
000038  d505              BPL      |L12.70|
;;;646            USBD_Suspend();
00003a  f7fffffe          BL       USBD_Suspend
;;;647    #ifdef __RTX
;;;648    
;;;649            if (USBD_RTX_DevTask) {
;;;650                isr_evt_set(USBD_EVT_SUSPEND, USBD_RTX_DevTask);
;;;651            }
;;;652    
;;;653    #else
;;;654    
;;;655            if (USBD_P_Suspend_Event) {
00003e  4830              LDR      r0,|L12.256|
000040  6800              LDR      r0,[r0,#0]  ; USBD_P_Suspend_Event
000042  b100              CBZ      r0,|L12.70|
;;;656                USBD_P_Suspend_Event();
000044  4780              BLX      r0
                  |L12.70|
;;;657            }
;;;658    
;;;659    #endif
;;;660        }
;;;661    
;;;662        /* USB Wakeup                                                               */
;;;663        if (istr & ISTR_WKUP) {
000046  04e0              LSLS     r0,r4,#19
000048  d505              BPL      |L12.86|
;;;664            USBD_WakeUp();
00004a  f7fffffe          BL       USBD_WakeUp
;;;665    #ifdef __RTX
;;;666    
;;;667            if (USBD_RTX_DevTask) {
;;;668                isr_evt_set(USBD_EVT_RESUME,  USBD_RTX_DevTask);
;;;669            }
;;;670    
;;;671    #else
;;;672    
;;;673            if (USBD_P_Resume_Event) {
00004e  482d              LDR      r0,|L12.260|
000050  6800              LDR      r0,[r0,#0]  ; USBD_P_Resume_Event
000052  b100              CBZ      r0,|L12.86|
;;;674                USBD_P_Resume_Event();
000054  4780              BLX      r0
                  |L12.86|
;;;675            }
;;;676    
;;;677    #endif
;;;678        }
;;;679    
;;;680        /* Start of Frame                                                           */
;;;681        if (istr & ISTR_SOF) {
000056  05a0              LSLS     r0,r4,#22
000058  d503              BPL      |L12.98|
;;;682    #ifdef __RTX
;;;683    
;;;684            if (USBD_RTX_DevTask) {
;;;685                isr_evt_set(USBD_EVT_SOF, USBD_RTX_DevTask);
;;;686            }
;;;687    
;;;688    #else
;;;689    
;;;690            if (USBD_P_SOF_Event) {
00005a  482b              LDR      r0,|L12.264|
00005c  6800              LDR      r0,[r0,#0]  ; USBD_P_SOF_Event
00005e  b100              CBZ      r0,|L12.98|
;;;691                USBD_P_SOF_Event();
000060  4780              BLX      r0
                  |L12.98|
;;;692            }
;;;693    
;;;694    #endif
;;;695        }
;;;696    
;;;697        /* PMA Over/underrun                                                        */
;;;698        if (istr & ISTR_PMAOVR) {
;;;699    #ifdef __RTX
;;;700            LastError = 2;
;;;701    
;;;702            if (USBD_RTX_DevTask) {
;;;703                isr_evt_set(USBD_EVT_ERROR, USBD_RTX_DevTask);
;;;704            }
;;;705    
;;;706    #else
;;;707    
;;;708            if (USBD_P_Error_Event) {
000062  4d2a              LDR      r5,|L12.268|
000064  0460              LSLS     r0,r4,#17             ;698
000066  d503              BPL      |L12.112|
000068  6829              LDR      r1,[r5,#0]  ; USBD_P_Error_Event
00006a  b109              CBZ      r1,|L12.112|
;;;709                USBD_P_Error_Event(2);
00006c  2002              MOVS     r0,#2
00006e  4788              BLX      r1
                  |L12.112|
;;;710            }
;;;711    
;;;712    #endif
;;;713        }
;;;714    
;;;715        /* Error: No Answer, CRC Error, Bit Stuff Error, Frame Format Error         */
;;;716        if (istr & ISTR_ERR) {
;;;717    #ifdef __RTX
;;;718            LastError = 1;
;;;719    
;;;720            if (USBD_RTX_DevTask) {
;;;721                isr_evt_set(USBD_EVT_ERROR, USBD_RTX_DevTask);
;;;722            }
;;;723    
;;;724    #else
;;;725    
;;;726            if (USBD_P_Error_Event) {
;;;727                USBD_P_Error_Event(1);
;;;728            }
;;;729    
;;;730    #endif
;;;731        }
;;;732    
;;;733        /* Endpoint Interrupts                                                      */
;;;734        while ((istr & ISTR_CTR) && !stat_is_empty()) {
;;;735            num_val = stat_deque();
;;;736            num = (num_val >> EP_NUM_SHIFT) & EP_NUM_MASK;
;;;737            val = (num_val >> VAL_SHIFT) & VAL_MASK;
;;;738            if (val & EP_CTR_TX) {
;;;739    #ifdef __RTX
;;;740    
;;;741                if (USBD_RTX_EPTask[num]) {
;;;742                    isr_evt_set(USBD_EVT_IN,  USBD_RTX_EPTask[num]);
;;;743                }
;;;744    
;;;745    #else
;;;746    
;;;747                if (USBD_P_EP[num]) {
000070  4f27              LDR      r7,|L12.272|
000072  04a0              LSLS     r0,r4,#18             ;716
000074  d52b              BPL      |L12.206|
000076  6829              LDR      r1,[r5,#0]            ;726  ; USBD_P_Error_Event
000078  b349              CBZ      r1,|L12.206|
00007a  2001              MOVS     r0,#1                 ;727
00007c  e026              B        |L12.204|
                  |L12.126|
00007e  f3ef8010          MRS      r0,PRIMASK            ;727
000082  f0100f01          TST      r0,#1                 ;727
000086  b672              CPSID    i                     ;727
000088  4822              LDR      r0,|L12.276|
00008a  f04f020b          MOV      r2,#0xb               ;727
00008e  f8500021          LDR      r0,[r0,r1,LSL #2]     ;727
000092  f1010101          ADD      r1,r1,#1              ;727
000096  fbb1f6f2          UDIV     r6,r1,r2              ;727
00009a  fb021116          MLS      r1,r2,r6,r1           ;727
00009e  f8c81008          STR      r1,[r8,#8]            ;727  ; StatQueueHead
0000a2  d100              BNE      |L12.166|
0000a4  b662              CPSIE    i                     ;727
                  |L12.166|
0000a6  b286              UXTH     r6,r0                 ;736
0000a8  0c05              LSRS     r5,r0,#16             ;737
0000aa  0628              LSLS     r0,r5,#24             ;738
0000ac  d504              BPL      |L12.184|
0000ae  f8571026          LDR      r1,[r7,r6,LSL #2]
0000b2  b109              CBZ      r1,|L12.184|
;;;748                    USBD_P_EP[num](USBD_EVT_IN);
0000b4  2008              MOVS     r0,#8
0000b6  4788              BLX      r1
                  |L12.184|
;;;749                }
;;;750    
;;;751    #endif
;;;752            }
;;;753    
;;;754            if (val & EP_CTR_RX) {
0000b8  0428              LSLS     r0,r5,#16
0000ba  d508              BPL      |L12.206|
;;;755    #ifdef __RTX
;;;756    
;;;757                if (USBD_RTX_EPTask[num]) {
;;;758                    isr_evt_set((val & EP_SETUP) ? USBD_EVT_SETUP : USBD_EVT_OUT, USBD_RTX_EPTask[num]);
;;;759                }
;;;760    
;;;761    #else
;;;762    
;;;763                if (USBD_P_EP[num]) {
0000bc  f8571026          LDR      r1,[r7,r6,LSL #2]
0000c0  b129              CBZ      r1,|L12.206|
;;;764                    USBD_P_EP[num]((val & EP_SETUP) ? USBD_EVT_SETUP : USBD_EVT_OUT);
0000c2  0528              LSLS     r0,r5,#20
0000c4  d501              BPL      |L12.202|
0000c6  2002              MOVS     r0,#2
0000c8  e000              B        |L12.204|
                  |L12.202|
0000ca  2004              MOVS     r0,#4
                  |L12.204|
0000cc  4788              BLX      r1
                  |L12.206|
0000ce  0420              LSLS     r0,r4,#16             ;734
0000d0  d50f              BPL      |L12.242|
0000d2  f3ef8010          MRS      r0,PRIMASK            ;734
0000d6  f0000201          AND      r2,r0,#1              ;734
0000da  b672              CPSID    i                     ;734
0000dc  e9d81002          LDRD     r1,r0,[r8,#8]         ;734
0000e0  4281              CMP      r1,r0                 ;734
0000e2  d101              BNE      |L12.232|
0000e4  2001              MOVS     r0,#1                 ;734
0000e6  e000              B        |L12.234|
                  |L12.232|
0000e8  2000              MOVS     r0,#0                 ;734
                  |L12.234|
0000ea  b902              CBNZ     r2,|L12.238|
0000ec  b662              CPSIE    i                     ;734
                  |L12.238|
0000ee  2800              CMP      r0,#0                 ;734
0000f0  d0c5              BEQ      |L12.126|
                  |L12.242|
;;;765                }
;;;766    
;;;767    #endif
;;;768            }
;;;769        }
;;;770    }
0000f2  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

0000f6  0000              DCW      0x0000
                  |L12.248|
                          DCD      ||.data||
                  |L12.252|
                          DCD      USBD_P_Reset_Event
                  |L12.256|
                          DCD      USBD_P_Suspend_Event
                  |L12.260|
                          DCD      USBD_P_Resume_Event
                  |L12.264|
                          DCD      USBD_P_SOF_Event
                  |L12.268|
                          DCD      USBD_P_Error_Event
                  |L12.272|
                          DCD      USBD_P_EP
                  |L12.276|
                          DCD      ||.bss||

                          AREA ||i.USBD_Init||, CODE, READONLY, ALIGN=2

                  USBD_Init PROC
;;;159    
;;;160    void USBD_Init(void)
000000  4806              LDR      r0,|L13.28|
;;;161    {
000002  b510              PUSH     {r4,lr}
;;;162        RCC->APB1ENR |= (1 << 23);            /* enable clock for USB               */
000004  69c1              LDR      r1,[r0,#0x1c]
000006  f4410100          ORR      r1,r1,#0x800000
00000a  61c1              STR      r1,[r0,#0x1c]
00000c  2014              MOVS     r0,#0x14
00000e  f7fffffe          BL       __NVIC_EnableIRQ
;;;163        USBD_IntrEna();                       /* Enable USB Interrupts              */
;;;164        /* Control USB connecting via SW                                            */
;;;165        USB_CONNECT_OFF();
000012  4903              LDR      r1,|L13.32|
000014  f44f4000          MOV      r0,#0x8000
000018  6008              STR      r0,[r1,#0]
;;;166    }
00001a  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L13.28|
                          DCD      0x40021000
                  |L13.32|
                          DCD      0x40010814

                          AREA ||i.USBD_IntrEna||, CODE, READONLY, ALIGN=1

                  USBD_IntrEna PROC
;;;146    #else
;;;147    void          USBD_IntrEna(void)
000000  2014              MOVS     r0,#0x14
;;;148    {
;;;149    #endif
;;;150        NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
000002  f7ffbffe          B.W      __NVIC_EnableIRQ
;;;151    }
;;;152    
                          ENDP


                          AREA ||i.USBD_ReadEP||, CODE, READONLY, ALIGN=2

                  USBD_ReadEP PROC
;;;480    
;;;481    U32 USBD_ReadEP(U32 EPNum, U8 *pData, U32 bufsz)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
;;;483        /* Double Buffering is not yet supported                                    */
;;;484        U32 num, cnt, *pv, n;
;;;485        num = EPNum & 0x0F;
;;;486        pv  = (U32 *)(USB_PMA_ADDR + 2 * ((pBUF_DSCR + num)->ADDR_RX));
000002  4b13              LDR      r3,|L15.80|
000004  4606              MOV      r6,r0                 ;482
000006  f000000f          AND      r0,r0,#0xf            ;485
00000a  685b              LDR      r3,[r3,#4]  ; pBUF_DSCR
00000c  4c11              LDR      r4,|L15.84|
00000e  eb031000          ADD      r0,r3,r0,LSL #4
000012  6883              LDR      r3,[r0,#8]
;;;487        cnt = (pBUF_DSCR + num)->COUNT_RX & EP_COUNT_MASK;
000014  8980              LDRH     r0,[r0,#0xc]
000016  eb040443          ADD      r4,r4,r3,LSL #1       ;486
00001a  f3c00509          UBFX     r5,r0,#0,#10
;;;488        if (cnt > bufsz) {
00001e  4295              CMP      r5,r2
000020  d900              BLS      |L15.36|
;;;489            cnt = bufsz;
000022  4615              MOV      r5,r2
                  |L15.36|
;;;490        }
;;;491    
;;;492        for (n = 0; n < (cnt + 1) / 2; n++) {
000024  2300              MOVS     r3,#0
000026  1c6a              ADDS     r2,r5,#1
000028  e007              B        |L15.58|
                  |L15.42|
;;;493            *((__packed U16 *)pData) = *pv++;
00002a  f8340b04          LDRH     r0,[r4],#4
00002e  f8010b01          STRB     r0,[r1],#1
000032  0a00              LSRS     r0,r0,#8
000034  f8010b01          STRB     r0,[r1],#1
000038  1c5b              ADDS     r3,r3,#1
                  |L15.58|
00003a  ebb30f52          CMP      r3,r2,LSR #1          ;492
00003e  d3f4              BCC      |L15.42|
;;;494            pData += 2;
;;;495        }
;;;496    
;;;497        EP_Status(EPNum, EP_RX_VALID);
000040  f44f5140          MOV      r1,#0x3000
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       EP_Status
;;;498        return (cnt);
00004a  4628              MOV      r0,r5
;;;499    }
00004c  bd70              POP      {r4-r6,pc}
;;;500    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      ||.data||
                  |L15.84|
                          DCD      0x40006000

                          AREA ||i.USBD_Reset||, CODE, READONLY, ALIGN=2

                  USBD_Reset PROC
;;;196    
;;;197    void USBD_Reset(void)
000000  f04f21e0          MOV      r1,#0xe000e000
000004  f44f1080          MOV      r0,#0x100000
000008  2300              MOVS     r3,#0
00000a  f8c10180          STR      r0,[r1,#0x180]
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
;;;198    {
;;;199        NVIC_DisableIRQ(USB_LP_CAN1_RX0_IRQn);
;;;200    
;;;201        /* Double Buffering is not yet supported                                    */
;;;202        ISTR = 0;                             /* Clear Interrupt Status             */
000016  481e              LDR      r0,|L16.144|
000018  6003              STR      r3,[r0,#0]
;;;203        CNTR = CNTR_CTRM | CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM |
00001a  481e              LDR      r0,|L16.148|
00001c  6800              LDR      r0,[r0,#0]  ; USBD_P_Error_Event
00001e  b118              CBZ      r0,|L16.40|
;;;204    #ifdef __RTX
;;;205               ((USBD_RTX_DevTask   != 0) ? CNTR_ERRM    : 0) |
;;;206               ((USBD_RTX_DevTask   != 0) ? CNTR_PMAOVRM : 0) |
;;;207               ((USBD_RTX_DevTask   != 0) ? CNTR_SOFM    : 0) |
;;;208               ((USBD_RTX_DevTask   != 0) ? CNTR_ESOFM   : 0);
;;;209    #else
;;;210               ((USBD_P_Error_Event != 0) ? CNTR_ERRM    : 0) |
000020  f44f5000          MOV      r0,#0x2000
;;;211               ((USBD_P_Error_Event != 0) ? CNTR_PMAOVRM : 0) |
000024  0041              LSLS     r1,r0,#1
000026  e001              B        |L16.44|
                  |L16.40|
000028  2000              MOVS     r0,#0                 ;210
00002a  4601              MOV      r1,r0
                  |L16.44|
00002c  4308              ORRS     r0,r0,r1
00002e  491a              LDR      r1,|L16.152|
000030  6809              LDR      r1,[r1,#0]  ; USBD_P_SOF_Event
000032  2900              CMP      r1,#0
000034  d001              BEQ      |L16.58|
;;;212               ((USBD_P_SOF_Event   != 0) ? CNTR_SOFM    : 0) |
000036  f44f7100          MOV      r1,#0x200
                  |L16.58|
00003a  ea400001          ORR      r0,r0,r1
00003e  d002              BEQ      |L16.70|
;;;213               ((USBD_P_SOF_Event   != 0) ? CNTR_ESOFM   : 0);
000040  f44f7180          MOV      r1,#0x100
000044  e001              B        |L16.74|
                  |L16.70|
000046  f04f0100          MOV      r1,#0
                  |L16.74|
00004a  ea400001          ORR      r0,r0,r1
00004e  4913              LDR      r1,|L16.156|
000050  f440401c          ORR      r0,r0,#0x9c00
000054  6008              STR      r0,[r1,#0]
;;;214    #endif
;;;215        FreeBufAddr = EP_BUF_ADDR;
;;;216        BTABLE = 0x00;                        /* set BTABLE Address                 */
000056  4813              LDR      r0,|L16.164|
000058  4911              LDR      r1,|L16.160|
00005a  f04f0250          MOV      r2,#0x50              ;215
00005e  6003              STR      r3,[r0,#0]
;;;217        /* Setup Control Endpoint 0 */
;;;218        pBUF_DSCR->ADDR_TX = FreeBufAddr;
000060  6848              LDR      r0,[r1,#4]  ; pBUF_DSCR
;;;219        FreeBufAddr += USBD_MAX_PACKET0;
000062  6002              STR      r2,[r0,#0]
000064  f04f0290          MOV      r2,#0x90
;;;220        pBUF_DSCR->ADDR_RX = FreeBufAddr;
;;;221        FreeBufAddr += USBD_MAX_PACKET0;
000068  6082              STR      r2,[r0,#8]
00006a  f04f02d0          MOV      r2,#0xd0
00006e  800a              STRH     r2,[r1,#0]
;;;222    
;;;223        if (USBD_MAX_PACKET0 > 62) {
;;;224            pBUF_DSCR->COUNT_RX = ((USBD_MAX_PACKET0 << 5) - 1) | 0x8000;
000070  f24871ff          MOV      r1,#0x87ff
;;;225        } else {
;;;226            pBUF_DSCR->COUNT_RX =   USBD_MAX_PACKET0 << 9;
;;;227        }
;;;228    
;;;229        EPxREG(0) = EP_CONTROL | EP_RX_VALID;
000074  60c1              STR      r1,[r0,#0xc]
000076  490c              LDR      r1,|L16.168|
000078  f44f5048          MOV      r0,#0x3200
00007c  6008              STR      r0,[r1,#0]
;;;230        DADDR = DADDR_EF | 0;                 /* Enable USB Default Address         */
00007e  490b              LDR      r1,|L16.172|
000080  f04f0080          MOV      r0,#0x80
000084  6008              STR      r0,[r1,#0]
;;;231    
;;;232        NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
000086  f04f0014          MOV      r0,#0x14
00008a  f7ffbffe          B.W      __NVIC_EnableIRQ
;;;233    }
;;;234    
                          ENDP

00008e  0000              DCW      0x0000
                  |L16.144|
                          DCD      0x40005c44
                  |L16.148|
                          DCD      USBD_P_Error_Event
                  |L16.152|
                          DCD      USBD_P_SOF_Event
                  |L16.156|
                          DCD      0x40005c40
                  |L16.160|
                          DCD      ||.data||
                  |L16.164|
                          DCD      0x40005c50
                  |L16.168|
                          DCD      0x40005c00
                  |L16.172|
                          DCD      0x40005c4c

                          AREA ||i.USBD_ResetEP||, CODE, READONLY, ALIGN=1

                  USBD_ResetEP PROC
;;;422    
;;;423    void USBD_ResetEP(U32 EPNum)
000000  f7ffbffe          B.W      EP_Reset
;;;424    {
;;;425        EP_Reset(EPNum);
;;;426    }
;;;427    
                          ENDP


                          AREA ||i.USBD_Resume||, CODE, READONLY, ALIGN=1

                  USBD_Resume PROC
;;;254    
;;;255    void USBD_Resume(void)
000000  4770              BX       lr
;;;256    {
;;;257        /* Performed by Hardware                                                    */
;;;258    }
;;;259    
                          ENDP


                          AREA ||i.USBD_SetAddress||, CODE, READONLY, ALIGN=2

                  USBD_SetAddress PROC
;;;291    
;;;292    void USBD_SetAddress(U32 adr, U32 setup)
000000  2900              CMP      r1,#0
;;;293    {
000002  d103              BNE      |L19.12|
;;;294        if (setup) {
;;;295            return;
;;;296        }
;;;297    
;;;298        DADDR = DADDR_EF | adr;
000004  4902              LDR      r1,|L19.16|
000006  f0400080          ORR      r0,r0,#0x80
00000a  6008              STR      r0,[r1,#0]
                  |L19.12|
;;;299    }
00000c  4770              BX       lr
;;;300    
                          ENDP

00000e  0000              DCW      0x0000
                  |L19.16|
                          DCD      0x40005c4c

                          AREA ||i.USBD_SetStallEP||, CODE, READONLY, ALIGN=1

                  USBD_SetStallEP PROC
;;;436    
;;;437    void USBD_SetStallEP(U32 EPNum)
000000  f2410110          MOV      r1,#0x1010
;;;438    {
;;;439        EP_Status(EPNum, EP_TX_STALL | EP_RX_STALL);
000004  f7ffbffe          B.W      EP_Status
;;;440    }
;;;441    
                          ENDP


                          AREA ||i.USBD_Suspend||, CODE, READONLY, ALIGN=2

                  USBD_Suspend PROC
;;;241    
;;;242    void USBD_Suspend(void)
000000  4804              LDR      r0,|L21.20|
;;;243    {
;;;244        CNTR |= CNTR_FSUSP;                   /* Force Suspend                      */
000002  6801              LDR      r1,[r0,#0]
000004  f0410108          ORR      r1,r1,#8
000008  6001              STR      r1,[r0,#0]
;;;245        CNTR |= CNTR_LPMODE;                  /* Low Power Mode                     */
00000a  6801              LDR      r1,[r0,#0]
00000c  f0410104          ORR      r1,r1,#4
000010  6001              STR      r1,[r0,#0]
;;;246    }
000012  4770              BX       lr
;;;247    
                          ENDP

                  |L21.20|
                          DCD      0x40005c40

                          AREA ||i.USBD_WakeUp||, CODE, READONLY, ALIGN=2

                  USBD_WakeUp PROC
;;;266    
;;;267    void USBD_WakeUp(void)
000000  4802              LDR      r0,|L22.12|
;;;268    {
;;;269        CNTR &= ~CNTR_FSUSP;                  /* Clear Suspend                      */
000002  6801              LDR      r1,[r0,#0]
000004  f0210108          BIC      r1,r1,#8
000008  6001              STR      r1,[r0,#0]
;;;270    }
00000a  4770              BX       lr
;;;271    
                          ENDP

                  |L22.12|
                          DCD      0x40005c40

                          AREA ||i.USBD_WakeUpCfg||, CODE, READONLY, ALIGN=1

                  USBD_WakeUpCfg PROC
;;;278    
;;;279    void USBD_WakeUpCfg(BOOL cfg)
000000  4770              BX       lr
;;;280    {
;;;281        /* Not needed                                                               */
;;;282    }
;;;283    
                          ENDP


                          AREA ||i.USBD_WriteEP||, CODE, READONLY, ALIGN=2

                  USBD_WriteEP PROC
;;;511    
;;;512    U32 USBD_WriteEP(U32 EPNum, U8 *pData, U32 cnt)
000000  b5f0              PUSH     {r4-r7,lr}
;;;513    {
;;;514        /* Double Buffering is not yet supported                                    */
;;;515        U32 num, *pv, n;
;;;516        U16 statusEP;
;;;517        num = EPNum & 0x0F;
;;;518        pv  = (U32 *)(USB_PMA_ADDR + 2 * ((pBUF_DSCR + num)->ADDR_TX));
000002  4f17              LDR      r7,|L24.96|
000004  4615              MOV      r5,r2                 ;513
000006  4606              MOV      r6,r0                 ;513
000008  687a              LDR      r2,[r7,#4]  ; pBUF_DSCR
00000a  f000000f          AND      r0,r0,#0xf            ;517
00000e  eb021200          ADD      r2,r2,r0,LSL #4
000012  4b14              LDR      r3,|L24.100|
000014  6812              LDR      r2,[r2,#0]
000016  eb030442          ADD      r4,r3,r2,LSL #1
;;;519    
;;;520        for (n = 0; n < (cnt + 1) / 2; n++) {
00001a  2300              MOVS     r3,#0
00001c  1c6a              ADDS     r2,r5,#1
00001e  e008              B        |L24.50|
                  |L24.32|
;;;521            *pv++ = *((__packed U16 *)pData);
000020  f891c001          LDRB     r12,[r1,#1]
000024  f811eb02          LDRB     lr,[r1],#2
000028  1c5b              ADDS     r3,r3,#1
00002a  ea4e2c0c          ORR      r12,lr,r12,LSL #8
00002e  f844cb04          STR      r12,[r4],#4
                  |L24.50|
000032  ebb30f52          CMP      r3,r2,LSR #1          ;520
000036  d3f3              BCC      |L24.32|
;;;522            pData += 2;
;;;523        }
;;;524    
;;;525        (pBUF_DSCR + num)->COUNT_TX = cnt;
000038  6879              LDR      r1,[r7,#4]  ; pBUF_DSCR
00003a  eb011100          ADD      r1,r1,r0,LSL #4
;;;526        statusEP = EPxREG(num);
00003e  604d              STR      r5,[r1,#4]
000040  4909              LDR      r1,|L24.104|
000042  eb010080          ADD      r0,r1,r0,LSL #2
000046  f8d00c00          LDR      r0,[r0,#0xc00]
;;;527    
;;;528        if ((statusEP & EP_STAT_TX) != EP_TX_STALL) {
00004a  f3c01001          UBFX     r0,r0,#4,#2
00004e  2801              CMP      r0,#1
000050  d003              BEQ      |L24.90|
;;;529            EP_Status(EPNum, EP_TX_VALID);      /* do not make EP valid if stalled    */
000052  2130              MOVS     r1,#0x30
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       EP_Status
                  |L24.90|
;;;530        }
;;;531    
;;;532        return (cnt);
00005a  4628              MOV      r0,r5
;;;533    }
00005c  bdf0              POP      {r4-r7,pc}
;;;534    
                          ENDP

00005e  0000              DCW      0x0000
                  |L24.96|
                          DCD      ||.data||
                  |L24.100|
                          DCD      0x40006000
                  |L24.104|
                          DCD      0x40005000

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;567    
;;;568    void USB_LP_CAN1_RX0_IRQHandler(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;569    {
;;;570        uint32_t istr;
;;;571        uint32_t num;
;;;572        uint32_t val;
;;;573    
;;;574        istr = ISTR;
000004  4a24              LDR      r2,|L25.152|
000006  6810              LDR      r0,[r2,#0]
;;;575        // Zero out endpoint ID since this is read from the queue
;;;576        LastIstr |= istr & ~(ISTR_DIR | ISTR_EP_ID);
000008  4f24              LDR      r7,|L25.156|
00000a  f020011f          BIC      r1,r0,#0x1f
00000e  693b              LDR      r3,[r7,#0x10]  ; LastIstr
000010  4319              ORRS     r1,r1,r3
;;;577        // Clear interrupts that are pending
;;;578        ISTR = ~(istr & USB_ISTR_W0C_MASK);
000012  6139              STR      r1,[r7,#0x10]  ; LastIstr
000014  f40041fe          AND      r1,r0,#0x7f00
000018  43c9              MVNS     r1,r1
00001a  6011              STR      r1,[r2,#0]
;;;579        if (istr & ISTR_CTR) {
;;;580            while ((istr = ISTR) & ISTR_CTR) {
;;;581                num = istr & ISTR_EP_ID;
;;;582                val = EPxREG(num);
00001c  f8df9080          LDR      r9,|L25.160|
000020  0400              LSLS     r0,r0,#16             ;579
;;;583    
;;;584                // Process and filter out the zero length status out endpoint to prevent
;;;585                // the next SETUP packet from being dropped.
;;;586                if ((0 == num) && (val & EP_CTR_RX) && !(val & EP_SETUP)
;;;587                        && (0 == ((pBUF_DSCR + num)->COUNT_RX & EP_COUNT_MASK))) {
;;;588                    if (val & EP_CTR_TX) {
;;;589                        // Drop the RX event but not TX
;;;590                        stat_enque((((val & VAL_MASK) & ~EP_CTR_RX) << VAL_SHIFT) | 
;;;591                                   ((num & EP_NUM_MASK) << EP_NUM_SHIFT));
;;;592                    } else {
;;;593                        // Drop the event
;;;594                    }
;;;595                } else {
;;;596                    stat_enque(((val & VAL_MASK) << VAL_SHIFT) | 
;;;597                               ((num & EP_NUM_MASK) << EP_NUM_SHIFT));
;;;598                }
;;;599    
;;;600    
;;;601                if (val & EP_CTR_RX) {
;;;602                    EPxREG(num) = EP_VAL_UNCHANGED(val) & ~EP_CTR_RX;
000022  f2480680          MOV      r6,#0x8080
000026  d532              BPL      |L25.142|
000028  4690              MOV      r8,r2                 ;574
                  |L25.42|
00002a  f8d80000          LDR      r0,[r8,#0]            ;580
00002e  0401              LSLS     r1,r0,#16             ;580
000030  d52d              BPL      |L25.142|
000032  f010000f          ANDS     r0,r0,#0xf            ;581
000036  eb090580          ADD      r5,r9,r0,LSL #2       ;582
00003a  f8d54c00          LDR      r4,[r5,#0xc00]        ;582
00003e  d107              BNE      |L25.80|
000040  0421              LSLS     r1,r4,#16             ;586
000042  d505              BPL      |L25.80|
000044  0521              LSLS     r1,r4,#20             ;586
000046  d403              BMI      |L25.80|
000048  6879              LDR      r1,[r7,#4]            ;587  ; pBUF_DSCR
00004a  8989              LDRH     r1,[r1,#0xc]          ;587
00004c  0589              LSLS     r1,r1,#22             ;587
00004e  d015              BEQ      |L25.124|
                  |L25.80|
000050  f364401f          BFI      r0,r4,#16,#16         ;596
000054  f7fffffe          BL       stat_enque
000058  0420              LSLS     r0,r4,#16             ;601
00005a  d506              BPL      |L25.106|
                  |L25.92|
00005c  ea440006          ORR      r0,r4,r6
000060  f640718f          MOV      r1,#0xf8f
000064  4008              ANDS     r0,r0,r1
000066  f8c50c00          STR      r0,[r5,#0xc00]
                  |L25.106|
;;;603                }
;;;604    
;;;605                if (val & EP_CTR_TX) {
00006a  0620              LSLS     r0,r4,#24
00006c  d5dd              BPL      |L25.42|
;;;606                    EPxREG(num) = EP_VAL_UNCHANGED(val) & ~EP_CTR_TX;
00006e  4334              ORRS     r4,r4,r6
000070  f648700f          MOV      r0,#0x8f0f
000074  4004              ANDS     r4,r4,r0
000076  f8c54c00          STR      r4,[r5,#0xc00]
00007a  e7d6              B        |L25.42|
                  |L25.124|
00007c  0621              LSLS     r1,r4,#24             ;588
00007e  d5ed              BPL      |L25.92|
000080  f3c4010e          UBFX     r1,r4,#0,#15          ;590
000084  f361401f          BFI      r0,r1,#16,#16         ;590
000088  f7fffffe          BL       stat_enque
00008c  e7e6              B        |L25.92|
                  |L25.142|
;;;607                }
;;;608            }
;;;609        }
;;;610        
;;;611        USBD_SignalHandler();
00008e  e8bd47f0          POP      {r4-r10,lr}
000092  f7ffbffe          B.W      USBD_SignalHandler
;;;612    }
;;;613    
                          ENDP

000096  0000              DCW      0x0000
                  |L25.152|
                          DCD      0x40005c44
                  |L25.156|
                          DCD      ||.data||
                  |L25.160|
                          DCD      0x40005000

                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1502    */
;;;1503   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1504   {
000002  db09              BLT      |L26.24|
;;;1505     if ((int32_t)(IRQn) >= 0)
;;;1506     {
;;;1507       __COMPILER_BARRIER();
;;;1508       NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L26.24|
;;;1509       __COMPILER_BARRIER();
;;;1510     }
;;;1511   }
000018  4770              BX       lr
;;;1512   
                          ENDP


                          AREA ||i.stat_enque||, CODE, READONLY, ALIGN=2

                  stat_enque PROC
;;;58     
;;;59     inline static void stat_enque(uint32_t stat)
000000  b510              PUSH     {r4,lr}
000002  f3ef8110          MRS      r1,PRIMASK
000006  f0110f01          TST      r1,#1
00000a  b672              CPSID    i
;;;60     {
;;;61         cortex_int_state_t state;
;;;62         state = cortex_int_get_and_disable();
;;;63         StatQueue[StatQueueTail] = stat;
00000c  4c08              LDR      r4,|L27.48|
00000e  4b09              LDR      r3,|L27.52|
000010  68d9              LDR      r1,[r3,#0xc]  ; StatQueueTail
000012  f8440021          STR      r0,[r4,r1,LSL #2]
;;;64         StatQueueTail = (StatQueueTail + 1) % (sizeof(StatQueue) / sizeof(StatQueue[0]));
000016  f04f000b          MOV      r0,#0xb
00001a  f1010101          ADD      r1,r1,#1
00001e  fbb1f4f0          UDIV     r4,r1,r0
000022  fb001014          MLS      r0,r0,r4,r1
000026  60d8              STR      r0,[r3,#0xc]          ;60  ; StatQueueTail
000028  d100              BNE      |L27.44|
00002a  b662              CPSIE    i                     ;60
                  |L27.44|
;;;65         cortex_int_restore(state);
;;;66     }
00002c  bd10              POP      {r4,pc}
;;;67     
                          ENDP

00002e  0000              DCW      0x0000
                  |L27.48|
                          DCD      ||.bss||
                  |L27.52|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  StatQueue
                          %        44

                          AREA ||.data||, DATA, ALIGN=2

                  FreeBufAddr
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  pBUF_DSCR
                          DCD      0x40006000
                  StatQueueHead
                          DCD      0x00000000
                  StatQueueTail
                          DCD      0x00000000
                  LastIstr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\usbd_STM32F103.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_usbd_STM32F103_c_4b00160d____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___16_usbd_STM32F103_c_4b00160d____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_usbd_STM32F103_c_4b00160d____REVSH|
#line 495
|__asm___16_usbd_STM32F103_c_4b00160d____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_usbd_STM32F103_c_4b00160d____RRX|
#line 682
|__asm___16_usbd_STM32F103_c_4b00160d____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
