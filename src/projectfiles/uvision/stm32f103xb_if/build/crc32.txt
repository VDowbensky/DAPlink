; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\crc32.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\crc32.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\crc32.crf ..\..\..\source\daplink\crc32.c]
                          THUMB

                          AREA ||i.crc32||, CODE, READONLY, ALIGN=2

                  crc32 PROC
;;;108    uint32_t
;;;109    crc32(const void *data, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    {
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
;;;111        crc            remainder = INITIAL_REMAINDER;
000008  f04f34ff          MOV      r4,#0xffffffff
;;;112        int            byte;
;;;113        unsigned char  bit;
;;;114        unsigned char const *message = data;
;;;115    
;;;116        /*
;;;117         * Perform modulo-2 division, a byte at a time.
;;;118         */
;;;119        for (byte = 0; byte < nBytes; ++byte) {
00000c  2500              MOVS     r5,#0
;;;120            /*
;;;121             * Bring the next byte into the remainder.
;;;122             */
;;;123            remainder ^= (REFLECT_DATA(message[byte]) << (WIDTH - 8));
;;;124    
;;;125            /*
;;;126             * Perform modulo-2 division, a bit at a time.
;;;127             */
;;;128            for (bit = 8; bit > 0; --bit) {
;;;129                /*
;;;130                 * Try to divide the current data bit.
;;;131                 */
;;;132                if (remainder & TOPBIT) {
;;;133                    remainder = (remainder << 1) ^ POLYNOMIAL;
00000e  f8df803c          LDR      r8,|L1.76|
000012  e012              B        |L1.58|
                  |L1.20|
000014  5d70              LDRB     r0,[r6,r5]            ;123
000016  2108              MOVS     r1,#8                 ;123
000018  f7fffffe          BL       reflect
00001c  ea846400          EOR      r4,r4,r0,LSL #24      ;123
000020  2008              MOVS     r0,#8                 ;128
000022  4641              MOV      r1,r8
                  |L1.36|
000024  2c00              CMP      r4,#0                 ;132
000026  da02              BGE      |L1.46|
000028  ea810444          EOR      r4,r1,r4,LSL #1
00002c  e000              B        |L1.48|
                  |L1.46|
;;;134                } else {
;;;135                    remainder = (remainder << 1);
00002e  0064              LSLS     r4,r4,#1
                  |L1.48|
000030  1e40              SUBS     r0,r0,#1
000032  f01000ff          ANDS     r0,r0,#0xff           ;128
000036  d1f5              BNE      |L1.36|
000038  1c6d              ADDS     r5,r5,#1              ;128
                  |L1.58|
00003a  42bd              CMP      r5,r7                 ;119
00003c  dbea              BLT      |L1.20|
;;;136                }
;;;137            }
;;;138        }
;;;139    
;;;140        /*
;;;141         * The final remainder is the CRC result.
;;;142         */
;;;143        return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
00003e  2120              MOVS     r1,#0x20
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       reflect
000046  43c0              MVNS     r0,r0
;;;144    }   /* crc32() */
000048  e8bd81f0          POP      {r4-r8,pc}
;;;145    
                          ENDP

                  |L1.76|
                          DCD      0x04c11db7

                          AREA ||i.crc32_continue||, CODE, READONLY, ALIGN=2

                  crc32_continue PROC
;;;157    uint32_t
;;;158    crc32_continue(uint32_t prev_crc, const void *data, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;159    {
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;160        crc            remainder = REFLECT_REMAINDER(prev_crc ^ FINAL_XOR_VALUE);
000008  2120              MOVS     r1,#0x20
00000a  43c0              MVNS     r0,r0
00000c  f7fffffe          BL       reflect
000010  4604              MOV      r4,r0
;;;161        int            byte;
;;;162        unsigned char  bit;
;;;163        unsigned char const *message = data;
;;;164    
;;;165        /*
;;;166         * Perform modulo-2 division, a byte at a time.
;;;167         */
;;;168        for (byte = 0; byte < nBytes; ++byte) {
000012  2500              MOVS     r5,#0
;;;169            /*
;;;170             * Bring the next byte into the remainder.
;;;171             */
;;;172            remainder ^= (REFLECT_DATA(message[byte]) << (WIDTH - 8));
;;;173    
;;;174            /*
;;;175             * Perform modulo-2 division, a bit at a time.
;;;176             */
;;;177            for (bit = 8; bit > 0; --bit) {
;;;178                /*
;;;179                 * Try to divide the current data bit.
;;;180                 */
;;;181                if (remainder & TOPBIT) {
;;;182                    remainder = (remainder << 1) ^ POLYNOMIAL;
000014  f8df803c          LDR      r8,|L2.84|
000018  e012              B        |L2.64|
                  |L2.26|
00001a  5d70              LDRB     r0,[r6,r5]            ;172
00001c  2108              MOVS     r1,#8                 ;172
00001e  f7fffffe          BL       reflect
000022  ea846400          EOR      r4,r4,r0,LSL #24      ;172
000026  2008              MOVS     r0,#8                 ;177
000028  4641              MOV      r1,r8
                  |L2.42|
00002a  2c00              CMP      r4,#0                 ;181
00002c  da02              BGE      |L2.52|
00002e  ea810444          EOR      r4,r1,r4,LSL #1
000032  e000              B        |L2.54|
                  |L2.52|
;;;183                } else {
;;;184                    remainder = (remainder << 1);
000034  0064              LSLS     r4,r4,#1
                  |L2.54|
000036  1e40              SUBS     r0,r0,#1
000038  f01000ff          ANDS     r0,r0,#0xff           ;177
00003c  d1f5              BNE      |L2.42|
00003e  1c6d              ADDS     r5,r5,#1              ;177
                  |L2.64|
000040  42bd              CMP      r5,r7                 ;168
000042  dbea              BLT      |L2.26|
;;;185                }
;;;186            }
;;;187        }
;;;188    
;;;189        /*
;;;190         * The final remainder is the CRC result.
;;;191         */
;;;192        return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
000044  2120              MOVS     r1,#0x20
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       reflect
00004c  43c0              MVNS     r0,r0
;;;193    }   /* crc32_continue() */
00004e  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x04c11db7

                          AREA ||i.reflect||, CODE, READONLY, ALIGN=1

                  reflect PROC
;;;73     static unsigned long
;;;74     reflect(unsigned long data, unsigned char nBits)
000000  b570              PUSH     {r4-r6,lr}
;;;75     {
000002  4603              MOV      r3,r0
;;;76         unsigned long  reflection = 0x00000000;
000004  2000              MOVS     r0,#0
;;;77         unsigned char  bit;
;;;78     
;;;79         /*
;;;80          * Reflect the data about the center bit.
;;;81          */
;;;82         for (bit = 0; bit < nBits; ++bit) {
000006  4602              MOV      r2,r0
;;;83             /*
;;;84              * If the LSB bit is set, set the reflection of it.
;;;85              */
;;;86             if (data & 0x01) {
;;;87                 reflection |= (1 << ((nBits - 1) - bit));
000008  2601              MOVS     r6,#1
00000a  e009              B        |L3.32|
                  |L3.12|
00000c  07dc              LSLS     r4,r3,#31             ;86
00000e  d004              BEQ      |L3.26|
000010  1a8d              SUBS     r5,r1,r2
000012  1e6d              SUBS     r5,r5,#1
000014  fa06f405          LSL      r4,r6,r5
000018  4320              ORRS     r0,r0,r4
                  |L3.26|
;;;88             }
;;;89     
;;;90             data = (data >> 1);
00001a  085b              LSRS     r3,r3,#1
00001c  1c52              ADDS     r2,r2,#1
00001e  b2d2              UXTB     r2,r2                 ;82
                  |L3.32|
000020  428a              CMP      r2,r1                 ;82
000022  d3f3              BCC      |L3.12|
;;;91         }
;;;92     
;;;93         return (reflection);
;;;94     }	/* reflect() */
000024  bd70              POP      {r4-r6,pc}
;;;95     
                          ENDP

