; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\hal_cm3.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\hal_cm3.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\hal_cm3.crf ..\..\..\source\rtos\cm3\HAL_CM3.c]
                          THUMB

                          AREA ||i.dbg_init||, CODE, READONLY, ALIGN=2

                  dbg_init PROC
;;;323    
;;;324    void dbg_init (void) {
000000  4808              LDR      r0,|L1.36|
;;;325      if ((DEMCR & DEMCR_TRCENA)     &&
000002  6800              LDR      r0,[r0,#0]
000004  01c0              LSLS     r0,r0,#7
000006  d50b              BPL      |L1.32|
;;;326          (ITM_CONTROL & ITM_ITMENA) &&
000008  4807              LDR      r0,|L1.40|
00000a  6800              LDR      r0,[r0,#0]
00000c  07c0              LSLS     r0,r0,#31
00000e  d007              BEQ      |L1.32|
;;;327          (ITM_ENABLE & (1UL << 31))) {
000010  4805              LDR      r0,|L1.40|
000012  3880              SUBS     r0,r0,#0x80
000014  6800              LDR      r0,[r0,#0]
000016  2800              CMP      r0,#0
000018  da02              BGE      |L1.32|
;;;328        dbg_msg = __TRUE;
00001a  4904              LDR      r1,|L1.44|
00001c  2001              MOVS     r0,#1
00001e  7008              STRB     r0,[r1,#0]
                  |L1.32|
;;;329      }
;;;330    }
000020  4770              BX       lr
;;;331    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0xe000edfc
                  |L1.40|
                          DCD      0xe0000e80
                  |L1.44|
                          DCD      ||.data||

                          AREA ||i.dbg_task_notify||, CODE, READONLY, ALIGN=1

                  dbg_task_notify PROC
;;;334    
;;;335    void dbg_task_notify (P_TCB p_tcb, BOOL create) {
000000  f04f4260          MOV      r2,#0xe0000000
                  |L2.4|
;;;336      while (ITM_PORT31_U32 == 0);
000004  6fd3              LDR      r3,[r2,#0x7c]
000006  2b00              CMP      r3,#0
000008  d0fc              BEQ      |L2.4|
;;;337      ITM_PORT31_U32 = (U32)p_tcb->ptask;
00000a  6ac3              LDR      r3,[r0,#0x2c]
00000c  67d3              STR      r3,[r2,#0x7c]
                  |L2.14|
;;;338      while (ITM_PORT31_U32 == 0);
00000e  6fd3              LDR      r3,[r2,#0x7c]
000010  2b00              CMP      r3,#0
000012  d0fc              BEQ      |L2.14|
;;;339      ITM_PORT31_U16 = (create << 8) | p_tcb->task_id;
000014  78c0              LDRB     r0,[r0,#3]
000016  ea402001          ORR      r0,r0,r1,LSL #8
00001a  f8a2007c          STRH     r0,[r2,#0x7c]
;;;340    }
00001e  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.dbg_task_switch||, CODE, READONLY, ALIGN=1

                  dbg_task_switch PROC
;;;344    
;;;345    void dbg_task_switch (U32 task_id) {
000000  f04f4160          MOV      r1,#0xe0000000
                  |L3.4|
;;;346      while (ITM_PORT31_U32 == 0);
000004  6fca              LDR      r2,[r1,#0x7c]
000006  2a00              CMP      r2,#0
000008  d0fc              BEQ      |L3.4|
;;;347      ITM_PORT31_U8 = task_id;
00000a  f881007c          STRB     r0,[r1,#0x7c]
;;;348    }
00000e  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.rt_init_stack||, CODE, READONLY, ALIGN=2

                  rt_init_stack PROC
;;;278    
;;;279    void rt_init_stack (P_TCB p_TCB, FUNCP task_body) {
000000  b510              PUSH     {r4,lr}
;;;280      /* Prepare TCB and saved context for a first time start of a task. */
;;;281      U32 *stk,i,size;
;;;282    
;;;283      /* Prepare a complete interrupt frame for first task start */
;;;284      size = p_TCB->priv_stack >> 2;
000002  8c42              LDRH     r2,[r0,#0x22]
000004  0892              LSRS     r2,r2,#2
000006  d103              BNE      |L4.16|
;;;285      if (size == 0) {
;;;286        size = (U16)os_stackinfo >> 2;
000008  4a0e              LDR      r2,|L4.68|
00000a  8812              LDRH     r2,[r2,#0]  ; os_stackinfo
00000c  f3c2028d          UBFX     r2,r2,#2,#14
                  |L4.16|
;;;287      }
;;;288    
;;;289      /* Write to the top of stack. */
;;;290      stk = &p_TCB->stack[size];
000010  6a83              LDR      r3,[r0,#0x28]
000012  eb030382          ADD      r3,r3,r2,LSL #2
;;;291    
;;;292      /* Auto correct to 8-byte ARM stack alignment. */
;;;293      if ((U32)stk & 0x04) {
000016  075a              LSLS     r2,r3,#29
000018  d500              BPL      |L4.28|
00001a  1f1b              SUBS     r3,r3,#4
                  |L4.28|
;;;294        stk--;
;;;295      }
;;;296    
;;;297      stk -= 16;
;;;298    
;;;299      /* Default xPSR and initial PC */
;;;300      stk[15] = INITIAL_xPSR;
00001c  f04f7280          MOV      r2,#0x1000000
000020  e9431202          STRD     r1,r2,[r3,#-8]
;;;301      stk[14] = (U32)task_body;
;;;302    
;;;303      /* Clear R1-R12,LR registers. */
;;;304      for (i = 0; i < 14; i++) {
000024  2200              MOVS     r2,#0
000026  4614              MOV      r4,r2
000028  3b40              SUBS     r3,r3,#0x40
                  |L4.42|
;;;305        stk[i] = 0;
00002a  f8434022          STR      r4,[r3,r2,LSL #2]
00002e  1c52              ADDS     r2,r2,#1
000030  2a0e              CMP      r2,#0xe               ;304
000032  d3fa              BCC      |L4.42|
;;;306      }
;;;307    
;;;308      /* Assign a void pointer to R0. */
;;;309      stk[8] = (U32)p_TCB->msg;
000034  69c2              LDR      r2,[r0,#0x1c]
;;;310    
;;;311      /* Initial Task stack pointer. */
;;;312      p_TCB->tsk_stack = (U32)stk;
000036  621a              STR      r2,[r3,#0x20]
;;;313    
;;;314      /* Task entry point. */
;;;315      p_TCB->ptask = task_body;
;;;316    
;;;317      /* Set a magic word for checking of stack overflow. */
;;;318      p_TCB->stack[0] = MAGIC_WORD;
000038  6243              STR      r3,[r0,#0x24]
00003a  62c1              STR      r1,[r0,#0x2c]
00003c  6a80              LDR      r0,[r0,#0x28]
00003e  4902              LDR      r1,|L4.72|
000040  6001              STR      r1,[r0,#0]
;;;319    }
000042  bd10              POP      {r4,pc}
;;;320    
                          ENDP

                  |L4.68|
                          DCD      os_stackinfo
                  |L4.72|
                          DCD      0xe25a2ea5

                          AREA ||.data||, DATA, ALIGN=0

                  dbg_msg
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\rtos\\cm3\\HAL_CM3.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |rt_set_PSP|
#line 44
|rt_set_PSP| PROC
#line 44

 MSR PSP,R0
 BX LR
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |rt_get_PSP|
#line 52
|rt_get_PSP| PROC
#line 52

 MRS R0,PSP
 BX LR
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |os_set_env|
	IMPORT |os_flags|
#line 60
|os_set_env| PROC
#line 60

 
 MOV R0,SP 
 MSR PSP,R0
 LDR R0,= |os_flags|
 LDRB R0,[R0]
 LSLS R0,#31
 MOVNE R0,#0x02 
 MOVEQ R0,#0x03 
 MSR CONTROL,R0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |_alloc_box|
	IMPORT |rt_alloc_box|
#line 78
|_alloc_box| PROC
#line 78

 
 LDR R12,= |rt_alloc_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |_free_box|
	IMPORT |rt_free_box|
#line 96
|_free_box| PROC
#line 96

 
 LDR R12,= |rt_free_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
	IMPORT |os_tsk|
#line 114
|SVC_Handler| PROC
#line 114

 PRESERVE8

#line 120


 IMPORT SVC_Count
 IMPORT SVC_Table
 IMPORT rt_stk_check

 MRS R0,PSP 
 LDR R1,[R0,#24] 
 LDRB R1,[R1,#-2] 
 CBNZ R1,SVC_User

 LDM R0,{R0-R3,R12} 
 BLX R12 

 MRS R12,PSP 
 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
 BEQ SVC_Exit 

 CBZ R1,SVC_Restore 

 PUSH {R2,R3}
 MOV R3,#1
 STRB R3,[R1,#33] 
 STMDB R12!,{R4-R11} 
 STR R12,[R1,#36] 
 BL rt_stk_check 
 POP {R2,R3}

SVC_Restore
 STR R2,[R3] 

 LDR R12,[R2,#36] 
 LDMIA R12!,{R4-R11} 
 LDRB R3,[R2,#33] 
 MSR PSP,R12 

 CBZ R3,SVC_Return
 LDRB R0,[R2,#32] 

SVC_Exit
 STR R0,[R12] 

SVC_Return
 MVN LR,#:NOT:0xFFFFFFFD 
#line 169

 BX LR


 

SVC_User
 PUSH {R4,LR} 
 LDR R2,=SVC_Count
 LDR R2,[R2]
 CMP R1,R2
 BHI SVC_Done 

 LDR R4,=SVC_Table-4
 LDR R4,[R4,R1,LSL #2] 

 LDM R0,{R0-R3,R12} 
 BLX R4 

 MRS R12,PSP
 STM R12,{R0-R3} 
SVC_Done
 POP {R4,PC} 

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
	IMPORT |rt_pop_req|
#line 199
|PendSV_Handler| PROC
#line 199

 PRESERVE8

#line 205


 BL  |rt_pop_req|

Sys_Switch
 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
 BEQ Sys_Exit

 PUSH {R2,R3}
 MOV R3,#0
 STRB R3,[R1,#33] 
 MRS R12,PSP 
 STMDB R12!,{R4-R11} 
 STR R12,[R1,#36] 
 BL rt_stk_check 

 POP {R2,R3}
 STR R2,[R3] 

 LDR R12,[R2,#36] 
 LDMIA R12!,{R4-R11} 
 MSR PSP,R12 

 LDRB R3,[R2,#33] 
 CBZ R3,Sys_Exit
 LDRB R3,[R2,#32] 
 STR R3,[R12]
Sys_Exit
 MVN LR,#:NOT:0xFFFFFFFD 
#line 239

 BX LR 


 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SysTick_Handler|
	IMPORT |rt_systick|
#line 249
|SysTick_Handler| PROC
#line 249

 PRESERVE8

#line 255


 BL  |rt_systick|
 B Sys_Switch

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |OS_Tick_Handler|
	IMPORT |os_tick_irqack|
#line 266
|OS_Tick_Handler| PROC
#line 266

 PRESERVE8

 BL  |os_tick_irqack|
 BL  |rt_systick|
 B Sys_Switch

 ALIGN
	ENDP

;*** End   embedded assembler ***
