; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\usbd_user_hid.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usbd_user_hid.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\usbd_user_hid.crf ..\..\..\source\usb\hid\usbd_user_hid.c]
                          THUMB

                          AREA ||i.hid_send_packet||, CODE, READONLY, ALIGN=2

                  hid_send_packet PROC
;;;43     
;;;44     void hid_send_packet()
000000  b51c              PUSH     {r2-r4,lr}
;;;45     {
;;;46         uint8_t * sbuf;
;;;47         int slen;
;;;48         if (DAP_queue_get_send_buf(&DAP_Cmd_queue, &sbuf, &slen)) {
000002  aa01              ADD      r2,sp,#4
000004  4669              MOV      r1,sp
000006  480a              LDR      r0,|L1.48|
000008  f7fffffe          BL       DAP_queue_get_send_buf
00000c  2800              CMP      r0,#0
00000e  d007              BEQ      |L1.32|
;;;49             if (slen > USBD_HID_OUTREPORT_MAX_SZ){
000010  9801              LDR      r0,[sp,#4]
000012  2840              CMP      r0,#0x40
000014  dd05              BLE      |L1.34|
;;;50                 util_assert(0);
000016  2232              MOVS     r2,#0x32
000018  a106              ADR      r1,|L1.52|
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       _util_assert
                  |L1.32|
;;;51             }else {
;;;52                 usbd_hid_get_report_trigger(0, sbuf, USBD_HID_OUTREPORT_MAX_SZ);
;;;53             }
;;;54         }
;;;55     }
000020  bd1c              POP      {r2-r4,pc}
                  |L1.34|
000022  2240              MOVS     r2,#0x40              ;52
000024  2000              MOVS     r0,#0                 ;52
000026  9900              LDR      r1,[sp,#0]            ;52
000028  f7fffffe          BL       usbd_hid_get_report_trigger
00002c  bd1c              POP      {r2-r4,pc}
;;;56     
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      ||.bss||
                  |L1.52|
000034  2e2e5c2e          DCB      "..\\..\\..\\source\\usb\\hid\\usbd_user_hid.c",0
000038  2e5c2e2e
00003c  5c736f75
000040  7263655c
000044  7573625c
000048  6869645c
00004c  75736264
000050  5f757365
000054  725f6869
000058  642e6300

                          AREA ||i.usbd_hid_get_report||, CODE, READONLY, ALIGN=2

                  usbd_hid_get_report PROC
;;;64     // USB HID Callback: when data needs to be prepared for the host
;;;65     int usbd_hid_get_report(U8 rtype, U8 rid, U8 *buf, U8 req)
000000  b57c              PUSH     {r2-r6,lr}
;;;66     {
000002  461c              MOV      r4,r3
000004  4615              MOV      r5,r2
;;;67         uint8_t * sbuf;
;;;68         int slen;
;;;69         switch (rtype) {
000006  2801              CMP      r0,#1
000008  d11c              BNE      |L2.68|
;;;70             case HID_REPORT_INPUT:
;;;71                 switch (req) {
00000a  b10c              CBZ      r4,|L2.16|
00000c  2c01              CMP      r4,#1
00000e  d119              BNE      |L2.68|
                  |L2.16|
;;;72                     case USBD_HID_REQ_PERIOD_UPDATE:
;;;73                         break;
;;;74     
;;;75                     case USBD_HID_REQ_EP_CTRL:
;;;76                     case USBD_HID_REQ_EP_INT:
;;;77                         if (DAP_queue_get_send_buf(&DAP_Cmd_queue, &sbuf, &slen)) {
000010  aa01              ADD      r2,sp,#4
000012  4669              MOV      r1,sp
000014  480c              LDR      r0,|L2.72|
000016  f7fffffe          BL       DAP_queue_get_send_buf
00001a  b170              CBZ      r0,|L2.58|
;;;78                             if (slen > USBD_HID_OUTREPORT_MAX_SZ){
00001c  9a01              LDR      r2,[sp,#4]
00001e  2a40              CMP      r2,#0x40
000020  dd05              BLE      |L2.46|
;;;79                                 util_assert(0);
000022  224f              MOVS     r2,#0x4f
000024  a109              ADR      r1,|L2.76|
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       _util_assert
00002c  e00a              B        |L2.68|
                  |L2.46|
;;;80                             }else {
;;;81                                 memcpy(buf, sbuf, slen);
00002e  4628              MOV      r0,r5
000030  9900              LDR      r1,[sp,#0]
000032  f7fffffe          BL       __aeabi_memcpy
;;;82                                 return (USBD_HID_OUTREPORT_MAX_SZ);
000036  2040              MOVS     r0,#0x40
;;;83                             }
;;;84                         } else if (req == USBD_HID_REQ_EP_INT) {
;;;85                             USB_ResponseIdle = 1;
;;;86                         }
;;;87                         break;
;;;88                 }
;;;89     
;;;90                 break;
;;;91     
;;;92             case HID_REPORT_FEATURE:
;;;93                 break;
;;;94         }
;;;95     
;;;96         return (0);
;;;97     }
000038  bd7c              POP      {r2-r6,pc}
                  |L2.58|
00003a  2c01              CMP      r4,#1                 ;84
00003c  d102              BNE      |L2.68|
00003e  490d              LDR      r1,|L2.116|
000040  2001              MOVS     r0,#1                 ;85
000042  7008              STRB     r0,[r1,#0]            ;85
                  |L2.68|
000044  2000              MOVS     r0,#0                 ;96
000046  bd7c              POP      {r2-r6,pc}
;;;98     
                          ENDP

                  |L2.72|
                          DCD      ||.bss||
                  |L2.76|
00004c  2e2e5c2e          DCB      "..\\..\\..\\source\\usb\\hid\\usbd_user_hid.c",0
000050  2e5c2e2e
000054  5c736f75
000058  7263655c
00005c  7573625c
000060  6869645c
000064  75736264
000068  5f757365
00006c  725f6869
000070  642e6300
                  |L2.116|
                          DCD      ||.data||

                          AREA ||i.usbd_hid_init||, CODE, READONLY, ALIGN=2

                  usbd_hid_init PROC
;;;57     // USB HID Callback: when system initializes
;;;58     void usbd_hid_init(void)
000000  4902              LDR      r1,|L3.12|
;;;59     {
;;;60         USB_ResponseIdle = 1;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;61         DAP_queue_init(&DAP_Cmd_queue);
000006  4802              LDR      r0,|L3.16|
000008  f7ffbffe          B.W      DAP_queue_init
;;;62     }
;;;63     
                          ENDP

                  |L3.12|
                          DCD      ||.data||
                  |L3.16|
                          DCD      ||.bss||

                          AREA ||i.usbd_hid_no_activity||, CODE, READONLY, ALIGN=1

                  usbd_hid_no_activity PROC
;;;100    __attribute__((weak))
;;;101    uint8_t usbd_hid_no_activity(U8 *buf)
000000  2000              MOVS     r0,#0
;;;102    {
;;;103        return 0;
;;;104    }
000002  4770              BX       lr
;;;105    
                          ENDP


                          AREA ||i.usbd_hid_set_report||, CODE, READONLY, ALIGN=2

                  usbd_hid_set_report PROC
;;;106    // USB HID Callback: when data is received from the host
;;;107    void usbd_hid_set_report(U8 rtype, U8 rid, U8 *buf, int len, U8 req)
000000  b538              PUSH     {r3-r5,lr}
;;;108    {
;;;109        uint8_t * rbuf;
;;;110        main_led_state_t led_next_state = MAIN_LED_FLASH;
000002  2401              MOVS     r4,#1
000004  461d              MOV      r5,r3                 ;108
000006  4611              MOV      r1,r2                 ;108
;;;111        switch (rtype) {
000008  2802              CMP      r0,#2
00000a  d113              BNE      |L5.52|
;;;112            case HID_REPORT_OUTPUT:
;;;113                if (len == 0) {
00000c  2d00              CMP      r5,#0
00000e  d011              BEQ      |L5.52|
;;;114                    break;
;;;115                }
;;;116    
;;;117                if (buf[0] == ID_DAP_TransferAbort) {
000010  7808              LDRB     r0,[r1,#0]
000012  2807              CMP      r0,#7
000014  d00b              BEQ      |L5.46|
;;;118                    DAP_TransferAbort = 1;
;;;119                    break;
;;;120                }
;;;121    
;;;122                // execute and store to DAP_queue
;;;123                if (DAP_queue_execute_buf(&DAP_Cmd_queue, buf, len, &rbuf)) {
000016  466b              MOV      r3,sp
000018  462a              MOV      r2,r5
00001a  4810              LDR      r0,|L5.92|
00001c  f7fffffe          BL       DAP_queue_execute_buf
000020  b190              CBZ      r0,|L5.72|
;;;124                    if(usbd_hid_no_activity(rbuf) == 1){
000022  9800              LDR      r0,[sp,#0]
000024  f7fffffe          BL       usbd_hid_no_activity
000028  2801              CMP      r0,#1
00002a  d004              BEQ      |L5.54|
00002c  e004              B        |L5.56|
                  |L5.46|
00002e  490c              LDR      r1,|L5.96|
000030  2001              MOVS     r0,#1                 ;118
000032  7008              STRB     r0,[r1,#0]            ;118
                  |L5.52|
;;;125                        //revert HID LED to default if the response is null
;;;126                        led_next_state = MAIN_LED_DEF;
;;;127                    }
;;;128                    if (USB_ResponseIdle) {
;;;129                        hid_send_packet();
;;;130                        USB_ResponseIdle = 0;
;;;131                    }
;;;132                } else {
;;;133                    util_assert(0);
;;;134                }
;;;135    
;;;136                main_blink_hid_led(led_next_state);
;;;137    
;;;138                break;
;;;139    
;;;140            case HID_REPORT_FEATURE:
;;;141                break;
;;;142        }
;;;143    }
000034  bd38              POP      {r3-r5,pc}
                  |L5.54|
000036  2400              MOVS     r4,#0                 ;126
                  |L5.56|
000038  4d0a              LDR      r5,|L5.100|
00003a  7828              LDRB     r0,[r5,#0]            ;128  ; USB_ResponseIdle
00003c  b148              CBZ      r0,|L5.82|
00003e  f7fffffe          BL       hid_send_packet
000042  2000              MOVS     r0,#0                 ;130
000044  7028              STRB     r0,[r5,#0]            ;130
000046  e004              B        |L5.82|
                  |L5.72|
000048  2285              MOVS     r2,#0x85              ;133
00004a  a107              ADR      r1,|L5.104|
00004c  2000              MOVS     r0,#0                 ;133
00004e  f7fffffe          BL       _util_assert
                  |L5.82|
000052  4620              MOV      r0,r4                 ;136
000054  f7fffffe          BL       main_blink_hid_led
000058  bd38              POP      {r3-r5,pc}
;;;144    
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      ||.bss||
                  |L5.96|
                          DCD      DAP_TransferAbort
                  |L5.100|
                          DCD      ||.data||
                  |L5.104|
000068  2e2e5c2e          DCB      "..\\..\\..\\source\\usb\\hid\\usbd_user_hid.c",0
00006c  2e5c2e2e
000070  5c736f75
000074  7263655c
000078  7573625c
00007c  6869645c
000080  75736264
000084  5f757365
000088  725f6869
00008c  642e6300

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DAP_Cmd_queue
                          %        280

                          AREA ||.data||, DATA, ALIGN=0

                  USB_ResponseIdle
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\usb\\hid\\usbd_user_hid.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_305a1c67____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___15_usbd_user_hid_c_305a1c67____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_305a1c67____REVSH|
#line 495
|__asm___15_usbd_user_hid_c_305a1c67____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_305a1c67____RRX|
#line 682
|__asm___15_usbd_user_hid_c_305a1c67____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
