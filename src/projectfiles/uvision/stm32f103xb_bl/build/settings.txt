; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\settings.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\settings.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\settings.crf ..\..\..\source\daplink\settings\settings.c]
                          THUMB

                          AREA ||i.config_init||, CODE, READONLY, ALIGN=2

                  config_init PROC
;;;69     
;;;70     void config_init()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;71     {
;;;72         uint32_t new_size;
;;;73         // Initialize RAM copy
;;;74         memset(&config_ram_copy, 0, sizeof(config_ram_copy));
000004  218e              MOVS     r1,#0x8e
000006  4829              LDR      r0,|L1.172|
000008  f7fffffe          BL       __aeabi_memclr
;;;75         // Read settings from RAM if the key is valid
;;;76         new_size = sizeof(config_ram);
00000c  258e              MOVS     r5,#0x8e
;;;77     
;;;78         if (CFG_KEY == config_ram.key) {
00000e  4828              LDR      r0,|L1.176|
000010  f7fffffe          BL       __aeabi_uread4
000014  4f27              LDR      r7,|L1.180|
000016  4c26              LDR      r4,|L1.176|
000018  4e24              LDR      r6,|L1.172|
00001a  42b8              CMP      r0,r7
00001c  d113              BNE      |L1.70|
;;;79             uint32_t size = MIN(config_ram.size, sizeof(config_ram));
00001e  7960              LDRB     r0,[r4,#5]  ; config_ram
000020  7921              LDRB     r1,[r4,#4]  ; config_ram
000022  ea412500          ORR      r5,r1,r0,LSL #8
000026  2d8e              CMP      r5,#0x8e
000028  d201              BCS      |L1.46|
00002a  462a              MOV      r2,r5
00002c  e001              B        |L1.50|
                  |L1.46|
00002e  f04f028e          MOV      r2,#0x8e
                  |L1.50|
;;;80             new_size = MAX(config_ram.size, sizeof(config_ram));
000032  d801              BHI      |L1.56|
000034  f04f058e          MOV      r5,#0x8e
                  |L1.56|
;;;81             memcpy(&config_ram_copy, (void *)&config_ram, size);
000038  491d              LDR      r1,|L1.176|
00003a  481c              LDR      r0,|L1.172|
00003c  f7fffffe          BL       __aeabi_memcpy
;;;82             config_ram_copy.assert_file_name[sizeof(config_ram_copy.assert_file_name) - 1] = 0;
000040  2000              MOVS     r0,#0
000042  f8860047          STRB     r0,[r6,#0x47]
                  |L1.70|
;;;83         }
;;;84     
;;;85         // Initialize RAM
;;;86         memset((void *)&config_ram, 0, sizeof(config_ram));
000046  218e              MOVS     r1,#0x8e
000048  4819              LDR      r0,|L1.176|
00004a  f7fffffe          BL       __aeabi_memclr
;;;87         config_ram.key = CFG_KEY;
00004e  4918              LDR      r1,|L1.176|
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       __aeabi_uwrite4
;;;88         config_ram.size = new_size;
000056  7125              STRB     r5,[r4,#4]
000058  0a28              LSRS     r0,r5,#8
00005a  7160              STRB     r0,[r4,#5]
;;;89         // Copy assert info back over (must be explicitly cleared)
;;;90         memcpy(config_ram.assert_file_name,
00005c  2241              MOVS     r2,#0x41
00005e  4635              MOV      r5,r6
000060  1df1              ADDS     r1,r6,#7
000062  1de0              ADDS     r0,r4,#7
000064  f7fffffe          BL       __aeabi_memcpy
;;;91                config_ram_copy.assert_file_name,
;;;92                sizeof(config_ram_copy.assert_file_name));
;;;93         config_ram.assert_line =  config_ram_copy.assert_line;
000068  f8950049          LDRB     r0,[r5,#0x49]  ; config_ram_copy
00006c  f8151f48          LDRB     r1,[r5,#0x48]!  ; config_ram_copy
000070  ea412000          ORR      r0,r1,r0,LSL #8
000074  f8040f48          STRB     r0,[r4,#0x48]!
000078  0a00              LSRS     r0,r0,#8
00007a  7060              STRB     r0,[r4,#1]
;;;94         config_ram.assert_source =  config_ram_copy.assert_source;
00007c  78a8              LDRB     r0,[r5,#2]  ; config_ram_copy
00007e  70a0              STRB     r0,[r4,#2]
;;;95         config_ram.valid_dumps = config_ram_copy.valid_dumps;
000080  78e8              LDRB     r0,[r5,#3]  ; config_ram_copy
000082  70e0              STRB     r0,[r4,#3]
;;;96         memcpy(config_ram.hexdump, config_ram_copy.hexdump, sizeof(config_ram_copy.hexdump[0]) * config_ram_copy.valid_dumps);
000084  0082              LSLS     r2,r0,#2
000086  4909              LDR      r1,|L1.172|
000088  4809              LDR      r0,|L1.176|
00008a  314c              ADDS     r1,r1,#0x4c
00008c  304c              ADDS     r0,r0,#0x4c
00008e  f7fffffe          BL       __aeabi_memcpy
;;;97         config_ram.disable_msd = config_ram_copy.disable_msd;
000092  f8950044          LDRB     r0,[r5,#0x44]  ; config_ram_copy
000096  f8840044          STRB     r0,[r4,#0x44]
;;;98         config_ram.page_erase_enable = config_ram_copy.page_erase_enable;
00009a  f8950045          LDRB     r0,[r5,#0x45]  ; config_ram_copy
00009e  f8840045          STRB     r0,[r4,#0x45]
;;;99         config_rom_init();
0000a2  e8bd41f0          POP      {r4-r8,lr}
0000a6  f7ffbffe          B.W      config_rom_init
;;;100    }
;;;101    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L1.172|
                          DCD      ||.bss||
                  |L1.176|
                          DCD      cfgram
                  |L1.180|
                          DCD      0x6b766c64

                          AREA ||i.config_ram_add_hexdump||, CODE, READONLY, ALIGN=2

                  config_ram_add_hexdump PROC
;;;203    
;;;204    uint8_t config_ram_add_hexdump(uint32_t hexdump)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206        if (config_ram.valid_dumps >= ALLOWED_HEXDUMP) {
000002  4c09              LDR      r4,|L2.40|
000004  f894104b          LDRB     r1,[r4,#0x4b]  ; config_ram
000008  2910              CMP      r1,#0x10
00000a  d301              BCC      |L2.16|
;;;207            return 0;
00000c  2000              MOVS     r0,#0
;;;208        }
;;;209    
;;;210        //alignment is maintained here
;;;211        config_ram.hexdump[config_ram.valid_dumps++] = hexdump;
;;;212        return config_ram.valid_dumps;
;;;213    }
00000e  bd10              POP      {r4,pc}
                  |L2.16|
000010  eb040181          ADD      r1,r4,r1,LSL #2       ;211
000014  314c              ADDS     r1,r1,#0x4c           ;211
000016  f7fffffe          BL       __aeabi_uwrite4
00001a  f8140f4b          LDRB     r0,[r4,#0x4b]!        ;211  ; config_ram
00001e  1c40              ADDS     r0,r0,#1              ;211
000020  b2c0              UXTB     r0,r0                 ;211
000022  7020              STRB     r0,[r4,#0]            ;211
000024  bd10              POP      {r4,pc}
;;;214    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      cfgram

                          AREA ||i.config_ram_clear_assert||, CODE, READONLY, ALIGN=2

                  config_ram_clear_assert PROC
;;;137    
;;;138    void config_ram_clear_assert()
000000  b510              PUSH     {r4,lr}
;;;139    {
;;;140        memset(config_ram.assert_file_name, 0, sizeof(config_ram.assert_file_name));
000002  4c05              LDR      r4,|L3.24|
000004  2141              MOVS     r1,#0x41
000006  1de0              ADDS     r0,r4,#7
000008  f7fffffe          BL       __aeabi_memclr
;;;141        config_ram.assert_line = 0;
00000c  2100              MOVS     r1,#0
00000e  f8041f48          STRB     r1,[r4,#0x48]!
000012  7061              STRB     r1,[r4,#1]
;;;142        config_ram.valid_dumps = 0;
000014  70e1              STRB     r1,[r4,#3]
;;;143    }
000016  bd10              POP      {r4,pc}
;;;144    
                          ENDP

                  |L3.24|
                          DCD      cfgram

                          AREA ||i.config_ram_get_assert||, CODE, READONLY, ALIGN=2

                  config_ram_get_assert PROC
;;;154    
;;;155    bool config_ram_get_assert(char *buf, uint16_t buf_size, uint16_t *line, assert_source_t *source)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;156    {
;;;157        // Initialize
;;;158        const char *start;
;;;159        uint32_t copy_size;
;;;160        uint32_t assert_size = strlen(config_ram.assert_file_name) + 1;
000004  4f1a              LDR      r7,|L4.112|
000006  4681              MOV      r9,r0                 ;156
000008  461d              MOV      r5,r3                 ;156
00000a  4616              MOV      r6,r2                 ;156
00000c  4688              MOV      r8,r1                 ;156
00000e  1df8              ADDS     r0,r7,#7
000010  f7fffffe          BL       strlen
000014  1c44              ADDS     r4,r0,#1
;;;161    
;;;162        if (0 != buf) {
000016  f1b90000          SUBS     r0,r9,#0
00001a  d002              BEQ      |L4.34|
;;;163            memset(buf, 0, buf_size);
00001c  4641              MOV      r1,r8
00001e  f7fffffe          BL       __aeabi_memclr
                  |L4.34|
000022  2000              MOVS     r0,#0
;;;164        }
;;;165    
;;;166        if (0 != line) {
000024  b106              CBZ      r6,|L4.40|
;;;167            *line = 0;
000026  8030              STRH     r0,[r6,#0]
                  |L4.40|
;;;168        }
;;;169    
;;;170        if (0 != source) {
000028  b105              CBZ      r5,|L4.44|
;;;171            *source = ASSERT_SOURCE_NONE;
00002a  7028              STRB     r0,[r5,#0]
                  |L4.44|
;;;172        }
;;;173    
;;;174        // If the string is empty then there is no assert
;;;175        if (0 == config_ram.assert_file_name[0]) {
00002c  79f8              LDRB     r0,[r7,#7]  ; config_ram
00002e  2800              CMP      r0,#0
000030  d01c              BEQ      |L4.108|
;;;176            return false;
;;;177        }
;;;178    
;;;179        // Determine size to copy
;;;180        if (assert_size <= buf_size) {
000032  4544              CMP      r4,r8
000034  d802              BHI      |L4.60|
;;;181            start = config_ram.assert_file_name;
000036  1df9              ADDS     r1,r7,#7
;;;182            copy_size = assert_size;
000038  4622              MOV      r2,r4
00003a  e004              B        |L4.70|
                  |L4.60|
;;;183        } else {
;;;184            start = &config_ram.assert_file_name[assert_size - buf_size];
00003c  eba40008          SUB      r0,r4,r8
000040  19c1              ADDS     r1,r0,r7
;;;185            copy_size = buf_size;
000042  4642              MOV      r2,r8
000044  1dc9              ADDS     r1,r1,#7
                  |L4.70|
;;;186        }
;;;187    
;;;188        // Copy data over
;;;189        if (0 != buf) {
000046  f1b90f00          CMP      r9,#0
00004a  d006              BEQ      |L4.90|
;;;190            *line = config_ram.assert_line;
00004c  f8970049          LDRB     r0,[r7,#0x49]  ; config_ram
000050  f8973048          LDRB     r3,[r7,#0x48]  ; config_ram
000054  ea432000          ORR      r0,r3,r0,LSL #8
000058  8030              STRH     r0,[r6,#0]
                  |L4.90|
;;;191        }
;;;192    
;;;193        if (0 != line) {
00005a  b116              CBZ      r6,|L4.98|
;;;194            memcpy(buf, start, copy_size);
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       __aeabi_memcpy
                  |L4.98|
;;;195        }
;;;196    
;;;197        if (0 != source) {
000062  b115              CBZ      r5,|L4.106|
;;;198            *source = (assert_source_t)config_ram.assert_source;
000064  f897004a          LDRB     r0,[r7,#0x4a]  ; config_ram
000068  7028              STRB     r0,[r5,#0]
                  |L4.106|
;;;199        }
;;;200    
;;;201        return true;
00006a  2001              MOVS     r0,#1
                  |L4.108|
;;;202    }
00006c  e8bd87f0          POP      {r4-r10,pc}
;;;203    
                          ENDP

                  |L4.112|
                          DCD      cfgram

                          AREA ||i.config_ram_get_disable_msd||, CODE, READONLY, ALIGN=2

                  config_ram_get_disable_msd PROC
;;;230    
;;;231    uint8_t config_ram_get_disable_msd(void)
000000  4801              LDR      r0,|L5.8|
;;;232    {
;;;233        return config_ram.disable_msd;
000002  f890008c          LDRB     r0,[r0,#0x8c]  ; config_ram
;;;234    }
000006  4770              BX       lr
;;;235    
                          ENDP

                  |L5.8|
                          DCD      cfgram

                          AREA ||i.config_ram_get_hexdumps||, CODE, READONLY, ALIGN=2

                  config_ram_get_hexdumps PROC
;;;214    
;;;215    uint8_t config_ram_get_hexdumps(uint32_t **hexdumps)
000000  4905              LDR      r1,|L6.24|
;;;216    {
;;;217        if (config_ram.valid_dumps == 0) {
000002  f891204b          LDRB     r2,[r1,#0x4b]  ; config_ram
000006  b12a              CBZ      r2,|L6.20|
;;;218            return 0;
;;;219        }
;;;220    
;;;221        //prevent memcopy check alignment
;;;222        *hexdumps = config_ram.hexdump;
000008  f101024c          ADD      r2,r1,#0x4c
;;;223        return config_ram.valid_dumps;
00000c  6002              STR      r2,[r0,#0]
00000e  f891004b          LDRB     r0,[r1,#0x4b]  ; config_ram
;;;224    }
000012  4770              BX       lr
                  |L6.20|
000014  2000              MOVS     r0,#0                 ;218
000016  4770              BX       lr
;;;225    
                          ENDP

                  |L6.24|
                          DCD      cfgram

                          AREA ||i.config_ram_get_hold_in_bl||, CODE, READONLY, ALIGN=2

                  config_ram_get_hold_in_bl PROC
;;;144    
;;;145    bool config_ram_get_hold_in_bl()
000000  4802              LDR      r0,|L7.12|
;;;146    {
;;;147        return config_ram.hold_in_bl;
000002  7980              LDRB     r0,[r0,#6]  ; config_ram
000004  2800              CMP      r0,#0                 ;146
000006  d000              BEQ      |L7.10|
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;148    }
00000a  4770              BX       lr
;;;149    
                          ENDP

                  |L7.12|
                          DCD      cfgram

                          AREA ||i.config_ram_get_initial_hold_in_bl||, CODE, READONLY, ALIGN=2

                  config_ram_get_initial_hold_in_bl PROC
;;;149    
;;;150    bool config_ram_get_initial_hold_in_bl()
000000  4802              LDR      r0,|L8.12|
;;;151    {
;;;152        return config_ram_copy.hold_in_bl;
000002  7980              LDRB     r0,[r0,#6]  ; config_ram_copy
000004  2800              CMP      r0,#0                 ;151
000006  d000              BEQ      |L8.10|
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;153    }
00000a  4770              BX       lr
;;;154    
                          ENDP

                  |L8.12|
                          DCD      ||.bss||

                          AREA ||i.config_ram_get_page_erase||, CODE, READONLY, ALIGN=2

                  config_ram_get_page_erase PROC
;;;240    
;;;241    bool config_ram_get_page_erase(void)
000000  4803              LDR      r0,|L9.16|
;;;242    {
;;;243        return config_ram.page_erase_enable;
000002  f890008d          LDRB     r0,[r0,#0x8d]  ; config_ram
000006  2800              CMP      r0,#0                 ;242
000008  d000              BEQ      |L9.12|
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;244    }
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      cfgram

                          AREA ||i.config_ram_set_assert||, CODE, READONLY, ALIGN=2

                  config_ram_set_assert PROC
;;;106    
;;;107    void config_ram_set_assert(const char *file, uint16_t line)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;108    {
000004  4688              MOV      r8,r1
000006  4607              MOV      r7,r0
;;;109        // Initialize
;;;110        uint32_t file_name_size = strlen(file) + 1;
000008  f7fffffe          BL       strlen
;;;111        const char *start;
;;;112        uint32_t assert_buf_size = sizeof(config_ram.assert_file_name);
;;;113        uint32_t copy_size;
;;;114        memset(config_ram.assert_file_name, 0, sizeof(config_ram.assert_file_name));
00000c  4d12              LDR      r5,|L10.88|
00000e  1c44              ADDS     r4,r0,#1              ;110
000010  2641              MOVS     r6,#0x41              ;112
000012  4631              MOV      r1,r6
000014  1de8              ADDS     r0,r5,#7
000016  f7fffffe          BL       __aeabi_memclr
;;;115    
;;;116        // Determine size to copy
;;;117        if (file_name_size <= assert_buf_size) {
00001a  2c41              CMP      r4,#0x41
00001c  d802              BHI      |L10.36|
;;;118            start = file;
00001e  4639              MOV      r1,r7
;;;119            copy_size = file_name_size;
000020  4622              MOV      r2,r4
000022  e002              B        |L10.42|
                  |L10.36|
000024  3c41              SUBS     r4,r4,#0x41
;;;120        } else {
;;;121            start = &file[file_name_size - assert_buf_size];
000026  19e1              ADDS     r1,r4,r7
;;;122            copy_size = assert_buf_size;
000028  4632              MOV      r2,r6
                  |L10.42|
;;;123        }
;;;124    
;;;125        // Write to ram
;;;126        memcpy(config_ram.assert_file_name, start, copy_size);
00002a  462c              MOV      r4,r5
00002c  1de8              ADDS     r0,r5,#7
00002e  f7fffffe          BL       __aeabi_memcpy
;;;127        config_ram.assert_line = line;
000032  f8848048          STRB     r8,[r4,#0x48]
000036  ea4f2018          LSR      r0,r8,#8
00003a  f8840049          STRB     r0,[r4,#0x49]
;;;128    
;;;129        if (daplink_is_bootloader()) {
00003e  f7fffffe          BL       daplink_is_bootloader
000042  b108              CBZ      r0,|L10.72|
;;;130            config_ram.assert_source = ASSERT_SOURCE_BL;
000044  2001              MOVS     r0,#1
000046  e003              B        |L10.80|
                  |L10.72|
;;;131        } else if (daplink_is_interface()) {
000048  f7fffffe          BL       daplink_is_interface
00004c  b100              CBZ      r0,|L10.80|
;;;132            config_ram.assert_source = ASSERT_SOURCE_APP;
00004e  2002              MOVS     r0,#2
                  |L10.80|
000050  f884004a          STRB     r0,[r4,#0x4a]         ;130
;;;133        } else {
;;;134            config_ram.assert_source = ASSERT_SOURCE_NONE;
;;;135        }
;;;136    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;137    
                          ENDP

                  |L10.88|
                          DCD      cfgram

                          AREA ||i.config_ram_set_disable_msd||, CODE, READONLY, ALIGN=2

                  config_ram_set_disable_msd PROC
;;;225    
;;;226    void config_ram_set_disable_msd(bool disable_msd)
000000  4901              LDR      r1,|L11.8|
;;;227    {
;;;228        config_ram.disable_msd = disable_msd;
000002  f881008c          STRB     r0,[r1,#0x8c]
;;;229    }
000006  4770              BX       lr
;;;230    
                          ENDP

                  |L11.8|
                          DCD      cfgram

                          AREA ||i.config_ram_set_hold_in_bl||, CODE, READONLY, ALIGN=2

                  config_ram_set_hold_in_bl PROC
;;;101    
;;;102    void config_ram_set_hold_in_bl(bool hold)
000000  4901              LDR      r1,|L12.8|
;;;103    {
;;;104        config_ram.hold_in_bl = hold;
000002  7188              STRB     r0,[r1,#6]
;;;105    }
000004  4770              BX       lr
;;;106    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      cfgram

                          AREA ||i.config_ram_set_page_erase||, CODE, READONLY, ALIGN=2

                  config_ram_set_page_erase PROC
;;;235    
;;;236    void config_ram_set_page_erase(bool page_erase_enable)
000000  4901              LDR      r1,|L13.8|
;;;237    {
;;;238        config_ram.page_erase_enable = page_erase_enable;
000002  f881008d          STRB     r0,[r1,#0x8d]
;;;239    }
000006  4770              BX       lr
;;;240    
                          ENDP

                  |L13.8|
                          DCD      cfgram

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  config_ram_copy
                          %        142

                          AREA cfgram, DATA, NOINIT, ALIGN=0

                  config_ram
                          %        142

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\settings\\settings.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_settings_c_56d4b884____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___10_settings_c_56d4b884____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_settings_c_56d4b884____REVSH|
#line 495
|__asm___10_settings_c_56d4b884____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_settings_c_56d4b884____RRX|
#line 682
|__asm___10_settings_c_56d4b884____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
