; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\file_stream.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\file_stream.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\file_stream.crf ..\..\..\source\daplink\drag-n-drop\file_stream.c]
                          THUMB

                          AREA ||i.close_bin||, CODE, READONLY, ALIGN=1

                  close_bin PROC
;;;280    
;;;281    static error_t close_bin(void *state)
000000  f7ffbffe          B.W      flash_decoder_close
;;;282    {
;;;283        error_t status;
;;;284        status = flash_decoder_close();
;;;285        return status;
;;;286    }
;;;287    
                          ENDP


                          AREA ||i.close_hex||, CODE, READONLY, ALIGN=1

                  close_hex PROC
;;;360    
;;;361    static error_t close_hex(void *state)
000000  f7ffbffe          B.W      flash_decoder_close
;;;362    {
;;;363        error_t status;
;;;364        status = flash_decoder_close();
;;;365        return status;
;;;366    }
                          ENDP


                          AREA ||i.detect_bin||, CODE, READONLY, ALIGN=1

                  detect_bin PROC
;;;206    
;;;207    static bool detect_bin(const uint8_t *data, uint32_t size)
000000  b510              PUSH     {r4,lr}
;;;208    {
;;;209        return FLASH_DECODER_TYPE_UNKNOWN != flash_decoder_detect_type(data, size, 0, false);
000002  2300              MOVS     r3,#0
000004  461a              MOV      r2,r3
000006  f7fffffe          BL       flash_decoder_detect_type
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L3.16|
00000e  2001              MOVS     r0,#1
                  |L3.16|
;;;210    }
000010  bd10              POP      {r4,pc}
;;;211    
                          ENDP


                          AREA ||i.detect_hex||, CODE, READONLY, ALIGN=1

                  detect_hex PROC
;;;289    
;;;290    static bool detect_hex(const uint8_t *data, uint32_t size)
000000  b510              PUSH     {r4,lr}
;;;291    {
;;;292        return 1 == validate_hexfile(data);
000002  f7fffffe          BL       validate_hexfile
000006  2801              CMP      r0,#1
000008  d000              BEQ      |L4.12|
00000a  2000              MOVS     r0,#0
                  |L4.12|
;;;293    }
00000c  bd10              POP      {r4,pc}
;;;294    
                          ENDP


                          AREA ||i.open_bin||, CODE, READONLY, ALIGN=1

                  open_bin PROC
;;;211    
;;;212    static error_t open_bin(void *state)
000000  f7ffbffe          B.W      flash_decoder_open
;;;213    {
;;;214        error_t status;
;;;215        status = flash_decoder_open();
;;;216        return status;
;;;217    }
;;;218    
                          ENDP


                          AREA ||i.open_hex||, CODE, READONLY, ALIGN=1

                  open_hex PROC
;;;294    
;;;295    static error_t open_hex(void *state)
000000  b510              PUSH     {r4,lr}
;;;296    {
000002  4604              MOV      r4,r0
;;;297        error_t status;
;;;298        hex_state_t *hex_state = (hex_state_t *)state;
;;;299        memset(hex_state, 0, sizeof(*hex_state));
000004  f2401101          MOV      r1,#0x101
000008  f7fffffe          BL       __aeabi_memclr
;;;300        reset_hex_parser();
00000c  f7fffffe          BL       reset_hex_parser
;;;301        hex_state->parsing_complete = false;
000010  2000              MOVS     r0,#0
000012  7020              STRB     r0,[r4,#0]
;;;302        status = flash_decoder_open();
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      flash_decoder_open
;;;303        return status;
;;;304    }
;;;305    
                          ENDP


                          AREA ||i.stream_close||, CODE, READONLY, ALIGN=2

                  stream_close PROC
;;;185    
;;;186    error_t stream_close(void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188        error_t status;
;;;189    
;;;190        // Stream must not be closed already
;;;191        if (STREAM_STATE_CLOSED == state) {
000002  4c09              LDR      r4,|L7.40|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b140              CBZ      r0,|L7.26|
;;;192            util_assert(0);
;;;193            return ERROR_INTERNAL;
;;;194        }
;;;195    
;;;196        // Check thread after checking state since the stream thread is
;;;197        // set only if stream_open has been called
;;;198        stream_thread_assert();
000008  f7fffffe          BL       stream_thread_assert
;;;199        // Close stream
;;;200        status = current_stream->close(&shared_state);
00000c  6860              LDR      r0,[r4,#4]  ; current_stream
00000e  68c1              LDR      r1,[r0,#0xc]
000010  4806              LDR      r0,|L7.44|
000012  4788              BLX      r1
;;;201        state = STREAM_STATE_CLOSED;
000014  2100              MOVS     r1,#0
000016  7021              STRB     r1,[r4,#0]
;;;202        return status;
;;;203    }
000018  bd10              POP      {r4,pc}
                  |L7.26|
00001a  22c0              MOVS     r2,#0xc0              ;192
00001c  a104              ADR      r1,|L7.48|
00001e  2000              MOVS     r0,#0                 ;192
000020  f7fffffe          BL       _util_assert
000024  2002              MOVS     r0,#2                 ;193
000026  bd10              POP      {r4,pc}
;;;204    
                          ENDP

                  |L7.40|
                          DCD      ||.data||
                  |L7.44|
                          DCD      ||.bss||
                  |L7.48|
000030  2866696c          DCB      "(file)",0
000034  652900  
000037  00                DCB      0

                          AREA ||i.stream_open||, CODE, READONLY, ALIGN=2

                  stream_open PROC
;;;126    
;;;127    error_t stream_open(stream_type_t stream_type)
000000  b570              PUSH     {r4-r6,lr}
;;;128    {
;;;129        error_t status;
;;;130    
;;;131        // Stream must not be open already
;;;132        if (state != STREAM_STATE_CLOSED) {
000002  4c13              LDR      r4,|L8.80|
000004  4605              MOV      r5,r0                 ;128
000006  7820              LDRB     r0,[r4,#0]  ; state
000008  b108              CBZ      r0,|L8.14|
;;;133            util_assert(0);
00000a  2285              MOVS     r2,#0x85
;;;134            return ERROR_INTERNAL;
00000c  e002              B        |L8.20|
                  |L8.14|
;;;135        }
;;;136    
;;;137        // Stream must be of a supported type
;;;138        if (stream_type >= STREAM_TYPE_COUNT) {
00000e  2d02              CMP      r5,#2
000010  d306              BCC      |L8.32|
;;;139            util_assert(0);
000012  228b              MOVS     r2,#0x8b
                  |L8.20|
000014  a10f              ADR      r1,|L8.84|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       _util_assert
;;;140            return ERROR_INTERNAL;
00001c  2002              MOVS     r0,#2
                  |L8.30|
;;;141        }
;;;142    
;;;143        stream_thread_set();
;;;144        // Initialize all variables
;;;145        memset(&shared_state, 0, sizeof(shared_state));
;;;146        state = STREAM_STATE_OPEN;
;;;147        current_stream = &stream[stream_type];
;;;148        // Initialize the specified stream
;;;149        status = current_stream->open(&shared_state);
;;;150    
;;;151        if (ERROR_SUCCESS != status) {
;;;152            state = STREAM_STATE_ERROR;
;;;153        }
;;;154    
;;;155        return status;
;;;156    }
00001e  bd70              POP      {r4-r6,pc}
                  |L8.32|
000020  f7fffffe          BL       osThreadGetId
000024  60a0              STR      r0,[r4,#8]            ;145  ; stream_thread_tid
000026  f44f7182          MOV      r1,#0x104             ;145
00002a  480c              LDR      r0,|L8.92|
00002c  f7fffffe          BL       __aeabi_memclr4
000030  2001              MOVS     r0,#1                 ;146
000032  7020              STRB     r0,[r4,#0]            ;146
000034  4806              LDR      r0,|L8.80|
000036  300c              ADDS     r0,r0,#0xc            ;147
000038  eb001005          ADD      r0,r0,r5,LSL #4       ;147
00003c  6060              STR      r0,[r4,#4]            ;149  ; current_stream
00003e  6841              LDR      r1,[r0,#4]            ;149
000040  4806              LDR      r0,|L8.92|
000042  4788              BLX      r1                    ;149
000044  2800              CMP      r0,#0                 ;151
000046  d0ea              BEQ      |L8.30|
000048  2103              MOVS     r1,#3                 ;152
00004a  7021              STRB     r1,[r4,#0]            ;152
00004c  bd70              POP      {r4-r6,pc}
;;;157    
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      ||.data||
                  |L8.84|
000054  2866696c          DCB      "(file)",0
000058  652900  
00005b  00                DCB      0
                  |L8.92|
                          DCD      ||.bss||

                          AREA ||i.stream_start_identify||, CODE, READONLY, ALIGN=2

                  stream_start_identify PROC
;;;100    
;;;101    stream_type_t stream_start_identify(const uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;102    {
;;;103        stream_type_t i;
;;;104    
;;;105        for (i = STREAM_TYPE_START; i < STREAM_TYPE_COUNT; i++) {
;;;106            if (stream[i].detect(data, size)) {
000004  4d09              LDR      r5,|L9.44|
000006  460e              MOV      r6,r1                 ;102
000008  4607              MOV      r7,r0                 ;102
00000a  2400              MOVS     r4,#0                 ;105
                  |L9.12|
00000c  eb051004          ADD      r0,r5,r4,LSL #4
000010  4631              MOV      r1,r6
000012  6802              LDR      r2,[r0,#0]
000014  4638              MOV      r0,r7
000016  4790              BLX      r2
000018  b110              CBZ      r0,|L9.32|
;;;107                return i;
00001a  4620              MOV      r0,r4
                  |L9.28|
;;;108            }
;;;109        }
;;;110    
;;;111        return STREAM_TYPE_NONE;
;;;112    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L9.32|
000020  1c64              ADDS     r4,r4,#1
000022  b2e4              UXTB     r4,r4                 ;105
000024  2c02              CMP      r4,#2                 ;105
000026  d3f1              BCC      |L9.12|
000028  2003              MOVS     r0,#3                 ;111
00002a  e7f7              B        |L9.28|
;;;113    
                          ENDP

                  |L9.44|
                          DCD      ||.data||+0xc

                          AREA ||i.stream_thread_assert||, CODE, READONLY, ALIGN=2

                  stream_thread_assert PROC
;;;95     }
;;;96     static void stream_thread_assert(void)
000000  b510              PUSH     {r4,lr}
;;;97     {
;;;98         util_assert(osThreadGetId() == stream_thread_tid);
000002  f7fffffe          BL       osThreadGetId
000006  4906              LDR      r1,|L10.32|
000008  6889              LDR      r1,[r1,#8]  ; stream_thread_tid
00000a  4288              CMP      r0,r1
00000c  d101              BNE      |L10.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L10.20|
                  |L10.18|
000012  2000              MOVS     r0,#0
                  |L10.20|
000014  e8bd4010          POP      {r4,lr}
000018  2262              MOVS     r2,#0x62
00001a  a102              ADR      r1,|L10.36|
00001c  f7ffbffe          B.W      _util_assert
;;;99     }
;;;100    
                          ENDP

                  |L10.32|
                          DCD      ||.data||
                  |L10.36|
000024  2866696c          DCB      "(file)",0
000028  652900  
00002b  00                DCB      0

                          AREA ||i.stream_type_from_name||, CODE, READONLY, ALIGN=2

                  stream_type_from_name PROC
;;;114    // Identify the file type from its extension
;;;115    stream_type_t stream_type_from_name(const vfs_filename_t filename)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117        // 8.3 file names must be in upper case
;;;118        if (0 == strncmp("BIN", &filename[8], 3)) {
000002  f1000108          ADD      r1,r0,#8
000006  2203              MOVS     r2,#3
000008  460c              MOV      r4,r1
00000a  a007              ADR      r0,|L11.40|
00000c  f7fffffe          BL       strncmp
000010  2800              CMP      r0,#0
000012  d006              BEQ      |L11.34|
;;;119            return STREAM_TYPE_BIN;
;;;120        } else if (0 == strncmp("HEX", &filename[8], 3)) {
000014  2203              MOVS     r2,#3
000016  4621              MOV      r1,r4
000018  a004              ADR      r0,|L11.44|
00001a  f7fffffe          BL       strncmp
00001e  b108              CBZ      r0,|L11.36|
;;;121            return STREAM_TYPE_HEX;
;;;122        } else {
;;;123            return STREAM_TYPE_NONE;
000020  2003              MOVS     r0,#3
                  |L11.34|
;;;124        }
;;;125    }
000022  bd10              POP      {r4,pc}
                  |L11.36|
000024  2001              MOVS     r0,#1                 ;121
000026  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  |L11.40|
000028  42494e00          DCB      "BIN",0
                  |L11.44|
00002c  48455800          DCB      "HEX",0

                          AREA ||i.stream_write||, CODE, READONLY, ALIGN=2

                  stream_write PROC
;;;157    
;;;158    error_t stream_write(const uint8_t *data, uint32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;159    {
;;;160        error_t status;
;;;161    
;;;162        // Stream must be open already
;;;163        if (state != STREAM_STATE_OPEN) {
000002  4d15              LDR      r5,|L12.88|
000004  4606              MOV      r6,r0                 ;159
000006  460c              MOV      r4,r1                 ;159
000008  7828              LDRB     r0,[r5,#0]  ; state
00000a  2801              CMP      r0,#1
00000c  d006              BEQ      |L12.28|
;;;164            util_assert(0);
00000e  22a4              MOVS     r2,#0xa4
000010  a112              ADR      r1,|L12.92|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       _util_assert
;;;165            return ERROR_INTERNAL;
000018  2002              MOVS     r0,#2
;;;166        }
;;;167    
;;;168        // Check thread after checking state since the stream thread is
;;;169        // set only if stream_open has been called
;;;170        stream_thread_assert();
;;;171        // Write to stream
;;;172        status = current_stream->write(&shared_state, data, size);
;;;173    
;;;174        if (ERROR_SUCCESS_DONE == status) {
;;;175            state = STREAM_STATE_END;
;;;176        } else if ((ERROR_SUCCESS_DONE_OR_CONTINUE == status) || (ERROR_SUCCESS == status)) {
;;;177            // Stream should remain in the open state
;;;178            util_assert(STREAM_STATE_OPEN == state);
;;;179        } else {
;;;180            state = STREAM_STATE_ERROR;
;;;181        }
;;;182    
;;;183        return status;
;;;184    }
00001a  bd70              POP      {r4-r6,pc}
                  |L12.28|
00001c  f7fffffe          BL       stream_thread_assert
000020  6868              LDR      r0,[r5,#4]            ;172  ; current_stream
000022  4622              MOV      r2,r4                 ;172
000024  4631              MOV      r1,r6                 ;172
000026  6883              LDR      r3,[r0,#8]            ;172
000028  480e              LDR      r0,|L12.100|
00002a  4798              BLX      r3                    ;172
00002c  4604              MOV      r4,r0                 ;172
00002e  2813              CMP      r0,#0x13              ;174
000030  d006              BEQ      |L12.64|
000032  2c14              CMP      r4,#0x14              ;176
000034  d006              BEQ      |L12.68|
000036  b12c              CBZ      r4,|L12.68|
000038  2003              MOVS     r0,#3                 ;180
                  |L12.58|
00003a  7028              STRB     r0,[r5,#0]            ;180
                  |L12.60|
00003c  4620              MOV      r0,r4                 ;183
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2002              MOVS     r0,#2                 ;175
000042  e7fa              B        |L12.58|
                  |L12.68|
000044  7828              LDRB     r0,[r5,#0]            ;178  ; state
000046  2801              CMP      r0,#1                 ;178
000048  d000              BEQ      |L12.76|
00004a  2000              MOVS     r0,#0                 ;178
                  |L12.76|
00004c  22b2              MOVS     r2,#0xb2              ;178
00004e  a103              ADR      r1,|L12.92|
000050  f7fffffe          BL       _util_assert
000054  e7f2              B        |L12.60|
;;;185    
                          ENDP

000056  0000              DCW      0x0000
                  |L12.88|
                          DCD      ||.data||
                  |L12.92|
00005c  2866696c          DCB      "(file)",0
000060  652900  
000063  00                DCB      0
                  |L12.100|
                          DCD      ||.bss||

                          AREA ||i.write_bin||, CODE, READONLY, ALIGN=1

                  write_bin PROC
;;;218    
;;;219    static error_t write_bin(void *state, const uint8_t *data, uint32_t size)
000000  b5fe              PUSH     {r1-r7,lr}
;;;220    {
000002  4604              MOV      r4,r0
;;;221        error_t status;
;;;222        bin_state_t *bin_state = (bin_state_t *)state;
;;;223    
;;;224        if (bin_state->buf_pos < FLASH_DECODER_MIN_SIZE) {
000004  f8900030          LDRB     r0,[r0,#0x30]
000008  4615              MOV      r5,r2                 ;220
00000a  460f              MOV      r7,r1                 ;220
00000c  2830              CMP      r0,#0x30
00000e  d301              BCC      |L13.20|
;;;225            flash_decoder_type_t flash_type;
;;;226            uint32_t size_left;
;;;227            uint32_t copy_size;
;;;228            uint32_t start_addr;
;;;229            const flash_intf_t *flash_intf;
;;;230            // Buffer Data
;;;231            size_left = FLASH_DECODER_MIN_SIZE - bin_state->buf_pos;
;;;232            copy_size = MIN(size_left, size);
;;;233            memcpy(bin_state->vector_buf + bin_state->buf_pos, data, copy_size);
;;;234            bin_state->buf_pos += copy_size;
;;;235    
;;;236            if (bin_state->buf_pos < FLASH_DECODER_MIN_SIZE) {
;;;237                // Not enough data to determine type
;;;238                return ERROR_SUCCESS;
;;;239            }
;;;240    
;;;241            data += copy_size;
;;;242            size -= copy_size;
;;;243            // Determine type
;;;244            flash_type = flash_decoder_detect_type(bin_state->vector_buf, bin_state->buf_pos, 0, false);
;;;245    
;;;246            if (FLASH_DECODER_TYPE_UNKNOWN == flash_type) {
;;;247                return ERROR_FD_UNSUPPORTED_UPDATE;
;;;248            }
;;;249    
;;;250            // Determine flash addresss
;;;251            status = flash_decoder_get_flash(flash_type, 0, false, &start_addr, &flash_intf);
;;;252    
;;;253            if (ERROR_SUCCESS != status) {
;;;254                return status;
;;;255            }
;;;256    
;;;257            bin_state->flash_addr = start_addr;
;;;258            // Pass on data to the decoder
;;;259            status = flash_decoder_write(bin_state->flash_addr, bin_state->vector_buf, bin_state->buf_pos);
;;;260    
;;;261            if (ERROR_SUCCESS != status) {
;;;262                return status;
;;;263            }
;;;264    
;;;265            bin_state->flash_addr += bin_state->buf_pos;
;;;266        }
000010  6b60              LDR      r0,[r4,#0x34]
000012  e031              B        |L13.120|
                  |L13.20|
000014  f1c00630          RSB      r6,r0,#0x30           ;231
000018  42ae              CMP      r6,r5                 ;232
00001a  d300              BCC      |L13.30|
00001c  4616              MOV      r6,r2                 ;232
                  |L13.30|
00001e  4420              ADD      r0,r0,r4              ;233
000020  4632              MOV      r2,r6                 ;233
000022  f7fffffe          BL       __aeabi_memcpy
000026  f8940030          LDRB     r0,[r4,#0x30]         ;234
00002a  4430              ADD      r0,r0,r6              ;234
00002c  b2c1              UXTB     r1,r0                 ;234
00002e  f8841030          STRB     r1,[r4,#0x30]         ;234
000032  2930              CMP      r1,#0x30              ;236
000034  d201              BCS      |L13.58|
000036  2000              MOVS     r0,#0                 ;238
                  |L13.56|
;;;267    
;;;268        // Write data
;;;269        status = flash_decoder_write(bin_state->flash_addr, data, size);
;;;270    
;;;271        if (ERROR_SUCCESS != status) {
;;;272            return status;
;;;273        }
;;;274    
;;;275        bin_state->flash_addr += size;
;;;276        // There is no way to determine the end of a binary
;;;277        // file so any point could be the end
;;;278        return ERROR_SUCCESS_DONE_OR_CONTINUE;
;;;279    }
000038  bdfe              POP      {r1-r7,pc}
                  |L13.58|
00003a  2300              MOVS     r3,#0                 ;244
00003c  4437              ADD      r7,r7,r6              ;241
00003e  1bad              SUBS     r5,r5,r6              ;242
000040  461a              MOV      r2,r3                 ;244
000042  4620              MOV      r0,r4                 ;244
000044  f7fffffe          BL       flash_decoder_detect_type
000048  b308              CBZ      r0,|L13.142|
00004a  a902              ADD      r1,sp,#8              ;251
00004c  2200              MOVS     r2,#0                 ;251
00004e  9100              STR      r1,[sp,#0]            ;251
000050  ab01              ADD      r3,sp,#4              ;251
000052  4611              MOV      r1,r2                 ;251
000054  f7fffffe          BL       flash_decoder_get_flash
000058  2800              CMP      r0,#0                 ;253
00005a  d1ed              BNE      |L13.56|
00005c  9801              LDR      r0,[sp,#4]            ;257
00005e  6360              STR      r0,[r4,#0x34]         ;259
000060  f8942030          LDRB     r2,[r4,#0x30]         ;259
000064  4621              MOV      r1,r4                 ;259
000066  f7fffffe          BL       flash_decoder_write
00006a  2800              CMP      r0,#0                 ;261
00006c  d1e4              BNE      |L13.56|
00006e  f8941030          LDRB     r1,[r4,#0x30]         ;265
000072  6b60              LDR      r0,[r4,#0x34]         ;265
000074  4408              ADD      r0,r0,r1              ;265
000076  6360              STR      r0,[r4,#0x34]         ;265
                  |L13.120|
000078  462a              MOV      r2,r5                 ;269
00007a  4639              MOV      r1,r7                 ;269
00007c  f7fffffe          BL       flash_decoder_write
000080  2800              CMP      r0,#0                 ;271
000082  d1d9              BNE      |L13.56|
000084  6b60              LDR      r0,[r4,#0x34]         ;275
000086  4428              ADD      r0,r0,r5              ;275
000088  6360              STR      r0,[r4,#0x34]         ;278
00008a  2014              MOVS     r0,#0x14              ;278
00008c  bdfe              POP      {r1-r7,pc}
                  |L13.142|
00008e  201c              MOVS     r0,#0x1c              ;247
000090  bdfe              POP      {r1-r7,pc}
;;;280    
                          ENDP


                          AREA ||i.write_hex||, CODE, READONLY, ALIGN=2

                  write_hex PROC
;;;305    
;;;306    static error_t write_hex(void *state, const uint8_t *data, uint32_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;307    {
000004  b086              SUB      sp,sp,#0x18
;;;308        error_t status = ERROR_SUCCESS;
000006  2400              MOVS     r4,#0
000008  4616              MOV      r6,r2                 ;307
00000a  460f              MOV      r7,r1                 ;307
00000c  4605              MOV      r5,r0                 ;307
;;;309        hex_state_t *hex_state = (hex_state_t *)state;
;;;310        hexfile_parse_status_t parse_status = HEX_PARSE_UNINIT;
;;;311        uint32_t bin_start_address = 0; // Decoded from the hex file, the binary buffer data starts at this address
;;;312        uint32_t bin_buf_written = 0;   // The amount of data in the binary buffer starting at address above
00000e  9403              STR      r4,[sp,#0xc]
;;;313        uint32_t block_amt_parsed = 0;  // amount of data parsed in the block on the last call
000010  9404              STR      r4,[sp,#0x10]
;;;314    
;;;315        while (1) {
;;;316            // try to decode a block of hex data into bin data
;;;317            parse_status = parse_hex_blob(data, size, &block_amt_parsed, hex_state->bin_buffer, sizeof(hex_state->bin_buffer), &bin_start_address, &bin_buf_written);
000012  f10d0810          ADD      r8,sp,#0x10
000016  f10d090c          ADD      r9,sp,#0xc
00001a  f44f7a80          MOV      r10,#0x100
00001e  9405              STR      r4,[sp,#0x14]
                  |L14.32|
000020  f8cda000          STR      r10,[sp,#0]
000024  e9cd9801          STRD     r9,r8,[sp,#4]
000028  1c6b              ADDS     r3,r5,#1
00002a  aa05              ADD      r2,sp,#0x14
00002c  4631              MOV      r1,r6
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       parse_hex_blob
;;;318    
;;;319            // the entire block of hex was decoded. This is a simple state
;;;320            if (HEX_PARSE_OK == parse_status) {
000034  b168              CBZ      r0,|L14.82|
;;;321                if (bin_buf_written > 0) {
;;;322                    status = flash_decoder_write(bin_start_address, hex_state->bin_buffer, bin_buf_written);
;;;323                }
;;;324    
;;;325                break;
;;;326            } else if (HEX_PARSE_UNALIGNED == parse_status) {
000036  2802              CMP      r0,#2
000038  d013              BEQ      |L14.98|
;;;327                if (bin_buf_written > 0) {
;;;328                    status = flash_decoder_write(bin_start_address, hex_state->bin_buffer, bin_buf_written);
;;;329    
;;;330                    if (ERROR_SUCCESS != status) {
;;;331                        break;
;;;332                    }
;;;333                }
;;;334    
;;;335                // incrememntal offset to finish the block
;;;336                size -= block_amt_parsed;
;;;337                data += block_amt_parsed;
;;;338            } else if (HEX_PARSE_EOF == parse_status) {
00003a  2801              CMP      r0,#1
00003c  d01d              BEQ      |L14.122|
;;;339                if (bin_buf_written > 0) {
;;;340                    status = flash_decoder_write(bin_start_address, hex_state->bin_buffer, bin_buf_written);
;;;341                }
;;;342    
;;;343                if (ERROR_SUCCESS == status) {
;;;344                    status = ERROR_SUCCESS_DONE;
;;;345                }
;;;346    
;;;347                break;
;;;348            } else if (HEX_PARSE_CKSUM_FAIL == parse_status) {
00003e  2804              CMP      r0,#4
000040  d025              BEQ      |L14.142|
;;;349                status = ERROR_HEX_CKSUM;
;;;350                break;
;;;351            } else if ((HEX_PARSE_UNINIT == parse_status) || (HEX_PARSE_FAILURE == parse_status)) {
000042  2805              CMP      r0,#5
000044  d001              BEQ      |L14.74|
000046  2806              CMP      r0,#6
000048  d1ea              BNE      |L14.32|
                  |L14.74|
;;;352                util_assert(HEX_PARSE_UNINIT != parse_status);
00004a  2805              CMP      r0,#5
00004c  d021              BEQ      |L14.146|
00004e  2001              MOVS     r0,#1
000050  e020              B        |L14.148|
                  |L14.82|
000052  9a04              LDR      r2,[sp,#0x10]         ;321
000054  b322              CBZ      r2,|L14.160|
000056  1c69              ADDS     r1,r5,#1              ;322
000058  9803              LDR      r0,[sp,#0xc]          ;322
00005a  f7fffffe          BL       flash_decoder_write
00005e  4604              MOV      r4,r0                 ;322
000060  e01e              B        |L14.160|
                  |L14.98|
000062  9a04              LDR      r2,[sp,#0x10]         ;327
000064  b12a              CBZ      r2,|L14.114|
000066  1c69              ADDS     r1,r5,#1              ;328
000068  9803              LDR      r0,[sp,#0xc]          ;328
00006a  f7fffffe          BL       flash_decoder_write
00006e  0004              MOVS     r4,r0                 ;328
000070  d116              BNE      |L14.160|
                  |L14.114|
000072  9805              LDR      r0,[sp,#0x14]         ;336
000074  1a36              SUBS     r6,r6,r0              ;336
000076  4407              ADD      r7,r7,r0              ;337
000078  e7d2              B        |L14.32|
                  |L14.122|
00007a  9a04              LDR      r2,[sp,#0x10]         ;339
00007c  b122              CBZ      r2,|L14.136|
00007e  1c69              ADDS     r1,r5,#1              ;340
000080  9803              LDR      r0,[sp,#0xc]          ;340
000082  f7fffffe          BL       flash_decoder_write
000086  4604              MOV      r4,r0                 ;340
                  |L14.136|
000088  b954              CBNZ     r4,|L14.160|
00008a  2413              MOVS     r4,#0x13              ;344
00008c  e008              B        |L14.160|
                  |L14.142|
00008e  2415              MOVS     r4,#0x15              ;349
000090  e006              B        |L14.160|
                  |L14.146|
000092  2000              MOVS     r0,#0
                  |L14.148|
000094  f44f72b0          MOV      r2,#0x160
000098  a103              ADR      r1,|L14.168|
00009a  f7fffffe          BL       _util_assert
;;;353                status = ERROR_HEX_PARSER;
00009e  2416              MOVS     r4,#0x16
                  |L14.160|
;;;354                break;
;;;355            }
;;;356        }
;;;357    
;;;358        return status;
;;;359    }
0000a0  b006              ADD      sp,sp,#0x18
0000a2  4620              MOV      r0,r4                 ;358
0000a4  e8bd87f0          POP      {r4-r10,pc}
;;;360    
                          ENDP

                  |L14.168|
0000a8  2866696c          DCB      "(file)",0
0000ac  652900  
0000af  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  shared_state
                          %        260

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  current_stream
                          DCD      0x00000000
                  stream_thread_tid
                          DCD      0x00000000
                  stream
                          DCD      detect_bin
                          DCD      open_bin
                          DCD      write_bin
                          DCD      close_bin
                          DCD      detect_hex
                          DCD      open_hex
                          DCD      write_hex
                          DCD      close_hex
