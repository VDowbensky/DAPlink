; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\intelhex.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\intelhex.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\intelhex.crf ..\..\..\source\daplink\drag-n-drop\intelhex.c]
                          THUMB

                          AREA ||i.ctoh||, CODE, READONLY, ALIGN=1

                  ctoh PROC
;;;60      */
;;;61     static uint8_t ctoh(char c)
000000  06c1              LSLS     r1,r0,#27
;;;62     {
;;;63         return (c & 0x10) ? /*0-9*/ c & 0xf : /*A-F, a-f*/ (c & 0xf) + 9;
000002  f000000f          AND      r0,r0,#0xf
000006  d400              BMI      |L1.10|
000008  3009              ADDS     r0,r0,#9              ;62
                  |L1.10|
;;;64     }
00000a  4770              BX       lr
;;;65     
                          ENDP


                          AREA ||i.parse_hex_blob||, CODE, READONLY, ALIGN=2

                  parse_hex_blob PROC
;;;96     
;;;97     hexfile_parse_status_t parse_hex_blob(const uint8_t *hex_blob, const uint32_t hex_blob_size, uint32_t *hex_parse_cnt, uint8_t *bin_buf, const uint32_t bin_buf_size, uint32_t *bin_buf_address, uint32_t *bin_buf_cnt)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;98     {
000004  468a              MOV      r10,r1
;;;99         uint8_t *end = (uint8_t *)hex_blob + hex_blob_size;
;;;100        hexfile_parse_status_t status = HEX_PARSE_UNINIT;
;;;101        // reset the amount of data that is being return'd
;;;102        *bin_buf_cnt = (uint32_t)0;
000006  9c0c              LDR      r4,[sp,#0x30]
000008  4605              MOV      r5,r0                 ;98
00000a  eb00080a          ADD      r8,r0,r10             ;99
;;;103    
;;;104        // we had an exit state where the address was unaligned to the previous record and data count.
;;;105        //  Need to pop the last record into the buffer before decoding anthing else since it was
;;;106        //  already decoded.
;;;107        if (load_unaligned_record) {
00000e  4e87              LDR      r6,|L2.556|
000010  2000              MOVS     r0,#0                 ;102
000012  6020              STR      r0,[r4,#0]
000014  78f0              LDRB     r0,[r6,#3]  ; load_unaligned_record
;;;108            // need some help...
;;;109            load_unaligned_record = 0;
;;;110            // move from line buffer back to input buffer
;;;111            memcpy((uint8_t *)bin_buf, (uint8_t *)line.data, line.byte_count);
000016  f8df9218          LDR      r9,|L2.560|
00001a  461f              MOV      r7,r3                 ;98
00001c  4693              MOV      r11,r2                ;98
00001e  2800              CMP      r0,#0                 ;107
000020  d01c              BEQ      |L2.92|
000022  2000              MOVS     r0,#0                 ;109
000024  70f0              STRB     r0,[r6,#3]            ;109
000026  f8992000          LDRB     r2,[r9,#0]  ; line
00002a  f1090104          ADD      r1,r9,#4
00002e  4618              MOV      r0,r3
000030  f7fffffe          BL       __aeabi_memcpy
;;;112            bin_buf += line.byte_count;
000034  f8990000          LDRB     r0,[r9,#0]  ; line
;;;113            *bin_buf_cnt = (uint32_t)(*bin_buf_cnt) + line.byte_count;
000038  6821              LDR      r1,[r4,#0]
00003a  4407              ADD      r7,r7,r0              ;112
00003c  4408              ADD      r0,r0,r1
;;;114            // Store next address to write
;;;115            next_address_to_write = ((next_address_to_write & 0xffff0000) | line.address) + line.byte_count;
00003e  6020              STR      r0,[r4,#0]
000040  6870              LDR      r0,[r6,#4]  ; next_address_to_write
000042  f8992002          LDRB     r2,[r9,#2]  ; line
000046  0c01              LSRS     r1,r0,#16
000048  f8993001          LDRB     r3,[r9,#1]  ; line
00004c  0409              LSLS     r1,r1,#16
00004e  ea432002          ORR      r0,r3,r2,LSL #8
000052  4301              ORRS     r1,r1,r0
000054  f8990000          LDRB     r0,[r9,#0]  ; line
000058  4408              ADD      r0,r0,r1
00005a  6070              STR      r0,[r6,#4]  ; next_address_to_write
                  |L2.92|
00005c  e0de              B        |L2.540|
                  |L2.94|
;;;116        }
;;;117    
;;;118        while (hex_blob != end) {
;;;119            switch ((uint8_t)(*hex_blob)) {
00005e  7828              LDRB     r0,[r5,#0]
000060  280a              CMP      r0,#0xa
                  |L2.98|
000062  d027              BEQ      |L2.180|
000064  280d              CMP      r0,#0xd
000066  d0fc              BEQ      |L2.98|
000068  283a              CMP      r0,#0x3a
00006a  d01b              BEQ      |L2.164|
;;;120                // we've hit the end of an ascii line
;;;121                // junk we dont care about could also just run the validate_checksum on &line
;;;122                case '\r':
;;;123                case '\n':
;;;124                    //ignore new lines
;;;125                    break;
;;;126    
;;;127                // found start of a new record. reset state variables
;;;128                case ':':
;;;129                    memset(line.buf, 0, sizeof(hex_line_t));
;;;130                    low_nibble = 0;
;;;131                    idx = 0;
;;;132                    record_processed = 0;
;;;133                    break;
;;;134    
;;;135                // decoding lines
;;;136                default:
;;;137                    if (low_nibble) {
00006c  7831              LDRB     r1,[r6,#0]  ; low_nibble
00006e  2900              CMP      r1,#0
000070  d078              BEQ      |L2.356|
;;;138                        line.buf[idx] |= ctoh((uint8_t)(*hex_blob)) & 0xf;
000072  f7fffffe          BL       ctoh
000076  f000020f          AND      r2,r0,#0xf
00007a  7870              LDRB     r0,[r6,#1]  ; idx
00007c  f8193000          LDRB     r3,[r9,r0]
000080  431a              ORRS     r2,r2,r3
000082  f8092000          STRB     r2,[r9,r0]
000086  1c40              ADDS     r0,r0,#1
;;;139                        if (++idx >= (line.byte_count + 5)) { //all data in
000088  b2c2              UXTB     r2,r0
00008a  7072              STRB     r2,[r6,#1]
00008c  f8990000          LDRB     r0,[r9,#0]  ; line
000090  9000              STR      r0,[sp,#0]
000092  1d40              ADDS     r0,r0,#5
000094  4282              CMP      r2,r0
000096  d364              BCC      |L2.354|
;;;140                            if (0 == validate_checksum(&line)) {
000098  4a65              LDR      r2,|L2.560|
00009a  2100              MOVS     r1,#0
00009c  4608              MOV      r0,r1
00009e  7813              LDRB     r3,[r2,#0]
0000a0  1d5b              ADDS     r3,r3,#5
0000a2  e00e              B        |L2.194|
                  |L2.164|
0000a4  2125              MOVS     r1,#0x25              ;129
0000a6  4862              LDR      r0,|L2.560|
0000a8  f7fffffe          BL       __aeabi_memclr
0000ac  2000              MOVS     r0,#0                 ;130
0000ae  7030              STRB     r0,[r6,#0]            ;130
0000b0  7070              STRB     r0,[r6,#1]            ;131
0000b2  70b0              STRB     r0,[r6,#2]            ;132
                  |L2.180|
0000b4  e0b1              B        |L2.538|
                  |L2.182|
0000b6  f812c000          LDRB     r12,[r2,r0]           ;133
0000ba  1c40              ADDS     r0,r0,#1              ;133
0000bc  4461              ADD      r1,r1,r12             ;133
0000be  b2c9              UXTB     r1,r1                 ;133
0000c0  b2c0              UXTB     r0,r0                 ;133
                  |L2.194|
0000c2  4283              CMP      r3,r0                 ;133
0000c4  d8f7              BHI      |L2.182|
0000c6  b109              CBZ      r1,|L2.204|
;;;141                                status = HEX_PARSE_CKSUM_FAIL;
0000c8  2004              MOVS     r0,#4
;;;142                                goto hex_parser_exit;
0000ca  e04c              B        |L2.358|
                  |L2.204|
;;;143                            } else {
;;;144                                if (!record_processed) {
0000cc  78b0              LDRB     r0,[r6,#2]  ; record_processed
0000ce  2800              CMP      r0,#0
0000d0  d147              BNE      |L2.354|
;;;145                                    record_processed = 1;
0000d2  2001              MOVS     r0,#1
0000d4  70b0              STRB     r0,[r6,#2]
;;;146                                    // address byteswap...
;;;147                                    line.address = swap16(line.address);
0000d6  f8991002          LDRB     r1,[r9,#2]  ; line
0000da  f8992001          LDRB     r2,[r9,#1]  ; line
0000de  ea422101          ORR      r1,r2,r1,LSL #8
0000e2  ba49              REV16    r1,r1
0000e4  f8891001          STRB     r1,[r9,#1]
0000e8  0a09              LSRS     r1,r1,#8
0000ea  f8891002          STRB     r1,[r9,#2]
;;;148    
;;;149                                    switch (line.record_type) {
0000ee  f8990003          LDRB     r0,[r9,#3]  ; line
0000f2  b130              CBZ      r0,|L2.258|
0000f4  2801              CMP      r0,#1
0000f6  d036              BEQ      |L2.358|
0000f8  2802              CMP      r0,#2
0000fa  d04a              BEQ      |L2.402|
0000fc  2804              CMP      r0,#4
0000fe  d130              BNE      |L2.354|
000100  e061              B        |L2.454|
                  |L2.258|
;;;150                                        case DATA_RECORD:
;;;151                                            // keeping a record of the last hex record
;;;152                                            memcpy(shadow_line.buf, line.buf, sizeof(hex_line_t));
000102  494b              LDR      r1,|L2.560|
000104  2225              MOVS     r2,#0x25
000106  f1010025          ADD      r0,r1,#0x25
00010a  f7fffffe          BL       __aeabi_memcpy
;;;153    
;;;154                                            // verify this is a continous block of memory or need to exit and dump
;;;155                                            if (((next_address_to_write & 0xffff0000) | line.address) != next_address_to_write) {
00010e  6870              LDR      r0,[r6,#4]  ; next_address_to_write
000110  f8992002          LDRB     r2,[r9,#2]  ; line
000114  f8993001          LDRB     r3,[r9,#1]  ; line
000118  0c01              LSRS     r1,r0,#16
00011a  0409              LSLS     r1,r1,#16
00011c  ea432202          ORR      r2,r3,r2,LSL #8
000120  4311              ORRS     r1,r1,r2
000122  4281              CMP      r1,r0
000124  d003              BEQ      |L2.302|
;;;156                                                load_unaligned_record = 1;
000126  2001              MOVS     r0,#1
000128  70f0              STRB     r0,[r6,#3]
;;;157                                                status = HEX_PARSE_UNALIGNED;
00012a  2002              MOVS     r0,#2
;;;158                                                goto hex_parser_exit;
00012c  e01b              B        |L2.358|
                  |L2.302|
;;;159                                            }
;;;160    
;;;161                                            // move from line buffer back to input buffer
;;;162                                            memcpy(bin_buf, line.data, line.byte_count);
00012e  f1090104          ADD      r1,r9,#4
000132  4638              MOV      r0,r7
000134  9a00              LDR      r2,[sp,#0]
000136  f7fffffe          BL       __aeabi_memcpy
;;;163                                            bin_buf += line.byte_count;
00013a  f8990000          LDRB     r0,[r9,#0]  ; line
;;;164                                            *bin_buf_cnt = (uint32_t)(*bin_buf_cnt) + line.byte_count;
00013e  6821              LDR      r1,[r4,#0]
000140  4407              ADD      r7,r7,r0              ;163
000142  4408              ADD      r0,r0,r1
;;;165                                            // Save next address to write
;;;166                                            next_address_to_write = ((next_address_to_write & 0xffff0000) | line.address) + line.byte_count;
000144  6020              STR      r0,[r4,#0]
000146  6870              LDR      r0,[r6,#4]  ; next_address_to_write
000148  f8992002          LDRB     r2,[r9,#2]  ; line
00014c  0c01              LSRS     r1,r0,#16
00014e  f8993001          LDRB     r3,[r9,#1]  ; line
000152  0409              LSLS     r1,r1,#16
000154  ea432002          ORR      r0,r3,r2,LSL #8
000158  4301              ORRS     r1,r1,r0
00015a  f8990000          LDRB     r0,[r9,#0]  ; line
00015e  4408              ADD      r0,r0,r1
;;;167                                            break;
000160  6070              STR      r0,[r6,#4]  ; next_address_to_write
                  |L2.354|
000162  e056              B        |L2.530|
                  |L2.356|
000164  e04c              B        |L2.512|
                  |L2.358|
;;;168    
;;;169                                        case EOF_RECORD:
;;;170                                            status = HEX_PARSE_EOF;
;;;171                                            goto hex_parser_exit;
;;;172    
;;;173                                        case EXT_SEG_ADDR_RECORD:
;;;174                                            // Could have had data in the buffer so must exit and try to program
;;;175                                            //  before updating bin_buf_address with next_address_to_write
;;;176                                            memset(bin_buf, 0xff, (bin_buf_size - (uint32_t)(*bin_buf_cnt)));
;;;177                                            // figure the start address for the buffer before returning
;;;178                                            *bin_buf_address = next_address_to_write - (uint32_t)(*bin_buf_cnt);
;;;179                                            *hex_parse_cnt = (uint32_t)(hex_blob_size - (end - hex_blob));
;;;180                                            // update the address msb's
;;;181                                            next_address_to_write = (next_address_to_write & 0x00000000) | ((line.data[0] << 12) | (line.data[1] << 4));
;;;182                                            // Need to exit and program if buffer has been filled
;;;183                                            status = HEX_PARSE_UNALIGNED;
;;;184                                            return status;
;;;185    
;;;186                                        case EXT_LINEAR_ADDR_RECORD:
;;;187                                            // Could have had data in the buffer so must exit and try to program
;;;188                                            //  before updating bin_buf_address with next_address_to_write
;;;189                                            //  Good catch Gaute!!
;;;190                                            memset(bin_buf, 0xff, (bin_buf_size - (uint32_t)(*bin_buf_cnt)));
;;;191                                            // figure the start address for the buffer before returning
;;;192                                            *bin_buf_address = next_address_to_write - (uint32_t)(*bin_buf_cnt);
;;;193                                            *hex_parse_cnt = (uint32_t)(hex_blob_size - (end - hex_blob));
;;;194                                            // update the address msb's
;;;195                                            next_address_to_write = (next_address_to_write & 0x00000000) | ((line.data[0] << 24) | (line.data[1] << 16));
;;;196                                            // Need to exit and program if buffer has been filled
;;;197                                            status = HEX_PARSE_UNALIGNED;
;;;198                                            return status;
;;;199    
;;;200                                        default:
;;;201                                            break;
;;;202                                    }
;;;203                                }
;;;204                            }
;;;205                        }
;;;206                    } else {
;;;207                        if (idx < sizeof(hex_line_t)) {
;;;208                            line.buf[idx] = ctoh((uint8_t)(*hex_blob)) << 4;
;;;209                        }
;;;210                    }
;;;211    
;;;212                    low_nibble = !low_nibble;
;;;213                    break;
;;;214            }
;;;215    
;;;216            hex_blob++;
;;;217        }
;;;218    
;;;219        // decoded an entire hex block - verify (cant do this hex_parse_cnt is figured below)
;;;220        //status = (hex_blob_size == (uint32_t)(*hex_parse_cnt)) ? HEX_PARSE_OK : HEX_PARSE_FAILURE;
;;;221        status = HEX_PARSE_OK;
000166  4681              MOV      r9,r0
;;;222    hex_parser_exit:
;;;223        memset(bin_buf, 0xff, (bin_buf_size - (uint32_t)(*bin_buf_cnt)));
000168  6821              LDR      r1,[r4,#0]
00016a  980a              LDR      r0,[sp,#0x28]
00016c  22ff              MOVS     r2,#0xff
00016e  1a41              SUBS     r1,r0,r1
000170  4638              MOV      r0,r7
000172  f7fffffe          BL       __aeabi_memset
;;;224        // figure the start address for the buffer before returning
;;;225        *bin_buf_address = next_address_to_write - (uint32_t)(*bin_buf_cnt);
000176  6820              LDR      r0,[r4,#0]
000178  6871              LDR      r1,[r6,#4]  ; next_address_to_write
00017a  1a09              SUBS     r1,r1,r0
00017c  980b              LDR      r0,[sp,#0x2c]
;;;226        *hex_parse_cnt = (uint32_t)(hex_blob_size - (end - hex_blob));
00017e  6001              STR      r1,[r0,#0]
000180  eba80105          SUB      r1,r8,r5
000184  ebaa0101          SUB      r1,r10,r1
;;;227        return status;
000188  4648              MOV      r0,r9
00018a  f8cb1000          STR      r1,[r11,#0]
                  |L2.398|
;;;228    }
00018e  e8bd8ff8          POP      {r3-r11,pc}
                  |L2.402|
000192  6821              LDR      r1,[r4,#0]            ;176
000194  980a              LDR      r0,[sp,#0x28]         ;176
000196  22ff              MOVS     r2,#0xff              ;176
000198  1a41              SUBS     r1,r0,r1              ;176
00019a  4638              MOV      r0,r7                 ;176
00019c  f7fffffe          BL       __aeabi_memset
0001a0  6820              LDR      r0,[r4,#0]            ;178
0001a2  6871              LDR      r1,[r6,#4]            ;178  ; next_address_to_write
0001a4  1a09              SUBS     r1,r1,r0              ;178
0001a6  980b              LDR      r0,[sp,#0x2c]         ;178
0001a8  6001              STR      r1,[r0,#0]            ;179
0001aa  eba80105          SUB      r1,r8,r5              ;179
0001ae  ebaa0101          SUB      r1,r10,r1             ;179
0001b2  f8cb1000          STR      r1,[r11,#0]           ;181
0001b6  f8991004          LDRB     r1,[r9,#4]            ;181  ; line
0001ba  f8990005          LDRB     r0,[r9,#5]            ;181  ; line
0001be  0309              LSLS     r1,r1,#12             ;181
0001c0  ea411000          ORR      r0,r1,r0,LSL #4       ;181
0001c4  e019              B        |L2.506|
                  |L2.454|
0001c6  6821              LDR      r1,[r4,#0]            ;190
0001c8  980a              LDR      r0,[sp,#0x28]         ;190
0001ca  22ff              MOVS     r2,#0xff              ;190
0001cc  1a41              SUBS     r1,r0,r1              ;190
0001ce  4638              MOV      r0,r7                 ;190
0001d0  f7fffffe          BL       __aeabi_memset
0001d4  6820              LDR      r0,[r4,#0]            ;192
0001d6  6871              LDR      r1,[r6,#4]            ;192  ; next_address_to_write
0001d8  1a09              SUBS     r1,r1,r0              ;192
0001da  980b              LDR      r0,[sp,#0x2c]         ;192
0001dc  6001              STR      r1,[r0,#0]            ;193
0001de  eba80105          SUB      r1,r8,r5              ;193
0001e2  ebaa0101          SUB      r1,r10,r1             ;193
0001e6  f8cb1000          STR      r1,[r11,#0]           ;195
0001ea  f8991005          LDRB     r1,[r9,#5]            ;195  ; line
0001ee  f8992004          LDRB     r2,[r9,#4]            ;195  ; line
0001f2  ea422001          ORR      r0,r2,r1,LSL #8       ;195
0001f6  ba40              REV16    r0,r0                 ;195
0001f8  0400              LSLS     r0,r0,#16             ;195
                  |L2.506|
0001fa  6070              STR      r0,[r6,#4]            ;197  ; next_address_to_write
0001fc  2002              MOVS     r0,#2                 ;197
0001fe  e7c6              B        |L2.398|
                  |L2.512|
000200  7871              LDRB     r1,[r6,#1]            ;207  ; idx
000202  2925              CMP      r1,#0x25              ;207
000204  d20f              BCS      |L2.550|
000206  f7fffffe          BL       ctoh
00020a  7872              LDRB     r2,[r6,#1]            ;208  ; idx
00020c  0101              LSLS     r1,r0,#4              ;208
00020e  f8091002          STRB     r1,[r9,r2]            ;208
                  |L2.530|
000212  7830              LDRB     r0,[r6,#0]            ;212  ; low_nibble
000214  b138              CBZ      r0,|L2.550|
000216  2000              MOVS     r0,#0                 ;212
                  |L2.536|
000218  7030              STRB     r0,[r6,#0]            ;212
                  |L2.538|
00021a  1c6d              ADDS     r5,r5,#1              ;212
                  |L2.540|
00021c  4545              CMP      r5,r8                 ;118
00021e  f47faf1e          BNE      |L2.94|
000222  2000              MOVS     r0,#0                 ;221
000224  e79f              B        |L2.358|
                  |L2.550|
000226  2001              MOVS     r0,#1                 ;212
000228  e7f6              B        |L2.536|
                          ENDP

00022a  0000              DCW      0x0000
                  |L2.556|
                          DCD      ||.data||
                  |L2.560|
                          DCD      ||.bss||

                          AREA ||i.reset_hex_parser||, CODE, READONLY, ALIGN=2

                  reset_hex_parser PROC
;;;85     
;;;86     void reset_hex_parser(void)
000000  b510              PUSH     {r4,lr}
;;;87     {
;;;88         memset(line.buf, 0, sizeof(hex_line_t));
000002  2125              MOVS     r1,#0x25
000004  4807              LDR      r0,|L3.36|
000006  f7fffffe          BL       __aeabi_memclr
;;;89         memset(shadow_line.buf, 0, sizeof(hex_line_t));
00000a  4806              LDR      r0,|L3.36|
00000c  2125              MOVS     r1,#0x25
00000e  3025              ADDS     r0,r0,#0x25
000010  f7fffffe          BL       __aeabi_memclr
;;;90         next_address_to_write = 0;
000014  4804              LDR      r0,|L3.40|
000016  2100              MOVS     r1,#0
;;;91         low_nibble = 0;
000018  6041              STR      r1,[r0,#4]  ; next_address_to_write
00001a  7001              STRB     r1,[r0,#0]
;;;92         idx = 0;
00001c  7041              STRB     r1,[r0,#1]
;;;93         record_processed = 0;
00001e  7081              STRB     r1,[r0,#2]
;;;94         load_unaligned_record = 0;
000020  70c1              STRB     r1,[r0,#3]
;;;95     }
000022  bd10              POP      {r4,pc}
;;;96     
                          ENDP

                  |L3.36|
                          DCD      ||.bss||
                  |L3.40|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  line
                          %        37
                  shadow_line
                          %        37

                          AREA ||.data||, DATA, ALIGN=2

                  low_nibble
000000  00                DCB      0x00
                  idx
000001  00                DCB      0x00
                  record_processed
000002  00                DCB      0x00
                  load_unaligned_record
000003  00                DCB      0x00
                  next_address_to_write
                          DCD      0x00000000
