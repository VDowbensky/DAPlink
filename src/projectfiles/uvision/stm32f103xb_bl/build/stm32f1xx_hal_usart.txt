; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\stm32f1xx_hal_usart.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f1xx_hal_usart.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\stm32f1xx_hal_usart.crf ..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1074     */
;;;1075   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  f890103c          LDRB     r1,[r0,#0x3c]
;;;1076   {
;;;1077     /* Process Locked */
;;;1078     __HAL_LOCK(husart);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L1.34|
000008  2101              MOVS     r1,#1
00000a  f880103c          STRB     r1,[r0,#0x3c]
;;;1079     
;;;1080     /* Disable the USART DMA Tx request */
;;;1081     CLEAR_BIT(husart->Instance->CR3, (uint32_t)(USART_CR3_DMAT));
00000e  6801              LDR      r1,[r0,#0]
000010  694a              LDR      r2,[r1,#0x14]
000012  f0220280          BIC      r2,r2,#0x80
000016  614a              STR      r2,[r1,#0x14]
;;;1082     
;;;1083     /* Process Unlocked */
;;;1084     __HAL_UNLOCK(husart);
000018  2100              MOVS     r1,#0
00001a  f880103c          STRB     r1,[r0,#0x3c]
;;;1085   
;;;1086     return HAL_OK; 
00001e  4608              MOV      r0,r1
;;;1087   }
000020  4770              BX       lr
                  |L1.34|
000022  2002              MOVS     r0,#2                 ;1078
000024  4770              BX       lr
;;;1088   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1094     */
;;;1095   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  f890103c          LDRB     r1,[r0,#0x3c]
;;;1096   {
;;;1097     /* Process Locked */
;;;1098     __HAL_LOCK(husart);
000004  2901              CMP      r1,#1
000006  d00c              BEQ      |L2.34|
000008  2101              MOVS     r1,#1
00000a  f880103c          STRB     r1,[r0,#0x3c]
;;;1099     
;;;1100     /* Enable the USART DMA Tx request */
;;;1101     SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00000e  6801              LDR      r1,[r0,#0]
000010  694a              LDR      r2,[r1,#0x14]
000012  f0420280          ORR      r2,r2,#0x80
000016  614a              STR      r2,[r1,#0x14]
;;;1102     
;;;1103     /* Process Unlocked */
;;;1104     __HAL_UNLOCK(husart);
000018  2100              MOVS     r1,#0
00001a  f880103c          STRB     r1,[r0,#0x3c]
;;;1105   
;;;1106     return HAL_OK;
00001e  4608              MOV      r0,r1
;;;1107   }
000020  4770              BX       lr
                  |L2.34|
000022  2002              MOVS     r0,#2                 ;1098
000024  4770              BX       lr
;;;1108   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1114     */
;;;1115   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1116   {
000002  4604              MOV      r4,r0
;;;1117     /* The Lock is not implemented on this API to allow the user application
;;;1118        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback():
;;;1119        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1120        and the correspond call back is executed HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback()
;;;1121        */
;;;1122   
;;;1123     /* Abort the USART DMA Tx channel */
;;;1124     if(husart->hdmatx != NULL)
000004  6b40              LDR      r0,[r0,#0x34]
000006  b108              CBZ      r0,|L3.12|
;;;1125     {
;;;1126       HAL_DMA_Abort(husart->hdmatx);
000008  f7fffffe          BL       HAL_DMA_Abort
                  |L3.12|
;;;1127     }
;;;1128     /* Abort the USART DMA Rx channel */
;;;1129     if(husart->hdmarx != NULL)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  b108              CBZ      r0,|L3.20|
;;;1130     {  
;;;1131       HAL_DMA_Abort(husart->hdmarx);
000010  f7fffffe          BL       HAL_DMA_Abort
                  |L3.20|
;;;1132     }
;;;1133     
;;;1134     /* Disable the USART Tx/Rx DMA requests */
;;;1135     CLEAR_BIT(husart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
000014  6820              LDR      r0,[r4,#0]
000016  6941              LDR      r1,[r0,#0x14]
000018  f02101c0          BIC      r1,r1,#0xc0
00001c  6141              STR      r1,[r0,#0x14]
;;;1136   
;;;1137     husart->State = HAL_USART_STATE_READY;
00001e  2001              MOVS     r0,#1
000020  f884003d          STRB     r0,[r4,#0x3d]
;;;1138   
;;;1139     return HAL_OK;
000024  2000              MOVS     r0,#0
;;;1140   }
000026  bd10              POP      {r4,pc}
;;;1141   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;289      */
;;;290    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;291    {
000002  0004              MOVS     r4,r0
000004  d011              BEQ      |L4.42|
;;;292       /* Check the USART handle allocation */
;;;293      if(husart == NULL)
;;;294      {
;;;295        return HAL_ERROR;
;;;296      }
;;;297    
;;;298      /* Check the parameters */
;;;299      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;300    
;;;301      husart->State = HAL_USART_STATE_BUSY;
000006  2002              MOVS     r0,#2
000008  f884003d          STRB     r0,[r4,#0x3d]
;;;302    
;;;303      /* Disable the Peripheral */
;;;304      __HAL_USART_DISABLE(husart);
00000c  6820              LDR      r0,[r4,#0]
00000e  68c1              LDR      r1,[r0,#0xc]
000010  f4215100          BIC      r1,r1,#0x2000
000014  60c1              STR      r1,[r0,#0xc]
;;;305    
;;;306      /* DeInit the low level hardware */
;;;307      HAL_USART_MspDeInit(husart);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_USART_MspDeInit
;;;308    
;;;309      husart->ErrorCode = HAL_USART_ERROR_NONE;
00001c  2000              MOVS     r0,#0
00001e  6420              STR      r0,[r4,#0x40]
;;;310      husart->State = HAL_USART_STATE_RESET;
000020  f884003d          STRB     r0,[r4,#0x3d]
;;;311    
;;;312      /* Release Lock */
;;;313      __HAL_UNLOCK(husart);
000024  f884003c          STRB     r0,[r4,#0x3c]
;;;314    
;;;315      return HAL_OK;
;;;316    }
000028  bd10              POP      {r4,pc}
                  |L4.42|
00002a  2001              MOVS     r0,#1                 ;295
00002c  bd10              POP      {r4,pc}
;;;317    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;1314     */
;;;1315    __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1316   {
;;;1317     /* Prevent unused argument(s) compilation warning */
;;;1318     UNUSED(husart);
;;;1319     /* NOTE: This function should not be modified, when the callback is needed,
;;;1320              the HAL_USART_ErrorCallback can be implemented in the user file
;;;1321      */ 
;;;1322   }
;;;1323   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;1363     */
;;;1364   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  6c00              LDR      r0,[r0,#0x40]
;;;1365   {
;;;1366     return husart->ErrorCode;
;;;1367   }
000002  4770              BX       lr
;;;1368   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;1352     */
;;;1353   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;1354   {
;;;1355     return husart->State;
;;;1356   }
000004  4770              BX       lr
;;;1357   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_USART_IRQHandler PROC
;;;1147     */
;;;1148   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  b538              PUSH     {r3-r5,lr}
;;;1149   {
000002  4604              MOV      r4,r0
;;;1150     uint32_t tmp_flag = 0, tmp_it_source = 0;
;;;1151     
;;;1152     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_PE);
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
;;;1153     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_PE);
000008  68c2              LDR      r2,[r0,#0xc]
00000a  f3c10100          UBFX     r1,r1,#0,#1           ;1152
00000e  f4027280          AND      r2,r2,#0x100
000012  b121              CBZ      r1,|L8.30|
;;;1154     /* USART parity error interrupt occurred -----------------------------------*/
;;;1155     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000014  b11a              CBZ      r2,|L8.30|
;;;1156     {
;;;1157       husart->ErrorCode |= HAL_USART_ERROR_PE;
000016  6c21              LDR      r1,[r4,#0x40]
000018  f0410101          ORR      r1,r1,#1
00001c  6421              STR      r1,[r4,#0x40]
                  |L8.30|
;;;1158     }
;;;1159   
;;;1160     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_FE);
00001e  6801              LDR      r1,[r0,#0]
000020  f3c10240          UBFX     r2,r1,#1,#1
;;;1161     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_ERR);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0010101          AND      r1,r1,#1
;;;1162     /* USART frame error interrupt occurred ------------------------------------*/
;;;1163     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00002a  b122              CBZ      r2,|L8.54|
00002c  b119              CBZ      r1,|L8.54|
;;;1164     {
;;;1165       husart->ErrorCode |= HAL_USART_ERROR_FE;
00002e  6c22              LDR      r2,[r4,#0x40]
000030  f0420204          ORR      r2,r2,#4
000034  6422              STR      r2,[r4,#0x40]
                  |L8.54|
;;;1166     }
;;;1167   
;;;1168     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_NE);
000036  6802              LDR      r2,[r0,#0]
000038  f3c20280          UBFX     r2,r2,#2,#1
;;;1169     /* USART noise error interrupt occurred ------------------------------------*/
;;;1170     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00003c  b122              CBZ      r2,|L8.72|
00003e  b119              CBZ      r1,|L8.72|
;;;1171     {
;;;1172       husart->ErrorCode |= HAL_USART_ERROR_NE;
000040  6c22              LDR      r2,[r4,#0x40]
000042  f0420202          ORR      r2,r2,#2
000046  6422              STR      r2,[r4,#0x40]
                  |L8.72|
;;;1173     }
;;;1174   
;;;1175     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_ORE);
000048  6802              LDR      r2,[r0,#0]
00004a  f3c202c0          UBFX     r2,r2,#3,#1
;;;1176     /* USART Over-Run interrupt occurred ---------------------------------------*/
;;;1177     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00004e  b122              CBZ      r2,|L8.90|
000050  b119              CBZ      r1,|L8.90|
;;;1178     {
;;;1179       husart->ErrorCode |= HAL_USART_ERROR_ORE;
000052  6c21              LDR      r1,[r4,#0x40]
000054  f0410108          ORR      r1,r1,#8
000058  6421              STR      r1,[r4,#0x40]
                  |L8.90|
;;;1180     }
;;;1181   
;;;1182     if(husart->ErrorCode != HAL_USART_ERROR_NONE)
00005a  6c21              LDR      r1,[r4,#0x40]
;;;1183     {
;;;1184       /* Clear all the error flag at once */
;;;1185       __HAL_USART_CLEAR_PEFLAG(husart);
;;;1186   
;;;1187       /* Set the USART state ready to be able to start again the process */
;;;1188       husart->State = HAL_USART_STATE_READY;
00005c  2501              MOVS     r5,#1
00005e  b139              CBZ      r1,|L8.112|
000060  6801              LDR      r1,[r0,#0]            ;1185
000062  6840              LDR      r0,[r0,#4]            ;1185
000064  9000              STR      r0,[sp,#0]
000066  f884503d          STRB     r5,[r4,#0x3d]
;;;1189       
;;;1190       HAL_USART_ErrorCallback(husart);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_USART_ErrorCallback
                  |L8.112|
;;;1191     }
;;;1192   
;;;1193     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE);
000070  6820              LDR      r0,[r4,#0]
000072  6801              LDR      r1,[r0,#0]
;;;1194     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_RXNE);
000074  68c0              LDR      r0,[r0,#0xc]
000076  f3c11140          UBFX     r1,r1,#5,#1           ;1193
00007a  f0000020          AND      r0,r0,#0x20
;;;1195     /* USART in mode Receiver --------------------------------------------------*/
;;;1196     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00007e  b139              CBZ      r1,|L8.144|
000080  b130              CBZ      r0,|L8.144|
;;;1197     {
;;;1198       if(husart->State == HAL_USART_STATE_BUSY_RX)
000082  f894003d          LDRB     r0,[r4,#0x3d]
000086  2822              CMP      r0,#0x22
;;;1199       {
;;;1200         USART_Receive_IT(husart);
;;;1201       }
;;;1202       else
;;;1203       {
;;;1204         USART_TransmitReceive_IT(husart);
000088  4620              MOV      r0,r4
00008a  d02b              BEQ      |L8.228|
00008c  f7fffffe          BL       USART_TransmitReceive_IT
                  |L8.144|
;;;1205       }
;;;1206     }
;;;1207   
;;;1208     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_TXE);
000090  6820              LDR      r0,[r4,#0]
000092  6801              LDR      r1,[r0,#0]
;;;1209     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TXE);
000094  68c0              LDR      r0,[r0,#0xc]
000096  f3c111c0          UBFX     r1,r1,#7,#1           ;1208
00009a  f0000080          AND      r0,r0,#0x80
;;;1210     /* USART in mode Transmitter -----------------------------------------------*/
;;;1211     if((tmp_flag != RESET) && (tmp_it_source != RESET))
00009e  b139              CBZ      r1,|L8.176|
0000a0  b130              CBZ      r0,|L8.176|
;;;1212     {
;;;1213       if(husart->State == HAL_USART_STATE_BUSY_TX)
0000a2  f894003d          LDRB     r0,[r4,#0x3d]
0000a6  2812              CMP      r0,#0x12
;;;1214       {
;;;1215         USART_Transmit_IT(husart);
;;;1216       }
;;;1217       else
;;;1218       {
;;;1219         USART_TransmitReceive_IT(husart);
0000a8  4620              MOV      r0,r4
0000aa  d01e              BEQ      |L8.234|
0000ac  f7fffffe          BL       USART_TransmitReceive_IT
                  |L8.176|
;;;1220       }
;;;1221     }
;;;1222     
;;;1223     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_TC);
0000b0  6821              LDR      r1,[r4,#0]
0000b2  6808              LDR      r0,[r1,#0]
;;;1224     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TC);
0000b4  68ca              LDR      r2,[r1,#0xc]
0000b6  f3c01080          UBFX     r0,r0,#6,#1           ;1223
0000ba  f0020240          AND      r2,r2,#0x40
;;;1225     /* USART in mode Transmitter (transmission end) -----------------------------*/
;;;1226     if((tmp_flag != RESET) && (tmp_it_source != RESET))
0000be  2800              CMP      r0,#0
0000c0  d00f              BEQ      |L8.226|
0000c2  2a00              CMP      r2,#0
0000c4  d00d              BEQ      |L8.226|
0000c6  68ca              LDR      r2,[r1,#0xc]
;;;1227     {
;;;1228       USART_EndTransmit_IT(husart);
0000c8  4620              MOV      r0,r4
0000ca  f0220240          BIC      r2,r2,#0x40
0000ce  60ca              STR      r2,[r1,#0xc]
0000d0  6821              LDR      r1,[r4,#0]
0000d2  694a              LDR      r2,[r1,#0x14]
0000d4  f0220201          BIC      r2,r2,#1
0000d8  614a              STR      r2,[r1,#0x14]
0000da  f884503d          STRB     r5,[r4,#0x3d]
0000de  f7fffffe          BL       HAL_USART_TxCpltCallback
                  |L8.226|
;;;1229     } 
;;;1230   
;;;1231   }
0000e2  bd38              POP      {r3-r5,pc}
                  |L8.228|
0000e4  f7fffffe          BL       USART_Receive_IT
0000e8  e7d2              B        |L8.144|
                  |L8.234|
0000ea  f7fffffe          BL       USART_Transmit_IT
0000ee  e7df              B        |L8.176|
;;;1232   
                          ENDP


                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=1

                  HAL_USART_Init PROC
;;;242      */
;;;243    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;244    {
000002  0004              MOVS     r4,r0
000004  d004              BEQ      |L9.16|
;;;245      /* Check the USART handle allocation */
;;;246      if(husart == NULL)
;;;247      {
;;;248        return HAL_ERROR;
;;;249      }
;;;250    
;;;251      /* Check the parameters */
;;;252      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;253    
;;;254      if(husart->State == HAL_USART_STATE_RESET)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  2500              MOVS     r5,#0
00000c  b110              CBZ      r0,|L9.20|
00000e  e006              B        |L9.30|
                  |L9.16|
000010  2001              MOVS     r0,#1                 ;248
;;;255      {
;;;256        /* Allocate lock resource and initialize it */
;;;257        husart->Lock = HAL_UNLOCKED;
;;;258        
;;;259        /* Init the low level hardware */
;;;260        HAL_USART_MspInit(husart);
;;;261      }
;;;262      
;;;263      husart->State = HAL_USART_STATE_BUSY;
;;;264    
;;;265      /* Set the USART Communication parameters */
;;;266      USART_SetConfig(husart);
;;;267    
;;;268      /* In USART mode, the following bits must be kept cleared: 
;;;269         - LINEN bit in the USART_CR2 register
;;;270         - HDSEL, SCEN and IREN bits in the USART_CR3 register */
;;;271      CLEAR_BIT(husart->Instance->CR2, USART_CR2_LINEN);
;;;272      CLEAR_BIT(husart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN | USART_CR3_HDSEL));
;;;273    
;;;274      /* Enable the Peripheral */
;;;275      __HAL_USART_ENABLE(husart);
;;;276    
;;;277      /* Initialize the USART state */
;;;278      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;279      husart->State= HAL_USART_STATE_READY;
;;;280    
;;;281      return HAL_OK;
;;;282    }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  f884503c          STRB     r5,[r4,#0x3c]         ;257
000018  4620              MOV      r0,r4                 ;260
00001a  f7fffffe          BL       HAL_USART_MspInit
                  |L9.30|
00001e  2002              MOVS     r0,#2                 ;263
000020  f884003d          STRB     r0,[r4,#0x3d]         ;263
000024  4620              MOV      r0,r4                 ;266
000026  f7fffffe          BL       USART_SetConfig
00002a  6820              LDR      r0,[r4,#0]            ;271
00002c  6901              LDR      r1,[r0,#0x10]         ;271
00002e  f4214180          BIC      r1,r1,#0x4000         ;271
000032  6101              STR      r1,[r0,#0x10]         ;271
000034  6820              LDR      r0,[r4,#0]            ;272
000036  6941              LDR      r1,[r0,#0x14]         ;272
000038  f021012a          BIC      r1,r1,#0x2a           ;272
00003c  6141              STR      r1,[r0,#0x14]         ;272
00003e  6820              LDR      r0,[r4,#0]            ;275
000040  68c1              LDR      r1,[r0,#0xc]          ;275
000042  f4415100          ORR      r1,r1,#0x2000         ;275
000046  60c1              STR      r1,[r0,#0xc]          ;275
000048  6425              STR      r5,[r4,#0x40]         ;278
00004a  2001              MOVS     r0,#1                 ;279
00004c  f884003d          STRB     r0,[r4,#0x3d]         ;279
000050  2000              MOVS     r0,#0                 ;281
000052  bd70              POP      {r4-r6,pc}
;;;283    
                          ENDP


                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;338      */
;;;339     __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;340    {
;;;341      /* Prevent unused argument(s) compilation warning */
;;;342      UNUSED(husart);
;;;343      /* NOTE: This function should not be modified, when the callback is needed,
;;;344               the HAL_USART_MspDeInit can be implemented in the user file
;;;345       */ 
;;;346    }
;;;347    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;323      */
;;;324     __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;325    {
;;;326      /* Prevent unused argument(s) compilation warning */
;;;327      UNUSED(husart);
;;;328      /* NOTE: This function should not be modified, when the callback is needed,
;;;329               the HAL_USART_MspInit can be implemented in the user file
;;;330       */ 
;;;331    }
;;;332    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive PROC
;;;498      */
;;;499    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;500    {
000004  4604              MOV      r4,r0
;;;501      uint16_t* tmp=0;
;;;502    
;;;503      if(husart->State == HAL_USART_STATE_READY)
000006  f890003d          LDRB     r0,[r0,#0x3d]
00000a  4698              MOV      r8,r3                 ;500
00000c  460d              MOV      r5,r1                 ;500
00000e  2801              CMP      r0,#1
000010  d15d              BNE      |L12.206|
;;;504      {
;;;505        if((pRxData == NULL) || (Size == 0)) 
000012  b17d              CBZ      r5,|L12.52|
000014  b172              CBZ      r2,|L12.52|
;;;506        {
;;;507          return  HAL_ERROR;
;;;508        }
;;;509        
;;;510        /* Process Locked */
;;;511        __HAL_LOCK(husart);
000016  f894003c          LDRB     r0,[r4,#0x3c]
00001a  2801              CMP      r0,#1
00001c  d057              BEQ      |L12.206|
00001e  2601              MOVS     r6,#1
000020  f884603c          STRB     r6,[r4,#0x3c]
;;;512    
;;;513        husart->ErrorCode = HAL_USART_ERROR_NONE;
000024  2700              MOVS     r7,#0
000026  6427              STR      r7,[r4,#0x40]
;;;514        husart->State = HAL_USART_STATE_BUSY_RX;
000028  2022              MOVS     r0,#0x22
00002a  f884003d          STRB     r0,[r4,#0x3d]
;;;515    
;;;516        husart->RxXferSize = Size;
00002e  8622              STRH     r2,[r4,#0x30]
;;;517        husart->RxXferCount = Size;
000030  8662              STRH     r2,[r4,#0x32]
000032  e044              B        |L12.190|
                  |L12.52|
000034  2001              MOVS     r0,#1                 ;507
                  |L12.54|
;;;518        /* Check the remain data to be received */
;;;519        while(husart->RxXferCount > 0)
;;;520        {
;;;521          husart->RxXferCount--;
;;;522          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;523          {
;;;524            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;525            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;526            { 
;;;527              return HAL_TIMEOUT;
;;;528            }
;;;529            /* Send dummy byte in order to generate clock */
;;;530            WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));
;;;531            
;;;532            /* Wait for RXNE Flag */
;;;533            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;534            { 
;;;535              return HAL_TIMEOUT;
;;;536            }
;;;537            tmp = (uint16_t*) pRxData ;
;;;538            if(husart->Init.Parity == USART_PARITY_NONE)
;;;539            {
;;;540              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;541              pRxData +=2;
;;;542            }
;;;543            else
;;;544            {
;;;545              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;546              pRxData +=1;
;;;547            }
;;;548          }
;;;549          else
;;;550          {
;;;551            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;552            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;553            { 
;;;554              return HAL_TIMEOUT;
;;;555            }
;;;556    
;;;557            /* Send Dummy Byte in order to generate clock */
;;;558            WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));
;;;559    
;;;560            /* Wait until RXNE flag is set to receive the byte */
;;;561            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;562            {
;;;563              return HAL_TIMEOUT;
;;;564            }
;;;565            if(husart->Init.Parity == USART_PARITY_NONE)
;;;566            {
;;;567              /* Receive data */
;;;568              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;569            }
;;;570            else
;;;571            {
;;;572              /* Receive data */
;;;573              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;574            }
;;;575            
;;;576          }
;;;577        }
;;;578    
;;;579        husart->State = HAL_USART_STATE_READY;
;;;580    
;;;581        /* Process Unlocked */
;;;582        __HAL_UNLOCK(husart);
;;;583    
;;;584        return HAL_OK;
;;;585      }
;;;586      else
;;;587      {
;;;588        return HAL_BUSY;
;;;589      }
;;;590    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L12.58|
00003a  8e60              LDRH     r0,[r4,#0x32]         ;521
00003c  1e40              SUBS     r0,r0,#1              ;521
00003e  8660              STRH     r0,[r4,#0x32]         ;521
000040  68a0              LDR      r0,[r4,#8]            ;522
000042  4643              MOV      r3,r8                 ;552
000044  f5b05f80          CMP      r0,#0x1000            ;522
000048  f04f0200          MOV      r2,#0                 ;552
00004c  f04f0180          MOV      r1,#0x80              ;552
000050  4620              MOV      r0,r4                 ;552
000052  d003              BEQ      |L12.92|
000054  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000058  bb30              CBNZ     r0,|L12.168|
00005a  e01b              B        |L12.148|
                  |L12.92|
00005c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000060  bb10              CBNZ     r0,|L12.168|
000062  6821              LDR      r1,[r4,#0]            ;530
000064  f24010ff          MOV      r0,#0x1ff             ;530
000068  6048              STR      r0,[r1,#4]            ;530
00006a  4643              MOV      r3,r8                 ;533
00006c  2200              MOVS     r2,#0                 ;533
00006e  2120              MOVS     r1,#0x20              ;533
000070  4620              MOV      r0,r4                 ;533
000072  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000076  b9b8              CBNZ     r0,|L12.168|
000078  6920              LDR      r0,[r4,#0x10]         ;538
00007a  2800              CMP      r0,#0                 ;538
00007c  6820              LDR      r0,[r4,#0]            ;545
00007e  6840              LDR      r0,[r0,#4]            ;545
000080  d003              BEQ      |L12.138|
000082  b2c1              UXTB     r1,r0                 ;545
000084  f8251b01          STRH     r1,[r5],#1            ;545
000088  e019              B        |L12.190|
                  |L12.138|
00008a  f3c00108          UBFX     r1,r0,#0,#9           ;540
00008e  f8251b02          STRH     r1,[r5],#2            ;540
000092  e014              B        |L12.190|
                  |L12.148|
000094  6821              LDR      r1,[r4,#0]            ;558
000096  20ff              MOVS     r0,#0xff              ;558
000098  6048              STR      r0,[r1,#4]            ;558
00009a  4643              MOV      r3,r8                 ;561
00009c  2200              MOVS     r2,#0                 ;561
00009e  2120              MOVS     r1,#0x20              ;561
0000a0  4620              MOV      r0,r4                 ;561
0000a2  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000a6  b108              CBZ      r0,|L12.172|
                  |L12.168|
0000a8  2003              MOVS     r0,#3                 ;563
0000aa  e7c4              B        |L12.54|
                  |L12.172|
0000ac  6920              LDR      r0,[r4,#0x10]         ;565
0000ae  2800              CMP      r0,#0                 ;565
0000b0  6820              LDR      r0,[r4,#0]            ;573
0000b2  6840              LDR      r0,[r0,#4]            ;573
0000b4  d001              BEQ      |L12.186|
0000b6  f000007f          AND      r0,r0,#0x7f           ;573
                  |L12.186|
0000ba  f8050b01          STRB     r0,[r5],#1            ;568
                  |L12.190|
0000be  8e60              LDRH     r0,[r4,#0x32]         ;519
0000c0  2800              CMP      r0,#0                 ;519
0000c2  d1ba              BNE      |L12.58|
0000c4  f884603d          STRB     r6,[r4,#0x3d]         ;579
0000c8  f884703c          STRB     r7,[r4,#0x3c]         ;582
0000cc  e7b3              B        |L12.54|
                  |L12.206|
0000ce  2002              MOVS     r0,#2                 ;588
0000d0  e7b1              B        |L12.54|
;;;591    
                          ENDP


                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;923      */
;;;924    HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;925    {
000002  4604              MOV      r4,r0
;;;926      uint32_t *tmp=0;
;;;927      
;;;928      if(husart->State == HAL_USART_STATE_READY)
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  b081              SUB      sp,sp,#4              ;925
00000a  4615              MOV      r5,r2                 ;925
00000c  2801              CMP      r0,#1
00000e  d13d              BNE      |L13.140|
;;;929      {
;;;930        if((pRxData == NULL) || (Size == 0)) 
000010  9a02              LDR      r2,[sp,#8]
000012  b3c2              CBZ      r2,|L13.134|
000014  b3bd              CBZ      r5,|L13.134|
;;;931        {
;;;932          return HAL_ERROR;
;;;933        }
;;;934    
;;;935        /* Process Locked */
;;;936        __HAL_LOCK(husart);
000016  f894003c          LDRB     r0,[r4,#0x3c]
00001a  2801              CMP      r0,#1
00001c  d036              BEQ      |L13.140|
00001e  2001              MOVS     r0,#1
000020  f884003c          STRB     r0,[r4,#0x3c]
;;;937    
;;;938        husart->pRxBuffPtr = pRxData;
;;;939        husart->RxXferSize = Size;
000024  62e2              STR      r2,[r4,#0x2c]
000026  8625              STRH     r5,[r4,#0x30]
;;;940        husart->pTxBuffPtr = pRxData;
;;;941        husart->TxXferSize = Size;
000028  6262              STR      r2,[r4,#0x24]
00002a  8525              STRH     r5,[r4,#0x28]
;;;942    
;;;943        husart->ErrorCode = HAL_USART_ERROR_NONE;
00002c  2600              MOVS     r6,#0
00002e  6426              STR      r6,[r4,#0x40]
;;;944        husart->State = HAL_USART_STATE_BUSY_RX;
000030  2022              MOVS     r0,#0x22
000032  f884003d          STRB     r0,[r4,#0x3d]
;;;945    
;;;946        /* Set the USART DMA Rx transfer complete callback */
;;;947        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
000036  6ba1              LDR      r1,[r4,#0x38]
000038  4815              LDR      r0,|L13.144|
;;;948    
;;;949        /* Set the USART DMA Half transfer complete callback */
;;;950        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;951    
;;;952        /* Set the USART DMA Rx transfer error callback */
;;;953        husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;954    
;;;955        /* Enable the USART receive DMA channel */
;;;956        tmp = (uint32_t*)&pRxData;
;;;957        HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
00003a  462b              MOV      r3,r5
00003c  6288              STR      r0,[r1,#0x28]         ;950
00003e  6ba1              LDR      r1,[r4,#0x38]         ;950
000040  4814              LDR      r0,|L13.148|
000042  62c8              STR      r0,[r1,#0x2c]         ;953
000044  6ba1              LDR      r1,[r4,#0x38]         ;953
000046  4814              LDR      r0,|L13.152|
000048  6308              STR      r0,[r1,#0x30]
00004a  6821              LDR      r1,[r4,#0]
00004c  6ba0              LDR      r0,[r4,#0x38]
00004e  1d09              ADDS     r1,r1,#4
000050  f7fffffe          BL       HAL_DMA_Start_IT
;;;958    
;;;959        /* Enable the USART transmit DMA channel: the transmit channel is used in order
;;;960           to generate in the non-blocking mode the clock to the slave device, 
;;;961           this mode isn't a simplex receive mode but a full-duplex receive one */
;;;962        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
000054  6822              LDR      r2,[r4,#0]
000056  9902              LDR      r1,[sp,#8]
000058  462b              MOV      r3,r5
00005a  1d12              ADDS     r2,r2,#4
00005c  6b60              LDR      r0,[r4,#0x34]
00005e  f7fffffe          BL       HAL_DMA_Start_IT
;;;963    
;;;964        /* Clear the Overrun flag just before enabling the DMA Rx request: mandatory for the second transfer
;;;965           when using the USART in circular mode */
;;;966        __HAL_USART_CLEAR_OREFLAG(husart);
000062  6820              LDR      r0,[r4,#0]
000064  6801              LDR      r1,[r0,#0]
000066  6841              LDR      r1,[r0,#4]
;;;967        
;;;968        /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;969           in the USART CR3 register */
;;;970        SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000068  9100              STR      r1,[sp,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  f0410140          ORR      r1,r1,#0x40
000070  6141              STR      r1,[r0,#0x14]
;;;971    
;;;972        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;973           in the USART CR3 register */
;;;974        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000072  6820              LDR      r0,[r4,#0]
000074  6941              LDR      r1,[r0,#0x14]
000076  f0410180          ORR      r1,r1,#0x80
00007a  6141              STR      r1,[r0,#0x14]
;;;975    
;;;976        /* Process Unlocked */
;;;977        __HAL_UNLOCK(husart);
00007c  f884603c          STRB     r6,[r4,#0x3c]
;;;978    
;;;979        return HAL_OK;
000080  2000              MOVS     r0,#0
                  |L13.130|
;;;980      }
;;;981      else
;;;982      {
;;;983        return HAL_BUSY;
;;;984      }
;;;985    }
000082  b004              ADD      sp,sp,#0x10
000084  bd70              POP      {r4-r6,pc}
                  |L13.134|
000086  e7ff              B        |L13.136|
                  |L13.136|
000088  2001              MOVS     r0,#1                 ;932
00008a  e7fa              B        |L13.130|
                  |L13.140|
00008c  2002              MOVS     r0,#2                 ;983
00008e  e7f8              B        |L13.130|
;;;986    
                          ENDP

                  |L13.144|
                          DCD      USART_DMAReceiveCplt
                  |L13.148|
                          DCD      USART_DMARxHalfCplt
                  |L13.152|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive_IT PROC
;;;760      */
;;;761    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  f890303d          LDRB     r3,[r0,#0x3d]
;;;762    {
;;;763      if(husart->State == HAL_USART_STATE_READY)
000004  2b01              CMP      r3,#1
000006  d126              BNE      |L14.86|
;;;764      {
;;;765        if((pRxData == NULL) || (Size == 0)) 
000008  b319              CBZ      r1,|L14.82|
00000a  b312              CBZ      r2,|L14.82|
;;;766        {
;;;767          return HAL_ERROR;
;;;768        }
;;;769        /* Process Locked */
;;;770        __HAL_LOCK(husart);
00000c  f890303c          LDRB     r3,[r0,#0x3c]
000010  2b01              CMP      r3,#1
000012  d020              BEQ      |L14.86|
;;;771    
;;;772        husart->pRxBuffPtr = pRxData;
;;;773        husart->RxXferSize = Size;
000014  62c1              STR      r1,[r0,#0x2c]
000016  8602              STRH     r2,[r0,#0x30]
;;;774        husart->RxXferCount = Size;
000018  8642              STRH     r2,[r0,#0x32]
;;;775    
;;;776        husart->ErrorCode = HAL_USART_ERROR_NONE;
00001a  2100              MOVS     r1,#0
00001c  6401              STR      r1,[r0,#0x40]
;;;777        husart->State = HAL_USART_STATE_BUSY_RX;
00001e  2222              MOVS     r2,#0x22
000020  f880203d          STRB     r2,[r0,#0x3d]
;;;778    
;;;779        /* Process Unlocked */
;;;780        __HAL_UNLOCK(husart);
000024  f880103c          STRB     r1,[r0,#0x3c]
;;;781    
;;;782        /* Enable the USART Data Register not empty Interrupt */
;;;783        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
000028  6801              LDR      r1,[r0,#0]
00002a  68ca              LDR      r2,[r1,#0xc]
00002c  f0420220          ORR      r2,r2,#0x20
000030  60ca              STR      r2,[r1,#0xc]
;;;784    
;;;785        /* Enable the USART Parity Error Interrupt */
;;;786        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
000032  6801              LDR      r1,[r0,#0]
000034  68ca              LDR      r2,[r1,#0xc]
000036  f4427280          ORR      r2,r2,#0x100
00003a  60ca              STR      r2,[r1,#0xc]
;;;787    
;;;788        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;789        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
00003c  6801              LDR      r1,[r0,#0]
00003e  694a              LDR      r2,[r1,#0x14]
000040  f0420201          ORR      r2,r2,#1
000044  614a              STR      r2,[r1,#0x14]
;;;790    
;;;791        /* Send dummy byte in order to generate the clock for the slave to send data */
;;;792        WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));    
000046  6800              LDR      r0,[r0,#0]
000048  f24011ff          MOV      r1,#0x1ff
00004c  6041              STR      r1,[r0,#4]
;;;793    
;;;794        return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;795      }
;;;796      else
;;;797      {
;;;798        return HAL_BUSY;
;;;799      }
;;;800    }
000050  4770              BX       lr
                  |L14.82|
000052  2001              MOVS     r0,#1                 ;767
000054  4770              BX       lr
                  |L14.86|
000056  2002              MOVS     r0,#2                 ;798
000058  4770              BX       lr
;;;801    
                          ENDP


                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;1269     */
;;;1270   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1271   {
;;;1272     /* Prevent unused argument(s) compilation warning */
;;;1273     UNUSED(husart);
;;;1274     /* NOTE: This function should not be modified, when the callback is needed,
;;;1275              the HAL_USART_RxCpltCallback can be implemented in the user file
;;;1276      */
;;;1277   }
;;;1278   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;1284     */
;;;1285   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1286   {
;;;1287     /* Prevent unused argument(s) compilation warning */
;;;1288     UNUSED(husart);
;;;1289     /* NOTE: This function should not be modified, when the callback is needed,
;;;1290              the HAL_USART_RxHalfCpltCallback can be implemented in the user file
;;;1291      */
;;;1292   }
;;;1293   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;421      */
;;;422    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;423    {
000004  4604              MOV      r4,r0
;;;424      uint16_t* tmp=0;
;;;425    
;;;426      if(husart->State == HAL_USART_STATE_READY)
000006  f890003d          LDRB     r0,[r0,#0x3d]
00000a  4698              MOV      r8,r3                 ;423
00000c  460d              MOV      r5,r1                 ;423
00000e  2801              CMP      r0,#1
000010  d148              BNE      |L17.164|
;;;427      {
;;;428        if((pTxData == NULL) || (Size == 0)) 
000012  b17d              CBZ      r5,|L17.52|
000014  b172              CBZ      r2,|L17.52|
;;;429        {
;;;430          return  HAL_ERROR;
;;;431        }
;;;432    
;;;433        /* Process Locked */
;;;434        __HAL_LOCK(husart);
000016  f894003c          LDRB     r0,[r4,#0x3c]
00001a  2801              CMP      r0,#1
00001c  d042              BEQ      |L17.164|
00001e  2601              MOVS     r6,#1
000020  f884603c          STRB     r6,[r4,#0x3c]
;;;435    
;;;436        husart->ErrorCode = HAL_USART_ERROR_NONE;
000024  2700              MOVS     r7,#0
000026  6427              STR      r7,[r4,#0x40]
;;;437        husart->State = HAL_USART_STATE_BUSY_TX;
000028  2012              MOVS     r0,#0x12
00002a  f884003d          STRB     r0,[r4,#0x3d]
;;;438    
;;;439        husart->TxXferSize = Size;
00002e  8522              STRH     r2,[r4,#0x28]
;;;440        husart->TxXferCount = Size;
000030  8562              STRH     r2,[r4,#0x2a]
000032  e025              B        |L17.128|
                  |L17.52|
000034  2001              MOVS     r0,#1                 ;430
                  |L17.54|
;;;441        while(husart->TxXferCount > 0)
;;;442        {
;;;443          husart->TxXferCount--;
;;;444          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;445          {
;;;446            /* Wait for TC flag in order to write data in DR */
;;;447            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;448            {
;;;449              return HAL_TIMEOUT;
;;;450            }
;;;451            tmp = (uint16_t*) pTxData;
;;;452            WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
;;;453            if(husart->Init.Parity == USART_PARITY_NONE)
;;;454            {
;;;455              pTxData += 2;
;;;456            }
;;;457            else
;;;458            {
;;;459              pTxData += 1;
;;;460            }
;;;461          }
;;;462          else
;;;463          {
;;;464            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;465            {
;;;466              return HAL_TIMEOUT;
;;;467            }
;;;468            WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0xFF));
;;;469          }
;;;470        }
;;;471    
;;;472        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, Timeout) != HAL_OK)
;;;473        { 
;;;474          return HAL_TIMEOUT;
;;;475        }
;;;476    
;;;477        husart->State = HAL_USART_STATE_READY;
;;;478    
;;;479        /* Process Unlocked */
;;;480        __HAL_UNLOCK(husart);
;;;481    
;;;482        return HAL_OK;
;;;483      }
;;;484      else
;;;485      {
;;;486        return HAL_BUSY;
;;;487      }
;;;488    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L17.58|
00003a  8d60              LDRH     r0,[r4,#0x2a]         ;443
00003c  1e40              SUBS     r0,r0,#1              ;443
00003e  8560              STRH     r0,[r4,#0x2a]         ;443
000040  68a0              LDR      r0,[r4,#8]            ;444
000042  4643              MOV      r3,r8                 ;464
000044  f5b05f80          CMP      r0,#0x1000            ;444
000048  f04f0200          MOV      r2,#0                 ;464
00004c  f04f0180          MOV      r1,#0x80              ;464
000050  4620              MOV      r0,r4                 ;464
000052  d003              BEQ      |L17.92|
000054  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000058  b9e0              CBNZ     r0,|L17.148|
00005a  e00d              B        |L17.120|
                  |L17.92|
00005c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000060  b9c0              CBNZ     r0,|L17.148|
000062  8828              LDRH     r0,[r5,#0]            ;452
000064  6821              LDR      r1,[r4,#0]            ;452
000066  f3c00008          UBFX     r0,r0,#0,#9           ;452
00006a  6048              STR      r0,[r1,#4]            ;452
00006c  6920              LDR      r0,[r4,#0x10]         ;453
00006e  b108              CBZ      r0,|L17.116|
000070  1c6d              ADDS     r5,r5,#1              ;453
000072  e005              B        |L17.128|
                  |L17.116|
000074  1cad              ADDS     r5,r5,#2              ;459
000076  e003              B        |L17.128|
                  |L17.120|
000078  6821              LDR      r1,[r4,#0]            ;468
00007a  f8150b01          LDRB     r0,[r5],#1            ;468
00007e  6048              STR      r0,[r1,#4]            ;468
                  |L17.128|
000080  8d60              LDRH     r0,[r4,#0x2a]         ;441
000082  2800              CMP      r0,#0                 ;441
000084  d1d9              BNE      |L17.58|
000086  4643              MOV      r3,r8                 ;472
000088  2200              MOVS     r2,#0                 ;472
00008a  2140              MOVS     r1,#0x40              ;472
00008c  4620              MOV      r0,r4                 ;472
00008e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000092  b108              CBZ      r0,|L17.152|
                  |L17.148|
000094  2003              MOVS     r0,#3                 ;474
000096  e7ce              B        |L17.54|
                  |L17.152|
000098  f884603d          STRB     r6,[r4,#0x3d]         ;477
00009c  f884703c          STRB     r7,[r4,#0x3c]         ;480
0000a0  2000              MOVS     r0,#0                 ;482
0000a2  e7c8              B        |L17.54|
                  |L17.164|
0000a4  2002              MOVS     r0,#2                 ;486
0000a6  e7c6              B        |L17.54|
;;;489    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive PROC
;;;601      */
;;;602    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;603    {
000004  4604              MOV      r4,r0
;;;604      uint16_t* tmp=0;
;;;605    
;;;606      if(husart->State == HAL_USART_STATE_READY)
000006  f890003d          LDRB     r0,[r0,#0x3d]
00000a  f8dd9020          LDR      r9,[sp,#0x20]
00000e  4615              MOV      r5,r2                 ;603
000010  460e              MOV      r6,r1                 ;603
000012  2801              CMP      r0,#1
000014  d16d              BNE      |L18.242|
;;;607      {
;;;608        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
000016  b1a6              CBZ      r6,|L18.66|
000018  b19d              CBZ      r5,|L18.66|
00001a  b193              CBZ      r3,|L18.66|
;;;609        {
;;;610          return  HAL_ERROR;
;;;611        }
;;;612        /* Process Locked */
;;;613        __HAL_LOCK(husart);
00001c  f894003c          LDRB     r0,[r4,#0x3c]
000020  2801              CMP      r0,#1
000022  d066              BEQ      |L18.242|
000024  2701              MOVS     r7,#1
000026  f884703c          STRB     r7,[r4,#0x3c]
;;;614    
;;;615        husart->ErrorCode = HAL_USART_ERROR_NONE;
00002a  f04f0800          MOV      r8,#0
00002e  f8c48040          STR      r8,[r4,#0x40]
;;;616        husart->State = HAL_USART_STATE_BUSY_RX;
000032  2022              MOVS     r0,#0x22
000034  f884003d          STRB     r0,[r4,#0x3d]
;;;617    
;;;618        husart->RxXferSize = Size;
000038  8623              STRH     r3,[r4,#0x30]
;;;619        husart->TxXferSize = Size;
00003a  8523              STRH     r3,[r4,#0x28]
;;;620        husart->TxXferCount = Size;
00003c  8563              STRH     r3,[r4,#0x2a]
;;;621        husart->RxXferCount = Size;
00003e  8663              STRH     r3,[r4,#0x32]
000040  e04f              B        |L18.226|
                  |L18.66|
000042  2001              MOVS     r0,#1                 ;610
                  |L18.68|
;;;622    
;;;623        /* Check the remain data to be received */
;;;624        while(husart->TxXferCount > 0)
;;;625        {
;;;626          husart->TxXferCount--;
;;;627          husart->RxXferCount--;
;;;628          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;629          {
;;;630            /* Wait for TC flag in order to write data in DR */
;;;631            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;632            {
;;;633              return HAL_TIMEOUT;
;;;634            }
;;;635            tmp = (uint16_t*) pTxData;
;;;636            WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
;;;637            if(husart->Init.Parity == USART_PARITY_NONE)
;;;638            {
;;;639              pTxData += 2;
;;;640            }
;;;641            else
;;;642            {
;;;643              pTxData += 1;
;;;644            }
;;;645            
;;;646            /* Wait for RXNE Flag */
;;;647            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;648            {
;;;649              return HAL_TIMEOUT;
;;;650            }
;;;651            tmp = (uint16_t*) pRxData ;
;;;652            if(husart->Init.Parity == USART_PARITY_NONE)
;;;653            {
;;;654              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;655              pRxData += 2;
;;;656            }
;;;657            else
;;;658            {
;;;659              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;660              pRxData += 1;
;;;661            }
;;;662          } 
;;;663          else
;;;664          {
;;;665            /* Wait for TC flag in order to write data in DR */
;;;666            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;667            {
;;;668              return HAL_TIMEOUT;
;;;669            }
;;;670            WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0x00FF));
;;;671    
;;;672            /* Wait for RXNE Flag */
;;;673            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;674            {
;;;675              return HAL_TIMEOUT;
;;;676            }
;;;677            if(husart->Init.Parity == USART_PARITY_NONE)
;;;678            {
;;;679              /* Receive data */
;;;680              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;681            }
;;;682            else
;;;683            {
;;;684              /* Receive data */
;;;685              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;686            }
;;;687          }
;;;688        }
;;;689    
;;;690        husart->State = HAL_USART_STATE_READY;
;;;691    
;;;692        /* Process Unlocked */
;;;693        __HAL_UNLOCK(husart);
;;;694    
;;;695        return HAL_OK;
;;;696      }
;;;697      else
;;;698      {
;;;699        return HAL_BUSY;
;;;700      }
;;;701    }
000044  e8bd87f0          POP      {r4-r10,pc}
                  |L18.72|
000048  8d60              LDRH     r0,[r4,#0x2a]         ;626
00004a  1e40              SUBS     r0,r0,#1              ;626
00004c  8560              STRH     r0,[r4,#0x2a]         ;626
00004e  8e60              LDRH     r0,[r4,#0x32]         ;627
000050  1e40              SUBS     r0,r0,#1              ;627
000052  8660              STRH     r0,[r4,#0x32]         ;627
000054  68a0              LDR      r0,[r4,#8]            ;628
000056  464b              MOV      r3,r9                 ;666
000058  f5b05f80          CMP      r0,#0x1000            ;628
00005c  f04f0200          MOV      r2,#0                 ;666
000060  f04f0180          MOV      r1,#0x80              ;666
000064  4620              MOV      r0,r4                 ;666
000066  d003              BEQ      |L18.112|
000068  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00006c  bb70              CBNZ     r0,|L18.204|
00006e  e022              B        |L18.182|
                  |L18.112|
000070  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000074  bb50              CBNZ     r0,|L18.204|
000076  8830              LDRH     r0,[r6,#0]            ;636
000078  6821              LDR      r1,[r4,#0]            ;636
00007a  f3c00008          UBFX     r0,r0,#0,#9           ;636
00007e  6048              STR      r0,[r1,#4]            ;636
000080  6920              LDR      r0,[r4,#0x10]         ;637
000082  b140              CBZ      r0,|L18.150|
000084  1c76              ADDS     r6,r6,#1              ;637
                  |L18.134|
000086  464b              MOV      r3,r9                 ;647
000088  2200              MOVS     r2,#0                 ;647
00008a  2120              MOVS     r1,#0x20              ;647
00008c  4620              MOV      r0,r4                 ;647
00008e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000092  b9d8              CBNZ     r0,|L18.204|
000094  e001              B        |L18.154|
                  |L18.150|
000096  1cb6              ADDS     r6,r6,#2              ;647
000098  e7f5              B        |L18.134|
                  |L18.154|
00009a  6920              LDR      r0,[r4,#0x10]         ;652
00009c  2800              CMP      r0,#0                 ;652
00009e  6820              LDR      r0,[r4,#0]            ;659
0000a0  6840              LDR      r0,[r0,#4]            ;659
0000a2  d003              BEQ      |L18.172|
0000a4  b2c1              UXTB     r1,r0                 ;659
0000a6  f8251b01          STRH     r1,[r5],#1            ;659
0000aa  e01a              B        |L18.226|
                  |L18.172|
0000ac  f3c00108          UBFX     r1,r0,#0,#9           ;654
0000b0  f8251b02          STRH     r1,[r5],#2            ;654
0000b4  e015              B        |L18.226|
                  |L18.182|
0000b6  6821              LDR      r1,[r4,#0]            ;670
0000b8  f8160b01          LDRB     r0,[r6],#1            ;670
0000bc  6048              STR      r0,[r1,#4]            ;670
0000be  464b              MOV      r3,r9                 ;673
0000c0  2200              MOVS     r2,#0                 ;673
0000c2  2120              MOVS     r1,#0x20              ;673
0000c4  4620              MOV      r0,r4                 ;673
0000c6  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000ca  b108              CBZ      r0,|L18.208|
                  |L18.204|
0000cc  2003              MOVS     r0,#3                 ;675
0000ce  e7b9              B        |L18.68|
                  |L18.208|
0000d0  6920              LDR      r0,[r4,#0x10]         ;677
0000d2  2800              CMP      r0,#0                 ;677
0000d4  6820              LDR      r0,[r4,#0]            ;685
0000d6  6840              LDR      r0,[r0,#4]            ;685
0000d8  d001              BEQ      |L18.222|
0000da  f000007f          AND      r0,r0,#0x7f           ;685
                  |L18.222|
0000de  f8050b01          STRB     r0,[r5],#1            ;680
                  |L18.226|
0000e2  8d60              LDRH     r0,[r4,#0x2a]         ;624
0000e4  2800              CMP      r0,#0                 ;624
0000e6  d1af              BNE      |L18.72|
0000e8  f884703d          STRB     r7,[r4,#0x3d]         ;690
0000ec  f884803c          STRB     r8,[r4,#0x3c]         ;693
0000f0  e7a8              B        |L18.68|
                  |L18.242|
0000f2  2002              MOVS     r0,#2                 ;699
0000f4  e7a6              B        |L18.68|
;;;702    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;996      */
;;;997    HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b57f              PUSH     {r0-r6,lr}
;;;998    {
000002  4604              MOV      r4,r0
;;;999      uint32_t *tmp=0;
;;;1000     
;;;1001     if(husart->State == HAL_USART_STATE_READY)
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  b082              SUB      sp,sp,#8              ;998
00000a  461d              MOV      r5,r3                 ;998
00000c  2801              CMP      r0,#1
00000e  d14d              BNE      |L19.172|
;;;1002     {
;;;1003       if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
000010  9803              LDR      r0,[sp,#0xc]
000012  2800              CMP      r0,#0
000014  d048              BEQ      |L19.168|
000016  9a04              LDR      r2,[sp,#0x10]
000018  2a00              CMP      r2,#0
00001a  d045              BEQ      |L19.168|
00001c  2d00              CMP      r5,#0
00001e  d043              BEQ      |L19.168|
;;;1004       {
;;;1005         return HAL_ERROR;
;;;1006       }
;;;1007       /* Process Locked */
;;;1008       __HAL_LOCK(husart);
000020  f894103c          LDRB     r1,[r4,#0x3c]
000024  2901              CMP      r1,#1
000026  d041              BEQ      |L19.172|
000028  2101              MOVS     r1,#1
00002a  f884103c          STRB     r1,[r4,#0x3c]
;;;1009   
;;;1010       husart->pRxBuffPtr = pRxData;
;;;1011       husart->RxXferSize = Size;
00002e  62e2              STR      r2,[r4,#0x2c]
000030  8625              STRH     r5,[r4,#0x30]
;;;1012       husart->pTxBuffPtr = pTxData;
;;;1013       husart->TxXferSize = Size;
000032  6260              STR      r0,[r4,#0x24]
000034  8525              STRH     r5,[r4,#0x28]
;;;1014   
;;;1015       husart->ErrorCode = HAL_USART_ERROR_NONE;
000036  2600              MOVS     r6,#0
000038  6426              STR      r6,[r4,#0x40]
;;;1016       husart->State = HAL_USART_STATE_BUSY_TX_RX;
00003a  2032              MOVS     r0,#0x32
00003c  f884003d          STRB     r0,[r4,#0x3d]
;;;1017   
;;;1018       /* Set the USART DMA Rx transfer complete callback */
;;;1019       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
000040  6ba1              LDR      r1,[r4,#0x38]
000042  481b              LDR      r0,|L19.176|
;;;1020   
;;;1021       /* Set the USART DMA Half transfer complete callback */
;;;1022       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1023   
;;;1024       /* Set the USART DMA Tx transfer complete callback */
;;;1025       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1026   
;;;1027       /* Set the USART DMA Half transfer complete callback */
;;;1028       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1029   
;;;1030       /* Set the USART DMA Tx transfer error callback */
;;;1031       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1032   
;;;1033       /* Set the USART DMA Rx transfer error callback */
;;;1034       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1035   
;;;1036       /* Enable the USART receive DMA channel */
;;;1037       tmp = (uint32_t*)&pRxData;
;;;1038       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
000044  462b              MOV      r3,r5
000046  6288              STR      r0,[r1,#0x28]         ;1022
000048  6ba1              LDR      r1,[r4,#0x38]         ;1022
00004a  481a              LDR      r0,|L19.180|
00004c  62c8              STR      r0,[r1,#0x2c]         ;1025
00004e  6b61              LDR      r1,[r4,#0x34]         ;1025
000050  4819              LDR      r0,|L19.184|
000052  6288              STR      r0,[r1,#0x28]         ;1028
000054  6b61              LDR      r1,[r4,#0x34]         ;1028
000056  4819              LDR      r0,|L19.188|
000058  62c8              STR      r0,[r1,#0x2c]         ;1031
00005a  6b61              LDR      r1,[r4,#0x34]         ;1031
00005c  4818              LDR      r0,|L19.192|
00005e  6308              STR      r0,[r1,#0x30]         ;1034
000060  6ba1              LDR      r1,[r4,#0x38]         ;1034
000062  6308              STR      r0,[r1,#0x30]
000064  6821              LDR      r1,[r4,#0]
000066  6ba0              LDR      r0,[r4,#0x38]
000068  1d09              ADDS     r1,r1,#4
00006a  f7fffffe          BL       HAL_DMA_Start_IT
;;;1039   
;;;1040       /* Enable the USART transmit DMA channel */
;;;1041       tmp = (uint32_t*)&pTxData;
;;;1042       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
00006e  6822              LDR      r2,[r4,#0]
000070  9903              LDR      r1,[sp,#0xc]
000072  462b              MOV      r3,r5
000074  1d12              ADDS     r2,r2,#4
000076  6b60              LDR      r0,[r4,#0x34]
000078  f7fffffe          BL       HAL_DMA_Start_IT
;;;1043       
;;;1044       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1045       __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
00007c  6821              LDR      r1,[r4,#0]
00007e  f06f0040          MVN      r0,#0x40
000082  6008              STR      r0,[r1,#0]
;;;1046   
;;;1047       /* Clear the Overrun flag: mandatory for the second transfer in circular mode */
;;;1048       __HAL_USART_CLEAR_OREFLAG(husart);
000084  6820              LDR      r0,[r4,#0]
000086  6801              LDR      r1,[r0,#0]
000088  6841              LDR      r1,[r0,#4]
;;;1049       
;;;1050       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1051          in the USART CR3 register */
;;;1052       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00008a  9100              STR      r1,[sp,#0]
00008c  6941              LDR      r1,[r0,#0x14]
00008e  f0410140          ORR      r1,r1,#0x40
000092  6141              STR      r1,[r0,#0x14]
;;;1053   
;;;1054       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1055          in the USART CR3 register */
;;;1056       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000094  6820              LDR      r0,[r4,#0]
000096  6941              LDR      r1,[r0,#0x14]
000098  f0410180          ORR      r1,r1,#0x80
00009c  6141              STR      r1,[r0,#0x14]
;;;1057   
;;;1058       /* Process Unlocked */
;;;1059       __HAL_UNLOCK(husart);
00009e  f884603c          STRB     r6,[r4,#0x3c]
;;;1060   
;;;1061       return HAL_OK;
0000a2  2000              MOVS     r0,#0
                  |L19.164|
;;;1062     }
;;;1063     else
;;;1064     {
;;;1065       return HAL_BUSY;
;;;1066     }
;;;1067   }
0000a4  b006              ADD      sp,sp,#0x18
0000a6  bd70              POP      {r4-r6,pc}
                  |L19.168|
0000a8  2001              MOVS     r0,#1                 ;1005
0000aa  e7fb              B        |L19.164|
                  |L19.172|
0000ac  2002              MOVS     r0,#2                 ;1065
0000ae  e7f9              B        |L19.164|
;;;1068   
                          ENDP

                  |L19.176|
                          DCD      USART_DMAReceiveCplt
                  |L19.180|
                          DCD      USART_DMARxHalfCplt
                  |L19.184|
                          DCD      USART_DMATransmitCplt
                  |L19.188|
                          DCD      USART_DMATxHalfCplt
                  |L19.192|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive_IT PROC
;;;810      */
;;;811    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;812    {
;;;813      if(husart->State == HAL_USART_STATE_READY)
000002  f890403d          LDRB     r4,[r0,#0x3d]
000006  2c01              CMP      r4,#1
000008  d12b              BNE      |L20.98|
;;;814      {
;;;815        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
00000a  b341              CBZ      r1,|L20.94|
00000c  b33a              CBZ      r2,|L20.94|
00000e  b333              CBZ      r3,|L20.94|
;;;816        {
;;;817          return HAL_ERROR;
;;;818        }
;;;819        /* Process Locked */
;;;820        __HAL_LOCK(husart);
000010  f890403c          LDRB     r4,[r0,#0x3c]
000014  2c01              CMP      r4,#1
000016  d024              BEQ      |L20.98|
;;;821    
;;;822        husart->pRxBuffPtr = pRxData;
;;;823        husart->RxXferSize = Size;
000018  62c2              STR      r2,[r0,#0x2c]
00001a  8603              STRH     r3,[r0,#0x30]
;;;824        husart->RxXferCount = Size;
00001c  8643              STRH     r3,[r0,#0x32]
;;;825        husart->pTxBuffPtr = pTxData;
;;;826        husart->TxXferSize = Size;
00001e  6241              STR      r1,[r0,#0x24]
000020  8503              STRH     r3,[r0,#0x28]
;;;827        husart->TxXferCount = Size;
000022  8543              STRH     r3,[r0,#0x2a]
;;;828    
;;;829        husart->ErrorCode = HAL_USART_ERROR_NONE;
000024  2100              MOVS     r1,#0
000026  6401              STR      r1,[r0,#0x40]
;;;830        husart->State = HAL_USART_STATE_BUSY_TX_RX;
000028  2232              MOVS     r2,#0x32
00002a  f880203d          STRB     r2,[r0,#0x3d]
;;;831    
;;;832        /* Process Unlocked */
;;;833        __HAL_UNLOCK(husart);
00002e  f880103c          STRB     r1,[r0,#0x3c]
;;;834    
;;;835        /* Enable the USART Data Register not empty Interrupt */
;;;836        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
000032  6801              LDR      r1,[r0,#0]
000034  68ca              LDR      r2,[r1,#0xc]
000036  f0420220          ORR      r2,r2,#0x20
00003a  60ca              STR      r2,[r1,#0xc]
;;;837    
;;;838        /* Enable the USART Parity Error Interrupt */
;;;839        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
00003c  6801              LDR      r1,[r0,#0]
00003e  68ca              LDR      r2,[r1,#0xc]
000040  f4427280          ORR      r2,r2,#0x100
000044  60ca              STR      r2,[r1,#0xc]
;;;840    
;;;841        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;842        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
000046  6801              LDR      r1,[r0,#0]
000048  694a              LDR      r2,[r1,#0x14]
00004a  f0420201          ORR      r2,r2,#1
00004e  614a              STR      r2,[r1,#0x14]
;;;843    
;;;844        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;845        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
000050  6800              LDR      r0,[r0,#0]
000052  68c1              LDR      r1,[r0,#0xc]
000054  f0410180          ORR      r1,r1,#0x80
000058  60c1              STR      r1,[r0,#0xc]
;;;846    
;;;847        return HAL_OK;
00005a  2000              MOVS     r0,#0
;;;848      }
;;;849      else
;;;850      {
;;;851        return HAL_BUSY; 
;;;852      }
;;;853    }
00005c  bd10              POP      {r4,pc}
                  |L20.94|
00005e  2001              MOVS     r0,#1                 ;817
000060  bd10              POP      {r4,pc}
                  |L20.98|
000062  2002              MOVS     r0,#2                 ;851
000064  bd10              POP      {r4,pc}
;;;854    
                          ENDP


                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;862      */
;;;863    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;864    {
000002  4604              MOV      r4,r0
;;;865      uint32_t *tmp=0;
;;;866      
;;;867      if(husart->State == HAL_USART_STATE_READY)
000004  f890003d          LDRB     r0,[r0,#0x3d]
000008  2801              CMP      r0,#1
00000a  d130              BNE      |L21.110|
;;;868      {
;;;869        if((pTxData == NULL) || (Size == 0)) 
00000c  9901              LDR      r1,[sp,#4]
00000e  b361              CBZ      r1,|L21.106|
000010  b35a              CBZ      r2,|L21.106|
;;;870        {
;;;871          return HAL_ERROR;
;;;872        }
;;;873        /* Process Locked */
;;;874        __HAL_LOCK(husart);  
000012  f894003c          LDRB     r0,[r4,#0x3c]
000016  2801              CMP      r0,#1
000018  d029              BEQ      |L21.110|
00001a  2001              MOVS     r0,#1
00001c  f884003c          STRB     r0,[r4,#0x3c]
;;;875    
;;;876        husart->pTxBuffPtr = pTxData;
;;;877        husart->TxXferSize = Size;
000020  6261              STR      r1,[r4,#0x24]
000022  8522              STRH     r2,[r4,#0x28]
;;;878        husart->TxXferCount = Size;
000024  8562              STRH     r2,[r4,#0x2a]
;;;879    
;;;880        husart->ErrorCode = HAL_USART_ERROR_NONE;
000026  2500              MOVS     r5,#0
000028  6425              STR      r5,[r4,#0x40]
;;;881        husart->State = HAL_USART_STATE_BUSY_TX;
00002a  2012              MOVS     r0,#0x12
00002c  f884003d          STRB     r0,[r4,#0x3d]
;;;882    
;;;883        /* Set the USART DMA transfer complete callback */
;;;884        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
000030  6b63              LDR      r3,[r4,#0x34]
000032  4810              LDR      r0,|L21.116|
;;;885    
;;;886        /* Set the USART DMA Half transfer complete callback */
;;;887        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
000034  6298              STR      r0,[r3,#0x28]
000036  6b63              LDR      r3,[r4,#0x34]
000038  480f              LDR      r0,|L21.120|
;;;888    
;;;889        /* Set the DMA error callback */
;;;890        husart->hdmatx->XferErrorCallback = USART_DMAError;
00003a  62d8              STR      r0,[r3,#0x2c]
00003c  6b63              LDR      r3,[r4,#0x34]
00003e  480f              LDR      r0,|L21.124|
;;;891    
;;;892        /* Enable the USART transmit DMA channel */
;;;893        tmp = (uint32_t*)&pTxData;
;;;894        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
000040  6318              STR      r0,[r3,#0x30]
000042  6820              LDR      r0,[r4,#0]
000044  4613              MOV      r3,r2
000046  6b66              LDR      r6,[r4,#0x34]
000048  1d02              ADDS     r2,r0,#4
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       HAL_DMA_Start_IT
;;;895    
;;;896        /* Clear the TC flag in the SR register by writing 0 to it */
;;;897        __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
000050  6821              LDR      r1,[r4,#0]
000052  f06f0040          MVN      r0,#0x40
000056  6008              STR      r0,[r1,#0]
;;;898    
;;;899        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;900           in the USART CR3 register */
;;;901        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000058  6820              LDR      r0,[r4,#0]
00005a  6941              LDR      r1,[r0,#0x14]
00005c  f0410180          ORR      r1,r1,#0x80
000060  6141              STR      r1,[r0,#0x14]
;;;902    
;;;903        /* Process Unlocked */
;;;904        __HAL_UNLOCK(husart);
000062  f884503c          STRB     r5,[r4,#0x3c]
;;;905    
;;;906        return HAL_OK;
000066  2000              MOVS     r0,#0
;;;907      }
;;;908      else
;;;909      {
;;;910        return HAL_BUSY;
;;;911      }
;;;912    }
000068  bdfe              POP      {r1-r7,pc}
                  |L21.106|
00006a  2001              MOVS     r0,#1                 ;871
00006c  bdfe              POP      {r1-r7,pc}
                  |L21.110|
00006e  2002              MOVS     r0,#2                 ;910
000070  bdfe              POP      {r1-r7,pc}
;;;913    
                          ENDP

000072  0000              DCW      0x0000
                  |L21.116|
                          DCD      USART_DMATransmitCplt
                  |L21.120|
                          DCD      USART_DMATxHalfCplt
                  |L21.124|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit_IT PROC
;;;711      */
;;;712    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  f890303d          LDRB     r3,[r0,#0x3d]
;;;713    {
;;;714      if(husart->State == HAL_USART_STATE_READY)
000004  2b01              CMP      r3,#1
000006  d118              BNE      |L22.58|
;;;715      {
;;;716        if((pTxData == NULL) || (Size == 0)) 
000008  b1a9              CBZ      r1,|L22.54|
00000a  b1a2              CBZ      r2,|L22.54|
;;;717        {
;;;718          return HAL_ERROR;
;;;719        }
;;;720    
;;;721        /* Process Locked */
;;;722        __HAL_LOCK(husart);
00000c  f890303c          LDRB     r3,[r0,#0x3c]
000010  2b01              CMP      r3,#1
000012  d012              BEQ      |L22.58|
;;;723    
;;;724        husart->pTxBuffPtr = pTxData;
;;;725        husart->TxXferSize = Size;
000014  6241              STR      r1,[r0,#0x24]
000016  8502              STRH     r2,[r0,#0x28]
;;;726        husart->TxXferCount = Size;
000018  8542              STRH     r2,[r0,#0x2a]
;;;727    
;;;728        husart->ErrorCode = HAL_USART_ERROR_NONE;
00001a  2100              MOVS     r1,#0
00001c  6401              STR      r1,[r0,#0x40]
;;;729        husart->State = HAL_USART_STATE_BUSY_TX;
00001e  2212              MOVS     r2,#0x12
000020  f880203d          STRB     r2,[r0,#0x3d]
;;;730    
;;;731        /* The USART Error Interrupts: (Frame error, Noise error, Overrun error) 
;;;732           are not managed by the USART transmit process to avoid the overrun interrupt
;;;733           when the USART mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;734           to benefit for the frame error and noise interrupts the USART mode should be
;;;735           configured only for transmit "USART_MODE_TX"
;;;736           The __HAL_USART_ENABLE_IT(husart, USART_IT_ERR) can be used to enable the Frame error,
;;;737           Noise error interrupt */
;;;738    
;;;739        /* Process Unlocked */
;;;740        __HAL_UNLOCK(husart);
000024  f880103c          STRB     r1,[r0,#0x3c]
;;;741    
;;;742        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;743        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
000028  6800              LDR      r0,[r0,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f0410180          ORR      r1,r1,#0x80
000030  60c1              STR      r1,[r0,#0xc]
;;;744    
;;;745        return HAL_OK;
000032  2000              MOVS     r0,#0
;;;746      }
;;;747      else
;;;748      {
;;;749        return HAL_BUSY;
;;;750      }
;;;751    }
000034  4770              BX       lr
                  |L22.54|
000036  2001              MOVS     r0,#1                 ;718
000038  4770              BX       lr
                  |L22.58|
00003a  2002              MOVS     r0,#2                 ;749
00003c  4770              BX       lr
;;;752    
                          ENDP


                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;1239     */
;;;1240    __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1241   {
;;;1242     /* Prevent unused argument(s) compilation warning */
;;;1243     UNUSED(husart);
;;;1244     /* NOTE: This function should not be modified, when the callback is needed,
;;;1245              the HAL_USART_TxCpltCallback can be implemented in the user file
;;;1246      */
;;;1247   }
;;;1248   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;1254     */
;;;1255    __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1256   {
;;;1257     /* Prevent unused argument(s) compilation warning */
;;;1258     UNUSED(husart);
;;;1259     /* NOTE: This function should not be modified, when the callback is needed,
;;;1260              the HAL_USART_TxHalfCpltCallback can be implemented in the user file
;;;1261      */
;;;1262   }
;;;1263   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;1299     */
;;;1300   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1301   {
;;;1302     /* Prevent unused argument(s) compilation warning */
;;;1303     UNUSED(husart);
;;;1304     /* NOTE: This function should not be modified, when the callback is needed,
;;;1305              the HAL_USART_TxRxCpltCallback can be implemented in the user file
;;;1306      */
;;;1307   }
;;;1308   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;1496     */
;;;1497   static void USART_DMAError(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;1498   {
;;;1499     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1500   
;;;1501     husart->RxXferCount = 0;
000004  2100              MOVS     r1,#0
000006  8641              STRH     r1,[r0,#0x32]
;;;1502     husart->TxXferCount = 0;
000008  8541              STRH     r1,[r0,#0x2a]
;;;1503     husart->ErrorCode |= HAL_USART_ERROR_DMA;
00000a  6c01              LDR      r1,[r0,#0x40]
00000c  f0410110          ORR      r1,r1,#0x10
000010  6401              STR      r1,[r0,#0x40]
;;;1504     husart->State= HAL_USART_STATE_READY;
000012  2101              MOVS     r1,#1
000014  f880103d          STRB     r1,[r0,#0x3d]
;;;1505     
;;;1506     HAL_USART_ErrorCallback(husart);
000018  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1507   }
00001c  bd10              POP      {r4,pc}
;;;1508   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;1434     */
;;;1435   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1436   {
000002  4601              MOV      r1,r0
;;;1437     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a40              LDR      r0,[r0,#0x24]
;;;1438   
;;;1439     /* DMA Normal mode */
;;;1440     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d414              BMI      |L27.56|
;;;1441     {
;;;1442       husart->RxXferCount = 0;
00000e  2100              MOVS     r1,#0
000010  8641              STRH     r1,[r0,#0x32]
;;;1443       if(husart->State == HAL_USART_STATE_BUSY_RX)
000012  f890103d          LDRB     r1,[r0,#0x3d]
;;;1444       {
;;;1445         /* Disable the DMA transfer for the receiver requests by setting the DMAR bit 
;;;1446            in the USART CR3 register */
;;;1447         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1448   
;;;1449         husart->State= HAL_USART_STATE_READY;
000016  2201              MOVS     r2,#1
000018  2922              CMP      r1,#0x22              ;1443
;;;1450         HAL_USART_RxCpltCallback(husart);
;;;1451       }
;;;1452       /* the usart state is HAL_USART_STATE_BUSY_TX_RX*/
;;;1453       else
;;;1454       {
;;;1455         /* Disable the DMA transfer for the Transmit/receiver requests by setting the DMAT/DMAR bit 
;;;1456            in the USART CR3 register */
;;;1457         CLEAR_BIT(husart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
00001a  6801              LDR      r1,[r0,#0]
00001c  694b              LDR      r3,[r1,#0x14]
00001e  d005              BEQ      |L27.44|
000020  f02303c0          BIC      r3,r3,#0xc0
000024  614b              STR      r3,[r1,#0x14]
;;;1458   
;;;1459         husart->State= HAL_USART_STATE_READY;
000026  f880203d          STRB     r2,[r0,#0x3d]
;;;1460         HAL_USART_TxRxCpltCallback(husart);
00002a  e009              B        |L27.64|
                  |L27.44|
00002c  f0230340          BIC      r3,r3,#0x40           ;1447
000030  614b              STR      r3,[r1,#0x14]         ;1447
000032  f880203d          STRB     r2,[r0,#0x3d]         ;1449
000036  e006              B        |L27.70|
                  |L27.56|
;;;1461       }
;;;1462     }
;;;1463     /* DMA circular mode */
;;;1464     else
;;;1465     {
;;;1466       if(husart->State == HAL_USART_STATE_BUSY_RX)
000038  f890103d          LDRB     r1,[r0,#0x3d]
00003c  2922              CMP      r1,#0x22
00003e  d002              BEQ      |L27.70|
                  |L27.64|
;;;1467       {
;;;1468         HAL_USART_RxCpltCallback(husart);
;;;1469       }
;;;1470       /* the usart state is HAL_USART_STATE_BUSY_TX_RX*/
;;;1471       else
;;;1472       {
;;;1473         HAL_USART_TxRxCpltCallback(husart);
000040  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;1474       }
;;;1475     }
;;;1476   }
000044  bd10              POP      {r4,pc}
                  |L27.70|
000046  f7fffffe          BL       HAL_USART_RxCpltCallback
00004a  bd10              POP      {r4,pc}
;;;1477   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;1483     */
;;;1484   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1485   {
;;;1486     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1487   
;;;1488     HAL_USART_RxHalfCpltCallback(husart); 
000004  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;1489   }
000008  bd10              POP      {r4,pc}
;;;1490   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;1386     */
;;;1387   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1388   {
000002  4601              MOV      r1,r0
;;;1389     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a40              LDR      r0,[r0,#0x24]
;;;1390   
;;;1391     /* DMA Normal mode */
;;;1392     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d410              BMI      |L29.48|
;;;1393     {
;;;1394       husart->TxXferCount = 0;
00000e  2100              MOVS     r1,#0
000010  8541              STRH     r1,[r0,#0x2a]
;;;1395   
;;;1396       if(husart->State == HAL_USART_STATE_BUSY_TX)
000012  f890103d          LDRB     r1,[r0,#0x3d]
000016  2912              CMP      r1,#0x12
000018  d109              BNE      |L29.46|
;;;1397       {
;;;1398         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1399            in the USART CR3 register */
;;;1400         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00001a  6801              LDR      r1,[r0,#0]
00001c  694a              LDR      r2,[r1,#0x14]
00001e  f0220280          BIC      r2,r2,#0x80
000022  614a              STR      r2,[r1,#0x14]
;;;1401         
;;;1402         /* Enable the USART Transmit Complete Interrupt */    
;;;1403         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
000024  6800              LDR      r0,[r0,#0]
000026  68c1              LDR      r1,[r0,#0xc]
000028  f0410140          ORR      r1,r1,#0x40
00002c  60c1              STR      r1,[r0,#0xc]
                  |L29.46|
;;;1404       }
;;;1405     }
;;;1406     /* DMA Circular mode */
;;;1407     else
;;;1408     {
;;;1409       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1410       {
;;;1411         HAL_USART_TxCpltCallback(husart);
;;;1412       }
;;;1413     }
;;;1414   }
00002e  bd10              POP      {r4,pc}
                  |L29.48|
000030  f890103d          LDRB     r1,[r0,#0x3d]         ;1409
000034  2912              CMP      r1,#0x12              ;1409
000036  d1fa              BNE      |L29.46|
000038  f7fffffe          BL       HAL_USART_TxCpltCallback
00003c  bd10              POP      {r4,pc}
;;;1415   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;1421     */
;;;1422   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1423   {
;;;1424     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;1425   
;;;1426     HAL_USART_TxHalfCpltCallback(husart);
000004  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1427   }
000008  bd10              POP      {r4,pc}
;;;1428   
                          ENDP


                          AREA ||i.USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  USART_Receive_IT PROC
;;;1654     */
;;;1655   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1656   {
;;;1657     uint16_t* tmp=0;
;;;1658     if(husart->State == HAL_USART_STATE_BUSY_RX)
000002  f890103d          LDRB     r1,[r0,#0x3d]
000006  2922              CMP      r1,#0x22
000008  d001              BEQ      |L31.14|
;;;1659     {
;;;1660       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;1661       {
;;;1662         tmp = (uint16_t*) husart->pRxBuffPtr;
;;;1663         if(husart->Init.Parity == USART_PARITY_NONE)
;;;1664         {
;;;1665           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;1666           husart->pRxBuffPtr += 2;
;;;1667         }
;;;1668         else
;;;1669         {
;;;1670           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;1671           husart->pRxBuffPtr += 1;
;;;1672         }
;;;1673         if(--husart->RxXferCount != 0x00) 
;;;1674         {
;;;1675           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;1676           WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF)); 
;;;1677         }
;;;1678       } 
;;;1679       else
;;;1680       {
;;;1681         if(husart->Init.Parity == USART_PARITY_NONE)
;;;1682         {
;;;1683           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;1684         }
;;;1685         else
;;;1686         {
;;;1687           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;1688         }
;;;1689   
;;;1690         if(--husart->RxXferCount != 0x00) 
;;;1691         {
;;;1692           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;1693           WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));  
;;;1694         }
;;;1695       }
;;;1696   
;;;1697       if(husart->RxXferCount == 0)
;;;1698       {
;;;1699         /* Disable the USART RXNE Interrupt */
;;;1700         __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
;;;1701   
;;;1702         /* Disable the USART Parity Error Interrupt */
;;;1703         __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
;;;1704   
;;;1705         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1706         __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
;;;1707   
;;;1708         husart->State = HAL_USART_STATE_READY;
;;;1709         HAL_USART_RxCpltCallback(husart);
;;;1710         
;;;1711         return HAL_OK;
;;;1712       }
;;;1713       return HAL_OK;
;;;1714     }
;;;1715     else
;;;1716     {
;;;1717       return HAL_BUSY; 
00000a  2002              MOVS     r0,#2
;;;1718     }
;;;1719   }
00000c  bd10              POP      {r4,pc}
                  |L31.14|
00000e  6881              LDR      r1,[r0,#8]            ;1660
000010  f5b15f80          CMP      r1,#0x1000            ;1660
000014  d016              BEQ      |L31.68|
000016  6901              LDR      r1,[r0,#0x10]         ;1681
000018  2900              CMP      r1,#0                 ;1681
00001a  6801              LDR      r1,[r0,#0]            ;1681
00001c  d02c              BEQ      |L31.120|
00001e  6849              LDR      r1,[r1,#4]            ;1687
000020  f001037f          AND      r3,r1,#0x7f           ;1687
000024  6ac1              LDR      r1,[r0,#0x2c]         ;1687
000026  1c4a              ADDS     r2,r1,#1              ;1687
000028  62c2              STR      r2,[r0,#0x2c]         ;1687
00002a  700b              STRB     r3,[r1,#0]            ;1687
                  |L31.44|
00002c  8e41              LDRH     r1,[r0,#0x32]         ;1690
00002e  1e49              SUBS     r1,r1,#1              ;1690
000030  0409              LSLS     r1,r1,#16             ;1690
000032  0c09              LSRS     r1,r1,#16             ;1690
000034  8641              STRH     r1,[r0,#0x32]         ;1690
000036  d002              BEQ      |L31.62|
000038  21ff              MOVS     r1,#0xff              ;1693
                  |L31.58|
00003a  6802              LDR      r2,[r0,#0]            ;1693
00003c  6051              STR      r1,[r2,#4]            ;1693
                  |L31.62|
00003e  8e41              LDRH     r1,[r0,#0x32]         ;1697
000040  b301              CBZ      r1,|L31.132|
000042  e033              B        |L31.172|
                  |L31.68|
000044  6902              LDR      r2,[r0,#0x10]         ;1663
000046  6ac1              LDR      r1,[r0,#0x2c]         ;1663
000048  2a00              CMP      r2,#0                 ;1663
00004a  6802              LDR      r2,[r0,#0]            ;1670
00004c  6852              LDR      r2,[r2,#4]            ;1670
00004e  d00d              BEQ      |L31.108|
000050  b2d2              UXTB     r2,r2                 ;1670
000052  800a              STRH     r2,[r1,#0]            ;1670
000054  6ac1              LDR      r1,[r0,#0x2c]         ;1671
000056  1c49              ADDS     r1,r1,#1              ;1671
                  |L31.88|
000058  62c1              STR      r1,[r0,#0x2c]         ;1673
00005a  8e41              LDRH     r1,[r0,#0x32]         ;1673
00005c  1e49              SUBS     r1,r1,#1              ;1673
00005e  0409              LSLS     r1,r1,#16             ;1673
000060  0c09              LSRS     r1,r1,#16             ;1673
000062  8641              STRH     r1,[r0,#0x32]         ;1673
000064  d0eb              BEQ      |L31.62|
000066  f24011ff          MOV      r1,#0x1ff             ;1676
00006a  e7e6              B        |L31.58|
                  |L31.108|
00006c  f3c20208          UBFX     r2,r2,#0,#9           ;1665
000070  800a              STRH     r2,[r1,#0]            ;1665
000072  6ac1              LDR      r1,[r0,#0x2c]         ;1666
000074  1c89              ADDS     r1,r1,#2              ;1666
000076  e7ef              B        |L31.88|
                  |L31.120|
000078  684a              LDR      r2,[r1,#4]            ;1683
00007a  6ac1              LDR      r1,[r0,#0x2c]         ;1683
00007c  1c4b              ADDS     r3,r1,#1              ;1683
00007e  62c3              STR      r3,[r0,#0x2c]         ;1683
000080  700a              STRB     r2,[r1,#0]            ;1683
000082  e7d3              B        |L31.44|
                  |L31.132|
000084  6801              LDR      r1,[r0,#0]            ;1700
000086  68ca              LDR      r2,[r1,#0xc]          ;1700
000088  f0220220          BIC      r2,r2,#0x20           ;1700
00008c  60ca              STR      r2,[r1,#0xc]          ;1700
00008e  6801              LDR      r1,[r0,#0]            ;1703
000090  68ca              LDR      r2,[r1,#0xc]          ;1703
000092  f4227280          BIC      r2,r2,#0x100          ;1703
000096  60ca              STR      r2,[r1,#0xc]          ;1703
000098  6801              LDR      r1,[r0,#0]            ;1706
00009a  694a              LDR      r2,[r1,#0x14]         ;1706
00009c  f0220201          BIC      r2,r2,#1              ;1706
0000a0  614a              STR      r2,[r1,#0x14]         ;1706
0000a2  2101              MOVS     r1,#1                 ;1708
0000a4  f880103d          STRB     r1,[r0,#0x3d]         ;1708
0000a8  f7fffffe          BL       HAL_USART_RxCpltCallback
                  |L31.172|
0000ac  2000              MOVS     r0,#0                 ;1713
0000ae  bd10              POP      {r4,pc}
;;;1720   
                          ENDP


                          AREA ||i.USART_SetConfig||, CODE, READONLY, ALIGN=2

                  USART_SetConfig PROC
;;;1828     */
;;;1829   static void USART_SetConfig(USART_HandleTypeDef *husart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1830   {
000004  4604              MOV      r4,r0
;;;1831     /* Check the parameters */
;;;1832     assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
;;;1833     assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
;;;1834     assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
;;;1835     assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));  
;;;1836     assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
;;;1837     assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
;;;1838     assert_param(IS_USART_PARITY(husart->Init.Parity));
;;;1839     assert_param(IS_USART_MODE(husart->Init.Mode));
;;;1840   
;;;1841     /* The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the
;;;1842        receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. */
;;;1843     CLEAR_BIT(husart->Instance->CR1, ((uint32_t)(USART_CR1_TE | USART_CR1_RE)));
000006  6800              LDR      r0,[r0,#0]
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f021010c          BIC      r1,r1,#0xc
00000e  60c1              STR      r1,[r0,#0xc]
000010  e9d41006          LDRD     r1,r0,[r4,#0x18]
;;;1844   
;;;1845     /*---------------------------- USART CR2 Configuration ---------------------*/
;;;1846     /* Configure the USART Clock, CPOL, CPHA and LastBit -----------------------*/
;;;1847     /* Set CPOL bit according to husart->Init.CLKPolarity value */
;;;1848     /* Set CPHA bit according to husart->Init.CLKPhase value */
;;;1849     /* Set LBCL bit according to husart->Init.CLKLastBit value */
;;;1850     /* Set Stop Bits: Set STOP[13:12] bits according to husart->Init.StopBits value */
;;;1851     /* Write to USART CR2 */
;;;1852     MODIFY_REG(husart->Instance->CR2, 
000014  4301              ORRS     r1,r1,r0
000016  68e2              LDR      r2,[r4,#0xc]
000018  6a20              LDR      r0,[r4,#0x20]
00001a  4310              ORRS     r0,r0,r2
00001c  4301              ORRS     r1,r1,r0
00001e  6820              LDR      r0,[r4,#0]
000020  6902              LDR      r2,[r0,#0x10]
000022  f422527c          BIC      r2,r2,#0x3f00
000026  4311              ORRS     r1,r1,r2
000028  f4416100          ORR      r1,r1,#0x800
00002c  6101              STR      r1,[r0,#0x10]
;;;1853                (uint32_t)(USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN | USART_CR2_LBCL | USART_CR2_STOP),
;;;1854                ((uint32_t)(USART_CLOCK_ENABLE| husart->Init.CLKPolarity | husart->Init.CLKPhase| husart->Init.CLKLastBit | husart->Init.StopBits)));
;;;1855   
;;;1856     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1857     /* Configure the USART Word Length, Parity and mode: 
;;;1858        Set the M bits according to husart->Init.WordLength value 
;;;1859        Set PCE and PS bits according to husart->Init.Parity value
;;;1860        Set TE and RE bits according to husart->Init.Mode value */
;;;1861     MODIFY_REG(husart->Instance->CR1, 
00002e  68a1              LDR      r1,[r4,#8]
000030  6920              LDR      r0,[r4,#0x10]
000032  6962              LDR      r2,[r4,#0x14]
000034  4301              ORRS     r1,r1,r0
000036  6820              LDR      r0,[r4,#0]
000038  68c3              LDR      r3,[r0,#0xc]
00003a  f241650c          MOV      r5,#0x160c
00003e  43ab              BICS     r3,r3,r5
000040  431a              ORRS     r2,r2,r3
000042  4311              ORRS     r1,r1,r2
000044  60c1              STR      r1,[r0,#0xc]
;;;1862                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE),
;;;1863                (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode);
;;;1864   
;;;1865     /*-------------------------- USART CR3 Configuration -----------------------*/  
;;;1866     /* Clear CTSE and RTSE bits */
;;;1867     CLEAR_BIT(husart->Instance->CR3, (uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
000046  6820              LDR      r0,[r4,#0]
000048  6941              LDR      r1,[r0,#0x14]
00004a  f4217140          BIC      r1,r1,#0x300
00004e  6141              STR      r1,[r0,#0x14]
;;;1868   
;;;1869     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1870     if((husart->Instance == USART1))
000050  4928              LDR      r1,|L32.244|
000052  6820              LDR      r0,[r4,#0]
;;;1871     {
;;;1872       husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK2Freq(), husart->Init.BaudRate);
000054  2564              MOVS     r5,#0x64
000056  f04f0832          MOV      r8,#0x32
00005a  4288              CMP      r0,r1                 ;1870
00005c  d118              BNE      |L32.144|
00005e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000062  eb0001c0          ADD      r1,r0,r0,LSL #3
000066  eb011000          ADD      r0,r1,r0,LSL #4
00006a  6861              LDR      r1,[r4,#4]
00006c  0089              LSLS     r1,r1,#2
00006e  fbb0f0f1          UDIV     r0,r0,r1
000072  fbb0f6f5          UDIV     r6,r0,r5
000076  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00007a  eb0001c0          ADD      r1,r0,r0,LSL #3
00007e  eb011000          ADD      r0,r1,r0,LSL #4
000082  6861              LDR      r1,[r4,#4]
000084  0089              LSLS     r1,r1,#2
000086  fbb0f7f1          UDIV     r7,r0,r1
00008a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00008e  e017              B        |L32.192|
                  |L32.144|
;;;1873     }
;;;1874     else
;;;1875     {
;;;1876       husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK1Freq(), husart->Init.BaudRate);
000090  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000094  eb0001c0          ADD      r1,r0,r0,LSL #3
000098  eb011000          ADD      r0,r1,r0,LSL #4
00009c  6861              LDR      r1,[r4,#4]
00009e  0089              LSLS     r1,r1,#2
0000a0  fbb0f0f1          UDIV     r0,r0,r1
0000a4  fbb0f6f5          UDIV     r6,r0,r5
0000a8  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000ac  eb0001c0          ADD      r1,r0,r0,LSL #3
0000b0  eb011000          ADD      r0,r1,r0,LSL #4
0000b4  6861              LDR      r1,[r4,#4]
0000b6  0089              LSLS     r1,r1,#2
0000b8  fbb0f7f1          UDIV     r7,r0,r1
0000bc  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
                  |L32.192|
0000c0  eb0001c0          ADD      r1,r0,r0,LSL #3       ;1872
0000c4  eb011000          ADD      r0,r1,r0,LSL #4       ;1872
0000c8  6861              LDR      r1,[r4,#4]            ;1872
0000ca  0089              LSLS     r1,r1,#2              ;1872
0000cc  fbb0f0f1          UDIV     r0,r0,r1              ;1872
0000d0  fbb0f0f5          UDIV     r0,r0,r5              ;1872
0000d4  f06f0118          MVN      r1,#0x18              ;1872
0000d8  4348              MULS     r0,r1,r0              ;1872
0000da  eb070180          ADD      r1,r7,r0,LSL #2       ;1872
0000de  eb081001          ADD      r0,r8,r1,LSL #4       ;1872
0000e2  fbb0f0f5          UDIV     r0,r0,r5              ;1872
0000e6  6821              LDR      r1,[r4,#0]            ;1872
0000e8  f366101f          BFI      r0,r6,#4,#28          ;1872
0000ec  6088              STR      r0,[r1,#8]            ;1872
;;;1877     }
;;;1878   }
0000ee  e8bd81f0          POP      {r4-r8,pc}
;;;1879   
                          ENDP

0000f2  0000              DCW      0x0000
                  |L32.244|
                          DCD      0x40013800

                          AREA ||i.USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  USART_TransmitReceive_IT PROC
;;;1726     */
;;;1727   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1728   {
;;;1729     uint16_t* tmp=0;
;;;1730   
;;;1731     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000002  f890103d          LDRB     r1,[r0,#0x3d]
000006  2932              CMP      r1,#0x32
000008  d001              BEQ      |L33.14|
;;;1732     {
;;;1733       if(husart->TxXferCount != 0x00)
;;;1734       {
;;;1735         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
;;;1736         {
;;;1737           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;1738           {
;;;1739             tmp = (uint16_t*) husart->pTxBuffPtr;
;;;1740             WRITE_REG(husart->Instance->DR, (uint16_t)(*tmp & (uint16_t)0x01FF));
;;;1741             if(husart->Init.Parity == USART_PARITY_NONE)
;;;1742             {
;;;1743               husart->pTxBuffPtr += 2;
;;;1744             }
;;;1745             else
;;;1746             {
;;;1747               husart->pTxBuffPtr += 1;
;;;1748             }
;;;1749           } 
;;;1750           else
;;;1751           {
;;;1752             WRITE_REG(husart->Instance->DR, (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF));
;;;1753           }
;;;1754           husart->TxXferCount--;
;;;1755   
;;;1756           /* Check the latest data transmitted */
;;;1757           if(husart->TxXferCount == 0)
;;;1758           {
;;;1759              __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
;;;1760           }
;;;1761         }
;;;1762       }
;;;1763   
;;;1764       if(husart->RxXferCount != 0x00)
;;;1765       {
;;;1766         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
;;;1767         {
;;;1768           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;1769           {
;;;1770             tmp = (uint16_t*) husart->pRxBuffPtr;
;;;1771             if(husart->Init.Parity == USART_PARITY_NONE)
;;;1772             {
;;;1773               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;1774               husart->pRxBuffPtr += 2;
;;;1775             }
;;;1776             else
;;;1777             {
;;;1778               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;1779               husart->pRxBuffPtr += 1;
;;;1780             }
;;;1781           } 
;;;1782           else
;;;1783           {
;;;1784             if(husart->Init.Parity == USART_PARITY_NONE)
;;;1785             {
;;;1786               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;1787             }
;;;1788             else
;;;1789             {
;;;1790               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;1791             }
;;;1792           }
;;;1793           husart->RxXferCount--;
;;;1794         }
;;;1795       }
;;;1796   
;;;1797       /* Check the latest data received */
;;;1798       if(husart->RxXferCount == 0)
;;;1799       {
;;;1800         __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
;;;1801   
;;;1802         /* Disable the USART Parity Error Interrupt */
;;;1803         __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
;;;1804   
;;;1805         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1806         __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
;;;1807   
;;;1808         husart->State = HAL_USART_STATE_READY;
;;;1809   
;;;1810         HAL_USART_TxRxCpltCallback(husart);
;;;1811   
;;;1812         return HAL_OK;
;;;1813       }
;;;1814   
;;;1815       return HAL_OK;
;;;1816     }
;;;1817     else
;;;1818     {
;;;1819       return HAL_BUSY; 
00000a  2002              MOVS     r0,#2
;;;1820     }
;;;1821   }
00000c  bd10              POP      {r4,pc}
                  |L33.14|
00000e  8d41              LDRH     r1,[r0,#0x2a]         ;1733
000010  f44f5380          MOV      r3,#0x1000            ;1737
000014  b319              CBZ      r1,|L33.94|
000016  6801              LDR      r1,[r0,#0]            ;1735
000018  680a              LDR      r2,[r1,#0]            ;1735
00001a  43d2              MVNS     r2,r2                 ;1735
00001c  0612              LSLS     r2,r2,#24             ;1735
00001e  d41e              BMI      |L33.94|
000020  6882              LDR      r2,[r0,#8]            ;1737
000022  429a              CMP      r2,r3                 ;1737
000024  6a42              LDR      r2,[r0,#0x24]         ;1737
000026  d10c              BNE      |L33.66|
000028  8812              LDRH     r2,[r2,#0]            ;1740
00002a  f3c20208          UBFX     r2,r2,#0,#9           ;1740
00002e  604a              STR      r2,[r1,#4]            ;1740
000030  6901              LDR      r1,[r0,#0x10]         ;1741
000032  2900              CMP      r1,#0                 ;1741
000034  6a41              LDR      r1,[r0,#0x24]         ;1741
000036  d002              BEQ      |L33.62|
000038  1c49              ADDS     r1,r1,#1              ;1741
                  |L33.58|
00003a  6241              STR      r1,[r0,#0x24]         ;1743
00003c  e005              B        |L33.74|
                  |L33.62|
00003e  1c89              ADDS     r1,r1,#2              ;1743
000040  e7fb              B        |L33.58|
                  |L33.66|
000042  1c54              ADDS     r4,r2,#1              ;1752
000044  6244              STR      r4,[r0,#0x24]         ;1752
000046  7812              LDRB     r2,[r2,#0]            ;1752
000048  604a              STR      r2,[r1,#4]            ;1752
                  |L33.74|
00004a  8d41              LDRH     r1,[r0,#0x2a]         ;1754
00004c  1e49              SUBS     r1,r1,#1              ;1754
00004e  8541              STRH     r1,[r0,#0x2a]         ;1754
000050  8d41              LDRH     r1,[r0,#0x2a]         ;1757
000052  b921              CBNZ     r1,|L33.94|
000054  6801              LDR      r1,[r0,#0]            ;1759
000056  68ca              LDR      r2,[r1,#0xc]          ;1759
000058  f0220280          BIC      r2,r2,#0x80           ;1759
00005c  60ca              STR      r2,[r1,#0xc]          ;1759
                  |L33.94|
00005e  8e41              LDRH     r1,[r0,#0x32]         ;1764
000060  b319              CBZ      r1,|L33.170|
000062  6801              LDR      r1,[r0,#0]            ;1766
000064  680a              LDR      r2,[r1,#0]            ;1766
000066  43d2              MVNS     r2,r2                 ;1766
000068  0692              LSLS     r2,r2,#26             ;1766
00006a  d41e              BMI      |L33.170|
00006c  6882              LDR      r2,[r0,#8]            ;1768
00006e  429a              CMP      r2,r3                 ;1768
000070  d10f              BNE      |L33.146|
000072  6903              LDR      r3,[r0,#0x10]         ;1778
000074  6ac2              LDR      r2,[r0,#0x2c]         ;1778
000076  6849              LDR      r1,[r1,#4]            ;1778
000078  b12b              CBZ      r3,|L33.134|
00007a  b2c9              UXTB     r1,r1                 ;1778
00007c  8011              STRH     r1,[r2,#0]            ;1778
00007e  6ac1              LDR      r1,[r0,#0x2c]         ;1779
000080  1c49              ADDS     r1,r1,#1              ;1779
                  |L33.130|
000082  62c1              STR      r1,[r0,#0x2c]         ;1774
000084  e00e              B        |L33.164|
                  |L33.134|
000086  f3c10108          UBFX     r1,r1,#0,#9           ;1773
00008a  8011              STRH     r1,[r2,#0]            ;1773
00008c  6ac1              LDR      r1,[r0,#0x2c]         ;1774
00008e  1c89              ADDS     r1,r1,#2              ;1774
000090  e7f7              B        |L33.130|
                  |L33.146|
000092  6902              LDR      r2,[r0,#0x10]         ;1784
000094  b162              CBZ      r2,|L33.176|
000096  6849              LDR      r1,[r1,#4]            ;1790
000098  f001037f          AND      r3,r1,#0x7f           ;1790
00009c  6ac1              LDR      r1,[r0,#0x2c]         ;1790
00009e  1c4a              ADDS     r2,r1,#1              ;1790
0000a0  62c2              STR      r2,[r0,#0x2c]         ;1790
0000a2  700b              STRB     r3,[r1,#0]            ;1790
                  |L33.164|
0000a4  8e41              LDRH     r1,[r0,#0x32]         ;1793
0000a6  1e49              SUBS     r1,r1,#1              ;1793
0000a8  8641              STRH     r1,[r0,#0x32]         ;1793
                  |L33.170|
0000aa  8e41              LDRH     r1,[r0,#0x32]         ;1798
0000ac  b131              CBZ      r1,|L33.188|
0000ae  e019              B        |L33.228|
                  |L33.176|
0000b0  684a              LDR      r2,[r1,#4]            ;1786
0000b2  6ac1              LDR      r1,[r0,#0x2c]         ;1786
0000b4  1c4b              ADDS     r3,r1,#1              ;1786
0000b6  62c3              STR      r3,[r0,#0x2c]         ;1786
0000b8  700a              STRB     r2,[r1,#0]            ;1786
0000ba  e7f3              B        |L33.164|
                  |L33.188|
0000bc  6801              LDR      r1,[r0,#0]            ;1800
0000be  68ca              LDR      r2,[r1,#0xc]          ;1800
0000c0  f0220220          BIC      r2,r2,#0x20           ;1800
0000c4  60ca              STR      r2,[r1,#0xc]          ;1800
0000c6  6801              LDR      r1,[r0,#0]            ;1803
0000c8  68ca              LDR      r2,[r1,#0xc]          ;1803
0000ca  f4227280          BIC      r2,r2,#0x100          ;1803
0000ce  60ca              STR      r2,[r1,#0xc]          ;1803
0000d0  6801              LDR      r1,[r0,#0]            ;1806
0000d2  694a              LDR      r2,[r1,#0x14]         ;1806
0000d4  f0220201          BIC      r2,r2,#1              ;1806
0000d8  614a              STR      r2,[r1,#0x14]         ;1806
0000da  2101              MOVS     r1,#1                 ;1808
0000dc  f880103d          STRB     r1,[r0,#0x3d]         ;1808
0000e0  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L33.228|
0000e4  2000              MOVS     r0,#0                 ;1815
0000e6  bd10              POP      {r4,pc}
;;;1822   
                          ENDP


                          AREA ||i.USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  USART_Transmit_IT PROC
;;;1585     */
;;;1586   static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart)
000000  f890103d          LDRB     r1,[r0,#0x3d]
;;;1587   {
;;;1588     uint16_t* tmp=0;
;;;1589    
;;;1590     if(husart->State == HAL_USART_STATE_BUSY_TX)
000004  2912              CMP      r1,#0x12
000006  d001              BEQ      |L34.12|
;;;1591     {
;;;1592       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;1593       {
;;;1594         tmp = (uint16_t*) husart->pTxBuffPtr;
;;;1595         WRITE_REG(husart->Instance->DR, (uint16_t)(*tmp & (uint16_t)0x01FF));
;;;1596         if(husart->Init.Parity == USART_PARITY_NONE)
;;;1597         {
;;;1598           husart->pTxBuffPtr += 2;
;;;1599         }
;;;1600         else
;;;1601         {
;;;1602           husart->pTxBuffPtr += 1;
;;;1603         }
;;;1604       } 
;;;1605       else
;;;1606       { 
;;;1607         WRITE_REG(husart->Instance->DR, (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF));
;;;1608       }
;;;1609       
;;;1610       if(--husart->TxXferCount == 0)
;;;1611       {
;;;1612         /* Disable the USART Transmit data register empty Interrupt */
;;;1613         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
;;;1614   
;;;1615         /* Enable the USART Transmit Complete Interrupt */    
;;;1616         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
;;;1617       }
;;;1618       return HAL_OK;
;;;1619     }
;;;1620     else
;;;1621     {
;;;1622       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;1623     }
;;;1624   }
00000a  4770              BX       lr
                  |L34.12|
00000c  6881              LDR      r1,[r0,#8]            ;1592
00000e  f5b15f80          CMP      r1,#0x1000            ;1592
000012  6a41              LDR      r1,[r0,#0x24]         ;1592
000014  d00b              BEQ      |L34.46|
000016  1c4a              ADDS     r2,r1,#1              ;1607
000018  6242              STR      r2,[r0,#0x24]         ;1607
00001a  6802              LDR      r2,[r0,#0]            ;1607
00001c  7809              LDRB     r1,[r1,#0]            ;1607
00001e  6051              STR      r1,[r2,#4]            ;1607
                  |L34.32|
000020  8d41              LDRH     r1,[r0,#0x2a]         ;1610
000022  1e49              SUBS     r1,r1,#1              ;1610
000024  0409              LSLS     r1,r1,#16             ;1610
000026  0c09              LSRS     r1,r1,#16             ;1610
000028  8541              STRH     r1,[r0,#0x2a]         ;1610
00002a  d00e              BEQ      |L34.74|
00002c  e017              B        |L34.94|
                  |L34.46|
00002e  8809              LDRH     r1,[r1,#0]            ;1595
000030  6802              LDR      r2,[r0,#0]            ;1595
000032  f3c10108          UBFX     r1,r1,#0,#9           ;1595
000036  6051              STR      r1,[r2,#4]            ;1595
000038  6901              LDR      r1,[r0,#0x10]         ;1596
00003a  2900              CMP      r1,#0                 ;1596
00003c  6a41              LDR      r1,[r0,#0x24]         ;1596
00003e  d002              BEQ      |L34.70|
000040  1c49              ADDS     r1,r1,#1              ;1596
                  |L34.66|
000042  6241              STR      r1,[r0,#0x24]         ;1602
000044  e7ec              B        |L34.32|
                  |L34.70|
000046  1c89              ADDS     r1,r1,#2              ;1602
000048  e7fb              B        |L34.66|
                  |L34.74|
00004a  6801              LDR      r1,[r0,#0]            ;1613
00004c  68ca              LDR      r2,[r1,#0xc]          ;1613
00004e  f0220280          BIC      r2,r2,#0x80           ;1613
000052  60ca              STR      r2,[r1,#0xc]          ;1613
000054  6800              LDR      r0,[r0,#0]            ;1616
000056  68c1              LDR      r1,[r0,#0xc]          ;1616
000058  f0410140          ORR      r1,r1,#0x40           ;1616
00005c  60c1              STR      r1,[r0,#0xc]          ;1616
                  |L34.94|
00005e  2000              MOVS     r0,#0                 ;1618
000060  4770              BX       lr
;;;1625   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  USART_WaitOnFlagUntilTimeout PROC
;;;1517     */
;;;1518   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1519   {
000004  461d              MOV      r5,r3
000006  4690              MOV      r8,r2
000008  460f              MOV      r7,r1
00000a  4604              MOV      r4,r0
;;;1520     uint32_t tickstart = 0;
;;;1521   
;;;1522     /* Get tick */ 
;;;1523     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4606              MOV      r6,r0
;;;1524   
;;;1525     /* Wait until flag is set */
;;;1526     if(Status == RESET)
000012  ea5f0008          MOVS     r0,r8
000016  f04f0900          MOV      r9,#0
;;;1527     {
;;;1528       while(__HAL_USART_GET_FLAG(husart, Flag) == RESET)
;;;1529       {
;;;1530         /* Check for the Timeout */
;;;1531         if(Timeout != HAL_MAX_DELAY)
;;;1532         {
;;;1533           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1534           {
;;;1535             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1536             __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
;;;1537             __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
;;;1538             __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
;;;1539             __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
;;;1540   
;;;1541             husart->State= HAL_USART_STATE_READY;
00001a  f04f0801          MOV      r8,#1
00001e  d008              BEQ      |L35.50|
000020  e030              B        |L35.132|
                  |L35.34|
000022  1c68              ADDS     r0,r5,#1              ;1531
000024  d005              BEQ      |L35.50|
000026  b195              CBZ      r5,|L35.78|
000028  f7fffffe          BL       HAL_GetTick
00002c  1b80              SUBS     r0,r0,r6              ;1533
00002e  42a8              CMP      r0,r5                 ;1533
000030  d80d              BHI      |L35.78|
                  |L35.50|
000032  6820              LDR      r0,[r4,#0]            ;1528
000034  6800              LDR      r0,[r0,#0]            ;1528
000036  ea370000          BICS     r0,r7,r0              ;1528
00003a  d1f2              BNE      |L35.34|
00003c  e027              B        |L35.142|
                  |L35.62|
;;;1542   
;;;1543             /* Process Unlocked */
;;;1544             __HAL_UNLOCK(husart);
;;;1545   
;;;1546             return HAL_TIMEOUT;
;;;1547           }
;;;1548         }
;;;1549       }
;;;1550     }
;;;1551     else
;;;1552     {
;;;1553       while(__HAL_USART_GET_FLAG(husart, Flag) != RESET)
;;;1554       {
;;;1555         /* Check for the Timeout */
;;;1556         if(Timeout != HAL_MAX_DELAY)
00003e  1c68              ADDS     r0,r5,#1
000040  d020              BEQ      |L35.132|
;;;1557         {
;;;1558           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000042  b125              CBZ      r5,|L35.78|
000044  f7fffffe          BL       HAL_GetTick
000048  1b80              SUBS     r0,r0,r6
00004a  42a8              CMP      r0,r5
00004c  d91a              BLS      |L35.132|
                  |L35.78|
;;;1559           {
;;;1560             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1561             __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
00004e  6820              LDR      r0,[r4,#0]
000050  68c1              LDR      r1,[r0,#0xc]
000052  f0210180          BIC      r1,r1,#0x80
000056  60c1              STR      r1,[r0,#0xc]
;;;1562             __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  f0210120          BIC      r1,r1,#0x20
000060  60c1              STR      r1,[r0,#0xc]
;;;1563             __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
000062  6820              LDR      r0,[r4,#0]
000064  68c1              LDR      r1,[r0,#0xc]
000066  f4217180          BIC      r1,r1,#0x100
00006a  60c1              STR      r1,[r0,#0xc]
;;;1564             __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
00006c  6820              LDR      r0,[r4,#0]
00006e  6941              LDR      r1,[r0,#0x14]
000070  f0210101          BIC      r1,r1,#1
000074  6141              STR      r1,[r0,#0x14]
;;;1565   
;;;1566             husart->State= HAL_USART_STATE_READY;
000076  f884803d          STRB     r8,[r4,#0x3d]
;;;1567   
;;;1568             /* Process Unlocked */
;;;1569             __HAL_UNLOCK(husart);
00007a  f884903c          STRB     r9,[r4,#0x3c]
;;;1570   
;;;1571             return HAL_TIMEOUT;
00007e  2003              MOVS     r0,#3
                  |L35.128|
;;;1572           }
;;;1573         }
;;;1574       }
;;;1575     }
;;;1576     return HAL_OK;
;;;1577   }
000080  e8bd87f0          POP      {r4-r10,pc}
                  |L35.132|
000084  6820              LDR      r0,[r4,#0]            ;1553
000086  6800              LDR      r0,[r0,#0]            ;1553
000088  ea370000          BICS     r0,r7,r0              ;1553
00008c  d0d7              BEQ      |L35.62|
                  |L35.142|
00008e  2000              MOVS     r0,#0                 ;1576
000090  e7f6              B        |L35.128|
;;;1578   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____REVSH|
#line 495
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____RRX|
#line 682
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
