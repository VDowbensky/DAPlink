; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\flash_manager.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\flash_manager.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\flash_manager.crf ..\..\..\source\daplink\drag-n-drop\flash_manager.c]
                          THUMB

                          AREA ||i.flash_manager_data||, CODE, READONLY, ALIGN=2

                  flash_manager_data PROC
;;;113    
;;;114    error_t flash_manager_data(uint32_t addr, const uint8_t *data, uint32_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;115    {
;;;116        uint32_t size_left;
;;;117        uint32_t copy_size;
;;;118        uint32_t pos;
;;;119        error_t status = ERROR_SUCCESS;
;;;120        flash_manager_printf("flash_manager_data(addr=0x%x size=0x%x)\r\n", addr, size);
;;;121    
;;;122        if (state != STATE_OPEN) {
000004  4e3d              LDR      r6,|L1.252|
000006  4605              MOV      r5,r0                 ;115
000008  2400              MOVS     r4,#0                 ;119
00000a  7870              LDRB     r0,[r6,#1]  ; state
00000c  4617              MOV      r7,r2                 ;115
00000e  4688              MOV      r8,r1                 ;115
000010  2801              CMP      r0,#1
000012  d007              BEQ      |L1.36|
;;;123            util_assert(0);
000014  227b              MOVS     r2,#0x7b
000016  a13a              ADR      r1,|L1.256|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       _util_assert
;;;124            return ERROR_INTERNAL;
00001e  2002              MOVS     r0,#2
                  |L1.32|
;;;125        }
;;;126    
;;;127        // Setup the current sector if it is not setup already
;;;128        if (!current_sector_valid) {
;;;129            status = setup_next_sector(addr);
;;;130    
;;;131            if (ERROR_SUCCESS != status) {
;;;132                state = STATE_ERROR;
;;;133                return status;
;;;134            }
;;;135            current_sector_valid = true;
;;;136            last_addr = addr;
;;;137        }
;;;138    
;;;139        //non-increasing address support
;;;140        if (ROUND_DOWN(addr, current_write_block_size) != ROUND_DOWN(last_addr, current_write_block_size)) {
;;;141            status = flush_current_block(addr);
;;;142            if (ERROR_SUCCESS != status) {
;;;143                state = STATE_ERROR;
;;;144                return status;
;;;145            }
;;;146        }
;;;147    
;;;148        if (ROUND_DOWN(addr, current_sector_size) != ROUND_DOWN(last_addr, current_sector_size)) {
;;;149            status = setup_next_sector(addr);
;;;150            if (ERROR_SUCCESS != status) {
;;;151                state = STATE_ERROR;
;;;152                return status;
;;;153            }
;;;154        }
;;;155    
;;;156        while (true) {
;;;157            // flush if necessary
;;;158            if (addr >= current_write_block_addr + current_write_block_size) {
;;;159                status = flush_current_block(addr);
;;;160                if (ERROR_SUCCESS != status) {
;;;161                    state = STATE_ERROR;
;;;162                    return status;
;;;163                }
;;;164            }
;;;165    
;;;166            // Check for end
;;;167            if (size <= 0) {
;;;168                break;
;;;169            }
;;;170    
;;;171            // Change sector if necessary
;;;172            if (addr >= current_sector_addr + current_sector_size) {
;;;173                status = setup_next_sector(addr);
;;;174    
;;;175                if (ERROR_SUCCESS != status) {
;;;176                    state = STATE_ERROR;
;;;177                    return status;
;;;178                }
;;;179            }
;;;180    
;;;181            // write buffer
;;;182            pos = addr - current_write_block_addr;
;;;183            size_left = current_write_block_size - pos;
;;;184            copy_size = MIN(size, size_left);
;;;185            memcpy(buf + pos, data, copy_size);
;;;186            buf_empty = copy_size == 0;
;;;187            // Update variables
;;;188            addr += copy_size;
;;;189            data += copy_size;
;;;190            size -= copy_size;
;;;191        }
;;;192    
;;;193        last_addr = addr;
;;;194        return status;
;;;195    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L1.36|
000024  78f0              LDRB     r0,[r6,#3]            ;128  ; current_sector_valid
000026  f04f0a02          MOV      r10,#2                ;124
00002a  b950              CBNZ     r0,|L1.66|
00002c  4628              MOV      r0,r5                 ;129
00002e  f7fffffe          BL       setup_next_sector
000032  0004              MOVS     r4,r0                 ;129
000034  d002              BEQ      |L1.60|
                  |L1.54|
000036  f886a001          STRB     r10,[r6,#1]           ;132
00003a  e05c              B        |L1.246|
                  |L1.60|
00003c  2001              MOVS     r0,#1                 ;135
00003e  70f0              STRB     r0,[r6,#3]            ;135
000040  6175              STR      r5,[r6,#0x14]         ;136  ; last_addr
                  |L1.66|
000042  68b0              LDR      r0,[r6,#8]            ;140  ; current_write_block_size
000044  fbb5f1f0          UDIV     r1,r5,r0              ;140
000048  fb005111          MLS      r1,r0,r1,r5           ;140
00004c  1a6a              SUBS     r2,r5,r1              ;140
00004e  6971              LDR      r1,[r6,#0x14]         ;140  ; last_addr
000050  fbb1f3f0          UDIV     r3,r1,r0              ;140
000054  fb001013          MLS      r0,r0,r3,r1           ;140
000058  1a08              SUBS     r0,r1,r0              ;140
00005a  4282              CMP      r2,r0                 ;140
00005c  d004              BEQ      |L1.104|
00005e  4628              MOV      r0,r5                 ;141
000060  f7fffffe          BL       flush_current_block
000064  0004              MOVS     r4,r0                 ;141
000066  d1e6              BNE      |L1.54|
                  |L1.104|
000068  6930              LDR      r0,[r6,#0x10]         ;148  ; current_sector_size
00006a  fbb5f1f0          UDIV     r1,r5,r0              ;148
00006e  fb005111          MLS      r1,r0,r1,r5           ;148
000072  1a6a              SUBS     r2,r5,r1              ;148
000074  6971              LDR      r1,[r6,#0x14]         ;148  ; last_addr
000076  fbb1f3f0          UDIV     r3,r1,r0              ;148
00007a  fb001013          MLS      r0,r0,r3,r1           ;148
00007e  1a08              SUBS     r0,r1,r0              ;148
000080  4282              CMP      r2,r0                 ;148
000082  d004              BEQ      |L1.142|
000084  4628              MOV      r0,r5                 ;149
000086  f7fffffe          BL       setup_next_sector
00008a  0004              MOVS     r4,r0                 ;149
00008c  d1d3              BNE      |L1.54|
                  |L1.142|
00008e  46b1              MOV      r9,r6                 ;122
                  |L1.144|
000090  464e              MOV      r6,r9                 ;158
000092  e9d60101          LDRD     r0,r1,[r6,#4]         ;158
000096  4408              ADD      r0,r0,r1              ;158
000098  42a8              CMP      r0,r5                 ;158
00009a  d807              BHI      |L1.172|
00009c  4628              MOV      r0,r5                 ;159
00009e  f7fffffe          BL       flush_current_block
0000a2  0004              MOVS     r4,r0                 ;159
0000a4  d002              BEQ      |L1.172|
                  |L1.166|
0000a6  f889a001          STRB     r10,[r9,#1]           ;161
0000aa  e024              B        |L1.246|
                  |L1.172|
0000ac  b30f              CBZ      r7,|L1.242|
0000ae  e9d60103          LDRD     r0,r1,[r6,#0xc]       ;167
0000b2  4408              ADD      r0,r0,r1              ;172
0000b4  42a8              CMP      r0,r5                 ;172
0000b6  d804              BHI      |L1.194|
0000b8  4628              MOV      r0,r5                 ;173
0000ba  f7fffffe          BL       setup_next_sector
0000be  0004              MOVS     r4,r0                 ;173
0000c0  d1f1              BNE      |L1.166|
                  |L1.194|
0000c2  6870              LDR      r0,[r6,#4]            ;182  ; current_write_block_addr
0000c4  68b1              LDR      r1,[r6,#8]            ;183  ; current_write_block_size
0000c6  46b1              MOV      r9,r6                 ;182
0000c8  1a28              SUBS     r0,r5,r0              ;182
0000ca  1a0e              SUBS     r6,r1,r0              ;183
0000cc  42b7              CMP      r7,r6                 ;184
0000ce  d200              BCS      |L1.210|
0000d0  463e              MOV      r6,r7                 ;184
                  |L1.210|
0000d2  490d              LDR      r1,|L1.264|
0000d4  4632              MOV      r2,r6                 ;185
0000d6  4408              ADD      r0,r0,r1              ;185
0000d8  4641              MOV      r1,r8                 ;185
0000da  f7fffffe          BL       __aeabi_memcpy
0000de  b136              CBZ      r6,|L1.238|
0000e0  2000              MOVS     r0,#0                 ;186
                  |L1.226|
0000e2  f8890002          STRB     r0,[r9,#2]            ;186
0000e6  4435              ADD      r5,r5,r6              ;188
0000e8  44b0              ADD      r8,r8,r6              ;189
0000ea  1bbf              SUBS     r7,r7,r6              ;190
0000ec  e7d0              B        |L1.144|
                  |L1.238|
0000ee  2001              MOVS     r0,#1                 ;186
0000f0  e7f7              B        |L1.226|
                  |L1.242|
0000f2  f8c95014          STR      r5,[r9,#0x14]         ;193  ; last_addr
                  |L1.246|
0000f6  4620              MOV      r0,r4                 ;194
0000f8  e792              B        |L1.32|
;;;196    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L1.252|
                          DCD      ||.data||
                  |L1.256|
000100  2866696c          DCB      "(file)",0
000104  652900  
000107  00                DCB      0
                  |L1.264|
                          DCD      ||.bss||

                          AREA ||i.flash_manager_init||, CODE, READONLY, ALIGN=2

                  flash_manager_init PROC
;;;63     
;;;64     error_t flash_manager_init(const flash_intf_t *flash_intf)
000000  b570              PUSH     {r4-r6,lr}
;;;65     {
;;;66         error_t status;
;;;67         // Assert that interface has been properly uninitialized
;;;68         flash_manager_printf("flash_manager_init()\r\n");
;;;69     
;;;70         if (state != STATE_CLOSED) {
000002  4d1f              LDR      r5,|L2.128|
000004  4604              MOV      r4,r0                 ;65
000006  7868              LDRB     r0,[r5,#1]  ; state
000008  b108              CBZ      r0,|L2.14|
;;;71             util_assert(0);
00000a  2247              MOVS     r2,#0x47
;;;72             return ERROR_INTERNAL;
00000c  e026              B        |L2.92|
                  |L2.14|
00000e  b324              CBZ      r4,|L2.90|
000010  6860              LDR      r0,[r4,#4]
000012  b310              CBZ      r0,|L2.90|
000014  68a0              LDR      r0,[r4,#8]
000016  b300              CBZ      r0,|L2.90|
000018  68e0              LDR      r0,[r4,#0xc]
00001a  b1f0              CBZ      r0,|L2.90|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  b1e0              CBZ      r0,|L2.90|
000020  6960              LDR      r0,[r4,#0x14]
000022  b1d0              CBZ      r0,|L2.90|
000024  69a0              LDR      r0,[r4,#0x18]
000026  b1c0              CBZ      r0,|L2.90|
000028  69e0              LDR      r0,[r4,#0x1c]
00002a  b1b0              CBZ      r0,|L2.90|
;;;73         }
;;;74     
;;;75         // Check for a valid flash interface
;;;76         if (!flash_intf_valid(flash_intf)) {
;;;77             util_assert(0);
;;;78             return ERROR_INTERNAL;
;;;79         }
;;;80     
;;;81         // Initialize variables
;;;82         memset(buf, 0xFF, sizeof(buf));
00002c  22ff              MOVS     r2,#0xff
00002e  f44f6180          MOV      r1,#0x400
000032  4814              LDR      r0,|L2.132|
000034  f7fffffe          BL       __aeabi_memset
;;;83         buf_empty = true;
000038  2601              MOVS     r6,#1
00003a  70ae              STRB     r6,[r5,#2]
;;;84         current_sector_valid = false;
00003c  2000              MOVS     r0,#0
00003e  70e8              STRB     r0,[r5,#3]
;;;85         current_write_block_addr = 0;
;;;86         current_write_block_size = 0;
000040  6068              STR      r0,[r5,#4]  ; current_write_block_addr
;;;87         current_sector_addr = 0;
000042  60a8              STR      r0,[r5,#8]  ; current_write_block_size
;;;88         current_sector_size = 0;
000044  60e8              STR      r0,[r5,#0xc]  ; current_sector_addr
000046  6128              STR      r0,[r5,#0x10]  ; current_sector_size
000048  e9c50405          STRD     r0,r4,[r5,#0x14]
;;;89         last_addr = 0;
;;;90         intf = flash_intf;
;;;91         // Initialize flash
;;;92         status = intf->init();
00004c  6820              LDR      r0,[r4,#0]
00004e  4780              BLX      r0
000050  0004              MOVS     r4,r0
;;;93         flash_manager_printf("    intf->init ret=%i\r\n", status);
;;;94     
;;;95         if (ERROR_SUCCESS != status) {
000052  d108              BNE      |L2.102|
;;;96             return status;
;;;97         }
;;;98     
;;;99         if (!page_erase_enabled) {
000054  7828              LDRB     r0,[r5,#0]  ; page_erase_enabled
000056  b138              CBZ      r0,|L2.104|
000058  e010              B        |L2.124|
                  |L2.90|
00005a  224d              MOVS     r2,#0x4d              ;77
                  |L2.92|
00005c  a10a              ADR      r1,|L2.136|
00005e  2000              MOVS     r0,#0                 ;77
000060  f7fffffe          BL       _util_assert
000064  2002              MOVS     r0,#2                 ;78
                  |L2.102|
;;;100            // Erase flash and unint if there are errors
;;;101            status = intf->erase_chip();
;;;102            flash_manager_printf("    intf->erase_chip ret=%i\r\n", status);
;;;103    
;;;104            if (ERROR_SUCCESS != status) {
;;;105                intf->uninit();
;;;106                return status;
;;;107            }
;;;108        }
;;;109    
;;;110        state = STATE_OPEN;
;;;111        return status;
;;;112    }
000066  bd70              POP      {r4-r6,pc}
                  |L2.104|
000068  69a8              LDR      r0,[r5,#0x18]         ;101  ; intf
00006a  6900              LDR      r0,[r0,#0x10]         ;101
00006c  4780              BLX      r0                    ;101
00006e  0004              MOVS     r4,r0                 ;101
000070  d004              BEQ      |L2.124|
000072  69a8              LDR      r0,[r5,#0x18]         ;105  ; intf
000074  6840              LDR      r0,[r0,#4]            ;105
000076  4780              BLX      r0                    ;105
                  |L2.120|
000078  4620              MOV      r0,r4                 ;111
00007a  bd70              POP      {r4-r6,pc}
                  |L2.124|
00007c  706e              STRB     r6,[r5,#1]            ;110
00007e  e7fb              B        |L2.120|
;;;113    
                          ENDP

                  |L2.128|
                          DCD      ||.data||
                  |L2.132|
                          DCD      ||.bss||
                  |L2.136|
000088  2866696c          DCB      "(file)",0
00008c  652900  
00008f  00                DCB      0

                          AREA ||i.flash_manager_set_page_erase||, CODE, READONLY, ALIGN=2

                  flash_manager_set_page_erase PROC
;;;239    
;;;240    void flash_manager_set_page_erase(bool enabled)
000000  b510              PUSH     {r4,lr}
;;;241    {
000002  4604              MOV      r4,r0
;;;242        config_ram_set_page_erase(enabled);
000004  f7fffffe          BL       config_ram_set_page_erase
;;;243        page_erase_enabled = enabled;
000008  4801              LDR      r0,|L3.16|
00000a  7004              STRB     r4,[r0,#0]
;;;244    }
00000c  bd10              POP      {r4,pc}
;;;245    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      ||.data||

                          AREA ||i.flash_manager_uninit||, CODE, READONLY, ALIGN=2

                  flash_manager_uninit PROC
;;;196    
;;;197    error_t flash_manager_uninit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
;;;199        error_t flash_uninit_error;
;;;200        error_t flash_write_error = ERROR_SUCCESS;
;;;201        flash_manager_printf("flash_manager_uninit()\r\n");
;;;202    
;;;203        if (STATE_CLOSED == state) {
000002  4c15              LDR      r4,|L4.88|
000004  2500              MOVS     r5,#0                 ;200
000006  7860              LDRB     r0,[r4,#1]  ; state
000008  b110              CBZ      r0,|L4.16|
;;;204            util_assert(0);
;;;205            return ERROR_INTERNAL;
;;;206        }
;;;207    
;;;208        // Flush last buffer if its not empty
;;;209        if (STATE_OPEN == state) {
00000a  2801              CMP      r0,#1
00000c  d007              BEQ      |L4.30|
00000e  e00a              B        |L4.38|
                  |L4.16|
000010  22cc              MOVS     r2,#0xcc              ;204
000012  a112              ADR      r1,|L4.92|
000014  2000              MOVS     r0,#0                 ;204
000016  f7fffffe          BL       _util_assert
00001a  2002              MOVS     r0,#2                 ;205
;;;210            flash_write_error = flush_current_block(0);
;;;211            flash_manager_printf("    last flush_current_block ret=%i\r\n",flash_write_error);
;;;212        }
;;;213        // Close flash interface (even if there was an error during program_page)
;;;214        flash_uninit_error = intf->uninit();
;;;215        flash_manager_printf("    intf->uninit() ret=%i\r\n", flash_uninit_error);
;;;216        // Reset variables to catch accidental use
;;;217        memset(buf, 0xFF, sizeof(buf));
;;;218        buf_empty = true;
;;;219        current_sector_valid = false;
;;;220        current_write_block_addr = 0;
;;;221        current_write_block_size = 0;
;;;222        current_sector_addr = 0;
;;;223        current_sector_size = 0;
;;;224        last_addr = 0;
;;;225        state = STATE_CLOSED;
;;;226    
;;;227        // Make sure an error from a page write or from an
;;;228        // uninit gets propagated
;;;229        if (flash_uninit_error != ERROR_SUCCESS) {
;;;230            return flash_uninit_error;
;;;231        }
;;;232    
;;;233        if (flash_write_error != ERROR_SUCCESS) {
;;;234            return flash_write_error;
;;;235        }
;;;236    
;;;237        return ERROR_SUCCESS;
;;;238    }
00001c  bd70              POP      {r4-r6,pc}
                  |L4.30|
00001e  2000              MOVS     r0,#0                 ;210
000020  f7fffffe          BL       flush_current_block
000024  4605              MOV      r5,r0                 ;210
                  |L4.38|
000026  69a0              LDR      r0,[r4,#0x18]         ;214  ; intf
000028  6840              LDR      r0,[r0,#4]            ;214
00002a  4780              BLX      r0                    ;214
00002c  4606              MOV      r6,r0                 ;214
00002e  22ff              MOVS     r2,#0xff              ;217
000030  f44f6180          MOV      r1,#0x400             ;217
000034  480b              LDR      r0,|L4.100|
000036  f7fffffe          BL       __aeabi_memset
00003a  2001              MOVS     r0,#1                 ;218
00003c  70a0              STRB     r0,[r4,#2]            ;218
00003e  2100              MOVS     r1,#0                 ;219
000040  70e1              STRB     r1,[r4,#3]            ;219
000042  6061              STR      r1,[r4,#4]            ;221  ; current_write_block_addr
000044  60a1              STR      r1,[r4,#8]            ;222  ; current_write_block_size
000046  60e1              STR      r1,[r4,#0xc]          ;223  ; current_sector_addr
000048  6121              STR      r1,[r4,#0x10]         ;224  ; current_sector_size
00004a  6161              STR      r1,[r4,#0x14]         ;225  ; last_addr
00004c  7061              STRB     r1,[r4,#1]            ;225
00004e  b10e              CBZ      r6,|L4.84|
000050  4630              MOV      r0,r6                 ;230
000052  bd70              POP      {r4-r6,pc}
                  |L4.84|
000054  4628              MOV      r0,r5                 ;234
000056  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

                  |L4.88|
                          DCD      ||.data||
                  |L4.92|
00005c  2866696c          DCB      "(file)",0
000060  652900  
000063  00                DCB      0
                  |L4.100|
                          DCD      ||.bss||

                          AREA ||i.flush_current_block||, CODE, READONLY, ALIGN=2

                  flush_current_block PROC
;;;283    
;;;284    static error_t flush_current_block(uint32_t addr){
000000  b570              PUSH     {r4-r6,lr}
;;;285        // Write out current buffer if there is data in it
;;;286        error_t status = ERROR_SUCCESS;
;;;287        if (!buf_empty) {
000002  4e0e              LDR      r6,|L5.60|
000004  4605              MOV      r5,r0                 ;284
000006  2400              MOVS     r4,#0                 ;286
000008  78b0              LDRB     r0,[r6,#2]  ; buf_empty
00000a  b940              CBNZ     r0,|L5.30|
;;;288            status = intf->program_page(current_write_block_addr, buf, current_write_block_size);
00000c  69b0              LDR      r0,[r6,#0x18]  ; intf
00000e  490c              LDR      r1,|L5.64|
000010  6883              LDR      r3,[r0,#8]
000012  e9d60201          LDRD     r0,r2,[r6,#4]
000016  4798              BLX      r3
000018  4604              MOV      r4,r0
;;;289            flash_manager_printf("    intf->program_page(addr=0x%x, size=0x%x) ret=%i\r\n", current_write_block_addr, current_write_block_size, status);
;;;290            buf_empty = true;
00001a  2001              MOVS     r0,#1
00001c  70b0              STRB     r0,[r6,#2]
                  |L5.30|
;;;291        }
;;;292    
;;;293        // Setup for next block
;;;294        memset(buf, 0xFF, current_write_block_size);
00001e  22ff              MOVS     r2,#0xff
000020  4807              LDR      r0,|L5.64|
000022  68b1              LDR      r1,[r6,#8]  ; current_write_block_size
000024  f7fffffe          BL       __aeabi_memset
;;;295        current_write_block_addr = ROUND_DOWN(addr,current_write_block_size);
000028  68b0              LDR      r0,[r6,#8]  ; current_write_block_size
00002a  fbb5f1f0          UDIV     r1,r5,r0
00002e  fb005011          MLS      r0,r0,r1,r5
000032  1a28              SUBS     r0,r5,r0
;;;296        return status;
000034  6070              STR      r0,[r6,#4]  ; current_write_block_addr
000036  4620              MOV      r0,r4
;;;297    }
000038  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      ||.data||
                  |L5.64|
                          DCD      ||.bss||

                          AREA ||i.setup_next_sector||, CODE, READONLY, ALIGN=2

                  setup_next_sector PROC
;;;298    
;;;299    static error_t setup_next_sector(uint32_t addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;300    {
;;;301        uint32_t min_prog_size;
;;;302        uint32_t sector_size;
;;;303        error_t status;
;;;304        min_prog_size = intf->program_page_min_size(addr);
000004  4e36              LDR      r6,|L6.224|
000006  4607              MOV      r7,r0                 ;300
000008  69b0              LDR      r0,[r6,#0x18]  ; intf
00000a  6941              LDR      r1,[r0,#0x14]
00000c  4638              MOV      r0,r7
00000e  4788              BLX      r1
000010  4605              MOV      r5,r0
;;;305        sector_size = intf->erase_sector_size(addr);
000012  69b0              LDR      r0,[r6,#0x18]  ; intf
000014  6981              LDR      r1,[r0,#0x18]
000016  4638              MOV      r0,r7
000018  4788              BLX      r1
00001a  4604              MOV      r4,r0
;;;306    
;;;307        if ((min_prog_size <= 0) || (sector_size <= 0)) {
00001c  b135              CBZ      r5,|L6.44|
00001e  b12c              CBZ      r4,|L6.44|
;;;308            // Either of these conditions could cause divide by 0 error
;;;309            util_assert(0);
;;;310            return ERROR_INTERNAL;
;;;311        }
;;;312    
;;;313        // Assert required size and alignment
;;;314        util_assert(sizeof(buf) >= min_prog_size);
000020  f44f6880          MOV      r8,#0x400
000024  4545              CMP      r5,r8
000026  d80a              BHI      |L6.62|
000028  2001              MOVS     r0,#1
00002a  e009              B        |L6.64|
                  |L6.44|
00002c  f2401235          MOV      r2,#0x135             ;309
000030  a12c              ADR      r1,|L6.228|
000032  2000              MOVS     r0,#0                 ;309
000034  f7fffffe          BL       _util_assert
000038  2002              MOVS     r0,#2                 ;310
                  |L6.58|
;;;315        util_assert(sizeof(buf) % min_prog_size == 0);
;;;316        util_assert(sector_size >= min_prog_size);
;;;317        util_assert(sector_size % min_prog_size == 0);
;;;318        // Setup global variables
;;;319        current_sector_addr = ROUND_DOWN(addr, sector_size);
;;;320        current_sector_size = sector_size;
;;;321        current_write_block_addr = current_sector_addr;
;;;322        current_write_block_size = MIN(sector_size, sizeof(buf));
;;;323    
;;;324        //check flash algo every sector change, addresses with different flash algo should be sector aligned
;;;325        if (intf->flash_algo_set) {
;;;326            status = intf->flash_algo_set(current_sector_addr);
;;;327            if (ERROR_SUCCESS != status) {
;;;328                intf->uninit();
;;;329                return status;
;;;330            }
;;;331        }
;;;332    
;;;333        if (page_erase_enabled) {
;;;334            // Erase the current sector
;;;335            status = intf->erase_sector(current_sector_addr);
;;;336            flash_manager_printf("    intf->erase_sector(addr=0x%x) ret=%i\r\n", current_sector_addr);
;;;337            if (ERROR_SUCCESS != status) {
;;;338                intf->uninit();
;;;339                return status;
;;;340            }
;;;341        }
;;;342    
;;;343        // Clear out buffer in case block size changed
;;;344        memset(buf, 0xFF, current_write_block_size);
;;;345        flash_manager_printf("    setup_next_sector(addr=0x%x) sect_addr=0x%x, write_addr=0x%x,\r\n",
;;;346                             addr, current_sector_addr, current_write_block_addr);
;;;347        flash_manager_printf("        actual_write_size=0x%x, sector_size=0x%x, min_write=0x%x\r\n",
;;;348                             current_write_block_size, current_sector_size, min_prog_size);
;;;349        return ERROR_SUCCESS;
;;;350    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.62|
00003e  2000              MOVS     r0,#0                 ;314
                  |L6.64|
000040  f44f729d          MOV      r2,#0x13a             ;314
000044  a127              ADR      r1,|L6.228|
000046  f7fffffe          BL       _util_assert
00004a  fbb8f1f5          UDIV     r1,r8,r5              ;315
00004e  fb058011          MLS      r0,r5,r1,r8           ;315
000052  b148              CBZ      r0,|L6.104|
000054  2000              MOVS     r0,#0                 ;315
                  |L6.86|
000056  f240123b          MOV      r2,#0x13b             ;315
00005a  a122              ADR      r1,|L6.228|
00005c  f7fffffe          BL       _util_assert
000060  42ac              CMP      r4,r5                 ;316
000062  d303              BCC      |L6.108|
000064  2001              MOVS     r0,#1                 ;316
000066  e002              B        |L6.110|
                  |L6.104|
000068  2001              MOVS     r0,#1                 ;315
00006a  e7f4              B        |L6.86|
                  |L6.108|
00006c  2000              MOVS     r0,#0                 ;316
                  |L6.110|
00006e  f44f729e          MOV      r2,#0x13c             ;316
000072  a11c              ADR      r1,|L6.228|
000074  f7fffffe          BL       _util_assert
000078  fbb4f0f5          UDIV     r0,r4,r5              ;317
00007c  fb054010          MLS      r0,r5,r0,r4           ;317
000080  b1c0              CBZ      r0,|L6.180|
000082  2000              MOVS     r0,#0                 ;317
                  |L6.132|
000084  f240123d          MOV      r2,#0x13d             ;317
000088  a116              ADR      r1,|L6.228|
00008a  f7fffffe          BL       _util_assert
00008e  fbb7f0f4          UDIV     r0,r7,r4              ;319
000092  fb047010          MLS      r0,r4,r0,r7           ;319
000096  1a38              SUBS     r0,r7,r0              ;319
000098  e9c60403          STRD     r0,r4,[r6,#0xc]       ;319
00009c  6070              STR      r0,[r6,#4]            ;322  ; current_write_block_addr
00009e  4544              CMP      r4,r8                 ;322
0000a0  d300              BCC      |L6.164|
0000a2  4644              MOV      r4,r8                 ;322
                  |L6.164|
0000a4  60b4              STR      r4,[r6,#8]            ;325  ; current_write_block_size
0000a6  69b1              LDR      r1,[r6,#0x18]         ;325  ; intf
0000a8  6a09              LDR      r1,[r1,#0x20]         ;325
0000aa  b129              CBZ      r1,|L6.184|
0000ac  4788              BLX      r1                    ;326
0000ae  0004              MOVS     r4,r0                 ;326
0000b0  d10a              BNE      |L6.200|
0000b2  e001              B        |L6.184|
                  |L6.180|
0000b4  2001              MOVS     r0,#1                 ;317
0000b6  e7e5              B        |L6.132|
                  |L6.184|
0000b8  7830              LDRB     r0,[r6,#0]            ;333  ; page_erase_enabled
0000ba  b150              CBZ      r0,|L6.210|
0000bc  69b0              LDR      r0,[r6,#0x18]         ;335  ; intf
0000be  68c1              LDR      r1,[r0,#0xc]          ;335
0000c0  68f0              LDR      r0,[r6,#0xc]          ;335  ; current_sector_addr
0000c2  4788              BLX      r1                    ;335
0000c4  0004              MOVS     r4,r0                 ;335
0000c6  d004              BEQ      |L6.210|
                  |L6.200|
0000c8  69b0              LDR      r0,[r6,#0x18]         ;338  ; intf
0000ca  6840              LDR      r0,[r0,#4]            ;338
0000cc  4780              BLX      r0                    ;338
0000ce  4620              MOV      r0,r4                 ;339
0000d0  e7b3              B        |L6.58|
                  |L6.210|
0000d2  22ff              MOVS     r2,#0xff              ;344
0000d4  4805              LDR      r0,|L6.236|
0000d6  68b1              LDR      r1,[r6,#8]            ;344  ; current_write_block_size
0000d8  f7fffffe          BL       __aeabi_memset
0000dc  2000              MOVS     r0,#0                 ;349
0000de  e7ac              B        |L6.58|
                          ENDP

                  |L6.224|
                          DCD      ||.data||
                  |L6.228|
0000e4  2866696c          DCB      "(file)",0
0000e8  652900  
0000eb  00                DCB      0
                  |L6.236|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  buf
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  page_erase_enabled
000000  00                DCB      0x00
                  state
000001  00                DCB      0x00
                  buf_empty
000002  00                DCB      0x00
                  current_sector_valid
000003  00                DCB      0x00
                  current_write_block_addr
                          DCD      0x00000000
                  current_write_block_size
                          DCD      0x00000000
                  current_sector_addr
                          DCD      0x00000000
                  current_sector_size
                          DCD      0x00000000
                  last_addr
                          DCD      0x00000000
                  intf
                          DCD      0x00000000
