; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\iap_flash_intf.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\iap_flash_intf.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\iap_flash_intf.crf ..\..\..\source\daplink\drag-n-drop\iap_flash_intf.c]
                          THUMB

                          AREA ||i.critical_erase_and_program||, CODE, READONLY, ALIGN=2

                  critical_erase_and_program PROC
;;;471    
;;;472    static error_t critical_erase_and_program(uint32_t addr, const uint8_t *data, uint32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;473    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;474        uint32_t iap_status;
;;;475    
;;;476        if (size < DAPLINK_MIN_WRITE_SIZE) {
000008  f5b26f80          CMP      r2,#0x400
00000c  d207              BCS      |L1.30|
;;;477            util_assert(0);
00000e  f24012dd          MOV      r2,#0x1dd
000012  a10a              ADR      r1,|L1.60|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       _util_assert
;;;478            return ERROR_INTERNAL;
00001a  2002              MOVS     r0,#2
;;;479        }
;;;480    
;;;481        // CRITICAL SECTION BELOW HERE!
;;;482        // If something goes wrong with either
;;;483        // the erase or write then the device
;;;484        // will no longer be bootable.
;;;485        // Erase the first sector
;;;486        iap_status = flash_erase_sector(addr);
;;;487    
;;;488        if (iap_status != 0) {
;;;489            return ERROR_ERASE_ALL;
;;;490        }
;;;491    
;;;492        // Program the interface's vector table
;;;493        iap_status = flash_program_page(addr, size, (uint8_t *)data);
;;;494    
;;;495        if (iap_status != 0) {
;;;496            return ERROR_IAP_WRITE;
;;;497        }
;;;498    
;;;499        return ERROR_SUCCESS;
;;;500    }
00001c  bd70              POP      {r4-r6,pc}
                  |L1.30|
00001e  f7fffffe          BL       flash_erase_sector
000022  b108              CBZ      r0,|L1.40|
000024  2010              MOVS     r0,#0x10              ;489
                  |L1.38|
000026  bd70              POP      {r4-r6,pc}
                  |L1.40|
000028  462a              MOV      r2,r5                 ;493
00002a  4621              MOV      r1,r4                 ;493
00002c  4630              MOV      r0,r6                 ;493
00002e  f7fffffe          BL       flash_program_page
000032  2800              CMP      r0,#0                 ;495
000034  d0f7              BEQ      |L1.38|
000036  201f              MOVS     r0,#0x1f              ;496
000038  bd70              POP      {r4-r6,pc}
;;;501    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
00003c  2866696c          DCB      "(file)",0
000040  652900  
000043  00                DCB      0

                          AREA ||i.erase_chip||, CODE, READONLY, ALIGN=2

                  erase_chip PROC
;;;304    
;;;305    static error_t erase_chip(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;306    {
;;;307        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;308        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;309    
;;;310        if (state != STATE_OPEN) {
000004  4e16              LDR      r6,|L2.96|
000006  4c14              LDR      r4,|L2.88|
000008  4d14              LDR      r5,|L2.92|
00000a  7830              LDRB     r0,[r6,#0]  ; state
00000c  2801              CMP      r0,#1
00000e  d006              BEQ      |L2.30|
;;;311            util_assert(0);
000010  f2401237          MOV      r2,#0x137
000014  a113              ADR      r1,|L2.100|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       _util_assert
;;;312            return ERROR_INTERNAL;
00001c  e009              B        |L2.50|
                  |L2.30|
;;;313        }
;;;314    
;;;315        if (mass_erase_performed) {
00001e  78b0              LDRB     r0,[r6,#2]  ; mass_erase_performed
000020  2702              MOVS     r7,#2                 ;312
000022  b148              CBZ      r0,|L2.56|
;;;316            // Mass erase only allowed once
;;;317            util_assert(0);
000024  f240123d          MOV      r2,#0x13d
000028  a10e              ADR      r1,|L2.100|
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       _util_assert
;;;318            state = STATE_ERROR;
000030  7037              STRB     r7,[r6,#0]
                  |L2.50|
;;;319            return ERROR_INTERNAL;
000032  2002              MOVS     r0,#2
                  |L2.52|
;;;320        }
;;;321    
;;;322        for (uint32_t addr = updt_start; addr < updt_end; addr += DAPLINK_SECTOR_SIZE) {
;;;323            error_t status;
;;;324            status = erase_sector(addr);
;;;325    
;;;326            if (status != ERROR_SUCCESS) {
;;;327                state = STATE_ERROR;
;;;328                return ERROR_IAP_ERASE_ALL;
;;;329            }
;;;330        }
;;;331    
;;;332        mass_erase_performed = true;
;;;333        return ERROR_SUCCESS;
;;;334    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L2.56|
000038  4620              MOV      r0,r4                 ;324
00003a  f7fffffe          BL       erase_sector
00003e  b110              CBZ      r0,|L2.70|
000040  7037              STRB     r7,[r6,#0]            ;327
000042  2021              MOVS     r0,#0x21              ;328
000044  e7f6              B        |L2.52|
                  |L2.70|
000046  f5046480          ADD      r4,r4,#0x400
00004a  42ac              CMP      r4,r5                 ;322
00004c  d3f4              BCC      |L2.56|
00004e  2001              MOVS     r0,#1                 ;332
000050  70b0              STRB     r0,[r6,#2]            ;332
000052  2000              MOVS     r0,#0                 ;333
000054  e7ee              B        |L2.52|
;;;335    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      0x0800c000
                  |L2.92|
                          DCD      0x0801fc00
                  |L2.96|
                          DCD      ||.data||
                  |L2.100|
000064  2866696c          DCB      "(file)",0
000068  652900  
00006b  00                DCB      0

                          AREA ||i.erase_sector||, CODE, READONLY, ALIGN=2

                  erase_sector PROC
;;;247    
;;;248    static error_t erase_sector(uint32_t addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;249    {
;;;250        uint32_t iap_status;
;;;251        error_t status;
;;;252        uint32_t sector_size;
;;;253    
;;;254        if (state != STATE_OPEN) {
000004  4e2a              LDR      r6,|L3.176|
000006  4604              MOV      r4,r0                 ;249
000008  7830              LDRB     r0,[r6,#0]  ; state
00000a  2801              CMP      r0,#1
00000c  d005              BEQ      |L3.26|
;;;255            util_assert(0);
00000e  22ff              MOVS     r2,#0xff
000010  a128              ADR      r1,|L3.180|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       _util_assert
;;;256            return ERROR_INTERNAL;
000018  e019              B        |L3.78|
                  |L3.26|
00001a  f44f6880          MOV      r8,#0x400
00001e  4640              MOV      r0,r8
;;;257        }
;;;258    
;;;259        // Address must be on a sector boundary
;;;260        sector_size = erase_sector_size(addr);
;;;261    
;;;262        if (addr % sector_size != 0) {
000020  fbb4f1f0          UDIV     r1,r4,r0
000024  fb084111          MLS      r1,r8,r1,r4
000028  2502              MOVS     r5,#2                 ;256
00002a  b111              CBZ      r1,|L3.50|
;;;263            util_assert(0);
00002c  f2401207          MOV      r2,#0x107
;;;264            state = STATE_ERROR;
;;;265            return ERROR_INTERNAL;
000030  e008              B        |L3.68|
                  |L3.50|
;;;266        }
;;;267    
;;;268        // Address must be sequential - no gaps
;;;269        if (current_sector_set && (addr != current_sector + current_sector_size)) {
000032  78f1              LDRB     r1,[r6,#3]  ; current_sector_set
000034  b171              CBZ      r1,|L3.84|
000036  e9d61202          LDRD     r1,r2,[r6,#8]
00003a  4411              ADD      r1,r1,r2
00003c  42a1              CMP      r1,r4
00003e  d009              BEQ      |L3.84|
;;;270            util_assert(0);
000040  f44f7287          MOV      r2,#0x10e
                  |L3.68|
000044  a11b              ADR      r1,|L3.180|
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       _util_assert
;;;271            state = STATE_ERROR;
00004c  7035              STRB     r5,[r6,#0]
                  |L3.78|
;;;272            return ERROR_INTERNAL;
00004e  2002              MOVS     r0,#2
                  |L3.80|
;;;273        }
;;;274    
;;;275        if (!sector_erase_allowed(addr)) {
;;;276            state = STATE_ERROR;
;;;277            return ERROR_IAP_ERASE_SECTOR;
;;;278        }
;;;279    
;;;280        current_sector_set = true;
;;;281        current_sector = addr;
;;;282        current_sector_size = sector_size;
;;;283        status = intercept_sector_erase(addr);
;;;284    
;;;285        if (status != ERROR_IAP_NO_INTERCEPT) {
;;;286            // The operation has been intercepted so
;;;287            // return the result
;;;288            if (ERROR_SUCCESS != status) {
;;;289                state = STATE_ERROR;
;;;290            }
;;;291    
;;;292            return status;
;;;293        }
;;;294    
;;;295        iap_status = flash_erase_sector(addr);
;;;296    
;;;297        if (iap_status != 0) {
;;;298            state = STATE_ERROR;
;;;299            return ERROR_IAP_ERASE_SECTOR;
;;;300        }
;;;301    
;;;302        return ERROR_SUCCESS;
;;;303    }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L3.84|
000054  4919              LDR      r1,|L3.188|
000056  f1b46f00          CMP      r4,#0x8000000
00005a  d301              BCC      |L3.96|
00005c  428c              CMP      r4,r1
00005e  d323              BCC      |L3.168|
                  |L3.96|
000060  2101              MOVS     r1,#1
000062  70f1              STRB     r1,[r6,#3]            ;280
000064  4f16              LDR      r7,|L3.192|
000066  e9c64802          STRD     r4,r8,[r6,#8]         ;280
00006a  4816              LDR      r0,|L3.196|
00006c  42bc              CMP      r4,r7                 ;280
00006e  d301              BCC      |L3.116|
000070  4284              CMP      r4,r0                 ;280
000072  d301              BCC      |L3.120|
                  |L3.116|
000074  2022              MOVS     r0,#0x22              ;280
000076  e00c              B        |L3.146|
                  |L3.120|
000078  f7fffffe          BL       daplink_is_interface
00007c  0001              MOVS     r1,r0                 ;280
00007e  f04f0025          MOV      r0,#0x25              ;280
000082  d006              BEQ      |L3.146|
000084  4639              MOV      r1,r7                 ;280
000086  428c              CMP      r4,r1                 ;280
000088  d103              BNE      |L3.146|
00008a  4642              MOV      r2,r8                 ;280
00008c  4638              MOV      r0,r7                 ;280
00008e  f7fffffe          BL       critical_erase_and_program
                  |L3.146|
000092  2825              CMP      r0,#0x25              ;285
000094  d003              BEQ      |L3.158|
000096  2800              CMP      r0,#0                 ;288
000098  d0da              BEQ      |L3.80|
00009a  7035              STRB     r5,[r6,#0]            ;289
00009c  e7d8              B        |L3.80|
                  |L3.158|
00009e  4620              MOV      r0,r4                 ;295
0000a0  f7fffffe          BL       flash_erase_sector
0000a4  2800              CMP      r0,#0                 ;297
0000a6  d0d3              BEQ      |L3.80|
                  |L3.168|
0000a8  7035              STRB     r5,[r6,#0]            ;298
0000aa  2020              MOVS     r0,#0x20              ;299
0000ac  e7d0              B        |L3.80|
;;;304    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L3.176|
                          DCD      ||.data||
                  |L3.180|
0000b4  2866696c          DCB      "(file)",0
0000b8  652900  
0000bb  00                DCB      0
                  |L3.188|
                          DCD      0x0800bc00
                  |L3.192|
                          DCD      0x0800c000
                  |L3.196|
                          DCD      0x0801fc00

                          AREA ||i.erase_sector_size||, CODE, READONLY, ALIGN=1

                  erase_sector_size PROC
;;;340    
;;;341    static uint32_t erase_sector_size(uint32_t addr)
000000  f44f6080          MOV      r0,#0x400
;;;342    {
;;;343        return DAPLINK_SECTOR_SIZE;
;;;344    }
000004  4770              BX       lr
;;;345    
                          ENDP


                          AREA ||i.init||, CODE, READONLY, ALIGN=2

                  init PROC
;;;91     
;;;92     static error_t init()
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94         int iap_status;
;;;95         bool update_supported = DAPLINK_ROM_UPDATE_SIZE != 0;
;;;96     
;;;97         if (state != STATE_CLOSED) {
000002  4c12              LDR      r4,|L5.76|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L5.22|
;;;98             util_assert(0);
000008  2262              MOVS     r2,#0x62
00000a  a111              ADR      r1,|L5.80|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       _util_assert
;;;99             return ERROR_INTERNAL;
000012  2002              MOVS     r0,#2
;;;100        }
;;;101    
;;;102        if (!update_supported) {
;;;103            return ERROR_IAP_UPDT_NOT_SUPPORTED;
;;;104        }
;;;105    
;;;106        iap_status = Init(0, 0, 0);
;;;107    
;;;108        if (iap_status != 0) {
;;;109            return ERROR_IAP_INIT;
;;;110        }
;;;111    
;;;112        update_complete = false;
;;;113        mass_erase_performed = false;
;;;114        current_sector_set = false;
;;;115        current_sector = 0;
;;;116        current_sector_size = 0;
;;;117        current_page_set = false;
;;;118        current_page = 0;
;;;119        current_page_write_size = 0;
;;;120        crc = 0;
;;;121        memset(sector_buf, 0, sizeof(sector_buf));
;;;122        state = STATE_OPEN;
;;;123        return ERROR_SUCCESS;
;;;124    }
000014  bd10              POP      {r4,pc}
                  |L5.22|
000016  2200              MOVS     r2,#0                 ;106
000018  4611              MOV      r1,r2                 ;106
00001a  4610              MOV      r0,r2                 ;106
00001c  f7fffffe          BL       Init
000020  b108              CBZ      r0,|L5.38|
000022  201d              MOVS     r0,#0x1d              ;109
000024  bd10              POP      {r4,pc}
                  |L5.38|
000026  2000              MOVS     r0,#0                 ;112
000028  7060              STRB     r0,[r4,#1]            ;112
00002a  70a0              STRB     r0,[r4,#2]            ;113
00002c  70e0              STRB     r0,[r4,#3]            ;114
00002e  60a0              STR      r0,[r4,#8]            ;116  ; current_sector
000030  60e0              STR      r0,[r4,#0xc]          ;117  ; current_sector_size
000032  7120              STRB     r0,[r4,#4]            ;117
000034  6120              STR      r0,[r4,#0x10]         ;119  ; current_page
000036  6160              STR      r0,[r4,#0x14]         ;120  ; current_page_write_size
000038  61a0              STR      r0,[r4,#0x18]         ;121  ; crc
00003a  f44f6180          MOV      r1,#0x400             ;121
00003e  4806              LDR      r0,|L5.88|
000040  f7fffffe          BL       __aeabi_memclr
000044  2001              MOVS     r0,#1                 ;122
000046  7020              STRB     r0,[r4,#0]            ;122
000048  2000              MOVS     r0,#0                 ;123
00004a  bd10              POP      {r4,pc}
;;;125    
                          ENDP

                  |L5.76|
                          DCD      ||.data||
                  |L5.80|
000050  2866696c          DCB      "(file)",0
000054  652900  
000057  00                DCB      0
                  |L5.88|
                          DCD      ||.bss||

                          AREA ||i.intercept_page_write||, CODE, READONLY, ALIGN=2

                  intercept_page_write PROC
;;;368    
;;;369    static error_t intercept_page_write(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;370    {
;;;371        error_t status;
;;;372        uint32_t crc_size;
;;;373        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;374        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;375    
;;;376        if (state != STATE_OPEN) {
000004  f8df90d8          LDR      r9,|L6.224|
000008  4604              MOV      r4,r0                 ;370
00000a  4f33              LDR      r7,|L6.216|
00000c  f8990000          LDRB     r0,[r9,#0]  ; state
000010  4d32              LDR      r5,|L6.220|
000012  4690              MOV      r8,r2                 ;370
000014  468a              MOV      r10,r1                ;370
000016  2801              CMP      r0,#1
000018  d008              BEQ      |L6.44|
;;;377            util_assert(0);
00001a  f2401279          MOV      r2,#0x179
00001e  a131              ADR      r1,|L6.228|
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       _util_assert
;;;378            return ERROR_INTERNAL;
000026  2002              MOVS     r0,#2
                  |L6.40|
;;;379        }
;;;380    
;;;381        if ((addr < updt_start) || (addr >= updt_end)) {
;;;382            return ERROR_IAP_OUT_OF_BOUNDS;
;;;383        }
;;;384    
;;;385        if (!daplink_is_interface()) {
;;;386            return ERROR_IAP_NO_INTERCEPT;
;;;387        }
;;;388    
;;;389        /* Everything below here is interface specific */
;;;390        crc_size = MIN(size, updt_end - addr - 4);
;;;391        crc = crc32_continue(crc, buf, crc_size);
;;;392    
;;;393        // Intercept the data if it is in the first sector
;;;394        if ((addr >= updt_start) && (addr < updt_start + DAPLINK_SECTOR_SIZE)) {
;;;395            uint32_t buf_offset = addr - updt_start;
;;;396            memcpy(sector_buf + buf_offset, buf, size);
;;;397            // Intercept was successful
;;;398            return ERROR_SUCCESS;
;;;399        }
;;;400    
;;;401        // Finalize update if this is the last sector
;;;402        if (updt_end == addr + size) {
;;;403            uint32_t iap_status;
;;;404            uint32_t size_left = updt_end - addr;
;;;405            uint32_t crc_in_image = (buf[size_left - 4] << 0) |
;;;406                                    (buf[size_left - 3] << 8) |
;;;407                                    (buf[size_left - 2] << 16) |
;;;408                                    (buf[size_left - 1] << 24);
;;;409    
;;;410            if (crc != crc_in_image) {
;;;411                return ERROR_BL_UPDT_BAD_CRC;
;;;412            }
;;;413    
;;;414            // Program the current buffer
;;;415            iap_status = flash_program_page(addr, size, (uint8_t *)buf);
;;;416    
;;;417            if (iap_status != 0) {
;;;418                return ERROR_IAP_WRITE;
;;;419            }
;;;420    
;;;421            status = critical_erase_and_program(DAPLINK_ROM_UPDATE_START, sector_buf, DAPLINK_SECTOR_SIZE);
;;;422    
;;;423            if (ERROR_SUCCESS == status) {
;;;424                status = ERROR_SUCCESS;
;;;425            }
;;;426    
;;;427            // The bootloader has been updated so recompute the crc
;;;428            info_crc_compute();
;;;429            update_complete = true;
;;;430            return status;
;;;431        }
;;;432    
;;;433        return ERROR_IAP_NO_INTERCEPT;
;;;434    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L6.44|
00002c  42bc              CMP      r4,r7                 ;381
00002e  d301              BCC      |L6.52|
000030  42ac              CMP      r4,r5                 ;381
000032  d301              BCC      |L6.56|
                  |L6.52|
000034  2022              MOVS     r0,#0x22              ;382
000036  e7f7              B        |L6.40|
                  |L6.56|
000038  f7fffffe          BL       daplink_is_interface
00003c  b398              CBZ      r0,|L6.166|
00003e  1b2e              SUBS     r6,r5,r4              ;390
000040  1f30              SUBS     r0,r6,#4              ;390
000042  4641              MOV      r1,r8                 ;390
000044  4540              CMP      r0,r8                 ;390
000046  d901              BLS      |L6.76|
000048  460a              MOV      r2,r1                 ;390
00004a  e000              B        |L6.78|
                  |L6.76|
00004c  1f32              SUBS     r2,r6,#4              ;390
                  |L6.78|
00004e  4651              MOV      r1,r10                ;391
000050  f8d90018          LDR      r0,[r9,#0x18]         ;391  ; crc
000054  f7fffffe          BL       crc32_continue
000058  4601              MOV      r1,r0                 ;391
00005a  f8c90018          STR      r0,[r9,#0x18]         ;394  ; crc
00005e  4823              LDR      r0,|L6.236|
000060  4284              CMP      r4,r0                 ;394
000062  d208              BCS      |L6.118|
000064  4922              LDR      r1,|L6.240|
000066  1be0              SUBS     r0,r4,r7              ;395
000068  4408              ADD      r0,r0,r1              ;396
00006a  4642              MOV      r2,r8                 ;396
00006c  4651              MOV      r1,r10                ;396
00006e  f7fffffe          BL       __aeabi_memcpy
000072  2000              MOVS     r0,#0                 ;398
000074  e7d8              B        |L6.40|
                  |L6.118|
000076  eb040008          ADD      r0,r4,r8              ;402
00007a  42a8              CMP      r0,r5                 ;402
00007c  d129              BNE      |L6.210|
00007e  eb0a0006          ADD      r0,r10,r6             ;405
000082  f8103c02          LDRB     r3,[r0,#-2]           ;405
000086  f8102c03          LDRB     r2,[r0,#-3]           ;405
00008a  f8105d04          LDRB     r5,[r0,#-4]!          ;405
00008e  ea452202          ORR      r2,r5,r2,LSL #8       ;405
000092  78c0              LDRB     r0,[r0,#3]            ;405
000094  f363421f          BFI      r2,r3,#16,#16         ;405
000098  ea426000          ORR      r0,r2,r0,LSL #24      ;405
00009c  464d              MOV      r5,r9                 ;410
00009e  4281              CMP      r1,r0                 ;410
0000a0  d002              BEQ      |L6.168|
0000a2  2026              MOVS     r0,#0x26              ;411
0000a4  e7c0              B        |L6.40|
                  |L6.166|
0000a6  e014              B        |L6.210|
                  |L6.168|
0000a8  4652              MOV      r2,r10                ;415
0000aa  4641              MOV      r1,r8                 ;415
0000ac  4620              MOV      r0,r4                 ;415
0000ae  f7fffffe          BL       flash_program_page
0000b2  b108              CBZ      r0,|L6.184|
0000b4  201f              MOVS     r0,#0x1f              ;418
0000b6  e7b7              B        |L6.40|
                  |L6.184|
0000b8  f44f6280          MOV      r2,#0x400             ;421
0000bc  490c              LDR      r1,|L6.240|
0000be  4638              MOV      r0,r7                 ;421
0000c0  f7fffffe          BL       critical_erase_and_program
0000c4  4604              MOV      r4,r0                 ;421
0000c6  f7fffffe          BL       info_crc_compute
0000ca  2001              MOVS     r0,#1                 ;429
0000cc  7068              STRB     r0,[r5,#1]            ;429
0000ce  4620              MOV      r0,r4                 ;430
0000d0  e7aa              B        |L6.40|
                  |L6.210|
0000d2  2025              MOVS     r0,#0x25              ;433
0000d4  e7a8              B        |L6.40|
;;;435    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L6.216|
                          DCD      0x0800c000
                  |L6.220|
                          DCD      0x0801fc00
                  |L6.224|
                          DCD      ||.data||
                  |L6.228|
0000e4  2866696c          DCB      "(file)",0
0000e8  652900  
0000eb  00                DCB      0
                  |L6.236|
                          DCD      0x0800c400
                  |L6.240|
                          DCD      ||.bss||

                          AREA ||i.program_page||, CODE, READONLY, ALIGN=2

                  program_page PROC
;;;152    
;;;153    static error_t program_page(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;154    {
;;;155        uint32_t iap_status;
;;;156        error_t status;
;;;157        uint32_t min_prog_size;
;;;158        uint32_t sector_size;
;;;159        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;160    
;;;161        if (state != STATE_OPEN) {
000004  f8df8100          LDR      r8,|L7.264|
000008  4604              MOV      r4,r0                 ;154
00000a  f8df90f8          LDR      r9,|L7.260|
00000e  f8980000          LDRB     r0,[r8,#0]  ; state
000012  4615              MOV      r5,r2                 ;154
000014  468b              MOV      r11,r1                ;154
000016  2801              CMP      r0,#1
000018  d005              BEQ      |L7.38|
;;;162            util_assert(0);
00001a  22a2              MOVS     r2,#0xa2
00001c  a13b              ADR      r1,|L7.268|
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       _util_assert
;;;163            return ERROR_INTERNAL;
000024  e03f              B        |L7.166|
                  |L7.38|
000026  f44f6080          MOV      r0,#0x400
;;;164        }
;;;165    
;;;166        min_prog_size = program_page_min_size(addr);
;;;167        sector_size = erase_sector_size(addr);
;;;168    
;;;169        // Address must be on a write size boundary
;;;170        if (addr % min_prog_size != 0) {
00002a  fbb4f3f0          UDIV     r3,r4,r0
00002e  fb004313          MLS      r3,r0,r3,r4
000032  4601              MOV      r1,r0                 ;167
000034  2602              MOVS     r6,#2                 ;163
000036  b10b              CBZ      r3,|L7.60|
;;;171            util_assert(0);
000038  22ab              MOVS     r2,#0xab
;;;172            state = STATE_ERROR;
;;;173            return ERROR_INTERNAL;
00003a  e02e              B        |L7.154|
                  |L7.60|
;;;174        }
;;;175    
;;;176        // Programming size must be a non-zero multiple of the minimum write size
;;;177        if ((size < min_prog_size) || (size % min_prog_size != 0)) {
00003c  460a              MOV      r2,r1
00003e  4295              CMP      r5,r2
000040  d304              BCC      |L7.76|
000042  fbb5f3f0          UDIV     r3,r5,r0
000046  fb025013          MLS      r0,r2,r3,r5
00004a  b108              CBZ      r0,|L7.80|
                  |L7.76|
;;;178            util_assert(0);
00004c  22b2              MOVS     r2,#0xb2
;;;179            state = STATE_ERROR;
;;;180            return ERROR_INTERNAL;
00004e  e024              B        |L7.154|
                  |L7.80|
;;;181        }
;;;182    
;;;183        // Write must not cross a sector boundary
;;;184        if ((addr % sector_size) + size > sector_size) {
000050  fbb4f0f1          UDIV     r0,r4,r1
000054  fb024010          MLS      r0,r2,r0,r4
000058  4428              ADD      r0,r0,r5
00005a  4288              CMP      r0,r1
00005c  d901              BLS      |L7.98|
;;;185            util_assert(0);
00005e  22b9              MOVS     r2,#0xb9
;;;186            state = STATE_ERROR;
;;;187            return ERROR_INTERNAL;
000060  e01b              B        |L7.154|
                  |L7.98|
;;;188        }
;;;189    
;;;190        // Write must be in an erased sector (current_sector is always erased if it is set)
;;;191        if (!mass_erase_performed) {
000062  f8980002          LDRB     r0,[r8,#2]  ; mass_erase_performed
000066  b978              CBNZ     r0,|L7.136|
;;;192            if (!current_sector_set) {
000068  f8980003          LDRB     r0,[r8,#3]  ; current_sector_set
00006c  b150              CBZ      r0,|L7.132|
;;;193                util_assert(0);
;;;194                state = STATE_ERROR;
;;;195                return ERROR_INTERNAL;
;;;196            }
;;;197    
;;;198            if ((addr < current_sector) || (addr >= current_sector + current_sector_size)) {
00006e  f8d80008          LDR      r0,[r8,#8]  ; current_sector
000072  4284              CMP      r4,r0
000074  d304              BCC      |L7.128|
000076  f8d8100c          LDR      r1,[r8,#0xc]  ; current_sector_size
00007a  4408              ADD      r0,r0,r1
00007c  42a0              CMP      r0,r4
00007e  d803              BHI      |L7.136|
                  |L7.128|
;;;199                util_assert(0);
000080  22c7              MOVS     r2,#0xc7
;;;200                state = STATE_ERROR;
;;;201                return ERROR_INTERNAL;
000082  e00a              B        |L7.154|
                  |L7.132|
000084  22c1              MOVS     r2,#0xc1              ;193
000086  e008              B        |L7.154|
                  |L7.136|
;;;202            }
;;;203        }
;;;204    
;;;205        // Address must be sequential - no gaps
;;;206        if (current_page_set && (addr != current_page + current_page_write_size)) {
000088  f8980004          LDRB     r0,[r8,#4]  ; current_page_set
00008c  b170              CBZ      r0,|L7.172|
00008e  e9d80104          LDRD     r0,r1,[r8,#0x10]
000092  4408              ADD      r0,r0,r1
000094  42a0              CMP      r0,r4
000096  d009              BEQ      |L7.172|
;;;207            util_assert(0);
000098  22cf              MOVS     r2,#0xcf
                  |L7.154|
00009a  a11c              ADR      r1,|L7.268|
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       _util_assert
;;;208            state = STATE_ERROR;
0000a2  f8886000          STRB     r6,[r8,#0]
                  |L7.166|
;;;209            return ERROR_INTERNAL;
0000a6  2002              MOVS     r0,#2
                  |L7.168|
;;;210        }
;;;211    
;;;212        if (!page_program_allowed(addr, size)) {
;;;213            state = STATE_ERROR;
;;;214            return ERROR_IAP_WRITE;
;;;215        }
;;;216    
;;;217        current_page_set = true;
;;;218        current_page = addr;
;;;219        current_page_write_size = size;
;;;220        status = intercept_page_write(addr, buf, size);
;;;221    
;;;222        if (status != ERROR_IAP_NO_INTERCEPT) {
;;;223            // The operation has been intercepted so
;;;224            // return the result
;;;225            if (ERROR_SUCCESS != status) {
;;;226                state = STATE_ERROR;
;;;227            }
;;;228    
;;;229            return status;
;;;230        }
;;;231    
;;;232        iap_status = flash_program_page(addr, size, (uint8_t *)buf);
;;;233    
;;;234        if (iap_status != 0) {
;;;235            state = STATE_ERROR;
;;;236            return ERROR_IAP_WRITE;
;;;237        }
;;;238    
;;;239        if (addr + size >= updt_end) {
;;;240            // Something has been updated so recompute the crc
;;;241            info_crc_compute();
;;;242            update_complete = true;
;;;243        }
;;;244    
;;;245        return ERROR_SUCCESS;
;;;246    }
0000a8  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.172|
0000ac  4819              LDR      r0,|L7.276|
0000ae  1967              ADDS     r7,r4,r5
0000b0  4284              CMP      r4,r0
0000b2  d202              BCS      |L7.186|
0000b4  f1b76f00          CMP      r7,#0x8000000
0000b8  d817              BHI      |L7.234|
                  |L7.186|
0000ba  f04f0a01          MOV      r10,#1                ;217
0000be  f888a004          STRB     r10,[r8,#4]           ;217
0000c2  462a              MOV      r2,r5                 ;220
0000c4  4659              MOV      r1,r11                ;220
0000c6  4620              MOV      r0,r4                 ;220
0000c8  e9c84504          STRD     r4,r5,[r8,#0x10]      ;220
0000cc  f7fffffe          BL       intercept_page_write
0000d0  2825              CMP      r0,#0x25              ;222
0000d2  d004              BEQ      |L7.222|
0000d4  2800              CMP      r0,#0                 ;225
0000d6  d0e7              BEQ      |L7.168|
0000d8  f8886000          STRB     r6,[r8,#0]            ;226
0000dc  e7e4              B        |L7.168|
                  |L7.222|
0000de  465a              MOV      r2,r11                ;232
0000e0  4629              MOV      r1,r5                 ;232
0000e2  4620              MOV      r0,r4                 ;232
0000e4  f7fffffe          BL       flash_program_page
0000e8  b118              CBZ      r0,|L7.242|
                  |L7.234|
0000ea  f8886000          STRB     r6,[r8,#0]            ;235
0000ee  201f              MOVS     r0,#0x1f              ;236
0000f0  e7da              B        |L7.168|
                  |L7.242|
0000f2  454f              CMP      r7,r9                 ;239
0000f4  d303              BCC      |L7.254|
0000f6  f7fffffe          BL       info_crc_compute
0000fa  f888a001          STRB     r10,[r8,#1]           ;242
                  |L7.254|
0000fe  2000              MOVS     r0,#0                 ;245
000100  e7d2              B        |L7.168|
;;;247    
                          ENDP

000102  0000              DCW      0x0000
                  |L7.260|
                          DCD      0x0801fc00
                  |L7.264|
                          DCD      ||.data||
                  |L7.268|
00010c  2866696c          DCB      "(file)",0
000110  652900  
000113  00                DCB      0
                  |L7.276|
                          DCD      0x0800bc00

                          AREA ||i.program_page_min_size||, CODE, READONLY, ALIGN=1

                  program_page_min_size PROC
;;;335    
;;;336    static uint32_t program_page_min_size(uint32_t addr)
000000  f44f6080          MOV      r0,#0x400
;;;337    {
;;;338        return DAPLINK_MIN_WRITE_SIZE;
;;;339    }
000004  4770              BX       lr
;;;340    
                          ENDP


                          AREA ||i.target_flash_busy||, CODE, READONLY, ALIGN=2

                  target_flash_busy PROC
;;;501    
;;;502    static uint8_t target_flash_busy(void){
000000  4802              LDR      r0,|L9.12|
;;;503        return (state == STATE_OPEN);
000002  7800              LDRB     r0,[r0,#0]  ; state
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L9.10|
000008  2000              MOVS     r0,#0
                  |L9.10|
;;;504    }
00000a  4770              BX       lr
                          ENDP

                  |L9.12|
                          DCD      ||.data||

                          AREA ||i.uninit||, CODE, READONLY, ALIGN=2

                  uninit PROC
;;;125    
;;;126    static error_t uninit(void)
000000  b510              PUSH     {r4,lr}
;;;127    {
;;;128        int iap_status;
;;;129    
;;;130        if (STATE_CLOSED == state) {
000002  4c0d              LDR      r4,|L10.56|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L10.22|
;;;131            util_assert(0);
;;;132            return ERROR_INTERNAL;
;;;133        }
;;;134    
;;;135        state = STATE_CLOSED;
000008  2000              MOVS     r0,#0
00000a  7020              STRB     r0,[r4,#0]
;;;136        iap_status = UnInit(0);
00000c  f7fffffe          BL       UnInit
;;;137    
;;;138        if (iap_status != 0) {
000010  b140              CBZ      r0,|L10.36|
;;;139            return ERROR_IAP_UNINIT;
000012  201e              MOVS     r0,#0x1e
;;;140        }
;;;141    
;;;142        if (!update_complete && !daplink_is_bootloader()) {
;;;143            // Interface - Error if the bootloader update is not complete
;;;144            // Bootloader - For 3rd party applications the end of the update
;;;145            //              is unknown so it is not an error if the transfer
;;;146            //              ends early.
;;;147            return ERROR_IAP_UPDT_INCOMPLETE;
;;;148        }
;;;149    
;;;150        return ERROR_SUCCESS;
;;;151    }
000014  bd10              POP      {r4,pc}
                  |L10.22|
000016  2283              MOVS     r2,#0x83              ;131
000018  a108              ADR      r1,|L10.60|
00001a  2000              MOVS     r0,#0                 ;131
00001c  f7fffffe          BL       _util_assert
000020  2002              MOVS     r0,#2                 ;132
000022  bd10              POP      {r4,pc}
                  |L10.36|
000024  7860              LDRB     r0,[r4,#1]            ;142  ; update_complete
000026  b910              CBNZ     r0,|L10.46|
000028  f7fffffe          BL       daplink_is_bootloader
00002c  b108              CBZ      r0,|L10.50|
                  |L10.46|
00002e  2000              MOVS     r0,#0                 ;150
000030  bd10              POP      {r4,pc}
                  |L10.50|
000032  2024              MOVS     r0,#0x24              ;147
000034  bd10              POP      {r4,pc}
;;;152    
                          ENDP

000036  0000              DCW      0x0000
                  |L10.56|
                          DCD      ||.data||
                  |L10.60|
00003c  2866696c          DCB      "(file)",0
000040  652900  
000043  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  sector_buf
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  flash_intf
                          DCD      init
                          DCD      uninit
                          DCD      program_page
                          DCD      erase_sector
                          DCD      erase_chip
                          DCD      program_page_min_size
                          DCD      erase_sector_size
                          DCD      target_flash_busy
                          DCD      0x00000000

                          AREA ||area_number.15||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.constdata||
                  flash_intf_iap_protected
                          DCD      flash_intf

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00                DCB      0x00
                  update_complete
000001  00                DCB      0x00
                  mass_erase_performed
000002  00                DCB      0x00
                  current_sector_set
000003  00                DCB      0x00
                  current_page_set
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  current_sector
                          DCD      0x00000000
                  current_sector_size
                          DCD      0x00000000
                  current_page
                          DCD      0x00000000
                  current_page_write_size
                          DCD      0x00000000
                  ||crc||
                          DCD      0x00000000
