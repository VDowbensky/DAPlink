; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\main.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\main.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\main.crf ..\..\..\source\daplink\bootloader\main.c]
                          THUMB

                          AREA ||i.USBD_SignalHandler||, CODE, READONLY, ALIGN=2

                  USBD_SignalHandler PROC
;;;94     
;;;95     void USBD_SignalHandler()
000000  4802              LDR      r0,|L1.12|
;;;96     {
;;;97         osThreadFlagsSet(main_task_id, FLAGS_MAIN_PROC_USB);
000002  f44f7100          MOV      r1,#0x200
000006  6880              LDR      r0,[r0,#8]  ; main_task_id
000008  f7ffbffe          B.W      osThreadFlagsSet
;;;98     }
;;;99     
                          ENDP

                  |L1.12|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;227    
;;;228    int main(void)
000000  f7fffffe          BL       sdk_init
;;;229    {
;;;230        // initialize vendor sdk
;;;231        sdk_init();
;;;232        // init leds and button
;;;233        gpio_init();
000004  f7fffffe          BL       gpio_init
;;;234        // init settings
;;;235        config_init();
000008  f7fffffe          BL       config_init
00000c  f7fffffe          BL       gpio_get_reset_btn_no_fwrd
;;;236    
;;;237        // check for invalid app image or rst button press. Should be checksum or CRC but NVIC validation is better than nothing.
;;;238        // If the interface has set the hold in bootloader setting don't jump to app
;;;239        if (!gpio_get_reset_btn() && g_board_info.target_cfg && validate_bin_nvic((uint8_t *)g_board_info.target_cfg->flash_regions[0].start) && !config_ram_get_initial_hold_in_bl()) {
000010  b9f8              CBNZ     r0,|L2.82|
000012  f7fffffe          BL       gpio_get_reset_btn_fwrd
000016  b9e0              CBNZ     r0,|L2.82|
000018  4813              LDR      r0,|L2.104|
00001a  4604              MOV      r4,r0
00001c  f7fffffe          BL       __aeabi_uread4
000020  b1b8              CBZ      r0,|L2.82|
000022  300c              ADDS     r0,r0,#0xc
000024  f7fffffe          BL       __aeabi_uread4
000028  f7fffffe          BL       validate_bin_nvic
00002c  b188              CBZ      r0,|L2.82|
00002e  f7fffffe          BL       config_ram_get_initial_hold_in_bl
000032  b970              CBNZ     r0,|L2.82|
000034  4620              MOV      r0,r4
;;;240            // change to the new vector table
;;;241            SCB->VTOR = g_board_info.target_cfg->flash_regions[0].start; //bootloaders should only have one flash region for interface
000036  f7fffffe          BL       __aeabi_uread4
00003a  300c              ADDS     r0,r0,#0xc
00003c  4604              MOV      r4,r0
00003e  f7fffffe          BL       __aeabi_uread4
000042  490a              LDR      r1,|L2.108|
000044  6008              STR      r0,[r1,#0]
000046  4620              MOV      r0,r4
;;;242            // modify stack pointer and start app
;;;243            modify_stack_pointer_and_start_app((*(uint32_t *)(g_board_info.target_cfg->flash_regions[0].start)), (*(uint32_t *)(g_board_info.target_cfg->flash_regions[0].start + 4)));
000048  f7fffffe          BL       __aeabi_uread4
00004c  c803              LDM      r0,{r0,r1}
00004e  f7fffffe          BL       modify_stack_pointer_and_start_app
                  |L2.82|
;;;244        }
;;;245    
;;;246        // config the usb interface descriptor and web auth token before USB connects
;;;247        //unique_string_auth_config();
;;;248        // either the rst pin was pressed or we have an empty app region
;;;249        osKernelInitialize();                 // Initialize CMSIS-RTOS
000052  f7fffffe          BL       osKernelInitialize
;;;250        osThreadNew(main_task, NULL, NULL);    // Create application main thread
000056  2200              MOVS     r2,#0
000058  4611              MOV      r1,r2
00005a  4805              LDR      r0,|L2.112|
00005c  f7fffffe          BL       osThreadNew
;;;251        osKernelStart();                      // Start thread execution
000060  f7fffffe          BL       osKernelStart
                  |L2.100|
;;;252        for (;;) {}
000064  e7fe              B        |L2.100|
;;;253    }
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      g_board_info+0x10
                  |L2.108|
                          DCD      0xe000ed08
                  |L2.112|
                          DCD      main_task

                          AREA ||i.main_blink_msc_led||, CODE, READONLY, ALIGN=2

                  main_blink_msc_led PROC
;;;87     // Flash MSC LED using 30mS tick
;;;88     void main_blink_msc_led(main_led_state_t state)
000000  4902              LDR      r1,|L3.12|
;;;89     {
;;;90         msc_led_usb_activity = 1;
000002  2201              MOVS     r2,#1
000004  700a              STRB     r2,[r1,#0]
;;;91         msc_led_state = state;
000006  7048              STRB     r0,[r1,#1]
;;;92         return;
;;;93     }
000008  4770              BX       lr
;;;94     
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      ||.data||

                          AREA ||i.main_task||, CODE, READONLY, ALIGN=2

                  main_task PROC
;;;99     
;;;100    void main_task(void * arg)
000000  2501              MOVS     r5,#1
;;;101    {
;;;102        // State processing
;;;103        uint16_t flags;
;;;104        // LED
;;;105        gpio_led_state_t msc_led_value = MSC_LED_DEF;
;;;106        // USB
;;;107        uint32_t usb_state_count;
;;;108    
;;;109        if (config_ram_get_initial_hold_in_bl()) {
000002  f7fffffe          BL       config_ram_get_initial_hold_in_bl
000006  b110              CBZ      r0,|L4.14|
;;;110            // Delay for 1 second for VMs
;;;111            osDelay(100);
000008  2064              MOVS     r0,#0x64
00000a  f7fffffe          BL       osDelay
                  |L4.14|
;;;112        }
;;;113    
;;;114        // Get a reference to this task
;;;115        main_task_id = osThreadGetId();
00000e  f7fffffe          BL       osThreadGetId
000012  4f43              LDR      r7,|L4.288|
;;;116        // Set LED defaults
;;;117        gpio_set_hid_led(GPIO_LED_OFF);
000014  60b8              STR      r0,[r7,#8]  ; main_task_id
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       gpio_set_hid_led
;;;118        gpio_set_cdc_led(GPIO_LED_OFF);
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       gpio_set_cdc_led
;;;119        gpio_set_msc_led(msc_led_value);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       gpio_set_msc_led
;;;120        // Update version information file
;;;121        info_init();
000028  f7fffffe          BL       info_init
;;;122        // USB
;;;123        usbd_init();
00002c  f7fffffe          BL       usbd_init
;;;124        vfs_mngr_init(true);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       vfs_mngr_init
;;;125        usbd_connect(0);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       usbd_connect
;;;126        usb_busy = MAIN_USB_IDLE;
00003c  f04f0800          MOV      r8,#0
000040  f8878003          STRB     r8,[r7,#3]
;;;127        usb_busy_count = 0;
;;;128        usb_state = MAIN_USB_CONNECTING;
000044  2001              MOVS     r0,#1
000046  f8c7800c          STR      r8,[r7,#0xc]  ; usb_busy_count
00004a  70b8              STRB     r0,[r7,#2]
;;;129        usb_state_count = USB_CONNECT_DELAY;
;;;130        // Start timer tasks
;;;131        osTimerId_t tmr_id = osTimerNew(timer_task_30mS, osTimerPeriodic, NULL, NULL);
00004c  4601              MOV      r1,r0
00004e  240b              MOVS     r4,#0xb               ;129
000050  4643              MOV      r3,r8
000052  4642              MOV      r2,r8
000054  4833              LDR      r0,|L4.292|
000056  f7fffffe          BL       osTimerNew
;;;132        osTimerStart(tmr_id, 3);
00005a  2103              MOVS     r1,#3
00005c  f7fffffe          BL       osTimerStart
;;;133    
;;;134        while (1) {
;;;135            // need to create a new event for programming failure
;;;136            flags = osThreadFlagsWait(FLAGS_MAIN_90MS     // 90mS tick
000060  f04f39ff          MOV      r9,#0xffffffff
000064  f2402a03          MOV      r10,#0x203
                  |L4.104|
000068  464a              MOV      r2,r9
00006a  2100              MOVS     r1,#0
00006c  4650              MOV      r0,r10
00006e  f7fffffe          BL       osThreadFlagsWait
000072  b286              UXTH     r6,r0
;;;137                            | FLAGS_MAIN_30MS            // 30mS tick
;;;138                            | FLAGS_MAIN_PROC_USB       // process usb events
;;;139                            , osFlagsWaitAny, 
;;;140                            osWaitForever);
;;;141    
;;;142            if (flags & FLAGS_MAIN_PROC_USB) {
000074  05b0              LSLS     r0,r6,#22
000076  d501              BPL      |L4.124|
;;;143                USBD_Handler();
000078  f7fffffe          BL       USBD_Handler
                  |L4.124|
;;;144            }
;;;145    
;;;146            if (flags & FLAGS_MAIN_90MS) {
00007c  07f0              LSLS     r0,r6,#31
00007e  d02f              BEQ      |L4.224|
;;;147                vfs_mngr_periodic(90); // FLAGS_MAIN_90MS
000080  205a              MOVS     r0,#0x5a
000082  f7fffffe          BL       vfs_mngr_periodic
;;;148    
;;;149                // Update USB busy status
;;;150                switch (usb_busy) {
000086  78f8              LDRB     r0,[r7,#3]  ; usb_busy
000088  2801              CMP      r0,#1
00008a  d106              BNE      |L4.154|
;;;151                    case MAIN_USB_ACTIVE:
;;;152                        if (DECZERO(usb_busy_count) == 0) {
00008c  68f8              LDR      r0,[r7,#0xc]  ; usb_busy_count
00008e  b110              CBZ      r0,|L4.150|
000090  1e40              SUBS     r0,r0,#1
000092  60f8              STR      r0,[r7,#0xc]  ; usb_busy_count
000094  d101              BNE      |L4.154|
                  |L4.150|
;;;153                            usb_busy = MAIN_USB_IDLE;
000096  f8878003          STRB     r8,[r7,#3]
                  |L4.154|
;;;154                        }
;;;155    
;;;156                        break;
;;;157    
;;;158                    case MAIN_USB_IDLE:
;;;159                    default:
;;;160                        break;
;;;161                }
;;;162    
;;;163                // Update USB connect status
;;;164                switch (usb_state) {
00009a  78b8              LDRB     r0,[r7,#2]  ; usb_state
00009c  b1f0              CBZ      r0,|L4.220|
00009e  2801              CMP      r0,#1
0000a0  d00e              BEQ      |L4.192|
0000a2  2803              CMP      r0,#3
0000a4  d014              BEQ      |L4.208|
0000a6  2804              CMP      r0,#4
0000a8  d11a              BNE      |L4.224|
;;;165                    case MAIN_USB_DISCONNECTING:
;;;166    
;;;167                        // Wait until USB is idle before disconnecting
;;;168                        if (usb_busy == MAIN_USB_IDLE && (DECZERO(usb_state_count) == 0)) {
0000aa  78f8              LDRB     r0,[r7,#3]  ; usb_busy
0000ac  b9c0              CBNZ     r0,|L4.224|
0000ae  b10c              CBZ      r4,|L4.180|
0000b0  1e64              SUBS     r4,r4,#1
0000b2  d115              BNE      |L4.224|
                  |L4.180|
;;;169                            usbd_connect(0);
0000b4  2000              MOVS     r0,#0
0000b6  f7fffffe          BL       usbd_connect
;;;170                            usb_state = MAIN_USB_DISCONNECTED;
0000ba  f8878002          STRB     r8,[r7,#2]
0000be  e00f              B        |L4.224|
                  |L4.192|
;;;171                        }
;;;172    
;;;173                        break;
;;;174    
;;;175                    case MAIN_USB_CONNECTING:
;;;176    
;;;177                        // Wait before connecting
;;;178                        if (DECZERO(usb_state_count) == 0) {
0000c0  b10c              CBZ      r4,|L4.198|
0000c2  1e64              SUBS     r4,r4,#1
0000c4  d10c              BNE      |L4.224|
                  |L4.198|
;;;179                            usbd_connect(1);
0000c6  2001              MOVS     r0,#1
0000c8  f7fffffe          BL       usbd_connect
;;;180                            usb_state = MAIN_USB_CHECK_CONNECTED;
0000cc  2003              MOVS     r0,#3
0000ce  e003              B        |L4.216|
                  |L4.208|
;;;181                        }
;;;182    
;;;183                        break;
;;;184    
;;;185                    case MAIN_USB_CHECK_CONNECTED:
;;;186                        if (usbd_configured()) {
0000d0  f7fffffe          BL       usbd_configured
0000d4  b120              CBZ      r0,|L4.224|
;;;187                            usb_state = MAIN_USB_CONNECTED;
0000d6  2002              MOVS     r0,#2
                  |L4.216|
0000d8  70b8              STRB     r0,[r7,#2]            ;180
0000da  e001              B        |L4.224|
                  |L4.220|
;;;188                        }
;;;189    
;;;190                        break;
;;;191    
;;;192                    case MAIN_USB_DISCONNECTED:
;;;193                        SystemReset();
0000dc  f7fffffe          BL       SystemReset
                  |L4.224|
;;;194                        break;
;;;195    
;;;196                    case MAIN_USB_CONNECTED:
;;;197                    default:
;;;198                        break;
;;;199                }
;;;200            }
;;;201    
;;;202            // 30mS tick used for flashing LED when USB is busy
;;;203            if (flags & FLAGS_MAIN_30MS) {
0000e0  07b0              LSLS     r0,r6,#30
0000e2  d5c1              BPL      |L4.104|
;;;204                if (msc_led_usb_activity) {
0000e4  7838              LDRB     r0,[r7,#0]  ; msc_led_usb_activity
0000e6  2800              CMP      r0,#0
0000e8  d0be              BEQ      |L4.104|
;;;205                    
;;;206                    if ((msc_led_state == MAIN_LED_FLASH) || (msc_led_state == MAIN_LED_FLASH_PERMANENT)) {
0000ea  7878              LDRB     r0,[r7,#1]  ; msc_led_state
0000ec  2801              CMP      r0,#1
0000ee  d008              BEQ      |L4.258|
0000f0  2802              CMP      r0,#2
0000f2  d006              BEQ      |L4.258|
;;;207                        // Toggle LED value
;;;208                        msc_led_value = (GPIO_LED_ON == msc_led_value) ? GPIO_LED_OFF : GPIO_LED_ON;
;;;209                        // If in flash mode stop after one cycle but in bootloader LED stays on
;;;210                        if ((MSC_LED_DEF == msc_led_value) && (MAIN_LED_FLASH == msc_led_state)) {    
;;;211                            msc_led_usb_activity = 0;
;;;212                            msc_led_state = MAIN_LED_DEF;
;;;213                        }
;;;214    
;;;215                    }else{
;;;216                        //LED next state is MAIN_LED_DEF
;;;217                        msc_led_value = MSC_LED_DEF;
0000f4  2501              MOVS     r5,#1
;;;218                        msc_led_usb_activity = 0;
0000f6  f8878000          STRB     r8,[r7,#0]
                  |L4.250|
;;;219                    }
;;;220    
;;;221                    // Update hardware
;;;222                    gpio_set_msc_led(msc_led_value);
0000fa  4628              MOV      r0,r5
0000fc  f7fffffe          BL       gpio_set_msc_led
000100  e7b2              B        |L4.104|
                  |L4.258|
000102  2d01              CMP      r5,#1                 ;208
000104  d001              BEQ      |L4.266|
000106  2501              MOVS     r5,#1                 ;208
000108  e000              B        |L4.268|
                  |L4.266|
00010a  2500              MOVS     r5,#0                 ;208
                  |L4.268|
00010c  2d00              CMP      r5,#0                 ;210
00010e  d0f4              BEQ      |L4.250|
000110  2801              CMP      r0,#1                 ;210
000112  d1f2              BNE      |L4.250|
000114  f8878000          STRB     r8,[r7,#0]            ;211
000118  f8878001          STRB     r8,[r7,#1]            ;212
00011c  e7ed              B        |L4.250|
;;;223                }
;;;224            }
;;;225        }
;;;226    }
;;;227    
                          ENDP

00011e  0000              DCW      0x0000
                  |L4.288|
                          DCD      ||.data||
                  |L4.292|
                          DCD      timer_task_30mS

                          AREA ||i.timer_task_30mS||, CODE, READONLY, ALIGN=2

                  timer_task_30mS PROC
;;;77     // Timer task, set flags every 30mS and 90mS
;;;78     void timer_task_30mS(void * arg)
000000  b510              PUSH     {r4,lr}
;;;79     {
;;;80         static uint32_t i = 0;
;;;81         osThreadFlagsSet(main_task_id, FLAGS_MAIN_30MS);
000002  4c0b              LDR      r4,|L5.48|
000004  2102              MOVS     r1,#2
000006  68a0              LDR      r0,[r4,#8]  ; main_task_id
000008  f7fffffe          BL       osThreadFlagsSet
;;;82         if (!(i++ % 3)) {
00000c  6860              LDR      r0,[r4,#4]  ; i
00000e  2103              MOVS     r1,#3
000010  fbb0f2f1          UDIV     r2,r0,r1
000014  fb010112          MLS      r1,r1,r2,r0
000018  1c40              ADDS     r0,r0,#1
00001a  6060              STR      r0,[r4,#4]  ; i
00001c  2900              CMP      r1,#0
00001e  d105              BNE      |L5.44|
;;;83             osThreadFlagsSet(main_task_id, FLAGS_MAIN_90MS);
000020  68a0              LDR      r0,[r4,#8]  ; main_task_id
000022  e8bd4010          POP      {r4,lr}
000026  2101              MOVS     r1,#1
000028  f7ffbffe          B.W      osThreadFlagsSet
                  |L5.44|
;;;84         }
;;;85     }
00002c  bd10              POP      {r4,pc}
;;;86     
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  msc_led_usb_activity
000000  00                DCB      0x00
                  msc_led_state
000001  01                DCB      0x01
                  usb_state
000002  00                DCB      0x00
                  usb_busy
000003  00                DCB      0x00
                  i
                          DCD      0x00000000
                  main_task_id
                          DCD      0x00000000
                  usb_busy_count
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\bootloader\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d19b3d14____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___6_main_c_d19b3d14____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d19b3d14____REVSH|
#line 495
|__asm___6_main_c_d19b3d14____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d19b3d14____RRX|
#line 682
|__asm___6_main_c_d19b3d14____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |modify_stack_pointer_and_start_app|
#line 41 "..\\..\\..\\source\\daplink\\bootloader\\main.c"
|modify_stack_pointer_and_start_app| PROC
#line 42

 MOV SP, R0
 BX R1
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
