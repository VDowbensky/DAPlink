; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\util.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\util.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\util.crf ..\..\..\source\daplink\util.c]
                          THUMB

                          AREA ||i._util_assert||, CODE, READONLY, ALIGN=1

                  _util_assert PROC
;;;127    
;;;128    void _util_assert(bool expression, const char *filename, uint16_t line)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;129    {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  2800              CMP      r0,#0
00000a  d11a              BNE      |L1.66|
00000c  f3ef8010          MRS      r0,PRIMASK
000010  f0000501          AND      r5,r0,#1
000014  b672              CPSID    i
;;;130        bool assert_set;
;;;131        cortex_int_state_t int_state;
;;;132    
;;;133        if (expression) {
;;;134            return;
;;;135        }
;;;136    
;;;137        int_state = cortex_int_get_and_disable();
;;;138        // Only write the assert if there is not already one
;;;139        assert_set = config_ram_get_assert(0, 0, 0, 0);
000016  2300              MOVS     r3,#0
000018  461a              MOV      r2,r3
00001a  4619              MOV      r1,r3
00001c  4618              MOV      r0,r3
00001e  f7fffffe          BL       config_ram_get_assert
000022  0004              MOVS     r4,r0
;;;140    
;;;141        if (!assert_set) {
000024  d103              BNE      |L1.46|
;;;142            config_ram_set_assert(filename, line);
000026  4631              MOV      r1,r6
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       config_ram_set_assert
                  |L1.46|
00002e  b905              CBNZ     r5,|L1.50|
000030  b662              CPSIE    i
                  |L1.50|
;;;143        }
;;;144    
;;;145        cortex_int_restore(int_state);
;;;146    
;;;147        // Start a remount if this is the first assert
;;;148        // Do not call vfs_mngr_fs_remount from an ISR!
;;;149        if (!assert_set && !cortex_in_isr()) {
000032  2c00              CMP      r4,#0
000034  d105              BNE      |L1.66|
000036  f3ef8003          MRS      r0,XPSR
00003a  06c0              LSLS     r0,r0,#27
00003c  d101              BNE      |L1.66|
;;;150            vfs_mngr_fs_remount();
00003e  f7fffffe          BL       vfs_mngr_fs_remount
                  |L1.66|
;;;151        }
;;;152    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.util_assert_clear||, CODE, READONLY, ALIGN=1

                  util_assert_clear PROC
;;;153    
;;;154    void util_assert_clear()
000000  b510              PUSH     {r4,lr}
000002  f3ef8010          MRS      r0,PRIMASK
000006  f0000401          AND      r4,r0,#1
00000a  b672              CPSID    i
;;;155    {
;;;156        cortex_int_state_t int_state;
;;;157        int_state = cortex_int_get_and_disable();
;;;158        config_ram_clear_assert();
00000c  f7fffffe          BL       config_ram_clear_assert
000010  2c00              CMP      r4,#0
000012  d100              BNE      |L2.22|
000014  b662              CPSIE    i
                  |L2.22|
;;;159        cortex_int_restore(int_state);
;;;160    }
000016  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.util_div_round||, CODE, READONLY, ALIGN=1

                  util_div_round PROC
;;;122    
;;;123    uint32_t util_div_round(uint32_t dividen, uint32_t divisor)
000000  eb000051          ADD      r0,r0,r1,LSR #1
;;;124    {
;;;125        return (dividen + divisor / 2) / divisor;
000004  fbb0f0f1          UDIV     r0,r0,r1
;;;126    }
000008  4770              BX       lr
;;;127    
                          ENDP


                          AREA ||i.util_div_round_down||, CODE, READONLY, ALIGN=1

                  util_div_round_down PROC
;;;117    
;;;118    uint32_t util_div_round_down(uint32_t dividen, uint32_t divisor)
000000  fbb0f0f1          UDIV     r0,r0,r1
;;;119    {
;;;120        return dividen / divisor;
;;;121    }
000004  4770              BX       lr
;;;122    
                          ENDP


                          AREA ||i.util_div_round_up||, CODE, READONLY, ALIGN=1

                  util_div_round_up PROC
;;;112    
;;;113    uint32_t util_div_round_up(uint32_t dividen, uint32_t divisor)
000000  4408              ADD      r0,r0,r1
;;;114    {
;;;115        return (dividen + divisor - 1) / divisor;
000002  1e40              SUBS     r0,r0,#1
000004  fbb0f0f1          UDIV     r0,r0,r1
;;;116    }
000008  4770              BX       lr
;;;117    
                          ENDP


                          AREA ||i.util_write_hex16||, CODE, READONLY, ALIGN=1

                  util_write_hex16 PROC
;;;38     
;;;39     uint32_t util_write_hex16(char *str, uint16_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;40     {
000002  460e              MOV      r6,r1
000004  4605              MOV      r5,r0
;;;41         uint32_t pos = 0;
;;;42         pos += util_write_hex8(str + pos, (value >> 8) & 0xFF);
000006  0a09              LSRS     r1,r1,#8
000008  f7fffffe          BL       util_write_hex8
00000c  4604              MOV      r4,r0
;;;43         pos += util_write_hex8(str + pos, (value >> 0) & 0xFF);
00000e  b2f1              UXTB     r1,r6
000010  1928              ADDS     r0,r5,r4
000012  f7fffffe          BL       util_write_hex8
000016  4420              ADD      r0,r0,r4
;;;44         return pos;
;;;45     }
000018  bd70              POP      {r4-r6,pc}
;;;46     
                          ENDP


                          AREA ||i.util_write_hex32||, CODE, READONLY, ALIGN=1

                  util_write_hex32 PROC
;;;46     
;;;47     uint32_t util_write_hex32(char *str, uint32_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;49         uint32_t pos = 0;
;;;50         pos += util_write_hex8(str + pos, (value >> 0x18) & 0xFF);
000006  0e09              LSRS     r1,r1,#24
000008  f7fffffe          BL       util_write_hex8
00000c  4606              MOV      r6,r0
;;;51         pos += util_write_hex8(str + pos, (value >> 0x10) & 0xFF);
00000e  19a0              ADDS     r0,r4,r6
000010  f3c54107          UBFX     r1,r5,#16,#8
000014  f7fffffe          BL       util_write_hex8
000018  4406              ADD      r6,r6,r0
;;;52         pos += util_write_hex8(str + pos, (value >> 0x08) & 0xFF);
00001a  19a0              ADDS     r0,r4,r6
00001c  f3c52107          UBFX     r1,r5,#8,#8
000020  f7fffffe          BL       util_write_hex8
000024  4406              ADD      r6,r6,r0
;;;53         pos += util_write_hex8(str + pos, (value >> 0x00) & 0xFF);
000026  b2e9              UXTB     r1,r5
000028  19a0              ADDS     r0,r4,r6
00002a  f7fffffe          BL       util_write_hex8
00002e  4430              ADD      r0,r0,r6
;;;54         return pos;
;;;55     }
000030  bd70              POP      {r4-r6,pc}
;;;56     
                          ENDP


                          AREA ||i.util_write_hex8||, CODE, READONLY, ALIGN=2

                  util_write_hex8 PROC
;;;30     
;;;31     uint32_t util_write_hex8(char *str, uint8_t value)
000000  4a05              LDR      r2,|L8.24|
;;;32     {
;;;33         static const char nybble_chars[] = "0123456789abcdef";
;;;34         *(str + 0) = nybble_chars[(value >> 4) & 0x0F ];
000002  eb021311          ADD      r3,r2,r1,LSR #4
;;;35         *(str + 1) = nybble_chars[(value >> 0) & 0x0F ];
000006  f001010f          AND      r1,r1,#0xf
00000a  781b              LDRB     r3,[r3,#0]            ;34
00000c  7003              STRB     r3,[r0,#0]            ;34
00000e  5c51              LDRB     r1,[r2,r1]
000010  7041              STRB     r1,[r0,#1]
;;;36         return 2;
000012  2002              MOVS     r0,#2
;;;37     }
000014  4770              BX       lr
;;;38     
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      ||.constdata||

                          AREA ||i.util_write_string||, CODE, READONLY, ALIGN=1

                  util_write_string PROC
;;;100    
;;;101    uint32_t util_write_string(char *str, const char *data)
000000  4603              MOV      r3,r0
;;;102    {
;;;103        uint32_t pos = 0;
000002  2000              MOVS     r0,#0
000004  e001              B        |L9.10|
                  |L9.6|
;;;104    
;;;105        while (0 != data[pos]) {
;;;106            str[pos] = data[pos];
000006  541a              STRB     r2,[r3,r0]
000008  1c40              ADDS     r0,r0,#1
                  |L9.10|
00000a  5c0a              LDRB     r2,[r1,r0]            ;105
00000c  2a00              CMP      r2,#0                 ;105
00000e  d1fa              BNE      |L9.6|
;;;107            pos++;
;;;108        }
;;;109    
;;;110        return pos;
;;;111    }
000010  4770              BX       lr
;;;112    
                          ENDP


                          AREA ||i.util_write_uint32||, CODE, READONLY, ALIGN=1

                  util_write_uint32 PROC
;;;56     
;;;57     uint32_t util_write_uint32(char *str, uint32_t value)
000000  b5f0              PUSH     {r4-r7,lr}
;;;58     {
000002  4606              MOV      r6,r0
000004  2000              MOVS     r0,#0
000006  4602              MOV      r2,r0
;;;59         uint32_t temp_val;
;;;60         uint64_t digits;
;;;61         uint32_t i;
;;;62         // Count the number of digits
;;;63         digits = 0;
;;;64         temp_val = value;
000008  460b              MOV      r3,r1
;;;65     
;;;66         while (temp_val > 0) {
;;;67             temp_val /= 10;
00000a  250a              MOVS     r5,#0xa
00000c  e004              B        |L10.24|
                  |L10.14|
00000e  fbb3f3f5          UDIV     r3,r3,r5
000012  1c40              ADDS     r0,r0,#1
000014  f1420200          ADC      r2,r2,#0
                  |L10.24|
000018  2b00              CMP      r3,#0                 ;66
00001a  d1f8              BNE      |L10.14|
;;;68             digits += 1;
;;;69         }
;;;70     
;;;71         if (digits <= 0) {
00001c  ea500302          ORRS     r3,r0,r2
000020  d101              BNE      |L10.38|
000022  2001              MOVS     r0,#1
000024  2200              MOVS     r2,#0
                  |L10.38|
;;;72             digits = 1;
;;;73         }
;;;74     
;;;75         // Write the number
;;;76         for (i = 0; i < digits; i++) {
000026  2300              MOVS     r3,#0
000028  461f              MOV      r7,r3
00002a  e00e              B        |L10.74|
                  |L10.44|
;;;77             str[digits - i - 1] = '0' + (value % 10);
00002c  fbb1f4f5          UDIV     r4,r1,r5
000030  fb051414          MLS      r4,r5,r4,r1
;;;78             value /= 10;
000034  fbb1f1f5          UDIV     r1,r1,r5
000038  3430              ADDS     r4,r4,#0x30           ;77
00003a  ebb00c03          SUBS     r12,r0,r3             ;77
00003e  f1bc0c01          SUBS     r12,r12,#1            ;77
000042  f1030301          ADD      r3,r3,#1
000046  f806400c          STRB     r4,[r6,r12]           ;77
                  |L10.74|
00004a  1a1c              SUBS     r4,r3,r0
00004c  eb770402          SBCS     r4,r7,r2
000050  d3ec              BCC      |L10.44|
;;;79         }
;;;80     
;;;81         return digits;
;;;82     }
000052  bdf0              POP      {r4-r7,pc}
;;;83     
                          ENDP


                          AREA ||i.util_write_uint32_zp||, CODE, READONLY, ALIGN=1

                  util_write_uint32_zp PROC
;;;83     
;;;84     uint32_t util_write_uint32_zp(char *str, uint32_t value, uint16_t total_size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;85     {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;86         uint32_t size;
;;;87         // Get the size of value
;;;88         size = util_write_uint32(str, value);
00000a  f7fffffe          BL       util_write_uint32
00000e  4604              MOV      r4,r0
;;;89     
;;;90         if (size >= total_size) {
000010  42a8              CMP      r0,r5
000012  d20a              BCS      |L11.42|
;;;91             return size;
;;;92         }
;;;93     
;;;94         // Zero fill
;;;95         memset(str, '0', total_size);
000014  2230              MOVS     r2,#0x30
000016  4629              MOV      r1,r5
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       __aeabi_memset
;;;96         // Write value
;;;97         util_write_uint32(str + (total_size - size), value);
00001e  1b28              SUBS     r0,r5,r4
000020  4438              ADD      r0,r0,r7
000022  4631              MOV      r1,r6
000024  f7fffffe          BL       util_write_uint32
;;;98         return total_size;
000028  4628              MOV      r0,r5
                  |L11.42|
;;;99     }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;100    
                          ENDP


                          AREA ||i.vfs_mngr_fs_remount||, CODE, READONLY, ALIGN=1

                  vfs_mngr_fs_remount PROC
;;;28     //remove dependency from vfs_manager
;;;29     __attribute__((weak)) void vfs_mngr_fs_remount(void) {}
000000  4770              BX       lr
;;;30     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  nybble_chars
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38396162          DCB      0x38,0x39,0x61,0x62
00000c  63646566          DCB      0x63,0x64,0x65,0x66
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\util.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_util_c_dee0e2ed____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___6_util_c_dee0e2ed____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_util_c_dee0e2ed____REVSH|
#line 495
|__asm___6_util_c_dee0e2ed____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_util_c_dee0e2ed____RRX|
#line 682
|__asm___6_util_c_dee0e2ed____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
