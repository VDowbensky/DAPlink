; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\flash_decoder.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\flash_decoder.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\flash_decoder.crf ..\..\..\source\daplink\drag-n-drop\flash_decoder.c]
                          THUMB

                          AREA ||i.flash_decoder_close||, CODE, READONLY, ALIGN=2

                  flash_decoder_close PROC
;;;315    
;;;316    error_t flash_decoder_close(void)
000000  b570              PUSH     {r4-r6,lr}
;;;317    {
;;;318        error_t status = ERROR_SUCCESS;
;;;319        decoder_state_t prev_state = state;
000002  4d0d              LDR      r5,|L1.56|
000004  2000              MOVS     r0,#0                 ;318
000006  782c              LDRB     r4,[r5,#0]  ; state
000008  b174              CBZ      r4,|L1.40|
;;;320        flash_decoder_printf("flash_decoder_close()\r\n");
;;;321    
;;;322        if (DECODER_STATE_CLOSED == state) {
;;;323            util_assert(0);
;;;324            return ERROR_INTERNAL;
;;;325        }
;;;326    
;;;327        state = DECODER_STATE_CLOSED;
00000a  2100              MOVS     r1,#0
00000c  7029              STRB     r1,[r5,#0]
;;;328    
;;;329        if (flash_initialized) {
00000e  78a9              LDRB     r1,[r5,#2]  ; flash_initialized
000010  b109              CBZ      r1,|L1.22|
;;;330            status = flash_manager_uninit();
000012  f7fffffe          BL       flash_manager_uninit
                  |L1.22|
;;;331            flash_decoder_printf("    flash_manager_uninit ret %i\r\n", status);
;;;332        }
;;;333    
;;;334        if ((DECODER_STATE_DONE != prev_state) &&
000016  2c02              CMP      r4,#2
000018  d005              BEQ      |L1.38|
;;;335                (flash_type != FLASH_DECODER_TYPE_TARGET) &&
00001a  7869              LDRB     r1,[r5,#1]  ; flash_type
00001c  2903              CMP      r1,#3
00001e  d002              BEQ      |L1.38|
;;;336                (status == ERROR_SUCCESS)) {
000020  2800              CMP      r0,#0
000022  d100              BNE      |L1.38|
;;;337            status = ERROR_IAP_UPDT_INCOMPLETE;
000024  2024              MOVS     r0,#0x24
                  |L1.38|
;;;338        }
;;;339    
;;;340        return status;
;;;341    }
000026  bd70              POP      {r4-r6,pc}
                  |L1.40|
000028  f2401243          MOV      r2,#0x143             ;323
00002c  a103              ADR      r1,|L1.60|
00002e  2000              MOVS     r0,#0                 ;323
000030  f7fffffe          BL       _util_assert
000034  2002              MOVS     r0,#2                 ;324
000036  bd70              POP      {r4-r6,pc}
;;;342    
                          ENDP

                  |L1.56|
                          DCD      ||.data||
                  |L1.60|
00003c  2866696c          DCB      "(file)",0
000040  652900  
000043  00                DCB      0

                          AREA ||i.flash_decoder_detect_type||, CODE, READONLY, ALIGN=2

                  flash_decoder_detect_type PROC
;;;61     
;;;62     flash_decoder_type_t flash_decoder_detect_type(const uint8_t *data, uint32_t size, uint32_t addr, bool addr_valid)
000000  b5fe              PUSH     {r1-r7,lr}
;;;63     {
000002  461c              MOV      r4,r3
000004  4605              MOV      r5,r0
;;;64         daplink_info_t info;
;;;65         util_assert(size >= FLASH_DECODER_MIN_SIZE);
000006  2930              CMP      r1,#0x30
000008  d301              BCC      |L2.14|
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L2.16|
                  |L2.14|
00000e  2000              MOVS     r0,#0
                  |L2.16|
000010  2241              MOVS     r2,#0x41
000012  a115              ADR      r1,|L2.104|
000014  f7fffffe          BL       _util_assert
;;;66         // Check if this is a daplink image
;;;67         memcpy(&info, data + DAPLINK_INFO_OFFSET, sizeof(info));
000018  220c              MOVS     r2,#0xc
00001a  f1050120          ADD      r1,r5,#0x20
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       __aeabi_memcpy
;;;68         if(!addr_valid){ //reset until we know the binary type
;;;69             flash_type_target_bin = false;
000024  4e12              LDR      r6,|L2.112|
000026  b90c              CBNZ     r4,|L2.44|
000028  2000              MOVS     r0,#0
00002a  7130              STRB     r0,[r6,#4]
                  |L2.44|
;;;70         }
;;;71         if (DAPLINK_HIC_ID == info.hic_id) {
00002c  4911              LDR      r1,|L2.116|
00002e  9801              LDR      r0,[sp,#4]
000030  4288              CMP      r0,r1
000032  d10b              BNE      |L2.76|
;;;72             if (DAPLINK_BUILD_KEY_IF == info.build_key) {
000034  4910              LDR      r1,|L2.120|
000036  9800              LDR      r0,[sp,#0]
000038  4288              CMP      r0,r1
00003a  d101              BNE      |L2.64|
;;;73                 // Interface update
;;;74                 return FLASH_DECODER_TYPE_INTERFACE;
00003c  2002              MOVS     r0,#2
;;;75             } else if (DAPLINK_BUILD_KEY_BL == info.build_key) {
;;;76                 // Bootloader update
;;;77                 return FLASH_DECODER_TYPE_BOOTLOADER;
;;;78             } else {
;;;79                 return FLASH_DECODER_TYPE_UNKNOWN;
;;;80             }
;;;81         }
;;;82     
;;;83         // Check if a valid vector table for the target can be found
;;;84         if (validate_bin_nvic(data)) {
;;;85             if(!addr_valid){ //binary is a bin type
;;;86                 flash_type_target_bin = true;
;;;87             }
;;;88             return FLASH_DECODER_TYPE_TARGET;
;;;89         }
;;;90     
;;;91         // If an address is specified then the data can be decoded
;;;92         if (addr_valid) {
;;;93             // TODO - future improvement - make sure address is within target's flash
;;;94             return FLASH_DECODER_TYPE_TARGET;
;;;95         }
;;;96     
;;;97         return FLASH_DECODER_TYPE_UNKNOWN;
;;;98     }
00003e  bdfe              POP      {r1-r7,pc}
                  |L2.64|
000040  490d              LDR      r1,|L2.120|
000042  39fc              SUBS     r1,r1,#0xfc           ;75
000044  4288              CMP      r0,r1                 ;75
000046  d10c              BNE      |L2.98|
000048  2001              MOVS     r0,#1                 ;77
00004a  bdfe              POP      {r1-r7,pc}
                  |L2.76|
00004c  4628              MOV      r0,r5                 ;84
00004e  f7fffffe          BL       validate_bin_nvic
000052  b118              CBZ      r0,|L2.92|
000054  b91c              CBNZ     r4,|L2.94|
000056  2001              MOVS     r0,#1                 ;86
000058  7130              STRB     r0,[r6,#4]            ;86
00005a  e000              B        |L2.94|
                  |L2.92|
00005c  b10c              CBZ      r4,|L2.98|
                  |L2.94|
00005e  2003              MOVS     r0,#3                 ;94
000060  bdfe              POP      {r1-r7,pc}
                  |L2.98|
000062  2000              MOVS     r0,#0                 ;97
000064  bdfe              POP      {r1-r7,pc}
;;;99     
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
000068  2866696c          DCB      "(file)",0
00006c  652900  
00006f  00                DCB      0
                  |L2.112|
                          DCD      ||.data||
                  |L2.116|
                          DCD      0x97969908
                  |L2.120|
                          DCD      0x9b939e8f

                          AREA ||i.flash_decoder_get_flash||, CODE, READONLY, ALIGN=2

                  flash_decoder_get_flash PROC
;;;99     
;;;100    error_t flash_decoder_get_flash(flash_decoder_type_t type, uint32_t addr, bool addr_valid, uint32_t *start_addr, const flash_intf_t **flash_intf)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;101    {
;;;102        error_t status = ERROR_SUCCESS;
000004  f04f0400          MOV      r4,#0
000008  f8dd9038          LDR      r9,[sp,#0x38]         ;101
00000c  ea5f0803          MOVS     r8,r3                 ;101
000010  4693              MOV      r11,r2                ;101
000012  4607              MOV      r7,r0                 ;101
;;;103        uint32_t flash_start_local;
;;;104        const flash_intf_t *flash_intf_local = 0;
000014  4625              MOV      r5,r4
000016  d013              BEQ      |L3.64|
;;;105    
;;;106        if ((0 == start_addr) || (0 == flash_intf)) {
000018  ea5f0009          MOVS     r0,r9
00001c  d010              BEQ      |L3.64|
;;;107            util_assert(0);
;;;108            return ERROR_INTERNAL;
;;;109        }
;;;110    
;;;111        *start_addr = 0;
00001e  2000              MOVS     r0,#0
;;;112        *flash_intf = 0;
000020  f8c80000          STR      r0,[r8,#0]
;;;113        flash_start_local = 0;
000024  4606              MOV      r6,r0
;;;114        flash_intf_local = 0;
;;;115    
;;;116        if (daplink_is_bootloader()) {
000026  f8c90000          STR      r0,[r9,#0]
00002a  f7fffffe          BL       daplink_is_bootloader
;;;117            if (FLASH_DECODER_TYPE_INTERFACE == type) {
;;;118                if (addr_valid && (DAPLINK_ROM_IF_START != addr)) {
;;;119                    // Address is wrong so display error message
;;;120                    status = ERROR_FD_INTF_UPDT_ADDR_WRONG;
;;;121                } else {
;;;122                    // Setup for update
;;;123                    flash_start_local = DAPLINK_ROM_IF_START;
;;;124                    flash_intf_local = flash_intf_iap_protected;
00002e  f8dfa0cc          LDR      r10,|L3.252|
000032  b188              CBZ      r0,|L3.88|
000034  4832              LDR      r0,|L3.256|
000036  2f02              CMP      r7,#2                 ;117
000038  d004              BEQ      |L3.68|
;;;125                }
;;;126            } else if (FLASH_DECODER_TYPE_TARGET == type) {
00003a  2f03              CMP      r7,#3
00003c  d00a              BEQ      |L3.84|
00003e  e042              B        |L3.198|
                  |L3.64|
000040  226b              MOVS     r2,#0x6b              ;107
000042  e054              B        |L3.238|
                  |L3.68|
000044  f1bb0f00          CMP      r11,#0                ;118
000048  d004              BEQ      |L3.84|
00004a  9901              LDR      r1,[sp,#4]            ;118
00004c  4281              CMP      r1,r0                 ;118
00004e  d001              BEQ      |L3.84|
000050  241b              MOVS     r4,#0x1b              ;120
000052  e039              B        |L3.200|
                  |L3.84|
000054  4606              MOV      r6,r0                 ;123
000056  e012              B        |L3.126|
                  |L3.88|
;;;127                // "Target" update in this case would be a 3rd party interface application
;;;128                flash_start_local = DAPLINK_ROM_IF_START;
;;;129                flash_intf_local = flash_intf_iap_protected;
;;;130            } else {
;;;131                status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;132            }
;;;133        } else if (daplink_is_interface()) {
000058  f7fffffe          BL       daplink_is_interface
00005c  b390              CBZ      r0,|L3.196|
;;;134            if (FLASH_DECODER_TYPE_BOOTLOADER == type) {
00005e  2f01              CMP      r7,#1
000060  d002              BEQ      |L3.104|
;;;135                if (addr_valid && (DAPLINK_ROM_BL_START != addr)) {
;;;136                    // Address is wrong so display error message
;;;137                    status = ERROR_FD_BL_UPDT_ADDR_WRONG;
;;;138                } else {
;;;139                    // Setup for update
;;;140                    flash_start_local = DAPLINK_ROM_BL_START;
;;;141                    flash_intf_local = flash_intf_iap_protected;
;;;142                }
;;;143            } else if (FLASH_DECODER_TYPE_TARGET == type) {
000062  2f03              CMP      r7,#3
000064  d00e              BEQ      |L3.132|
000066  e02e              B        |L3.198|
                  |L3.104|
000068  f04f6100          MOV      r1,#0x8000000         ;135
00006c  f1bb0f00          CMP      r11,#0                ;135
000070  d004              BEQ      |L3.124|
000072  9801              LDR      r0,[sp,#4]            ;135
000074  4288              CMP      r0,r1                 ;135
000076  d001              BEQ      |L3.124|
000078  241a              MOVS     r4,#0x1a              ;137
00007a  e025              B        |L3.200|
                  |L3.124|
00007c  460e              MOV      r6,r1                 ;140
                  |L3.126|
00007e  f8da5000          LDR      r5,[r10,#0]           ;141  ; flash_intf_iap_protected
000082  e021              B        |L3.200|
                  |L3.132|
;;;144                if (g_board_info.target_cfg) {
000084  481f              LDR      r0,|L3.260|
000086  f7fffffe          BL       __aeabi_uread4
00008a  b1d8              CBZ      r0,|L3.196|
00008c  f100050c          ADD      r5,r0,#0xc
;;;145                    region_info_t * region = g_board_info.target_cfg->flash_regions;
;;;146                    for (; region->start != 0 || region->end != 0; ++region) {
000090  e006              B        |L3.160|
                  |L3.146|
;;;147                        if (kRegionIsDefault == region->flags) {
000092  f1050008          ADD      r0,r5,#8
000096  f7fffffe          BL       __aeabi_uread4
00009a  2801              CMP      r0,#1
00009c  d00d              BEQ      |L3.186|
00009e  3514              ADDS     r5,r5,#0x14
                  |L3.160|
0000a0  4628              MOV      r0,r5                 ;146
0000a2  f7fffffe          BL       __aeabi_uread4
0000a6  2800              CMP      r0,#0                 ;146
0000a8  d1f3              BNE      |L3.146|
0000aa  1d28              ADDS     r0,r5,#4              ;146
0000ac  f7fffffe          BL       __aeabi_uread4
0000b0  2800              CMP      r0,#0                 ;146
0000b2  d1ee              BNE      |L3.146|
                  |L3.180|
;;;148                            flash_start_local = region->start;
;;;149                            break;
;;;150                        }
;;;151                    }
;;;152                    flash_intf_local = flash_intf_target;
0000b4  4814              LDR      r0,|L3.264|
;;;153                } else {
0000b6  6805              LDR      r5,[r0,#0]  ; flash_intf_target
0000b8  e006              B        |L3.200|
                  |L3.186|
0000ba  4628              MOV      r0,r5                 ;148
0000bc  f7fffffe          BL       __aeabi_uread4
0000c0  4606              MOV      r6,r0                 ;148
0000c2  e7f7              B        |L3.180|
                  |L3.196|
0000c4  e7ff              B        |L3.198|
                  |L3.198|
;;;154                    status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;155                }
;;;156            } else {
;;;157                status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;158            }
;;;159        } else {
;;;160            status = ERROR_FD_UNSUPPORTED_UPDATE;
0000c6  241c              MOVS     r4,#0x1c
                  |L3.200|
;;;161        }
;;;162    
;;;163        // Don't allow bootloader updates unless automation is allowed
;;;164        if (!config_get_automation_allowed() && (FLASH_DECODER_TYPE_BOOTLOADER == type)) {
0000c8  f7fffffe          BL       config_get_automation_allowed
0000cc  b908              CBNZ     r0,|L3.210|
0000ce  2f01              CMP      r7,#1
0000d0  d004              BEQ      |L3.220|
                  |L3.210|
;;;165            status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;166        }
;;;167    
;;;168        if (ERROR_SUCCESS != status) {
0000d2  b12c              CBZ      r4,|L3.224|
                  |L3.212|
;;;169            return status;
0000d4  4620              MOV      r0,r4
                  |L3.214|
;;;170        }
;;;171    
;;;172        if (0 == flash_intf_local) {
;;;173            util_assert(0);
;;;174            return ERROR_INTERNAL;
;;;175        }
;;;176    
;;;177        *start_addr = flash_start_local;
;;;178        *flash_intf = flash_intf_local;
;;;179        return status;
;;;180    }
0000d6  b004              ADD      sp,sp,#0x10
0000d8  e8bd9ff0          POP      {r4-r12,pc}
                  |L3.220|
0000dc  241c              MOVS     r4,#0x1c              ;165
0000de  e7f9              B        |L3.212|
                  |L3.224|
0000e0  b125              CBZ      r5,|L3.236|
0000e2  f8c86000          STR      r6,[r8,#0]            ;178
0000e6  f8c95000          STR      r5,[r9,#0]            ;179
0000ea  e7f3              B        |L3.212|
                  |L3.236|
0000ec  22ad              MOVS     r2,#0xad              ;173
                  |L3.238|
0000ee  a107              ADR      r1,|L3.268|
0000f0  2000              MOVS     r0,#0                 ;173
0000f2  f7fffffe          BL       _util_assert
0000f6  2002              MOVS     r0,#2                 ;174
0000f8  e7ed              B        |L3.214|
;;;181    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L3.252|
                          DCD      flash_intf_iap_protected
                  |L3.256|
                          DCD      0x0800c000
                  |L3.260|
                          DCD      g_board_info+0x10
                  |L3.264|
                          DCD      flash_intf_target
                  |L3.268|
00010c  2866696c          DCB      "(file)",0
000110  652900  
000113  00                DCB      0

                          AREA ||i.flash_decoder_is_at_end||, CODE, READONLY, ALIGN=2

                  flash_decoder_is_at_end PROC
;;;342    
;;;343    static bool flash_decoder_is_at_end(uint32_t addr, const uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;344    {
;;;345        uint32_t end_addr=0;
;;;346    
;;;347        switch (flash_type) {
000004  491c              LDR      r1,|L4.120|
000006  4606              MOV      r6,r0                 ;344
000008  2500              MOVS     r5,#0                 ;345
00000a  7848              LDRB     r0,[r1,#1]  ; flash_type
00000c  4690              MOV      r8,r2                 ;344
00000e  2801              CMP      r0,#1
000010  d004              BEQ      |L4.28|
000012  2802              CMP      r0,#2
000014  d004              BEQ      |L4.32|
000016  2803              CMP      r0,#3
000018  d12c              BNE      |L4.116|
00001a  e003              B        |L4.36|
                  |L4.28|
;;;348            case FLASH_DECODER_TYPE_BOOTLOADER:
;;;349                end_addr = DAPLINK_ROM_BL_START + DAPLINK_ROM_BL_SIZE;
00001c  4d17              LDR      r5,|L4.124|
;;;350                break;
00001e  e022              B        |L4.102|
                  |L4.32|
;;;351    
;;;352            case FLASH_DECODER_TYPE_INTERFACE:
;;;353                end_addr = DAPLINK_ROM_IF_START + DAPLINK_ROM_IF_SIZE;
000020  4d17              LDR      r5,|L4.128|
;;;354                break;
000022  e020              B        |L4.102|
                  |L4.36|
;;;355    
;;;356            case FLASH_DECODER_TYPE_TARGET:
;;;357                //only if we are sure it is a bin for the target; without check unordered hex files will cause to terminate flashing
;;;358                if (flash_type_target_bin && g_board_info.target_cfg) {
000024  7908              LDRB     r0,[r1,#4]  ; flash_type_target_bin
000026  b328              CBZ      r0,|L4.116|
000028  4816              LDR      r0,|L4.132|
00002a  f7fffffe          BL       __aeabi_uread4
00002e  b308              CBZ      r0,|L4.116|
000030  f100040c          ADD      r4,r0,#0xc
;;;359                    region_info_t * region = g_board_info.target_cfg->flash_regions;
;;;360                    for (; region->start != 0 || region->end != 0; ++region) {
000034  e00c              B        |L4.80|
                  |L4.54|
;;;361                        if (addr >= region->start &&  addr<=region->end) {
000036  42b7              CMP      r7,r6
000038  d809              BHI      |L4.78|
00003a  1d20              ADDS     r0,r4,#4
00003c  f7fffffe          BL       __aeabi_uread4
000040  42b0              CMP      r0,r6
000042  d304              BCC      |L4.78|
;;;362                            end_addr = region->end;
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       __aeabi_uread4
00004a  4605              MOV      r5,r0
;;;363                            break;
00004c  e00a              B        |L4.100|
                  |L4.78|
00004e  3414              ADDS     r4,r4,#0x14
                  |L4.80|
000050  4620              MOV      r0,r4                 ;360
000052  f7fffffe          BL       __aeabi_uread4
000056  0007              MOVS     r7,r0                 ;360
000058  d1ed              BNE      |L4.54|
00005a  1d20              ADDS     r0,r4,#4              ;360
00005c  f7fffffe          BL       __aeabi_uread4
000060  2800              CMP      r0,#0                 ;360
000062  d1e8              BNE      |L4.54|
                  |L4.100|
;;;364                        }
;;;365                    }
;;;366                    if(end_addr == 0){ //invalid end_addr
000064  b135              CBZ      r5,|L4.116|
                  |L4.102|
;;;367                        return false;
;;;368                    }
;;;369    
;;;370                }
;;;371                else {
;;;372                    return false;
;;;373                }
;;;374                break;
;;;375    
;;;376            default:
;;;377                return false;
;;;378        }
;;;379    
;;;380        if (addr + size >= end_addr) {
000066  eb060008          ADD      r0,r6,r8
00006a  42a8              CMP      r0,r5
00006c  d302              BCC      |L4.116|
;;;381            return true;
00006e  2001              MOVS     r0,#1
                  |L4.112|
;;;382        } else {
;;;383            return false;
;;;384        }
;;;385    }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L4.116|
000074  2000              MOVS     r0,#0                 ;383
000076  e7fb              B        |L4.112|
                          ENDP

                  |L4.120|
                          DCD      ||.data||
                  |L4.124|
                          DCD      0x0800bc00
                  |L4.128|
                          DCD      0x0801fc00
                  |L4.132|
                          DCD      g_board_info+0x10

                          AREA ||i.flash_decoder_open||, CODE, READONLY, ALIGN=2

                  flash_decoder_open PROC
;;;181    
;;;182    error_t flash_decoder_open(void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184        flash_decoder_printf("flash_decoder_open()\r\n");
;;;185    
;;;186        // Stream must not be open already
;;;187        if (state != DECODER_STATE_CLOSED) {
000002  4c0c              LDR      r4,|L5.52|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L5.22|
;;;188            util_assert(0);
000008  22bc              MOVS     r2,#0xbc
00000a  a10b              ADR      r1,|L5.56|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       _util_assert
;;;189            return ERROR_INTERNAL;
000012  2002              MOVS     r0,#2
;;;190        }
;;;191    
;;;192        memset(flash_buf, 0xff, sizeof(flash_buf));
;;;193        state = DECODER_STATE_OPEN;
;;;194        flash_type = FLASH_DECODER_TYPE_UNKNOWN;
;;;195        flash_buf_pos = 0;
;;;196        initial_addr = 0;
;;;197        current_addr = 0;
;;;198        flash_initialized = false;
;;;199        initial_addr_set = false;
;;;200        return ERROR_SUCCESS;
;;;201    }
000014  bd10              POP      {r4,pc}
                  |L5.22|
000016  22ff              MOVS     r2,#0xff              ;192
000018  2130              MOVS     r1,#0x30              ;192
00001a  4809              LDR      r0,|L5.64|
00001c  f7fffffe          BL       __aeabi_memset
000020  2001              MOVS     r0,#1                 ;193
000022  7020              STRB     r0,[r4,#0]            ;193
000024  2000              MOVS     r0,#0                 ;194
000026  7060              STRB     r0,[r4,#1]            ;194
000028  60a0              STR      r0,[r4,#8]            ;196  ; flash_buf_pos
00002a  60e0              STR      r0,[r4,#0xc]          ;197  ; initial_addr
00002c  6120              STR      r0,[r4,#0x10]         ;198  ; current_addr
00002e  70a0              STRB     r0,[r4,#2]            ;198
000030  70e0              STRB     r0,[r4,#3]            ;199
000032  bd10              POP      {r4,pc}
;;;202    
                          ENDP

                  |L5.52|
                          DCD      ||.data||
                  |L5.56|
000038  2866696c          DCB      "(file)",0
00003c  652900  
00003f  00                DCB      0
                  |L5.64|
                          DCD      ||.bss||

                          AREA ||i.flash_decoder_write||, CODE, READONLY, ALIGN=2

                  flash_decoder_write PROC
;;;202    
;;;203    error_t flash_decoder_write(uint32_t addr, const uint8_t *data, uint32_t size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;204    {
;;;205        error_t status;
;;;206        flash_decoder_printf("flash_decoder_write(addr=0x%x, size=0x%x)\r\n", addr, size);
;;;207    
;;;208        if (DECODER_STATE_OPEN != state) {
000004  4f41              LDR      r7,|L6.268|
000006  4606              MOV      r6,r0                 ;204
000008  4689              MOV      r9,r1                 ;204
00000a  7838              LDRB     r0,[r7,#0]  ; state
00000c  4615              MOV      r5,r2                 ;204
00000e  2801              CMP      r0,#1
000010  d007              BEQ      |L6.34|
;;;209            util_assert(0);
000012  22d1              MOVS     r2,#0xd1
000014  a13e              ADR      r1,|L6.272|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       _util_assert
;;;210            return ERROR_INTERNAL;
00001c  2002              MOVS     r0,#2
                  |L6.30|
;;;211        }
;;;212    
;;;213        // Set the initial address the first time through
;;;214        if (!initial_addr_set) {
;;;215            initial_addr = addr;
;;;216            current_addr = initial_addr;
;;;217            flash_decoder_printf("     initial_addr=0x%x\r\n", initial_addr);
;;;218            initial_addr_set = true;
;;;219        }
;;;220    
;;;221        if (!flash_initialized) {
;;;222            uint32_t copy_size;
;;;223            bool flash_type_known = false;
;;;224            bool sequential;
;;;225            // Check if the data is sequential
;;;226            sequential = addr == current_addr;
;;;227            current_addr += size;
;;;228    
;;;229            // Buffer data until the flash type is known
;;;230            if (sequential) {
;;;231                // Copy data into buffer
;;;232                copy_size = MIN(size, sizeof(flash_buf) - flash_buf_pos);
;;;233                memcpy(&flash_buf[flash_buf_pos], data, copy_size);
;;;234                flash_buf_pos += copy_size;
;;;235                flash_decoder_printf("    buffering %i bytes\r\n", copy_size);
;;;236                // Update vars so they no longer include the buffered data
;;;237                data += copy_size;
;;;238                size -= copy_size;
;;;239                addr += copy_size;
;;;240    
;;;241                // If enough data has been buffered then determine the type
;;;242                if (flash_buf_pos >= sizeof(flash_buf)) {
;;;243                    util_assert(sizeof(flash_buf) == flash_buf_pos);
;;;244                    // Determine flash type and get info for it
;;;245                    flash_type = flash_decoder_detect_type(flash_buf, flash_buf_pos, initial_addr, true);
;;;246                    flash_decoder_printf("    Buffering complete, setting flash_type=%i\r\n", flash_type);
;;;247                    flash_type_known = true;
;;;248                }
;;;249            } else {
;;;250                flash_type = FLASH_DECODER_TYPE_TARGET;
;;;251                flash_decoder_printf("    Non sequential addr, setting flash_type=%i\r\n", flash_type);
;;;252                flash_type_known = true;
;;;253            }
;;;254    
;;;255            // If flash type is known initialize the flash manager
;;;256            if (flash_type_known) {
;;;257                const flash_intf_t *flash_intf;
;;;258                uint32_t flash_start_addr;
;;;259                status = flash_decoder_get_flash(flash_type, initial_addr, true, &flash_start_addr, &flash_intf);
;;;260    
;;;261                if (ERROR_SUCCESS != status) {
;;;262                    state = DECODER_STATE_ERROR;
;;;263                    return status;
;;;264                }
;;;265    
;;;266                flash_decoder_printf("    flash_start_addr=0x%x\r\n", flash_start_addr);
;;;267                // Initialize flash manager
;;;268                util_assert(!flash_initialized);
;;;269                status = flash_manager_init(flash_intf);
;;;270                flash_decoder_printf("    flash_manager_init ret %i\r\n", status);
;;;271    
;;;272                if (ERROR_SUCCESS != status) {
;;;273                    state = DECODER_STATE_ERROR;
;;;274                    return status;
;;;275                }
;;;276    
;;;277                flash_initialized = true;
;;;278            }
;;;279    
;;;280            // If flash has been initalized then write out buffered data
;;;281            if (flash_initialized) {
;;;282                status = flash_manager_data(initial_addr, flash_buf, flash_buf_pos);
;;;283                flash_decoder_printf("    Flushing buffer initial_addr=0x%x, flash_buf_pos=%i, flash_manager_data ret=%i\r\n",
;;;284                                     initial_addr, flash_buf_pos, status);
;;;285    
;;;286                if (ERROR_SUCCESS != status) {
;;;287                    state = DECODER_STATE_ERROR;
;;;288                    return status;
;;;289                }
;;;290            }
;;;291        }
;;;292    
;;;293        // Write data as normal if flash has been initialized
;;;294        if (flash_initialized) {
;;;295            status = flash_manager_data(addr, data, size);
;;;296            flash_decoder_printf("    Writing data, addr=0x%x, size=0x%x, flash_manager_data ret %i\r\n",
;;;297                                 addr, size, status);
;;;298    
;;;299            if (ERROR_SUCCESS != status) {
;;;300                state = DECODER_STATE_ERROR;
;;;301                return status;
;;;302            }
;;;303        }
;;;304    
;;;305        // Check if this is the end of data
;;;306        if (flash_decoder_is_at_end(addr, data, size)) {
;;;307            flash_decoder_printf("    End of transfer detected - addr 0x%08x, size 0x%08x\r\n",
;;;308                                 addr, size);
;;;309            state = DECODER_STATE_DONE;
;;;310            return ERROR_SUCCESS_DONE;
;;;311        }
;;;312    
;;;313        return ERROR_SUCCESS;
;;;314    }
00001e  e8bd8ffe          POP      {r1-r11,pc}
                  |L6.34|
000022  78f8              LDRB     r0,[r7,#3]            ;214  ; initial_addr_set
000024  f04f0a01          MOV      r10,#1                ;208
000028  b918              CBNZ     r0,|L6.50|
00002a  60fe              STR      r6,[r7,#0xc]          ;216  ; initial_addr
00002c  613e              STR      r6,[r7,#0x10]         ;218  ; current_addr
00002e  f887a003          STRB     r10,[r7,#3]           ;218
                  |L6.50|
000032  78b8              LDRB     r0,[r7,#2]            ;221  ; flash_initialized
000034  f04f0803          MOV      r8,#3                 ;250
000038  2800              CMP      r0,#0                 ;221
00003a  d153              BNE      |L6.228|
00003c  6939              LDR      r1,[r7,#0x10]         ;226  ; current_addr
00003e  428e              CMP      r6,r1                 ;226
000040  d101              BNE      |L6.70|
000042  2001              MOVS     r0,#1                 ;226
000044  e000              B        |L6.72|
                  |L6.70|
000046  2000              MOVS     r0,#0                 ;226
                  |L6.72|
000048  4429              ADD      r1,r1,r5              ;227
00004a  6139              STR      r1,[r7,#0x10]         ;230  ; current_addr
00004c  b330              CBZ      r0,|L6.156|
00004e  68b8              LDR      r0,[r7,#8]            ;232  ; flash_buf_pos
000050  f1c00430          RSB      r4,r0,#0x30           ;232
000054  42ac              CMP      r4,r5                 ;232
000056  d900              BLS      |L6.90|
000058  4614              MOV      r4,r2                 ;232
                  |L6.90|
00005a  492f              LDR      r1,|L6.280|
00005c  4622              MOV      r2,r4                 ;233
00005e  4408              ADD      r0,r0,r1              ;233
000060  4649              MOV      r1,r9                 ;233
000062  f7fffffe          BL       __aeabi_memcpy
000066  68b8              LDR      r0,[r7,#8]            ;234  ; flash_buf_pos
000068  1b2d              SUBS     r5,r5,r4              ;238
00006a  4420              ADD      r0,r0,r4              ;234
00006c  44a1              ADD      r9,r9,r4              ;237
00006e  4426              ADD      r6,r6,r4              ;239
000070  60b8              STR      r0,[r7,#8]            ;242  ; flash_buf_pos
000072  2830              CMP      r0,#0x30              ;242
000074  d32c              BCC      |L6.208|
000076  d102              BNE      |L6.126|
000078  f04f0001          MOV      r0,#1                 ;243
00007c  e001              B        |L6.130|
                  |L6.126|
00007e  f04f0000          MOV      r0,#0                 ;243
                  |L6.130|
000082  f04f02f3          MOV      r2,#0xf3              ;243
000086  a122              ADR      r1,|L6.272|
000088  f7fffffe          BL       _util_assert
00008c  e9d71202          LDRD     r1,r2,[r7,#8]         ;245
000090  2301              MOVS     r3,#1                 ;245
000092  4821              LDR      r0,|L6.280|
000094  f7fffffe          BL       flash_decoder_detect_type
000098  7078              STRB     r0,[r7,#1]            ;245
00009a  e001              B        |L6.160|
                  |L6.156|
00009c  f8878001          STRB     r8,[r7,#1]            ;250
                  |L6.160|
0000a0  a801              ADD      r0,sp,#4              ;259
0000a2  9000              STR      r0,[sp,#0]            ;259
0000a4  ab02              ADD      r3,sp,#8              ;259
0000a6  2201              MOVS     r2,#1                 ;259
0000a8  7878              LDRB     r0,[r7,#1]            ;259  ; flash_type
0000aa  68f9              LDR      r1,[r7,#0xc]          ;259  ; initial_addr
0000ac  f7fffffe          BL       flash_decoder_get_flash
0000b0  b9f0              CBNZ     r0,|L6.240|
0000b2  78b8              LDRB     r0,[r7,#2]            ;268  ; flash_initialized
0000b4  f44f7286          MOV      r2,#0x10c             ;268
0000b8  f0800001          EOR      r0,r0,#1              ;268
0000bc  a114              ADR      r1,|L6.272|
0000be  f7fffffe          BL       _util_assert
0000c2  9801              LDR      r0,[sp,#4]            ;269
0000c4  f7fffffe          BL       flash_manager_init
0000c8  b990              CBNZ     r0,|L6.240|
0000ca  f887a002          STRB     r10,[r7,#2]           ;277
0000ce  e001              B        |L6.212|
                  |L6.208|
0000d0  78b8              LDRB     r0,[r7,#2]            ;281  ; flash_initialized
0000d2  b180              CBZ      r0,|L6.246|
                  |L6.212|
0000d4  e9d72002          LDRD     r2,r0,[r7,#8]         ;282
0000d8  490f              LDR      r1,|L6.280|
0000da  f7fffffe          BL       flash_manager_data
0000de  b938              CBNZ     r0,|L6.240|
0000e0  78b8              LDRB     r0,[r7,#2]            ;294  ; flash_initialized
0000e2  b140              CBZ      r0,|L6.246|
                  |L6.228|
0000e4  462a              MOV      r2,r5                 ;295
0000e6  4649              MOV      r1,r9                 ;295
0000e8  4630              MOV      r0,r6                 ;295
0000ea  f7fffffe          BL       flash_manager_data
0000ee  b110              CBZ      r0,|L6.246|
                  |L6.240|
0000f0  f8878000          STRB     r8,[r7,#0]            ;300
0000f4  e793              B        |L6.30|
                  |L6.246|
0000f6  462a              MOV      r2,r5                 ;306
0000f8  4649              MOV      r1,r9                 ;306
0000fa  4630              MOV      r0,r6                 ;306
0000fc  f7fffffe          BL       flash_decoder_is_at_end
000100  2800              CMP      r0,#0                 ;306
000102  d08c              BEQ      |L6.30|
000104  2002              MOVS     r0,#2                 ;309
000106  7038              STRB     r0,[r7,#0]            ;309
000108  2013              MOVS     r0,#0x13              ;310
00010a  e788              B        |L6.30|
;;;315    
                          ENDP

                  |L6.268|
                          DCD      ||.data||
                  |L6.272|
000110  2866696c          DCB      "(file)",0
000114  652900  
000117  00                DCB      0
                  |L6.280|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  flash_buf
                          %        48

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00                DCB      0x00
                  flash_type
000001  00                DCB      0x00
                  flash_initialized
000002  00                DCB      0x00
                  initial_addr_set
000003  00                DCB      0x00
                  flash_type_target_bin
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  flash_buf_pos
                          DCD      0x00000000
                  initial_addr
                          DCD      0x00000000
                  current_addr
                          DCD      0x00000000
