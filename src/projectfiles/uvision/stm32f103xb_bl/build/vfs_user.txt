; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\vfs_user.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\vfs_user.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink -I..\..\..\source\daplink\bootloader -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\settings -I..\..\..\source\target -I..\..\..\source\rtos_none -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_bl -IC:\Users\Admin\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\Admin\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DDAPLINK_VERSION=256 -DMSC_ENDPOINT -DDAPLINK_BL -DDAPLINK_BUILD_KEY=0x9B939D93 -DDRAG_N_DROP_SUPPORT -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 --omf_browse=.\build\vfs_user.crf ..\..\..\source\daplink\drag-n-drop\vfs_user.c]
                          THUMB

                          AREA ||i.expand_info||, CODE, READONLY, ALIGN=2

                  expand_info PROC
;;;568    // expanding the special characters in mbed_redirect_file.
;;;569    static uint32_t expand_info(uint8_t *buf, uint32_t bufsize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;570    {
000004  4689              MOV      r9,r1
000006  4604              MOV      r4,r0
;;;571        uint8_t *orig_buf = buf;
000008  4680              MOV      r8,r0
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  1c64              ADDS     r4,r4,#1              ;570
                  |L1.14|
;;;572        uint8_t *insert_string;
;;;573    
;;;574        do {
;;;575            // Look for key or the end of the string
;;;576            while ((*buf != '@') && (*buf != 0)) {
00000e  7820              LDRB     r0,[r4,#0]
000010  2840              CMP      r0,#0x40
000012  d002              BEQ      |L1.26|
000014  2800              CMP      r0,#0
000016  d1f9              BNE      |L1.12|
000018  e063              B        |L1.226|
                  |L1.26|
;;;577                buf++;
;;;578            }
;;;579    
;;;580            // If key was found then replace it
;;;581            if ('@' == *buf) {
;;;582                switch (*(buf + 1)) {
00001a  7860              LDRB     r0,[r4,#1]
00001c  2862              CMP      r0,#0x62
00001e  d047              BEQ      |L1.176|
000020  dc12              BGT      |L1.72|
000022  2852              CMP      r0,#0x52
000024  d053              BEQ      |L1.206|
000026  dc08              BGT      |L1.58|
000028  2842              CMP      r0,#0x42
00002a  d041              BEQ      |L1.176|
00002c  2844              CMP      r0,#0x44
00002e  d048              BEQ      |L1.194|
000030  2848              CMP      r0,#0x48
000032  d040              BEQ      |L1.182|
000034  284d              CMP      r0,#0x4d
000036  d117              BNE      |L1.104|
000038  e033              B        |L1.162|
                  |L1.58|
00003a  2854              CMP      r0,#0x54
00003c  d03e              BEQ      |L1.188|
00003e  2855              CMP      r0,#0x55
000040  d032              BEQ      |L1.168|
000042  2856              CMP      r0,#0x56
000044  d110              BNE      |L1.104|
000046  e03f              B        |L1.200|
                  |L1.72|
000048  2872              CMP      r0,#0x72
00004a  d040              BEQ      |L1.206|
00004c  dc06              BGT      |L1.92|
00004e  2864              CMP      r0,#0x64
000050  d037              BEQ      |L1.194|
000052  2868              CMP      r0,#0x68
000054  d02f              BEQ      |L1.182|
000056  286d              CMP      r0,#0x6d
000058  d106              BNE      |L1.104|
00005a  e022              B        |L1.162|
                  |L1.92|
00005c  2874              CMP      r0,#0x74
00005e  d02d              BEQ      |L1.188|
000060  2875              CMP      r0,#0x75
000062  d021              BEQ      |L1.168|
000064  2876              CMP      r0,#0x76
000066  d02f              BEQ      |L1.200|
                  |L1.104|
;;;583                    case 'm':
;;;584                    case 'M':   // MAC address
;;;585                        insert_string = (uint8_t *)info_get_mac();
;;;586                        break;
;;;587    
;;;588                    case 'u':
;;;589                    case 'U':   // UUID
;;;590                        insert_string = (uint8_t *)info_get_unique_id();
;;;591                        break;
;;;592    
;;;593                    case 'b':
;;;594                    case 'B':   // Board ID
;;;595                        insert_string = (uint8_t *)info_get_board_id();
;;;596                        break;
;;;597    
;;;598                    case 'h':
;;;599                    case 'H':   // Host ID
;;;600                        insert_string = (uint8_t *)info_get_host_id();
;;;601                        break;
;;;602    
;;;603                    case 't':
;;;604                    case 'T':   // Target ID
;;;605                        insert_string = (uint8_t *)info_get_target_id();
;;;606                        break;
;;;607    
;;;608                    case 'd':
;;;609                    case 'D':   // HIC
;;;610                        insert_string = (uint8_t *)info_get_hic_id();
;;;611                        break;
;;;612    
;;;613                    case 'v':
;;;614                    case 'V':   // Firmware version
;;;615                        insert_string = (uint8_t *)info_get_version();
;;;616                        break;
;;;617    
;;;618                    case 'r':
;;;619                    case 'R':   // URL replacement
;;;620                        insert_string = (uint8_t *)get_daplink_target_url();
;;;621                        break;
;;;622    
;;;623                    default:
;;;624                        insert_string = (uint8_t *)"ERROR";
000068  a520              ADR      r5,|L1.236|
                  |L1.106|
;;;625                        break;
;;;626                }
;;;627    
;;;628                // Remove strip_count characters from the start of buf and then insert
;;;629                // insert_string at the new start of buf.
;;;630                uint32_t buf_len = strlen((const char *)buf);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       strlen
000070  4607              MOV      r7,r0
;;;631                uint32_t str_len = strlen((const char *)insert_string);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       strlen
000078  4606              MOV      r6,r0
;;;632                //buffer overflow check on insert
;;;633                if( (buf + str_len + buf_len - 2) < (orig_buf+bufsize)){
00007a  19a0              ADDS     r0,r4,r6
00007c  19c1              ADDS     r1,r0,r7
00007e  eb080209          ADD      r2,r8,r9
000082  1e89              SUBS     r1,r1,#2
000084  4291              CMP      r1,r2
000086  d22b              BCS      |L1.224|
;;;634                    // push out string
;;;635                    memmove(buf + str_len, buf + 2, buf_len - 2);
000088  1eba              SUBS     r2,r7,#2
00008a  1ca1              ADDS     r1,r4,#2
00008c  f7fffffe          BL       __aeabi_memmove
;;;636                    // insert
;;;637                    memcpy(buf, insert_string, str_len);
000090  4632              MOV      r2,r6
000092  4629              MOV      r1,r5
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       __aeabi_memcpy
;;;638                }else{
;;;639                    //stop the string expansion and leave as it is
;;;640                    buf += buf_len;
;;;641                    break;
;;;642                }
;;;643    
;;;644            }
;;;645        } while (*buf != '\0');
00009a  7820              LDRB     r0,[r4,#0]
00009c  2800              CMP      r0,#0                 ;637
00009e  d1b6              BNE      |L1.14|
0000a0  e01f              B        |L1.226|
                  |L1.162|
0000a2  f7fffffe          BL       info_get_mac
0000a6  e001              B        |L1.172|
                  |L1.168|
0000a8  f7fffffe          BL       info_get_unique_id
                  |L1.172|
0000ac  4605              MOV      r5,r0                 ;585
0000ae  e7dc              B        |L1.106|
                  |L1.176|
0000b0  f7fffffe          BL       info_get_board_id
0000b4  e7fa              B        |L1.172|
                  |L1.182|
0000b6  f7fffffe          BL       info_get_host_id
0000ba  e7f7              B        |L1.172|
                  |L1.188|
0000bc  f7fffffe          BL       info_get_target_id
0000c0  e7f4              B        |L1.172|
                  |L1.194|
0000c2  f7fffffe          BL       info_get_hic_id
0000c6  e7f1              B        |L1.172|
                  |L1.200|
0000c8  f7fffffe          BL       info_get_version
0000cc  e7ee              B        |L1.172|
                  |L1.206|
0000ce  4809              LDR      r0,|L1.244|
0000d0  f890002a          LDRB     r0,[r0,#0x2a]         ;616  ; g_board_info
0000d4  b110              CBZ      r0,|L1.220|
0000d6  4d07              LDR      r5,|L1.244|
0000d8  352a              ADDS     r5,r5,#0x2a           ;616
0000da  e7c6              B        |L1.106|
                  |L1.220|
0000dc  a506              ADR      r5,|L1.248|
0000de  e7c4              B        |L1.106|
                  |L1.224|
0000e0  443c              ADD      r4,r4,r7              ;640
                  |L1.226|
;;;646    
;;;647        return (buf - orig_buf);
0000e2  eba40008          SUB      r0,r4,r8
;;;648    }
0000e6  e8bd87f0          POP      {r4-r10,pc}
;;;649    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L1.236|
0000ec  4552524f          DCB      "ERROR",0
0000f0  5200    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L1.244|
                          DCD      g_board_info
                  |L1.248|
0000f8  68747470          DCB      "https://mbed.org/device/?code=@U?version=@V?target_id=@"
0000fc  733a2f2f
000100  6d626564
000104  2e6f7267
000108  2f646576
00010c  6963652f
000110  3f636f64
000114  653d4055
000118  3f766572
00011c  73696f6e
000120  3d40563f
000124  74617267
000128  65745f69
00012c  643d40  
00012f  5400              DCB      "T",0
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0

                          AREA ||i.get_file_size||, CODE, READONLY, ALIGN=2

                  get_file_size PROC
;;;317    // The file data must be null terminated for this to work correctly.
;;;318    static uint32_t get_file_size(vfs_read_cb_t read_func)
000000  4603              MOV      r3,r0
;;;319    {
;;;320        // Determine size of the file by faking a read
;;;321        return read_func(0, file_buffer, 1);
000002  2201              MOVS     r2,#1
000004  4901              LDR      r1,|L2.12|
000006  2000              MOVS     r0,#0
000008  4718              BX       r3
;;;322    }
;;;323    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.read_file_assert_txt||, CODE, READONLY, ALIGN=2

                  read_file_assert_txt PROC
;;;393    // File callback to be used with vfs_add_file to return file contents
;;;394    static uint32_t read_file_assert_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;395    {
000004  460c              MOV      r4,r1
;;;396        uint32_t pos;
;;;397        const char *source_str;
;;;398        char *buf = (char *)data;
;;;399        uint32_t * hexdumps = 0;
000006  2100              MOVS     r1,#0
;;;400        uint8_t valid_hexdumps = 0;
;;;401        uint8_t index = 0;
000008  460e              MOV      r6,r1
00000a  9100              STR      r1,[sp,#0]            ;395
00000c  b110              CBZ      r0,|L3.20|
;;;402    
;;;403        if (sector_offset != 0) {
;;;404            return 0;
00000e  2000              MOVS     r0,#0
                  |L3.16|
;;;405        }
;;;406    
;;;407        pos = 0;
;;;408    
;;;409        if (ASSERT_SOURCE_BL == assert_source) {
;;;410            source_str = "Bootloader";
;;;411        } else if (ASSERT_SOURCE_APP == assert_source) {
;;;412            source_str = "Application";
;;;413        } else {
;;;414            source_str = 0;
;;;415        }
;;;416    
;;;417        pos += util_write_string(buf + pos, "Assert\r\n");
;;;418        pos += util_write_string(buf + pos, "File: ");
;;;419        pos += util_write_string(buf + pos, assert_buf);
;;;420        pos += util_write_string(buf + pos, "\r\n");
;;;421        pos += util_write_string(buf + pos, "Line: ");
;;;422        pos += util_write_uint32(buf + pos, assert_line);
;;;423        pos += util_write_string(buf + pos, "\r\n");
;;;424    
;;;425        if (source_str != 0) {
;;;426            pos += util_write_string(buf + pos, "Source: ");
;;;427            pos += util_write_string(buf + pos, source_str);
;;;428            pos += util_write_string(buf + pos, "\r\n");
;;;429        }
;;;430    
;;;431        valid_hexdumps = config_ram_get_hexdumps(&hexdumps);
;;;432        if ((valid_hexdumps > 0) && (hexdumps != 0)) {
;;;433            //print hexdumps
;;;434            pos += util_write_string(buf + pos, "Hexdumps\r\n");
;;;435            while ((index < valid_hexdumps) && ((pos + 10) < VFS_SECTOR_SIZE)) { //hexdumps + newline is always 10 characters
;;;436                pos += util_write_hex32(buf + pos, hexdumps[index++]);
;;;437                pos += util_write_string(buf + pos, "\r\n");
;;;438            }
;;;439        }
;;;440    
;;;441        return pos;
;;;442    }
000010  e8bd83f8          POP      {r3-r9,pc}
                  |L3.20|
000014  f8df80c8          LDR      r8,|L3.224|
000018  f8980000          LDRB     r0,[r8,#0]            ;409  ; assert_source
00001c  2801              CMP      r0,#1                 ;409
00001e  d045              BEQ      |L3.172|
000020  2802              CMP      r0,#2                 ;411
000022  d045              BEQ      |L3.176|
000024  2700              MOVS     r7,#0                 ;414
                  |L3.38|
000026  4620              MOV      r0,r4                 ;417
000028  a12e              ADR      r1,|L3.228|
00002a  f7fffffe          BL       util_write_string
00002e  4605              MOV      r5,r0                 ;417
000030  1960              ADDS     r0,r4,r5              ;418
000032  a12f              ADR      r1,|L3.240|
000034  f7fffffe          BL       util_write_string
000038  4405              ADD      r5,r5,r0              ;418
00003a  1960              ADDS     r0,r4,r5              ;419
00003c  492e              LDR      r1,|L3.248|
00003e  f7fffffe          BL       util_write_string
000042  4405              ADD      r5,r5,r0              ;419
000044  1960              ADDS     r0,r4,r5              ;420
000046  a12d              ADR      r1,|L3.252|
000048  f7fffffe          BL       util_write_string
00004c  4405              ADD      r5,r5,r0              ;420
00004e  1960              ADDS     r0,r4,r5              ;421
000050  a12b              ADR      r1,|L3.256|
000052  f7fffffe          BL       util_write_string
000056  4405              ADD      r5,r5,r0              ;421
000058  1960              ADDS     r0,r4,r5              ;422
00005a  f8b81002          LDRH     r1,[r8,#2]            ;422  ; assert_line
00005e  f7fffffe          BL       util_write_uint32
000062  4405              ADD      r5,r5,r0              ;422
000064  1960              ADDS     r0,r4,r5              ;423
000066  a125              ADR      r1,|L3.252|
000068  f7fffffe          BL       util_write_string
00006c  4405              ADD      r5,r5,r0              ;423
00006e  b177              CBZ      r7,|L3.142|
000070  1960              ADDS     r0,r4,r5              ;426
000072  a125              ADR      r1,|L3.264|
000074  f7fffffe          BL       util_write_string
000078  4405              ADD      r5,r5,r0              ;426
00007a  1960              ADDS     r0,r4,r5              ;427
00007c  4639              MOV      r1,r7                 ;427
00007e  f7fffffe          BL       util_write_string
000082  4405              ADD      r5,r5,r0              ;427
000084  1960              ADDS     r0,r4,r5              ;428
000086  a11d              ADR      r1,|L3.252|
000088  f7fffffe          BL       util_write_string
00008c  4405              ADD      r5,r5,r0              ;428
                  |L3.142|
00008e  4668              MOV      r0,sp                 ;431
000090  f7fffffe          BL       config_ram_get_hexdumps
000094  0007              MOVS     r7,r0                 ;431
000096  d021              BEQ      |L3.220|
000098  9800              LDR      r0,[sp,#0]            ;432
00009a  b1f8              CBZ      r0,|L3.220|
00009c  1960              ADDS     r0,r4,r5              ;434
00009e  a11d              ADR      r1,|L3.276|
0000a0  f7fffffe          BL       util_write_string
0000a4  4405              ADD      r5,r5,r0              ;434
0000a6  f44f7800          MOV      r8,#0x200             ;435
0000aa  e011              B        |L3.208|
                  |L3.172|
0000ac  a71c              ADR      r7,|L3.288|
0000ae  e7ba              B        |L3.38|
                  |L3.176|
0000b0  a71e              ADR      r7,|L3.300|
0000b2  e7b8              B        |L3.38|
                  |L3.180|
0000b4  9800              LDR      r0,[sp,#0]            ;436
0000b6  f8501026          LDR      r1,[r0,r6,LSL #2]     ;436
0000ba  1c76              ADDS     r6,r6,#1              ;436
0000bc  b2f6              UXTB     r6,r6                 ;436
0000be  1960              ADDS     r0,r4,r5              ;436
0000c0  f7fffffe          BL       util_write_hex32
0000c4  4405              ADD      r5,r5,r0              ;436
0000c6  1960              ADDS     r0,r4,r5              ;437
0000c8  a10c              ADR      r1,|L3.252|
0000ca  f7fffffe          BL       util_write_string
0000ce  4405              ADD      r5,r5,r0              ;437
                  |L3.208|
0000d0  42be              CMP      r6,r7                 ;435
0000d2  d203              BCS      |L3.220|
0000d4  f105000a          ADD      r0,r5,#0xa            ;435
0000d8  4540              CMP      r0,r8                 ;435
0000da  d3eb              BCC      |L3.180|
                  |L3.220|
0000dc  4628              MOV      r0,r5                 ;441
0000de  e797              B        |L3.16|
;;;443    
                          ENDP

                  |L3.224|
                          DCD      ||.data||
                  |L3.228|
0000e4  41737365          DCB      "Assert\r\n",0
0000e8  72740d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L3.240|
0000f0  46696c65          DCB      "File: ",0
0000f4  3a2000  
0000f7  00                DCB      0
                  |L3.248|
                          DCD      ||.bss||+0x200
                  |L3.252|
0000fc  0d0a00            DCB      "\r\n",0
0000ff  00                DCB      0
                  |L3.256|
000100  4c696e65          DCB      "Line: ",0
000104  3a2000  
000107  00                DCB      0
                  |L3.264|
000108  536f7572          DCB      "Source: ",0
00010c  63653a20
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L3.276|
000114  48657864          DCB      "Hexdumps\r\n",0
000118  756d7073
00011c  0d0a00  
00011f  00                DCB      0
                  |L3.288|
000120  426f6f74          DCB      "Bootloader",0
000124  6c6f6164
000128  657200  
00012b  00                DCB      0
                  |L3.300|
00012c  4170706c          DCB      "Application",0
000130  69636174
000134  696f6e00

                          AREA ||i.read_file_details_txt||, CODE, READONLY, ALIGN=1

                  read_file_details_txt PROC
;;;334    // File callback to be used with vfs_add_file to return file contents
;;;335    static uint32_t read_file_details_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  460a              MOV      r2,r1
;;;336    {
000002  b108              CBZ      r0,|L4.8|
;;;337    
;;;338        if (sector_offset != 0) {
;;;339            return 0;
000004  2000              MOVS     r0,#0
;;;340        }
;;;341    
;;;342        return update_details_txt_file(data, VFS_SECTOR_SIZE);
;;;343    }
000006  4770              BX       lr
                  |L4.8|
000008  f44f7100          MOV      r1,#0x200             ;342
00000c  4610              MOV      r0,r2                 ;342
00000e  f7ffbffe          B.W      update_details_txt_file
;;;344    
                          ENDP


                          AREA ||i.read_file_fail_txt||, CODE, READONLY, ALIGN=2

                  read_file_fail_txt PROC
;;;356    // File callback to be used with vfs_add_file to return file contents
;;;357    static uint32_t read_file_fail_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;358    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;359        uint32_t size = 0;
;;;360        char *buf = (char *)data;
;;;361        error_t status = vfs_mngr_get_transfer_status();
000008  f7fffffe          BL       vfs_mngr_get_transfer_status
00000c  4606              MOV      r6,r0
;;;362        const char *contents = error_get_string(status);
00000e  f7fffffe          BL       error_get_string
000012  4607              MOV      r7,r0
;;;363        error_type_t type = error_get_type(status);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       error_get_type
00001a  4606              MOV      r6,r0
;;;364    
;;;365        if (sector_offset != 0) {
00001c  b114              CBZ      r4,|L5.36|
;;;366            return 0;
00001e  2000              MOVS     r0,#0
                  |L5.32|
;;;367        }
;;;368    
;;;369        size += util_write_string(buf + size, error_prefix);
;;;370        size += util_write_string(buf + size, contents);
;;;371        size += util_write_string(buf + size, "\r\n");
;;;372        size += util_write_string(buf + size, error_type_prefix);
;;;373    
;;;374        // Write each applicable error type, separated by commas
;;;375        int index = 0;
;;;376        bool first = true;
;;;377        while (type && index < ARRAY_SIZE(error_type_names)) {
;;;378            if (!first) {
;;;379                size += util_write_string(buf + size, ", ");
;;;380            }
;;;381            if (type & 1) {
;;;382                size += util_write_string(buf + size, error_type_names[index]);
;;;383                first = false;
;;;384            }
;;;385            index++;
;;;386            type >>= 1;
;;;387        }
;;;388    
;;;389        size += util_write_string(buf + size, "\r\n");
;;;390        return size;
;;;391    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L5.36|
000024  4628              MOV      r0,r5                 ;369
000026  491b              LDR      r1,|L5.148|
000028  f7fffffe          BL       util_write_string
00002c  4604              MOV      r4,r0                 ;369
00002e  1928              ADDS     r0,r5,r4              ;370
000030  4639              MOV      r1,r7                 ;370
000032  f7fffffe          BL       util_write_string
000036  4404              ADD      r4,r4,r0              ;370
000038  1928              ADDS     r0,r5,r4              ;371
00003a  a117              ADR      r1,|L5.152|
00003c  f7fffffe          BL       util_write_string
000040  4914              LDR      r1,|L5.148|
000042  4404              ADD      r4,r4,r0              ;371
000044  1928              ADDS     r0,r5,r4              ;372
000046  1fc9              SUBS     r1,r1,#7              ;372
000048  f7fffffe          BL       util_write_string
00004c  4404              ADD      r4,r4,r0              ;372
00004e  2700              MOVS     r7,#0                 ;375
000050  f04f0801          MOV      r8,#1                 ;376
000054  f8df9044          LDR      r9,|L5.156|
000058  e013              B        |L5.130|
                  |L5.90|
00005a  f1b80f00          CMP      r8,#0                 ;378
00005e  d104              BNE      |L5.106|
000060  1928              ADDS     r0,r5,r4              ;379
000062  a10f              ADR      r1,|L5.160|
000064  f7fffffe          BL       util_write_string
000068  4404              ADD      r4,r4,r0              ;379
                  |L5.106|
00006a  07f0              LSLS     r0,r6,#31             ;381
00006c  d007              BEQ      |L5.126|
00006e  f8591027          LDR      r1,[r9,r7,LSL #2]     ;382
000072  1928              ADDS     r0,r5,r4              ;382
000074  f7fffffe          BL       util_write_string
000078  4404              ADD      r4,r4,r0              ;382
00007a  f04f0800          MOV      r8,#0                 ;383
                  |L5.126|
00007e  0876              LSRS     r6,r6,#1              ;386
000080  1c7f              ADDS     r7,r7,#1              ;386
                  |L5.130|
000082  b10e              CBZ      r6,|L5.136|
000084  2f05              CMP      r7,#5                 ;377
000086  d3e8              BCC      |L5.90|
                  |L5.136|
000088  1928              ADDS     r0,r5,r4              ;389
00008a  a103              ADR      r1,|L5.152|
00008c  f7fffffe          BL       util_write_string
000090  4420              ADD      r0,r0,r4              ;389
000092  e7c5              B        |L5.32|
;;;392    
                          ENDP

                  |L5.148|
                          DCD      ||.constdata||+0x7
                  |L5.152|
000098  0d0a00            DCB      "\r\n",0
00009b  00                DCB      0
                  |L5.156|
                          DCD      ||.constdata||+0x180
                  |L5.160|
0000a0  2c2000            DCB      ", ",0
0000a3  00                DCB      0

                          AREA ||i.read_file_mbed_htm||, CODE, READONLY, ALIGN=2

                  read_file_mbed_htm PROC
;;;324    // File callback to be used with vfs_add_file to return file contents
;;;325    static uint32_t read_file_mbed_htm(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b570              PUSH     {r4-r6,lr}
;;;326    {
000002  460c              MOV      r4,r1
000004  b108              CBZ      r0,|L6.10|
;;;327        if (sector_offset != 0) {
;;;328            return 0;
000006  2000              MOVS     r0,#0
;;;329        }
;;;330    
;;;331        return update_html_file(data, VFS_SECTOR_SIZE);
;;;332    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  f44f7500          MOV      r5,#0x200             ;331
00000e  4629              MOV      r1,r5                 ;331
000010  4620              MOV      r0,r4                 ;331
000012  f7fffffe          BL       __aeabi_memclr
000016  4807              LDR      r0,|L6.52|
000018  f7fffffe          BL       strlen
00001c  4602              MOV      r2,r0                 ;331
00001e  4905              LDR      r1,|L6.52|
000020  4620              MOV      r0,r4                 ;331
000022  f7fffffe          BL       __aeabi_memcpy
000026  4629              MOV      r1,r5                 ;331
000028  4620              MOV      r0,r4                 ;331
00002a  e8bd4070          POP      {r4-r6,lr}            ;331
00002e  f7ffbffe          B.W      expand_info
;;;333    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      ||.constdata||+0xf

                          AREA ||i.read_file_need_bl_txt||, CODE, READONLY, ALIGN=2

                  read_file_need_bl_txt PROC
;;;444    // File callback to be used with vfs_add_file to return file contents
;;;445    static uint32_t read_file_need_bl_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;446    {
;;;447        const char *contents = "A bootloader update was started but unable to complete.\r\n"
000004  4d08              LDR      r5,|L7.40|
000006  4606              MOV      r6,r0                 ;446
000008  460f              MOV      r7,r1                 ;446
;;;448                               "Reload the bootloader to fix this error message.\r\n";
;;;449        uint32_t size = strlen(contents);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       strlen
000010  4604              MOV      r4,r0
;;;450    
;;;451        if (sector_offset != 0) {
000012  b116              CBZ      r6,|L7.26|
;;;452            return 0;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;453        }
;;;454    
;;;455        memcpy(data, contents, size);
;;;456        return size;
;;;457    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  4602              MOV      r2,r0                 ;455
00001c  4629              MOV      r1,r5                 ;455
00001e  4638              MOV      r0,r7                 ;455
000020  f7fffffe          BL       __aeabi_memcpy
000024  4620              MOV      r0,r4                 ;456
000026  e7f6              B        |L7.22|
;;;458    
                          ENDP

                  |L7.40|
                          DCD      ||.conststring||+0xd0

                          AREA ||i.update_details_txt_file||, CODE, READONLY, ALIGN=2

                  update_details_txt_file PROC
;;;469    
;;;470    static uint32_t update_details_txt_file(uint8_t *data, uint32_t datasize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;471    {
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;472        uint32_t pos=0;
;;;473        const char *mode_str;
;;;474    
;;;475        char *buf = (char *)data;
;;;476    
;;;477        //Needed by expand_info strlen
;;;478        memset(buf, 0, datasize);
000008  f7fffffe          BL       __aeabi_memclr
;;;479    
;;;480        pos += util_write_string(buf + pos, "# DAPLink Firmware - see https://mbed.com/daplink\r\n");
00000c  4620              MOV      r0,r4
00000e  a18c              ADR      r1,|L8.576|
000010  f7fffffe          BL       util_write_string
000014  4605              MOV      r5,r0
;;;481        // Unique ID
;;;482        pos += util_write_string(buf + pos, "Unique ID: @U\r\n");
000016  1960              ADDS     r0,r4,r5
000018  a196              ADR      r1,|L8.628|
00001a  f7fffffe          BL       util_write_string
00001e  4405              ADD      r5,r5,r0
;;;483        // HIC ID
;;;484        pos += util_write_string(buf + pos, "HIC ID: @D\r\n");
000020  1960              ADDS     r0,r4,r5
000022  a198              ADR      r1,|L8.644|
000024  f7fffffe          BL       util_write_string
000028  4405              ADD      r5,r5,r0
;;;485        // Settings
;;;486        pos += util_write_string(buf + pos, "Auto Reset: ");
00002a  1960              ADDS     r0,r4,r5
00002c  a199              ADR      r1,|L8.660|
00002e  f7fffffe          BL       util_write_string
000032  4405              ADD      r5,r5,r0
;;;487        pos += util_write_string(buf + pos, config_get_auto_rst() ? "1" : "0");
000034  f7fffffe          BL       config_get_auto_rst
000038  b108              CBZ      r0,|L8.62|
00003a  a19a              ADR      r1,|L8.676|
00003c  e000              B        |L8.64|
                  |L8.62|
00003e  a19a              ADR      r1,|L8.680|
                  |L8.64|
000040  1960              ADDS     r0,r4,r5
000042  f7fffffe          BL       util_write_string
000046  4405              ADD      r5,r5,r0
;;;488        pos += util_write_string(buf + pos, "\r\n");
000048  1960              ADDS     r0,r4,r5
00004a  a198              ADR      r1,|L8.684|
00004c  f7fffffe          BL       util_write_string
000050  4405              ADD      r5,r5,r0
;;;489        pos += util_write_string(buf + pos, "Automation allowed: ");
000052  1960              ADDS     r0,r4,r5
000054  a196              ADR      r1,|L8.688|
000056  f7fffffe          BL       util_write_string
00005a  4405              ADD      r5,r5,r0
;;;490        pos += util_write_string(buf + pos, config_get_automation_allowed() ? "1" : "0");
00005c  f7fffffe          BL       config_get_automation_allowed
000060  b108              CBZ      r0,|L8.102|
000062  a190              ADR      r1,|L8.676|
000064  e000              B        |L8.104|
                  |L8.102|
000066  a190              ADR      r1,|L8.680|
                  |L8.104|
000068  1960              ADDS     r0,r4,r5
00006a  f7fffffe          BL       util_write_string
00006e  4405              ADD      r5,r5,r0
;;;491        pos += util_write_string(buf + pos, "\r\n");
000070  1960              ADDS     r0,r4,r5
000072  a18e              ADR      r1,|L8.684|
000074  f7fffffe          BL       util_write_string
000078  4405              ADD      r5,r5,r0
;;;492        pos += util_write_string(buf + pos, "Overflow detection: ");
00007a  1960              ADDS     r0,r4,r5
00007c  a192              ADR      r1,|L8.712|
00007e  f7fffffe          BL       util_write_string
000082  4405              ADD      r5,r5,r0
;;;493        pos += util_write_string(buf + pos, config_get_overflow_detect() ? "1" : "0");
000084  f7fffffe          BL       config_get_overflow_detect
000088  b108              CBZ      r0,|L8.142|
00008a  a186              ADR      r1,|L8.676|
00008c  e000              B        |L8.144|
                  |L8.142|
00008e  a186              ADR      r1,|L8.680|
                  |L8.144|
000090  1960              ADDS     r0,r4,r5
000092  f7fffffe          BL       util_write_string
000096  4405              ADD      r5,r5,r0
;;;494        pos += util_write_string(buf + pos, "\r\n");
000098  1960              ADDS     r0,r4,r5
00009a  a184              ADR      r1,|L8.684|
00009c  f7fffffe          BL       util_write_string
0000a0  4405              ADD      r5,r5,r0
;;;495        pos += util_write_string(buf + pos, "Page erasing: ");
0000a2  1960              ADDS     r0,r4,r5
0000a4  a18e              ADR      r1,|L8.736|
0000a6  f7fffffe          BL       util_write_string
0000aa  4405              ADD      r5,r5,r0
;;;496        pos += util_write_string(buf + pos, config_ram_get_page_erase() ? "1" : "0");
0000ac  f7fffffe          BL       config_ram_get_page_erase
0000b0  b108              CBZ      r0,|L8.182|
0000b2  a17c              ADR      r1,|L8.676|
0000b4  e000              B        |L8.184|
                  |L8.182|
0000b6  a17c              ADR      r1,|L8.680|
                  |L8.184|
0000b8  1960              ADDS     r0,r4,r5
0000ba  f7fffffe          BL       util_write_string
0000be  4405              ADD      r5,r5,r0
;;;497        pos += util_write_string(buf + pos, "\r\n");
0000c0  1960              ADDS     r0,r4,r5
0000c2  a17a              ADR      r1,|L8.684|
0000c4  f7fffffe          BL       util_write_string
0000c8  4405              ADD      r5,r5,r0
;;;498        // Current mode
;;;499        mode_str = daplink_is_bootloader() ? "Bootloader" : "Interface";
0000ca  f7fffffe          BL       daplink_is_bootloader
0000ce  b108              CBZ      r0,|L8.212|
0000d0  a687              ADR      r6,|L8.752|
0000d2  e000              B        |L8.214|
                  |L8.212|
0000d4  a689              ADR      r6,|L8.764|
                  |L8.214|
;;;500        pos += util_write_string(buf + pos, "Daplink Mode: ");
0000d6  1960              ADDS     r0,r4,r5
0000d8  a18b              ADR      r1,|L8.776|
0000da  f7fffffe          BL       util_write_string
0000de  4405              ADD      r5,r5,r0
;;;501        pos += util_write_string(buf + pos, mode_str);
0000e0  1960              ADDS     r0,r4,r5
0000e2  4631              MOV      r1,r6
0000e4  f7fffffe          BL       util_write_string
0000e8  4405              ADD      r5,r5,r0
;;;502        pos += util_write_string(buf + pos, "\r\n");
0000ea  1960              ADDS     r0,r4,r5
0000ec  a16f              ADR      r1,|L8.684|
0000ee  f7fffffe          BL       util_write_string
0000f2  4405              ADD      r5,r5,r0
;;;503        // Current build's version
;;;504        pos += util_write_string(buf + pos, mode_str);
0000f4  1960              ADDS     r0,r4,r5
0000f6  4631              MOV      r1,r6
0000f8  f7fffffe          BL       util_write_string
0000fc  4405              ADD      r5,r5,r0
;;;505        pos += util_write_string(buf + pos, " Version: @V\r\n");
0000fe  1960              ADDS     r0,r4,r5
000100  a185              ADR      r1,|L8.792|
000102  f7fffffe          BL       util_write_string
000106  4405              ADD      r5,r5,r0
;;;506    
;;;507        // Other builds version (bl or if)
;;;508        if (!daplink_is_bootloader() && info_get_bootloader_present()) {
000108  f7fffffe          BL       daplink_is_bootloader
00010c  b9a0              CBNZ     r0,|L8.312|
00010e  f7fffffe          BL       info_get_bootloader_present
000112  b188              CBZ      r0,|L8.312|
;;;509            pos += util_write_string(buf + pos, "Bootloader Version: ");
000114  1960              ADDS     r0,r4,r5
000116  a184              ADR      r1,|L8.808|
000118  f7fffffe          BL       util_write_string
00011c  4405              ADD      r5,r5,r0
;;;510            pos += util_write_uint32_zp(buf + pos, info_get_bootloader_version(), 4);
00011e  f7fffffe          BL       info_get_bootloader_version
000122  4601              MOV      r1,r0
000124  1960              ADDS     r0,r4,r5
000126  2204              MOVS     r2,#4
000128  f7fffffe          BL       util_write_uint32_zp
00012c  4405              ADD      r5,r5,r0
;;;511            pos += util_write_string(buf + pos, "\r\n");
00012e  1960              ADDS     r0,r4,r5
000130  a15e              ADR      r1,|L8.684|
000132  f7fffffe          BL       util_write_string
000136  4405              ADD      r5,r5,r0
                  |L8.312|
;;;512        }
;;;513    
;;;514        if (!daplink_is_interface() && info_get_interface_present()) {
000138  f7fffffe          BL       daplink_is_interface
00013c  b9a0              CBNZ     r0,|L8.360|
00013e  f7fffffe          BL       info_get_interface_present
000142  b188              CBZ      r0,|L8.360|
;;;515            pos += util_write_string(buf + pos, "Interface Version: ");
000144  1960              ADDS     r0,r4,r5
000146  a17e              ADR      r1,|L8.832|
000148  f7fffffe          BL       util_write_string
00014c  4405              ADD      r5,r5,r0
;;;516            pos += util_write_uint32_zp(buf + pos, info_get_interface_version(), 4);
00014e  f7fffffe          BL       info_get_interface_version
000152  4601              MOV      r1,r0
000154  1960              ADDS     r0,r4,r5
000156  2204              MOVS     r2,#4
000158  f7fffffe          BL       util_write_uint32_zp
00015c  4405              ADD      r5,r5,r0
;;;517            pos += util_write_string(buf + pos, "\r\n");
00015e  1960              ADDS     r0,r4,r5
000160  a152              ADR      r1,|L8.684|
000162  f7fffffe          BL       util_write_string
000166  4405              ADD      r5,r5,r0
                  |L8.360|
;;;518        }
;;;519    
;;;520        // GIT sha
;;;521        pos += util_write_string(buf + pos, "Git SHA: ");
000168  1960              ADDS     r0,r4,r5
00016a  a17a              ADR      r1,|L8.852|
00016c  f7fffffe          BL       util_write_string
000170  4405              ADD      r5,r5,r0
;;;522        pos += util_write_string(buf + pos, GIT_COMMIT_SHA);
000172  1960              ADDS     r0,r4,r5
000174  a17a              ADR      r1,|L8.864|
000176  f7fffffe          BL       util_write_string
00017a  4405              ADD      r5,r5,r0
;;;523        pos += util_write_string(buf + pos, "\r\n");
00017c  1960              ADDS     r0,r4,r5
00017e  a14b              ADR      r1,|L8.684|
000180  f7fffffe          BL       util_write_string
000184  4405              ADD      r5,r5,r0
;;;524        // Local modifications when making the build
;;;525        pos += util_write_string(buf + pos, "Local Mods: ");
000186  1960              ADDS     r0,r4,r5
000188  a180              ADR      r1,|L8.908|
00018a  f7fffffe          BL       util_write_string
00018e  4405              ADD      r5,r5,r0
;;;526        pos += util_write_uint32(buf + pos, GIT_LOCAL_MODS);
000190  1960              ADDS     r0,r4,r5
000192  2100              MOVS     r1,#0
000194  f7fffffe          BL       util_write_uint32
000198  4405              ADD      r5,r5,r0
;;;527        pos += util_write_string(buf + pos, "\r\n");
00019a  1960              ADDS     r0,r4,r5
00019c  a143              ADR      r1,|L8.684|
00019e  f7fffffe          BL       util_write_string
0001a2  4405              ADD      r5,r5,r0
;;;528        // Supported USB endpoints
;;;529        pos += util_write_string(buf + pos, "USB Interfaces: ");
0001a4  1960              ADDS     r0,r4,r5
0001a6  a17d              ADR      r1,|L8.924|
0001a8  f7fffffe          BL       util_write_string
0001ac  4405              ADD      r5,r5,r0
;;;530    #ifdef MSC_ENDPOINT
;;;531        pos += util_write_string(buf + pos, "MSD");
0001ae  1960              ADDS     r0,r4,r5
0001b0  a17f              ADR      r1,|L8.944|
0001b2  f7fffffe          BL       util_write_string
0001b6  4405              ADD      r5,r5,r0
;;;532    #endif
;;;533    #ifdef CDC_ENDPOINT
;;;534        pos += util_write_string(buf + pos, ", CDC");
;;;535    #endif
;;;536    #ifdef HID_ENDPOINT
;;;537        pos += util_write_string(buf + pos, ", HID");
;;;538    #endif
;;;539    #if (WEBUSB_INTERFACE)
;;;540        pos += util_write_string(buf + pos, ", WebUSB");
;;;541    #endif
;;;542        pos += util_write_string(buf + pos, "\r\n");
0001b8  1960              ADDS     r0,r4,r5
0001ba  a13c              ADR      r1,|L8.684|
0001bc  f7fffffe          BL       util_write_string
0001c0  4405              ADD      r5,r5,r0
;;;543    
;;;544        // CRC of the bootloader (if there is one)
;;;545        if (info_get_bootloader_present()) {
0001c2  f7fffffe          BL       info_get_bootloader_present
0001c6  b180              CBZ      r0,|L8.490|
;;;546            pos += util_write_string(buf + pos, "Bootloader CRC: 0x");
0001c8  1960              ADDS     r0,r4,r5
0001ca  a17a              ADR      r1,|L8.948|
0001cc  f7fffffe          BL       util_write_string
0001d0  4405              ADD      r5,r5,r0
;;;547            pos += util_write_hex32(buf + pos, info_get_crc_bootloader());
0001d2  f7fffffe          BL       info_get_crc_bootloader
0001d6  4601              MOV      r1,r0
0001d8  1960              ADDS     r0,r4,r5
0001da  f7fffffe          BL       util_write_hex32
0001de  4405              ADD      r5,r5,r0
;;;548            pos += util_write_string(buf + pos, "\r\n");
0001e0  1960              ADDS     r0,r4,r5
0001e2  a132              ADR      r1,|L8.684|
0001e4  f7fffffe          BL       util_write_string
0001e8  4405              ADD      r5,r5,r0
                  |L8.490|
;;;549        }
;;;550    
;;;551        // CRC of the interface
;;;552        pos += util_write_string(buf + pos, "Interface CRC: 0x");
0001ea  1960              ADDS     r0,r4,r5
0001ec  a176              ADR      r1,|L8.968|
0001ee  f7fffffe          BL       util_write_string
0001f2  4405              ADD      r5,r5,r0
;;;553        pos += util_write_hex32(buf + pos, info_get_crc_interface());
0001f4  f7fffffe          BL       info_get_crc_interface
0001f8  4601              MOV      r1,r0
0001fa  1960              ADDS     r0,r4,r5
0001fc  f7fffffe          BL       util_write_hex32
000200  4405              ADD      r5,r5,r0
;;;554        pos += util_write_string(buf + pos, "\r\n");
000202  1960              ADDS     r0,r4,r5
000204  a129              ADR      r1,|L8.684|
000206  f7fffffe          BL       util_write_string
00020a  4405              ADD      r5,r5,r0
;;;555    
;;;556        // Number of remounts that have occurred
;;;557        pos += util_write_string(buf + pos, "Remount count: ");
00020c  1960              ADDS     r0,r4,r5
00020e  a173              ADR      r1,|L8.988|
000210  f7fffffe          BL       util_write_string
;;;558        pos += util_write_uint32(buf + pos, remount_count);
000214  4975              LDR      r1,|L8.1004|
000216  4405              ADD      r5,r5,r0              ;557
000218  1960              ADDS     r0,r4,r5
00021a  6849              LDR      r1,[r1,#4]  ; remount_count
00021c  f7fffffe          BL       util_write_uint32
000220  4405              ADD      r5,r5,r0
;;;559        pos += util_write_string(buf + pos, "\r\n");
000222  1960              ADDS     r0,r4,r5
000224  a121              ADR      r1,|L8.684|
000226  f7fffffe          BL       util_write_string
00022a  4428              ADD      r0,r0,r5
;;;560    
;;;561        //Target URL
;;;562        pos += util_write_string(buf + pos, "URL: @R\r\n");
00022c  4420              ADD      r0,r0,r4
00022e  a170              ADR      r1,|L8.1008|
000230  f7fffffe          BL       util_write_string
;;;563    
;;;564        return expand_info(data, datasize);
000234  4639              MOV      r1,r7
000236  4620              MOV      r0,r4
000238  e8bd41f0          POP      {r4-r8,lr}
00023c  f7ffbffe          B.W      expand_info
;;;565    }
;;;566    
                          ENDP

                  |L8.576|
000240  23204441          DCB      "# DAPLink Firmware - see https://mbed.com/daplink\r\n",0
000244  504c696e
000248  6b204669
00024c  726d7761
000250  7265202d
000254  20736565
000258  20687474
00025c  70733a2f
000260  2f6d6265
000264  642e636f
000268  6d2f6461
00026c  706c696e
000270  6b0d0a00
                  |L8.628|
000274  556e6971          DCB      "Unique ID: @U\r\n",0
000278  75652049
00027c  443a2040
000280  550d0a00
                  |L8.644|
000284  48494320          DCB      "HIC ID: @D\r\n",0
000288  49443a20
00028c  40440d0a
000290  00      
000291  00                DCB      0
000292  00                DCB      0
000293  00                DCB      0
                  |L8.660|
000294  4175746f          DCB      "Auto Reset: ",0
000298  20526573
00029c  65743a20
0002a0  00      
0002a1  00                DCB      0
0002a2  00                DCB      0
0002a3  00                DCB      0
                  |L8.676|
0002a4  3100              DCB      "1",0
0002a6  00                DCB      0
0002a7  00                DCB      0
                  |L8.680|
0002a8  3000              DCB      "0",0
0002aa  00                DCB      0
0002ab  00                DCB      0
                  |L8.684|
0002ac  0d0a00            DCB      "\r\n",0
0002af  00                DCB      0
                  |L8.688|
0002b0  4175746f          DCB      "Automation allowed: ",0
0002b4  6d617469
0002b8  6f6e2061
0002bc  6c6c6f77
0002c0  65643a20
0002c4  00      
0002c5  00                DCB      0
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L8.712|
0002c8  4f766572          DCB      "Overflow detection: ",0
0002cc  666c6f77
0002d0  20646574
0002d4  65637469
0002d8  6f6e3a20
0002dc  00      
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0
                  |L8.736|
0002e0  50616765          DCB      "Page erasing: ",0
0002e4  20657261
0002e8  73696e67
0002ec  3a2000  
0002ef  00                DCB      0
                  |L8.752|
0002f0  426f6f74          DCB      "Bootloader",0
0002f4  6c6f6164
0002f8  657200  
0002fb  00                DCB      0
                  |L8.764|
0002fc  496e7465          DCB      "Interface",0
000300  72666163
000304  6500    
000306  00                DCB      0
000307  00                DCB      0
                  |L8.776|
000308  4461706c          DCB      "Daplink Mode: ",0
00030c  696e6b20
000310  4d6f6465
000314  3a2000  
000317  00                DCB      0
                  |L8.792|
000318  20566572          DCB      " Version: @V\r\n",0
00031c  73696f6e
000320  3a204056
000324  0d0a00  
000327  00                DCB      0
                  |L8.808|
000328  426f6f74          DCB      "Bootloader Version: ",0
00032c  6c6f6164
000330  65722056
000334  65727369
000338  6f6e3a20
00033c  00      
00033d  00                DCB      0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L8.832|
000340  496e7465          DCB      "Interface Version: ",0
000344  72666163
000348  65205665
00034c  7273696f
000350  6e3a2000
                  |L8.852|
000354  47697420          DCB      "Git SHA: ",0
000358  5348413a
00035c  2000    
00035e  00                DCB      0
00035f  00                DCB      0
                  |L8.864|
000360  33303030          DCB      "30000496cbaf222d1b302d25baed72ed48ef200a",0
000364  30343936
000368  63626166
00036c  32323264
000370  31623330
000374  32643235
000378  62616564
00037c  37326564
000380  34386566
000384  32303061
000388  00      
000389  00                DCB      0
00038a  00                DCB      0
00038b  00                DCB      0
                  |L8.908|
00038c  4c6f6361          DCB      "Local Mods: ",0
000390  6c204d6f
000394  64733a20
000398  00      
000399  00                DCB      0
00039a  00                DCB      0
00039b  00                DCB      0
                  |L8.924|
00039c  55534220          DCB      "USB Interfaces: ",0
0003a0  496e7465
0003a4  72666163
0003a8  65733a20
0003ac  00      
0003ad  00                DCB      0
0003ae  00                DCB      0
0003af  00                DCB      0
                  |L8.944|
0003b0  4d534400          DCB      "MSD",0
                  |L8.948|
0003b4  426f6f74          DCB      "Bootloader CRC: 0x",0
0003b8  6c6f6164
0003bc  65722043
0003c0  52433a20
0003c4  307800  
0003c7  00                DCB      0
                  |L8.968|
0003c8  496e7465          DCB      "Interface CRC: 0x",0
0003cc  72666163
0003d0  65204352
0003d4  433a2030
0003d8  7800    
0003da  00                DCB      0
0003db  00                DCB      0
                  |L8.988|
0003dc  52656d6f          DCB      "Remount count: ",0
0003e0  756e7420
0003e4  636f756e
0003e8  743a2000
                  |L8.1004|
                          DCD      ||.data||
                  |L8.1008|
0003f0  55524c3a          DCB      "URL: @R\r\n",0
0003f4  2040520d
0003f8  0a00    
0003fa  00                DCB      0
0003fb  00                DCB      0

                          AREA ||i.vfs_user_build_filesystem||, CODE, READONLY, ALIGN=2

                  vfs_user_build_filesystem PROC
;;;136    
;;;137    void vfs_user_build_filesystem()
000000  b51c              PUSH     {r2-r4,lr}
000002  4c2f              LDR      r4,|L9.192|
000004  7fe0              LDRB     r0,[r4,#0x1f]  ; g_board_info
;;;138    {
000006  b110              CBZ      r0,|L9.14|
000008  f104001f          ADD      r0,r4,#0x1f
00000c  e000              B        |L9.16|
                  |L9.14|
00000e  a02d              ADR      r0,|L9.196|
                  |L9.16|
;;;139        uint32_t file_size;
;;;140        vfs_file_t file_handle;
;;;141        // Setup the filesystem based on target parameters
;;;142        vfs_init(get_daplink_drive_name(), VFS_DISK_SIZE);
000010  f04f6180          MOV      r1,#0x4000000
000014  f7fffffe          BL       vfs_init
;;;143        // MBED.HTM
;;;144        file_size = get_file_size(read_file_mbed_htm);
000018  482d              LDR      r0,|L9.208|
00001a  f7fffffe          BL       get_file_size
00001e  4603              MOV      r3,r0
000020  7d20              LDRB     r0,[r4,#0x14]  ; g_board_info
000022  b110              CBZ      r0,|L9.42|
000024  4826              LDR      r0,|L9.192|
000026  3014              ADDS     r0,r0,#0x14
000028  e000              B        |L9.44|
                  |L9.42|
00002a  a02a              ADR      r0,|L9.212|
                  |L9.44|
;;;145        vfs_create_file(get_daplink_url_name(), read_file_mbed_htm, 0, file_size);
00002c  2200              MOVS     r2,#0
00002e  4928              LDR      r1,|L9.208|
000030  f7fffffe          BL       vfs_create_file
;;;146        // DETAILS.TXT
;;;147        file_size = get_file_size(read_file_details_txt);
000034  482a              LDR      r0,|L9.224|
000036  f7fffffe          BL       get_file_size
00003a  4603              MOV      r3,r0
;;;148        vfs_create_file("DETAILS TXT", read_file_details_txt, 0, file_size);
00003c  2200              MOVS     r2,#0
00003e  4928              LDR      r1,|L9.224|
000040  a028              ADR      r0,|L9.228|
000042  f7fffffe          BL       vfs_create_file
;;;149    
;;;150        // FAIL.TXT
;;;151        if (vfs_mngr_get_transfer_status() != ERROR_SUCCESS) {
000046  f7fffffe          BL       vfs_mngr_get_transfer_status
00004a  b140              CBZ      r0,|L9.94|
;;;152            file_size = get_file_size(read_file_fail_txt);
00004c  4828              LDR      r0,|L9.240|
00004e  f7fffffe          BL       get_file_size
000052  4603              MOV      r3,r0
;;;153            vfs_create_file("FAIL    TXT", read_file_fail_txt, 0, file_size);
000054  2200              MOVS     r2,#0
000056  4926              LDR      r1,|L9.240|
000058  a026              ADR      r0,|L9.244|
00005a  f7fffffe          BL       vfs_create_file
                  |L9.94|
;;;154        }
;;;155    
;;;156        // ASSERT.TXT
;;;157        if (config_ram_get_assert(assert_buf, sizeof(assert_buf), &assert_line, &assert_source)) {
00005e  4b28              LDR      r3,|L9.256|
000060  2141              MOVS     r1,#0x41
000062  1c9a              ADDS     r2,r3,#2
000064  4827              LDR      r0,|L9.260|
000066  f7fffffe          BL       config_ram_get_assert
00006a  b158              CBZ      r0,|L9.132|
;;;158            file_size = get_file_size(read_file_assert_txt);
00006c  4826              LDR      r0,|L9.264|
00006e  f7fffffe          BL       get_file_size
000072  4603              MOV      r3,r0
;;;159            file_handle = vfs_create_file(assert_file, read_file_assert_txt, 0, file_size);
000074  2200              MOVS     r2,#0
000076  4924              LDR      r1,|L9.264|
000078  4824              LDR      r0,|L9.268|
00007a  f7fffffe          BL       vfs_create_file
;;;160            vfs_file_set_attr(file_handle, (vfs_file_attr_bit_t)0); // Remove read only attribute
00007e  2100              MOVS     r1,#0
000080  f7fffffe          BL       vfs_file_set_attr
                  |L9.132|
;;;161        }
;;;162    
;;;163        // NEED_BL.TXT
;;;164        volatile uint32_t bl_start = DAPLINK_ROM_BL_START; // Silence warnings about null pointer
000084  f04f6000          MOV      r0,#0x8000000
;;;165        volatile uint32_t if_start = DAPLINK_ROM_IF_START; // Silence warnings about null pointer
000088  9001              STR      r0,[sp,#4]
00008a  4821              LDR      r0,|L9.272|
;;;166    
;;;167        if (daplink_is_interface() &&
00008c  9000              STR      r0,[sp,#0]
00008e  f7fffffe          BL       daplink_is_interface
000092  2800              CMP      r0,#0
000094  d013              BEQ      |L9.190|
;;;168                (DAPLINK_ROM_BL_SIZE > 0) &&
;;;169                (0 == memcmp((void *)bl_start, (void *)if_start, DAPLINK_MIN_WRITE_SIZE))) {
000096  e9dd1000          LDRD     r1,r0,[sp,#0]
00009a  f44f6280          MOV      r2,#0x400
00009e  f7fffffe          BL       memcmp
0000a2  2800              CMP      r0,#0
0000a4  d10b              BNE      |L9.190|
;;;170            // If the bootloader contains a copy of the interfaces vector table
;;;171            // then an error occurred when updating so warn that the bootloader is
;;;172            // missing.
;;;173            file_size = get_file_size(read_file_need_bl_txt);
0000a6  481b              LDR      r0,|L9.276|
0000a8  f7fffffe          BL       get_file_size
;;;174            vfs_create_file("NEED_BL TXT", read_file_need_bl_txt, 0, file_size);
0000ac  b002              ADD      sp,sp,#8
0000ae  4603              MOV      r3,r0                 ;173
0000b0  e8bd4010          POP      {r4,lr}
0000b4  2200              MOVS     r2,#0
0000b6  4917              LDR      r1,|L9.276|
0000b8  a017              ADR      r0,|L9.280|
0000ba  f7ffbffe          B.W      vfs_create_file
                  |L9.190|
;;;175        }
;;;176    }
0000be  bd1c              POP      {r2-r4,pc}
;;;177    
                          ENDP

                  |L9.192|
                          DCD      g_board_info
                  |L9.196|
0000c4  4441504c          DCB      "DAPLINK    ",0
0000c8  494e4b20
0000cc  20202000
                  |L9.208|
                          DCD      read_file_mbed_htm
                  |L9.212|
0000d4  4d424544          DCB      "MBED    HTM",0
0000d8  20202020
0000dc  48544d00
                  |L9.224|
                          DCD      read_file_details_txt
                  |L9.228|
0000e4  44455441          DCB      "DETAILS TXT",0
0000e8  494c5320
0000ec  54585400
                  |L9.240|
                          DCD      read_file_fail_txt
                  |L9.244|
0000f4  4641494c          DCB      "FAIL    TXT",0
0000f8  20202020
0000fc  54585400
                  |L9.256|
                          DCD      ||.data||
                  |L9.260|
                          DCD      ||.bss||+0x200
                  |L9.264|
                          DCD      read_file_assert_txt
                  |L9.268|
                          DCD      ||.constdata||+0x103
                  |L9.272|
                          DCD      0x0800c000
                  |L9.276|
                          DCD      read_file_need_bl_txt
                  |L9.280|
000118  4e454544          DCB      "NEED_BL TXT",0
00011c  5f424c20
000120  54585400

                          AREA ||i.vfs_user_disconnecting||, CODE, READONLY, ALIGN=2

                  vfs_user_disconnecting PROC
;;;300    
;;;301    void vfs_user_disconnecting()
000000  b510              PUSH     {r4,lr}
;;;302    {
;;;303        // Reset if programming was successful  //TODO - move to flash layer
;;;304        if (daplink_is_bootloader() && (ERROR_SUCCESS == vfs_mngr_get_transfer_status())) {
000002  f7fffffe          BL       daplink_is_bootloader
000006  b120              CBZ      r0,|L10.18|
000008  f7fffffe          BL       vfs_mngr_get_transfer_status
00000c  b908              CBNZ     r0,|L10.18|
;;;305            SystemReset();
00000e  f7fffffe          BL       SystemReset
                  |L10.18|
;;;306        }
;;;307    
;;;308        // If hold in bootloader has been set then reset after usb is disconnected
;;;309        if (daplink_is_interface() && (config_ram_get_hold_in_bl() || config_ram_get_disable_msd()==1)) {
000012  f7fffffe          BL       daplink_is_interface
000016  b140              CBZ      r0,|L10.42|
000018  f7fffffe          BL       config_ram_get_hold_in_bl
00001c  b918              CBNZ     r0,|L10.38|
00001e  f7fffffe          BL       config_ram_get_disable_msd
000022  2801              CMP      r0,#1
000024  d101              BNE      |L10.42|
                  |L10.38|
;;;310            SystemReset();
000026  f7fffffe          BL       SystemReset
                  |L10.42|
;;;311        }
;;;312    
;;;313        remount_count++;
00002a  4802              LDR      r0,|L10.52|
00002c  6841              LDR      r1,[r0,#4]  ; remount_count
00002e  1c49              ADDS     r1,r1,#1
000030  6041              STR      r1,[r0,#4]  ; remount_count
;;;314    }
000032  bd10              POP      {r4,pc}
;;;315    
                          ENDP

                  |L10.52|
                          DCD      ||.data||

                          AREA ||i.vfs_user_file_change_handler||, CODE, READONLY, ALIGN=2

                  vfs_user_file_change_handler PROC
;;;191    // Callback to handle changes to the root directory.  Should be used with vfs_set_file_change_callback
;;;192    void vfs_user_file_change_handler(const vfs_filename_t filename, vfs_file_change_t change, vfs_file_t file, vfs_file_t new_file_data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;193    {
000002  460c              MOV      r4,r1
000004  4607              MOV      r7,r0
;;;194        // Call file changed hook. If it returns true, then it handled the request and we have nothing
;;;195        // more to do.
;;;196        if (vfs_user_file_change_handler_hook(filename, change, file, new_file_data)) {
000006  f7fffffe          BL       vfs_user_file_change_handler_hook
00000a  2800              CMP      r0,#0
00000c  d153              BNE      |L11.182|
00000e  f7fffffe          BL       gpio_get_reset_btn_no_fwrd
000012  b910              CBNZ     r0,|L11.26|
000014  f7fffffe          BL       gpio_get_reset_btn_fwrd
000018  b100              CBZ      r0,|L11.28|
                  |L11.26|
;;;197            return;
;;;198        }
;;;199    
;;;200        // Allow settings to be changed if automation mode is
;;;201        // enabled or if the user is holding the reset button
;;;202        bool btn_pressed = gpio_get_reset_btn();
00001a  2001              MOVS     r0,#1
                  |L11.28|
;;;203    
;;;204        if (!btn_pressed && !config_get_automation_allowed()) {
00001c  b918              CBNZ     r0,|L11.38|
00001e  f7fffffe          BL       config_get_automation_allowed
000022  2800              CMP      r0,#0
000024  d047              BEQ      |L11.182|
                  |L11.38|
;;;205            return;
;;;206        }
;;;207    
;;;208        if (VFS_FILE_CHANGED == change) {
000026  2c02              CMP      r4,#2
000028  d045              BEQ      |L11.182|
;;;209            // Unused
;;;210        }
;;;211    
;;;212        else if (VFS_FILE_CREATED == change) {
00002a  b174              CBZ      r4,|L11.74|
;;;213            bool do_remount = true; // Almost all magic files cause a remount.
;;;214            int32_t which_magic_file = -1;
;;;215    
;;;216            // Let the hook examine the filename. If it returned false then look for the standard
;;;217            // magic files.
;;;218            if (!vfs_user_magic_file_hook(filename, &do_remount)) {
;;;219                // Compare the new file's name to our table of magic filenames.
;;;220                for (int32_t i = 0; i < ARRAY_SIZE(s_magic_file_info); ++i) {
;;;221                    if (!memcmp(filename, s_magic_file_info[i].name, sizeof(vfs_filename_t))) {
;;;222                        which_magic_file = s_magic_file_info[i].which;
;;;223                    }
;;;224                }
;;;225    
;;;226                // Check if we matched a magic filename and handle it.
;;;227                if (which_magic_file != -1) {
;;;228                    switch (which_magic_file) {
;;;229                        case kDAPLinkModeActionFile:
;;;230                            if (daplink_is_interface()) {
;;;231                                config_ram_set_hold_in_bl(true);
;;;232                            } else {
;;;233                                // Do nothing - bootloader will go to interface by default
;;;234                            }
;;;235                            break;
;;;236                        case kTestAssertActionFile:
;;;237                            // Test asserts
;;;238                            util_assert(0);
;;;239                            do_remount = false;
;;;240                            break;
;;;241                        case kRefreshActionFile:
;;;242                            // Remount to update the drive
;;;243                            break;
;;;244                        case kEraseActionFile:
;;;245                            erase_target();
;;;246                            break;
;;;247                        case kAutoResetConfigFile:
;;;248                            config_set_auto_rst(true);
;;;249                            break;
;;;250                        case kHardResetConfigFile:
;;;251                            config_set_auto_rst(false);
;;;252                            break;
;;;253                        case kAutomationOnConfigFile:
;;;254                            config_set_automation_allowed(true);
;;;255                            break;
;;;256                        case kAutomationOffConfigFile:
;;;257                            config_set_automation_allowed(false);
;;;258                            break;
;;;259                        case kOverflowOnConfigFile:
;;;260                            config_set_overflow_detect(true);
;;;261                            break;
;;;262                        case kOverflowOffConfigFile:
;;;263                            config_set_overflow_detect(false);
;;;264                            break;
;;;265                        case kMSDOnConfigFile:
;;;266                            config_ram_set_disable_msd(false);
;;;267                            break;
;;;268                        case kMSDOffConfigFile:
;;;269                            config_ram_set_disable_msd(true);
;;;270                            break;
;;;271                        case kPageEraseActionFile:
;;;272                            config_ram_set_page_erase(true);
;;;273                            break;
;;;274                        case kChipEraseActionFile:
;;;275                            config_ram_set_page_erase(false);
;;;276                            break;
;;;277                        default:
;;;278                            util_assert(false);
;;;279                    }
;;;280                }
;;;281                else {
;;;282                    do_remount = false;
;;;283                }
;;;284            }
;;;285    
;;;286            // Remount if requested.
;;;287            if (do_remount) {
;;;288                vfs_mngr_fs_remount();
;;;289            }
;;;290        }
;;;291    
;;;292        else if (VFS_FILE_DELETED == change) {
00002c  2c01              CMP      r4,#1
00002e  d142              BNE      |L11.182|
;;;293            if (!memcmp(filename, assert_file, sizeof(vfs_filename_t))) {
000030  220b              MOVS     r2,#0xb
000032  493c              LDR      r1,|L11.292|
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       memcmp
00003a  2800              CMP      r0,#0
00003c  d13b              BNE      |L11.182|
;;;294                // Clear assert and remount to update the drive
;;;295                util_assert_clear();
00003e  f7fffffe          BL       util_assert_clear
;;;296                vfs_mngr_fs_remount();
000042  e8bd40f8          POP      {r3-r7,lr}
000046  f7ffbffe          B.W      vfs_mngr_fs_remount
                  |L11.74|
00004a  2001              MOVS     r0,#1                 ;213
00004c  f88d0000          STRB     r0,[sp,#0]            ;213
000050  1e85              SUBS     r5,r0,#2              ;214
000052  4669              MOV      r1,sp                 ;218
000054  4638              MOV      r0,r7                 ;218
000056  f7fffffe          BL       vfs_user_magic_file_hook
00005a  bb20              CBNZ     r0,|L11.166|
00005c  4e31              LDR      r6,|L11.292|
00005e  2400              MOVS     r4,#0                 ;220
000060  360d              ADDS     r6,r6,#0xd            ;221
                  |L11.98|
000062  220b              MOVS     r2,#0xb               ;221
000064  f8561034          LDR      r1,[r6,r4,LSL #3]     ;221
000068  4638              MOV      r0,r7                 ;221
00006a  f7fffffe          BL       memcmp
00006e  b910              CBNZ     r0,|L11.118|
000070  eb0600c4          ADD      r0,r6,r4,LSL #3       ;222
000074  7905              LDRB     r5,[r0,#4]            ;222
                  |L11.118|
000076  1c64              ADDS     r4,r4,#1              ;222
000078  2c0e              CMP      r4,#0xe               ;220
00007a  d3f2              BCC      |L11.98|
00007c  1c68              ADDS     r0,r5,#1              ;227
00007e  f04f0400          MOV      r4,#0                 ;227
000082  d016              BEQ      |L11.178|
000084  2d0e              CMP      r5,#0xe               ;228
000086  d240              BCS      |L11.266|
000088  e8dff005          TBB      [pc,r5]               ;228
00008c  070e4516          DCB      0x07,0x0e,0x45,0x16
000090  21232729          DCB      0x21,0x23,0x27,0x29
000094  2d2f3335          DCB      0x2d,0x2f,0x33,0x35
000098  393b              DCB      0x39,0x3b
00009a  f7fffffe          BL       daplink_is_interface
00009e  b110              CBZ      r0,|L11.166|
0000a0  2001              MOVS     r0,#1                 ;231
0000a2  f7fffffe          BL       config_ram_set_hold_in_bl
                  |L11.166|
0000a6  e036              B        |L11.278|
0000a8  22ee              MOVS     r2,#0xee              ;238
0000aa  a11f              ADR      r1,|L11.296|
0000ac  2000              MOVS     r0,#0                 ;238
0000ae  f7fffffe          BL       _util_assert
                  |L11.178|
0000b2  f88d4000          STRB     r4,[sp,#0]            ;282
                  |L11.182|
;;;297            }
;;;298        }
;;;299    }
0000b6  bdf8              POP      {r3-r7,pc}
0000b8  4c1d              LDR      r4,|L11.304|
0000ba  6820              LDR      r0,[r4,#0]  ; flash_intf_target
0000bc  6800              LDR      r0,[r0,#0]
0000be  4780              BLX      r0
0000c0  6820              LDR      r0,[r4,#0]  ; flash_intf_target
0000c2  6900              LDR      r0,[r0,#0x10]
0000c4  4780              BLX      r0
0000c6  6820              LDR      r0,[r4,#0]  ; flash_intf_target
0000c8  6840              LDR      r0,[r0,#4]
0000ca  4780              BLX      r0
0000cc  e023              B        |L11.278|
0000ce  2001              MOVS     r0,#1                 ;248
0000d0  e000              B        |L11.212|
0000d2  2000              MOVS     r0,#0                 ;251
                  |L11.212|
0000d4  f7fffffe          BL       config_set_auto_rst
0000d8  e01d              B        |L11.278|
0000da  2001              MOVS     r0,#1                 ;254
0000dc  e000              B        |L11.224|
0000de  2000              MOVS     r0,#0                 ;257
                  |L11.224|
0000e0  f7fffffe          BL       config_set_automation_allowed
0000e4  e017              B        |L11.278|
0000e6  2001              MOVS     r0,#1                 ;260
0000e8  e000              B        |L11.236|
0000ea  2000              MOVS     r0,#0                 ;263
                  |L11.236|
0000ec  f7fffffe          BL       config_set_overflow_detect
0000f0  e011              B        |L11.278|
0000f2  2000              MOVS     r0,#0                 ;266
0000f4  e000              B        |L11.248|
0000f6  2001              MOVS     r0,#1                 ;269
                  |L11.248|
0000f8  f7fffffe          BL       config_ram_set_disable_msd
0000fc  e00b              B        |L11.278|
0000fe  2001              MOVS     r0,#1                 ;272
000100  e000              B        |L11.260|
000102  2000              MOVS     r0,#0                 ;275
                  |L11.260|
000104  f7fffffe          BL       config_ram_set_page_erase
000108  e005              B        |L11.278|
                  |L11.266|
00010a  f44f728b          MOV      r2,#0x116             ;278
00010e  a106              ADR      r1,|L11.296|
000110  2000              MOVS     r0,#0                 ;278
000112  f7fffffe          BL       _util_assert
                  |L11.278|
000116  f89d0000          LDRB     r0,[sp,#0]            ;287
00011a  2800              CMP      r0,#0                 ;287
00011c  d0cb              BEQ      |L11.182|
00011e  f7fffffe          BL       vfs_mngr_fs_remount
000122  bdf8              POP      {r3-r7,pc}
;;;300    
                          ENDP

                  |L11.292|
                          DCD      ||.constdata||+0x103
                  |L11.296|
000128  2866696c          DCB      "(file)",0
00012c  652900  
00012f  00                DCB      0
                  |L11.304|
                          DCD      flash_intf_target

                          AREA ||i.vfs_user_file_change_handler_hook||, CODE, READONLY, ALIGN=1

                  vfs_user_file_change_handler_hook PROC
;;;178    // Default file change hook.
;;;179    __WEAK bool vfs_user_file_change_handler_hook(const vfs_filename_t filename, vfs_file_change_t change,
000000  2000              MOVS     r0,#0
;;;180            vfs_file_t file, vfs_file_t new_file_data)
;;;181    {
;;;182        return false;
;;;183    }
000002  4770              BX       lr
;;;184    
                          ENDP


                          AREA ||i.vfs_user_magic_file_hook||, CODE, READONLY, ALIGN=1

                  vfs_user_magic_file_hook PROC
;;;185    // Default magic file hook.
;;;186    __WEAK bool vfs_user_magic_file_hook(const vfs_filename_t filename, bool *do_remount)
000000  2000              MOVS     r0,#0
;;;187    {
;;;188        return false;
;;;189    }
000002  4770              BX       lr
;;;190    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  file_buffer
                          %        512
                  assert_buf
                          %        65

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  error_type_prefix
000000  74797065          DCB      0x74,0x79,0x70,0x65
000004  3a2000            DCB      0x3a,0x20,0x00
                  error_prefix
000007  65                DCB      0x65
000008  72726f72          DCB      0x72,0x72,0x6f,0x72
00000c  3a2000            DCB      0x3a,0x20,0x00
                  mbed_redirect_file
00000f  3c                DCB      0x3c
000010  21646f63          DCB      0x21,0x64,0x6f,0x63
000014  74797065          DCB      0x74,0x79,0x70,0x65
000018  2068746d          DCB      0x20,0x68,0x74,0x6d
00001c  6c3e0d0a          DCB      0x6c,0x3e,0x0d,0x0a
000020  3c212d2d          DCB      0x3c,0x21,0x2d,0x2d
000024  206d6265          DCB      0x20,0x6d,0x62,0x65
000028  6420506c          DCB      0x64,0x20,0x50,0x6c
00002c  6174666f          DCB      0x61,0x74,0x66,0x6f
000030  726d2057          DCB      0x72,0x6d,0x20,0x57
000034  65627369          DCB      0x65,0x62,0x73,0x69
000038  74652061          DCB      0x74,0x65,0x20,0x61
00003c  6e642041          DCB      0x6e,0x64,0x20,0x41
000040  75746865          DCB      0x75,0x74,0x68,0x65
000044  6e746963          DCB      0x6e,0x74,0x69,0x63
000048  6174696f          DCB      0x61,0x74,0x69,0x6f
00004c  6e205368          DCB      0x6e,0x20,0x53,0x68
000050  6f727463          DCB      0x6f,0x72,0x74,0x63
000054  7574202d          DCB      0x75,0x74,0x20,0x2d
000058  2d3e0d0a          DCB      0x2d,0x3e,0x0d,0x0a
00005c  3c68746d          DCB      0x3c,0x68,0x74,0x6d
000060  6c3e0d0a          DCB      0x6c,0x3e,0x0d,0x0a
000064  3c686561          DCB      0x3c,0x68,0x65,0x61
000068  643e0d0a          DCB      0x64,0x3e,0x0d,0x0a
00006c  3c6d6574          DCB      0x3c,0x6d,0x65,0x74
000070  61206368          DCB      0x61,0x20,0x63,0x68
000074  61727365          DCB      0x61,0x72,0x73,0x65
000078  743d2275          DCB      0x74,0x3d,0x22,0x75
00007c  74662d38          DCB      0x74,0x66,0x2d,0x38
000080  223e0d0a          DCB      0x22,0x3e,0x0d,0x0a
000084  3c746974          DCB      0x3c,0x74,0x69,0x74
000088  6c653e6d          DCB      0x6c,0x65,0x3e,0x6d
00008c  62656420          DCB      0x62,0x65,0x64,0x20
000090  57656273          DCB      0x57,0x65,0x62,0x73
000094  69746520          DCB      0x69,0x74,0x65,0x20
000098  53686f72          DCB      0x53,0x68,0x6f,0x72
00009c  74637574          DCB      0x74,0x63,0x75,0x74
0000a0  3c2f7469          DCB      0x3c,0x2f,0x74,0x69
0000a4  746c653e          DCB      0x74,0x6c,0x65,0x3e
0000a8  0d0a3c2f          DCB      0x0d,0x0a,0x3c,0x2f
0000ac  68656164          DCB      0x68,0x65,0x61,0x64
0000b0  3e0d0a3c          DCB      0x3e,0x0d,0x0a,0x3c
0000b4  626f6479          DCB      0x62,0x6f,0x64,0x79
0000b8  3e0d0a3c          DCB      0x3e,0x0d,0x0a,0x3c
0000bc  73637269          DCB      0x73,0x63,0x72,0x69
0000c0  70743e0d          DCB      0x70,0x74,0x3e,0x0d
0000c4  0a77696e          DCB      0x0a,0x77,0x69,0x6e
0000c8  646f772e          DCB      0x64,0x6f,0x77,0x2e
0000cc  6c6f6361          DCB      0x6c,0x6f,0x63,0x61
0000d0  74696f6e          DCB      0x74,0x69,0x6f,0x6e
0000d4  2e726570          DCB      0x2e,0x72,0x65,0x70
0000d8  6c616365          DCB      0x6c,0x61,0x63,0x65
0000dc  28224052          DCB      0x28,0x22,0x40,0x52
0000e0  22293b0d          DCB      0x22,0x29,0x3b,0x0d
0000e4  0a3c2f73          DCB      0x0a,0x3c,0x2f,0x73
0000e8  63726970          DCB      0x63,0x72,0x69,0x70
0000ec  743e0d0a          DCB      0x74,0x3e,0x0d,0x0a
0000f0  3c2f626f          DCB      0x3c,0x2f,0x62,0x6f
0000f4  64793e0d          DCB      0x64,0x79,0x3e,0x0d
0000f8  0a3c2f68          DCB      0x0a,0x3c,0x2f,0x68
0000fc  746d6c3e          DCB      0x74,0x6d,0x6c,0x3e
000100  0d0a00            DCB      0x0d,0x0a,0x00
                  assert_file
000103  41                DCB      0x41
000104  53534552          DCB      0x53,0x53,0x45,0x52
000108  54202054          DCB      0x54,0x20,0x20,0x54
00010c  58540000          DCB      0x58,0x54,0x00,0x00
                  s_magic_file_info
                          DCD      daplink_mode_file_name
000114  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||
00011c  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      ||.conststring||+0xc
000124  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      ||.conststring||+0x18
00012c  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      ||.conststring||+0x24
000134  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      ||.conststring||+0x30
00013c  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      ||.conststring||+0x3c
000144  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      ||.conststring||+0x48
00014c  07000000          DCB      0x07,0x00,0x00,0x00
                          DCD      ||.conststring||+0x54
000154  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      ||.conststring||+0x60
00015c  09000000          DCB      0x09,0x00,0x00,0x00
                          DCD      ||.conststring||+0x6c
000164  0a000000          DCB      0x0a,0x00,0x00,0x00
                          DCD      ||.conststring||+0x78
00016c  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      ||.conststring||+0x84
000174  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      ||.conststring||+0x90
00017c  0d000000          DCB      0x0d,0x00,0x00,0x00
                  error_type_names
                          DCD      ||.conststring||+0x9c
                          DCD      ||.conststring||+0xa8
                          DCD      ||.conststring||+0xb4
                          DCD      ||.conststring||+0xbc
                          DCD      ||.conststring||+0xc4

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  41535345          DCB      "ASSERT  ACT",0
000004  52542020
000008  41435400
00000c  52454652          DCB      "REFRESH ACT",0
000010  45534820
000014  41435400
000018  45524153          DCB      "ERASE   ACT",0
00001c  45202020
000020  41435400
000024  4155544f          DCB      "AUTO_RSTCFG",0
000028  5f525354
00002c  43464700
000030  48415244          DCB      "HARD_RSTCFG",0
000034  5f525354
000038  43464700
00003c  4155544f          DCB      "AUTO_ON CFG",0
000040  5f4f4e20
000044  43464700
000048  4155544f          DCB      "AUTO_OFFCFG",0
00004c  5f4f4646
000050  43464700
000054  4f56464c          DCB      "OVFL_ON CFG",0
000058  5f4f4e20
00005c  43464700
000060  4f56464c          DCB      "OVFL_OFFCFG",0
000064  5f4f4646
000068  43464700
00006c  4d53445f          DCB      "MSD_ON  CFG",0
000070  4f4e2020
000074  43464700
000078  4d53445f          DCB      "MSD_OFF CFG",0
00007c  4f464620
000080  43464700
000084  50414745          DCB      "PAGE_ON ACT",0
000088  5f4f4e20
00008c  41435400
000090  50414745          DCB      "PAGE_OFFACT",0
000094  5f4f4646
000098  41435400
00009c  696e7465          DCB      "internal",0
0000a0  726e616c
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
0000a8  7472616e          DCB      "transient",0
0000ac  7369656e
0000b0  7400    
0000b2  00                DCB      0
0000b3  00                DCB      0
0000b4  75736572          DCB      "user",0
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
0000bc  74617267          DCB      "target",0
0000c0  657400  
0000c3  00                DCB      0
0000c4  696e7465          DCB      "interface",0
0000c8  72666163
0000cc  6500    
0000ce  00                DCB      0
0000cf  00                DCB      0
0000d0  4120626f          DCB      "A bootloader update was started but unable to complete."
0000d4  6f746c6f
0000d8  61646572
0000dc  20757064
0000e0  61746520
0000e4  77617320
0000e8  73746172
0000ec  74656420
0000f0  62757420
0000f4  756e6162
0000f8  6c652074
0000fc  6f20636f
000100  6d706c65
000104  74652e  
000107  0d0a5265          DCB      "\r\nReload the bootloader to fix this error message.\r\n"
00010b  6c6f6164
00010f  20746865
000113  20626f6f
000117  746c6f61
00011b  64657220
00011f  746f2066
000123  69782074
000127  68697320
00012b  6572726f
00012f  72206d65
000133  73736167
000137  652e0d0a
00013b  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  assert_source
000000  0000              DCB      0x00,0x00
                  assert_line
000002  0000              DCB      0x00,0x00
                  remount_count
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_user.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_vfs_user_c_5190552d____REV16|
#line 480 "..\\..\\..\\source\\cmsis-core\\cmsis_armcc.h"
|__asm___10_vfs_user_c_5190552d____REV16| PROC
#line 481

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_vfs_user_c_5190552d____REVSH|
#line 495
|__asm___10_vfs_user_c_5190552d____REVSH| PROC
#line 496

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_vfs_user_c_5190552d____RRX|
#line 682
|__asm___10_vfs_user_c_5190552d____RRX| PROC
#line 683

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
